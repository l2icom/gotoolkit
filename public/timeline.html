<!DOCTYPE html>
<html lang="fr">

<head>
    <script>window.GO_TOOLKIT_SHARE_API_URL = 'https://share.gotoolkit.workers.dev/'</script>
    <meta charset="UTF-8" />
    <title>Timeline | Go-Toolkit</title>

    <!-- Vis Timeline -->
    <link rel="stylesheet" href="https://unpkg.com/vis-timeline@latest/styles/vis-timeline-graph2d.min.css"
        type="text/css" />
    <script src="https://unpkg.com/vis-timeline@latest/standalone/umd/vis-timeline-graph2d.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.4/moment-with-locales.min.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap">
    <link rel="stylesheet" href="styles/app-shell.css">
    <style>
        :root {
            --bg: #f3f4f6;
            --surface: #ffffff;
            --surface-soft: #f7f7f7;
            --border: #e5e7eb;
            --border-light: var(--border);
            --border-strong: #d1d5db;
            --timeline-background: #ffffff;

            --primary: #2a7a57;
            --primary-soft: rgba(42, 122, 87, 0.17);
            --primary-strong: #1f4f3d;

            --text: #111827;
            --muted: rgba(57, 76, 89, .85);

            --radius-lg: 16px;
            --radius-md: 999px;
            --radius-sm: 10px;

            --shadow-soft: 0 10px 30px rgba(15, 23, 42, 0.12);
            --app-font: "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
            --global-font-size: 12px;
            --app-border: #e5e7eb;
            --app-border-strong: #e5e7eb;
            --app-primary-strong: #1f4f3d;
            --app-bg: var(--bg);
            --app-text: var(--text);
            font-family: var(--app-font);
        }

        .gutenberg-card,
        .ia-actions,
        .gutenberg-script,
        .gutenberg-recette,
        .ia-prompt-fields {
            min-height: 0;
        }

        body {
            padding: 0;
            height: 100vh;
            background: #f3f4f6;
            color: var(--text);
            font-family: var(--app-font, "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif);
            overflow: hidden;
        }

        .vis-item .vis-item-content {
            white-space: normal !important;
            word-break: break-word;
            overflow-wrap: anywhere;
            padding: 0px 0px;
        }

        .type-milestone .vis-item-content {
            padding: 6px 15px;
        }

        .vis-item.type-milestone .vis-item-content {
            margin-left: -20px;
        }


        .app-main {
            display: flex;
            flex: 1 1 auto;
            gap: 12px;
            align-items: stretch;
            min-height: 0;
            position: relative;
        }

        .app::after {
            content: "";
            position: absolute;
            bottom: 16px;
            right: 16px;
            width: 120px;
            height: 120px;
            background: url("logo.gif") no-repeat center/contain;
            opacity: 0.25;
            pointer-events: none;
            z-index: -1;
        }

        .app {
            width: 100%;
            max-width: none;
            margin: 0 auto;
            align-items: stretch;
            height: 100vh;
        }

        .tabs-wrapper {
            display: flex;
            align-items: center;
            gap: 4px;
            flex: 1 1 auto;
            min-width: 0;
        }


        .tabs .tab {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }


        .tabs-actions {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
            flex-wrap: wrap;
        }

        .ia-header-actions {
            width: 100%;
            padding: 5px 0px;
        }

        h1 {
            margin: 0 0 4px;
            font-size: 19px;
        }

        .subtitle {
            margin: 0 0 12px;
            font-size: 13px;
            color: var(--muted);
        }

        textarea {
            width: 100%;
            border-radius: 10px;
            border: 1px solid var(--border-strong);
            line-height: 1.4;
            padding: 6px 8px;
            font-size: 13px;
            font-family: var(--app-font, "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif);
            resize: none;
            min-height: 80px;
            scrollbar-width: none;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }

        /* Sc√©nario / Script conservent leur police monospace pour la saisie structur√©e */
        .ia-prompt-field {
            font-family: Menlo, Consolas, "Courier New", monospace;
        }

        textarea:focus {
            outline: none;
            border: 1px solid var(--app-primary);
            scrollbar-width: thin;
        }

        textarea::-webkit-scrollbar {
            width: 0;
        }

        textarea:focus::-webkit-scrollbar {
            width: 6px;
        }

        textarea::-webkit-scrollbar-thumb {
            background: rgba(42, 122, 87, 0.35);
            border-radius: 10px;
        }

        select,
        .input-small {
            width: 100%;
            border-radius: 999px;
            border: 1px solid var(--border-strong);
            padding: 4px 8px;
            font-size: 11px;
            background: var(--surface-soft);
        }

        select:focus,
        .input-small:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 1px rgba(37, 99, 235, 0.3);
        }

        .hint {
            font-size: 11px;
            color: var(--muted);
        }

        .hint code {
            font-size: 10px;
            background: var(--surface-soft);
            border-radius: 6px;
            padding: 2px 4px;
        }

        /* Timeline + toolbar */
        .timeline-card {
            --vis-item-padding-vertical: 2px;
            --vis-item-padding-horizontal: 4px;
            --vis-group-label-padding-vertical: 4px;
            --vis-group-label-padding-horizontal: 10px;
            --vis-row-padding-vertical: 4px;
            background: var(--timeline-background);
            border-radius: var(--radius-lg);
            border: 1px solid var(--border);
            padding: 10px 10px 12px;
            display: flex;
            flex-direction: column;
            gap: 2px;
            flex: 1 1 auto;
            min-height: 0;
            height: 100%;
            width: 100%;
            max-width: none;
            min-width: 0;
            font-size: var(--global-font-size, 14px);
            aspect-ratio: auto;
        }

        .timeline-card[data-spacing="dense"] {
            --vis-item-padding-vertical: 4px;
            --vis-item-padding-horizontal: 6px;
            --vis-group-label-padding-vertical: 2px;
            --vis-group-label-padding-horizontal: 8px;
            --vis-row-padding-vertical: 4px;
        }

        .timeline-card[data-spacing="normal"] {
            --vis-item-padding-vertical: 6px;
            --vis-item-padding-horizontal: 10px;
            --vis-group-label-padding-vertical: 4px;
            --vis-group-label-padding-horizontal: 10px;
            --vis-row-padding-vertical: 6px;
        }

        .timeline-card[data-spacing="comfortable"] {
            --vis-item-padding-vertical: 10px;
            --vis-item-padding-horizontal: 16px;
            --vis-group-label-padding-vertical: 6px;
            --vis-group-label-padding-horizontal: 12px;
            --vis-row-padding-vertical: 10px;
        }

        .timeline-card[data-ratio="full"],
        .timeline-card:not([data-ratio]) {
            flex: 1 1 auto;
            aspect-ratio: auto;
            width: 100%;
            margin-inline: 0;
            max-width: none;
        }

        .timeline-card[data-ratio="16:9"],
        .timeline-card[data-ratio="4:3"],
        .timeline-card[data-ratio="a4"] {
            flex: 0 0 auto;
            aspect-ratio: auto;
            width: auto;
            max-width: 100%;
            margin-inline: auto;
        }

        .timeline-card[data-ratio="16:9"] {
            aspect-ratio: 16 / 9;
        }

        .timeline-card[data-ratio="4:3"] {
            aspect-ratio: 4 / 3;
        }

        .timeline-card[data-ratio="a4"] {
            aspect-ratio: 297 / 210;
        }

        /* Make timeline card corners rounded */
        .timeline-card {
            border-radius: 8px;
            overflow: hidden;
        }

        .gutenberg-card {
            display: none;
            flex: 0 0 350px;
            width: 350px;
            background: var(--surface);
            border-radius: 8px;
            border: 1px solid var(--border);
            padding: 8px 8px 10px;
            box-shadow: var(--shadow-soft);
            gap: 8px;
            height: 100%;
            min-height: 0;
            overflow-y: auto;
            transition: transform 0.18s ease, opacity 0.18s ease;
            font-size: 11px;
            font-family: var(--app-font, "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif);
        }

        .gutenberg-card * {
            font-family: inherit;
        }

        .gutenberg-card.open {
            display: flex;
            flex-direction: column;
            max-height: calc(100vh - 80px);
        }

        .gutenberg-card .modal-header {
            padding: 0 0 4px;
        }

        .gutenberg-card .gutenberg-title {
            font-size: 15px;
            font-weight: 700;
            margin: 0;
            padding: 0;
            line-height: 1;
        }

        .gutenberg-card .ia-actions {
            display: flex;
            flex-direction: column;
            gap: 6px;
            flex: 1 1 auto;
            min-height: 0;
            overflow: auto;
        }

        .gutenberg-card .ia-header-actions {
            padding: 0;
        }

        .gutenberg-card .ia-header-actions.gutenberg-script {
            flex-direction: column;
        }

        .gutenberg-card .ia-prompt-fields {
            height: 100%;
            min-height: 0;
            display: flex;
            flex-direction: column;
            flex: 1 1 auto;
            overflow: hidden;
        }

        .gutenberg-card .gutenberg-script .ia-prompt-fields textarea {
            flex: 1;
            min-height: 120px;
            height: 100%;
            resize: none;
            box-sizing: border-box;
        }

        .prompt-template-meta {
            font-size: 12px;
            color: var(--muted);
            margin: 2px 0 6px;
        }

        .gutenberg-card .ia-prompt-field {
            height: 100%;
            min-height: 0;
        }

        #promptModify {
            height: 100%;
            min-height: 120px;
            max-height: 2ee00px;
        }

        .gutenberg-card .gutenberg-recette {
            flex: 0 0 auto;
            height: auto;
            min-height: 0;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .gutenberg-recette-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        /* Increase the label font size for Sc√©nario and Script by 2px */
        .gutenberg-card label[for="promptCreate"],
        .gutenberg-card label[for="promptModify"] {
            font-size: 14px;
        }

        .gutenberg-card .gutenberg-script {
            flex: 1 1 auto;
            height: auto;
            min-height: 0;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .gutenberg-card .gutenberg-actions {
            margin-top: -4px;
        }

        .speech-field-wrapper {
            position: relative;
            height: 100%;
        }

        .speech-field-wrapper textarea {
            padding-right: 40px;
            position: relative;
            z-index: 2;
        }

        .speech-button {
            position: absolute;
            top: 6px;
            right: 6px;
            width: 24px;
            height: 24px;
            background: rgba(255, 255, 255, 0.85);
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border: none;
            color: var(--app-muted);
            border-radius: 999px;
            transition: box-shadow 0.2s ease, opacity 0.2s ease;
            opacity: 1;
            pointer-events: auto;
            z-index: 3;
        }

        .speech-button--active {
            color: #B11226;
            animation: speech-blink 2s infinite linear;
            opacity: 1;
        }

        @keyframes speech-blink {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.4;
            }
        }

        .speech-suggestion {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            bottom: 10px;
            pointer-events: none;
            font: inherit;
            line-height: 1.4;
            white-space: pre-wrap;
            word-break: break-word;
            z-index: 4;
        }

        .speech-suggestion span {
            display: inline;
        }

        .speech-suggestion-current {
            color: transparent;
        }

        .speech-suggestion-partial {
            color: rgba(15, 23, 42, 0.45);
        }

        .speech-suggestion:not(.visible) {
            visibility: hidden;
        }

        @keyframes speech-border {

            0%,
            100% {
                box-shadow: 0 0 0 0 rgba(177, 18, 38, 0.2);
            }

            50% {
                box-shadow: 0 0 0 6px rgba(177, 18, 38, 0.12);
            }
        }

        .speech-field-wrapper.speech-active textarea {
            border: 2px solid #B11226;
            animation: speech-border 2s infinite ease-in-out;
        }

        .speech-field-wrapper.speech-active textarea:focus {
            border-color: #B11226;
        }

        .timeline-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            flex: 1;
            min-height: 0;
        }

        .timeline-empty-state {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 24px;
            gap: 12px;
            background: rgba(255, 255, 255, 0.92);
            border-radius: 12px;
            border: 1px dashed var(--border-strong);
            color: var(--text);
            visibility: hidden;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease, visibility 0.2s ease;
            z-index: 1;
        }

        .timeline-empty-state.visible {
            visibility: visible;
            opacity: 1;
            pointer-events: auto;
        }

        .timeline-empty-text {
            margin: 0;
            font-size: 14px;
            color: var(--text);
        }

        .timeline-empty-link {
            font-weight: 600;
            color: var(--primary);
            text-decoration: none;
            border-bottom: 1px solid transparent;
        }

        .timeline-empty-link:hover,
        .timeline-empty-link:focus-visible {
            border-bottom-color: rgba(42, 122, 87, 0.6);
        }

        .timeline-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 16px;
            flex-wrap: wrap;
        }

        #timeline {
            position: relative;
            z-index: 0;
            background: var(--timeline-background);
            border-radius: 12px;
            height: 100%;
            padding: 6px;
        }


        #clearTimelineBtn {
            margin-left: auto;
        }

        .edit-tooltip {
            position: absolute;
            pointer-events: none;
            top: 0;
            left: 50%;
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 11px;
            background: rgba(15, 23, 42, 0.92);
            color: #fff;
            opacity: 0;
            transform: translate(-50%, -120%);
            white-space: nowrap;
            transition: opacity 0.1s ease;
            z-index: 3;
        }

        .edit-tooltip.visible {
            opacity: 1;
        }

        /* Tooltip affich√© sous le textarea Sc√©nario (noir semi-transparent, texte blanc) */
        .scenario-template-tooltip {
            position: absolute;
            z-index: 120;
            background: rgba(0, 0, 0, 0.82);
            color: #fff;
            padding: 8px 10px;
            border-radius: 8px;
            font-size: 12px;
            max-width: 420px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.28);
            pointer-events: none;
            white-space: pre-wrap;
            opacity: 0;
            transform-origin: top left;
            transform: translateY(8px);
            transition: opacity 0.12s ease, transform 0.12s ease;
        }

        .scenario-template-tooltip.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .header-buttons {
            display: flex;
            gap: 10px;
            margin-left: auto;
        }

        .menu-header {
            font-size: 14px;
            font-weight: 700;
        }

        #fileMenu .menu-panel {
            padding: 0;
            gap: 0;
        }

        .info-popup {
            position: absolute;
            top: 56px;
            right: 12px;
            width: 280px;
            background: #fff;
            border-radius: 14px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            padding: 15px;
            display: none;
            flex-direction: column;
            gap: 6px;
            font-size: 12px;
            z-index: 60;
        }

        .info-popup.open {
            display: flex;
        }

        .info-popup img {
            width: 48px;
            height: 48px;
            object-fit: contain;
            align-self: center;
        }

        .info-popup button {
            border-radius: 8px;
            border: 1px solid rgba(15, 23, 42, 0.15);
            padding: 6px 12px;
            font-size: 12px;
            cursor: pointer;
            min-width: 110px;
        }

        .info-popup button.secondary {
            background: #fff;
            border: 1px solid rgba(15, 23, 42, 0.15);
            color: var(--text);
        }

        .info-popup button.update-btn {
            background: #2a7a57;
            border-color: #2a7a57;
            color: #fff;
        }

        .info-actions {
            display: flex;
            justify-content: space-between;
            gap: 8px;
            flex-wrap: wrap;
        }

        /* Harmonized tour styles */
        .tour-overlay {
            position: fixed;
            inset: 0;
            background: transparent;
            display: none;
            z-index: 120;
            pointer-events: auto;
        }

        .tour-overlay.visible {
            display: block;
        }

        .tour-overlay.dimmed {
            background: rgba(15, 15, 15, 0.65);
        }

        .tour-highlight {
            position: absolute;
            border: 2px solid #2a7a57;
            border-radius: 12px;
            background: transparent;
            box-shadow: 0 0 0 9999px rgba(15, 15, 15, 0.65);
            transition: all 0.25s ease;
            pointer-events: none;
        }

        .tour-highlight.hidden {
            opacity: 0;
        }

        .tour-panel {
            position: absolute;
            bottom: 28px;
            left: 50%;
            transform: translateX(-50%);
            max-width: 460px;
            width: calc(100% - 40px);
            background: #fff;
            border-radius: 14px;
            padding: 18px;
            box-shadow: 0 16px 32px rgba(0, 0, 0, 0.28);
            color: #1f1f1f;
            display: flex;
            flex-direction: column;
            gap: 10px;
            font-family: var(--app-font, "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif);
        }

        .tour-panel h4 {
            margin: 0;
            font-size: 18px;
        }

        .tour-panel p {
            margin: 0;
            line-height: 1.4;
        }

        .tour-step-counter {
            font-size: 11px;
            color: #918b7f;
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        .tour-step-footer {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            flex-wrap: wrap;
            margin-top: 8px;
        }

        .tour-panel button {
            border-radius: 10px;
            border: 1px solid var(--border);
            background: #fff;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 13px;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        .tour-panel button:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 6px 18px rgba(15, 23, 42, 0.12);
        }

        .tour-panel button.primary {
            border: none;
            background: #2a7a57;
            color: #fff;
        }

        .tour-panel button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .tour-skip {
            position: absolute;
            top: 12px;
            right: 12px;
            border: none;
            background: rgba(255, 255, 255, 0.12);
            color: #fff;
            border-radius: 999px;
            padding: 6px 12px;
            font-size: 12px;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        .tour-skip:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
        }

        .menu-panel-btn {
            border-radius: 0;
            background: transparent !important;
            text-align: left;
            padding: 8px 12px;
            width: 100%;
            font-size: 14px;
            cursor: pointer;
            border: none !important;
            transition: background 0.2s ease;
        }

        .menu-panel-btn:hover {
            background: rgba(42, 122, 87, 0.08);
        }

        .global-actions {
            display: flex;
            flex-direction: row;
            gap: 8px;
            max-width: 800px;
            width: 100%;
            justify-content: flex-end;
            align-items: flex-start;
        }

        .tabs-actions {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
            flex-wrap: wrap;
        }

        .global-actions .header-row {
            display: flex;
            flex-direction: column;
            gap: 4px;
            width: 100%;
        }

        .ia-key-row label {
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 12px;
            color: var(--muted);
        }

        .ia-key-row input {
            width: 100%;
            border-radius: 12px;
            border: 1px solid var(--border);
            padding: 10px 12px;
            font-size: 13px;
            background: var(--surface-soft);
            color: var(--text);
            font-family: inherit;
        }

        .global-actions .header-row label,
        .global-actions .header-row textarea,
        .global-actions .header-row select,
        .global-actions .header-row button {
            width: 100%;
        }

        .ia-prompt-fields {
            width: 100%;
            position: relative;
        }

        .ia-prompt-field {
            display: block;
            width: 100%;
            max-height: none;
        }

        .ia-actions-footer {
            display: flex;
            justify-content: flex-end;
            margin-top: 8px;
            gap: 8px;
        }

        .ia-template-footer {
            justify-content: flex-start;
        }

        .global-actions textarea {
            max-height: 30px;
            font-size: 14px;
        }

        .global-actions button {
            align-self: flex-end;
            border: 1px solid rgba(15, 23, 42, 0.2);
            color: #0f172a;
            box-shadow: none;
        }

        .menu-trigger {
            position: relative;
            display: inline-flex;
        }

        .context-menu {
            position: absolute;
            top: calc(100% + 6px);
            right: 0;
            background: var(--surface);
            border: 1px solid rgba(15, 23, 42, 0.1);
            border-radius: 16px;
            box-shadow: 0 16px 32px rgba(15, 23, 42, 0.2);
            display: none;
            min-width: 220px;
            z-index: 40;
        }

        .context-menu.open {
            display: block;
        }

        .menu-panel {
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 12px;
        }

        .context-menu label,
        .context-menu button {
            font-size: 13px;
            color: var(--text);
        }

        .toast {
            position: fixed;
            bottom: 18px;
            right: 18px;
            background: rgba(15, 23, 42, 0.92);
            color: #fff;
            padding: 8px 16px;
            border-radius: 999px;
            font-size: 13px;
            box-shadow: 0 8px 18px rgba(15, 23, 42, 0.3);
            pointer-events: none;
            opacity: 0;
            transform: translateY(12px);
            transition: opacity 0.25s ease, transform 0.25s ease;
            z-index: 90;
        }

        .toast.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .color-modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(15, 23, 42, 0.55);
            backdrop-filter: blur(8px);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 18px;
            z-index: 90;
            opacity: 0;
            pointer-events: none;
            transition: opacity 140ms ease;
        }

        .color-modal-overlay.open {
            opacity: 1;
            pointer-events: auto;
        }

        .color-modal {
            background: var(--surface);
            border-radius: 18px;
            width: min(520px, 100%);
            max-height: min(90vh, 600px);
            display: flex;
            flex-direction: column;
            gap: 16px;
            padding: 18px;
            box-shadow: 0 20px 45px rgba(15, 23, 42, 0.3);
        }

        .color-modal .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding-bottom: 4px;
            border-bottom: 1px solid rgba(148, 163, 184, 0.3);
        }

        .color-modal h3 {
            margin: 0;
            font-size: 15px;
        }

        .color-modal .modal-close {
            font-size: 20px;
            color: var(--muted);
        }

        .color-modal-body {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .color-types {
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 320px;
            overflow-y: auto;
            padding-right: 4px;
        }

        .color-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .color-row-label {
            flex: 1;
        }

        .color-row-controls {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .color-row-label-input {
            width: 100%;
            border-radius: 10px;
            border: 1px solid var(--border-strong);
            padding: 6px 8px;
            font-size: 13px;
            background: transparent;
            color: inherit;
            transition: border-color 120ms ease;
            cursor: pointer;
        }

        .color-row-label-input:focus {
            outline: none;
            border-color: var(--muted);
            cursor: text;
        }

        .color-row-label-input:not(:read-only) {
            cursor: text;
        }

        .color-row-label-input:disabled {
            opacity: 0.65;
            cursor: not-allowed;
        }



        .color-row-controls input[type="color"] {
            width: 38px;
            height: 38px;
            border: none;
            padding: 0;
            background: transparent;
            cursor: pointer;
            border-radius: 6px;
        }

        .color-row-controls input[type="text"] {
            width: 90px;
            border-radius: 10px;
            border: 1px solid var(--border-strong);
            padding: 6px 8px;
            font-size: 12px;
            text-transform: lowercase;
        }

        .color-actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }

        .toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            align-items: center;
            margin-bottom: 8px;
        }

        .type-selector {
            border-radius: 0px;
            border-left: 1px solid rgba(15, 23, 42, 0.15);
            background: transparent;
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            font-size: 11px;
        }

        .type-selector-icon {
            font-size: 12px;
            line-height: 1;
        }

        .type-selector select {
            border: none;
            background: transparent;
            font-size: 12px;
            padding: 0;
            min-width: 120px;
            font-weight: 600;
            font-family: inherit;
            color: var(--text);
            cursor: pointer;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            text-transform: capitalize;
        }

        .type-selector select:disabled {
            opacity: 0.6;
        }

        .type-selector.disabled .type-selector-icon {
            color: rgba(15, 23, 42, 0.45);
        }

        .toolbar .item-actions {
            margin-left: auto;
        }

        .btn-group {
            display: inline-flex;
            border-radius: 4px;
            background: transparent;
            overflow: hidden;
        }

        .header-buttons .type-filter-panel {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: flex-end;
            min-width: 220px;
        }

        .type-filter-panel {
            flex-wrap: wrap;
            justify-content: flex-end;
        }

        .type-filter-option {
            position: relative;
            display: inline-flex;
            align-items: center;
            border-radius: 6px;
            padding: 4px 10px;
            font-size: 11px;
            cursor: pointer;
            transition: border-color 0.2s ease;
            overflow: hidden;
            background: #ffffff;
        }

        .type-filter-option input {
            position: absolute;
            inset: 0;
            opacity: 0;
            margin: 0;
            cursor: pointer;
        }

        .type-filter-option .type-filter-label {
            font-size: 12px;
            white-space: nowrap;
            text-transform: capitalize;
            letter-spacing: 0.02em;
        }

        .type-filter-option.active {
            transform: none;
            box-shadow: none;
        }

        /* vis.js styling */
        .vis-labelset .vis-label {
            font-size: var(--global-font-size);
            color: var(--muted);
            font-weight: 600;
        }


        .vis-item {
            border-radius: var(--radius-sm);
            border-width: 1px;
            font-size: var(--global-font-size);
            line-height: 1.1;
            padding-block: var(--vis-item-padding-vertical, 4px);
            padding-inline: var(--vis-item-padding-horizontal, 8px);
            cursor: pointer;
            background: #e5e7eb;
            border-color: #d1d5db;
            color: var(--text);
            transition:
                box-shadow 120ms ease,
                transform 80ms ease,
                background 120ms ease,
                border-color 120ms ease,
                color 120ms ease;
            white-space: normal;
            word-break: break-word;
            max-height: 50px;
            overflow: hidden;
        }

        #timeline .vis-labelset .vis-label {
            padding-block: var(--vis-group-label-padding-vertical, 4px);
            padding-inline: var(--vis-group-label-padding-horizontal, 10px);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        #timeline .vis-body .vis-row {
            padding-block: var(--vis-row-padding-vertical, 6px);
            border-bottom: 1px solid rgba(15, 23, 42, 0.04);
        }

        #timeline .vis-body .vis-row:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }


        .vis-item:hover {
            background: #dbeafe;
            border-color: var(--primary);
        }

        .vis-item.vis-selected {
            border-width: 2px;
            border-style: solid;
            background: rgba(37, 99, 235, 0.14);
            border-color: var(--primary-strong);
            color: #111827;
        }

        .vis-item.milestone-class,
        .vis-item.marker-class {
            background: transparent;
            border-color: transparent;
            box-shadow: none;
        }

        .vis-drag-center {
            border-color: var(--primary-strong) !important;
        }

        .type-milestone,
        .type-marker {
            background: transparent;
            border: none;
            padding: 0;
            overflow: visible;
            min-width: 0;
        }

        .type-milestone .diamond,
        .type-marker .diamond {
            width: 10px;
            height: 10px;
            border-radius: 3px;
            background: #fed7aa;
            border: 1px solid var(--marker-accent, var(--primary-color));
            transform: rotate(45deg);
            flex-shrink: 0;
        }

        .vis-item.vis-dot {
            border: none;
            background: transparent;
        }

        .vis-item.vis-dot::before {
            content: "";
            position: absolute;
            width: 10px;
            height: 10px;
            top: 50%;
            left: 50%;
            transform: translate(calc(-50% + 6px), -50%) rotate(45deg);
            border-radius: 0;
            background: var(--marker-selected-background, rgba(37, 99, 235, 0.14));
            box-shadow: 0 0 0 1px transparent;

        }

        .vis-item.vis-dot {
            background: transparent;
            border: none;
            color: transparent;
            box-shadow: none;
            width: 0;
            height: 0;
            padding: 0;
            margin: 0;
        }

        .vis-item .vis-item-content {
            padding: 0px 0px 0px 0px;
        }

        .type-milestone .vis-item-content,
        .type-marker .vis-item-content {
            padding-left: 18px;
            /* pull the box left to cover the dot */
        }



        .vis-item.type-milestone.vis-selected,
        .vis-item.type-marker.vis-selected,
        .vis-item.milestone-class.vis-selected,
        .vis-item.marker-class.vis-selected {
            border-width: 2px;
            background: transparent;
            border-color: var(--marker-selected-border, var(--primary-strong));
            border-style: solid;
            border-radius: 4px;
        }

        #timeline.vis-timeline,
        #timeline.vis-timeline .vis-panel {
            border: var(--border-light) !important;
            box-shadow: none;
        }

        #timeline .vis-timeline {
            border: none !important;
            box-shadow: none !important;
        }

        /* Remove / soften group borders */
        .vis-major,
        .vis-panel {
            border: var(--border-light) !important;
            /* ou alors une ligne super douce : */
            /* border-bottom: 1px solid rgba(0,0,0,0.06) !important; */
        }

        /* Option : rendre la ligne de s√©paration ultra discr√®te */
        .vis-group-level-0 {
            border: var(--border-light) !important;
        }

        .vis-group:not(:last-child) {
            border-bottom: 1px dotted var(--border-light) !important;
        }


        .vis-time-axis .vis-text {
            font-size: var(--global-font-size);
            color: var(--muted);
            font-weight: 600;
            overflow: visible;
        }

        #timeline .vis-time-axis .vis-grid.vis-vertical {
            border-left: 1px dotted var(--border-light) !important;
        }

        #timeline .vis-time-axis .vis-grid.vis-major {
            border-left: 1px dotted var(--border-light) !important;
        }

        .vis-panel.vis-center,
        .vis-panel.vis-left {
            border-color: var(--border-light);
        }

        @media (max-width: 900px) {
            .app {
                grid-template-columns: 1fr;
            }

            .app-main {
                position: relative;
            }

            .gutenberg-card {
                display: none;
                position: absolute;
                top: 0;
                right: 0;
                bottom: 0;
                width: min(360px, 90vw);
                max-width: 100%;
                flex: 0 0 auto;
                box-shadow: var(--shadow-soft);
                transform: translateX(110%);
                opacity: 0;
                pointer-events: none;
                visibility: hidden;
                z-index: 90;
            }

            .gutenberg-card.open {
                display: flex;
                transform: translateX(0);
                opacity: 1;
                pointer-events: auto;
                visibility: visible;
            }
        }
    </style>
</head>

<body class="app-body">
    <div class="app">
        <div class="app-header">
            <div class="tabs-actions">
                <a class="app-home-link" href="index.html" title="Revenir √† l'accueil">‚òç</a>
                <div class="nav-switch">
                    <button id="navSwitcherBtn" class="nav-switch-btn" type="button" aria-haspopup="true"
                        aria-expanded="false">‚á• Timeline ‚ñæ</button>
                    <div id="navSwitcherMenu" class="nav-switch-menu" role="menu">
                        <a class="nav-switch-link" href="canvas.html?v=2025.12.25.1" role="menuitem"> ‚óç Canvas</a>
                        <a class="nav-switch-link" href="grid.html?v=2025.12.25.1" role="menuitem">‚ñ¶ Grid</a>
                        <a class="nav-switch-link" href="draw.html?v=2025.12.25.1" role="menuitem">‚óá Draw</a>
                        <a class="nav-switch-link" href="voice.html?v=2025.12.25.1" role="menuitem">‚ñ∑ Voice</a>
                    </div>
                </div>

                <div class="tabs-wrapper">
                    <div id="viewTabs" class="tabs"></div>
                    <div class="tab-actions">
                        <button class="tab-action" id="addViewBtn" type="button" aria-label="Ajouter une vue">+</button>
                        <button class="tab-action" id="deleteViewBtn" type="button"
                            aria-label="Supprimer la vue active">√ó</button>
                    </div>
                </div>

                <!-- Template modal (6 choices) -->
                <div class="modal-overlay gt-template-modal" id="gtTemplateModal" role="dialog" aria-modal="true"
                    aria-labelledby="gtTemplateModalTitle">
                    <div class="modal gt-template-modal__dialog">
                        <div class="modal-header">
                            <h3 id="gtTemplateModalTitle" title="‚äû Petit Robert Downey Jr">‚äû Mod√®le</h3>
                            <button class="modal-close" id="gtTemplateModalClose" type="button"
                                aria-label="Fermer ‚äû Mod√®le">√ó</button>
                        </div>
                        <div class="gt-template-modal__list" id="gtTemplateModalList">
                            <!-- cards rendered by JS -->
                        </div>
                        <div class="modal-actions">
                            <button id="gtTemplateModalApply" class="btn-primary">Appliquer</button>
                        </div>
                    </div>
                </div>

                <div class="global-actions">
                    <button class="btn" id="gtTemplateModalTrigger" aria-label="Ouvrir ‚äû Mod√®le"
                        title="‚äû Petit Robert Downey Jr">‚äû Mod√®le</button>
                    <button class="btn" id="gtContextModalTrigger" aria-label="Ouvrir Contexte" title="‚∏ô Gutenberg">‚∏ô
                        Contexte</button>
                    <button class="btn" id="gtPromptModalTrigger" aria-label="Ouvrir Prompt" title="‚åò Prompt">‚åò
                        Prompt</button>

                    <div class="menu-trigger">
                        <button class="btn" id="optionsBtn" aria-label="Affichage" title="Affichage">‚óØ
                            Affichage</button>
                        <div class="context-menu" id="optionsMenu">
                            <div class="menu-panel">
                                <label>
                                    Taille (px)
                                    <select id="fontSizeInput">
                                        <option value="8">8</option>
                                        <option value="9">9</option>
                                        <option value="10">10</option>
                                        <option value="11">11</option>
                                        <option value="12">12</option>
                                        <option value="13">13</option>
                                        <option value="14">14</option>
                                        <option value="15">15</option>
                                        <option value="16">16</option>
                                    </select>
                                </label>
                                <label>
                                    Fond
                                    <select id="backgroundSelector">
                                        <option value="#ffffff" selected>Blanc</option>
                                        <option value="transparent">Transparent</option>
                                    </select>
                                </label>
                                <label>
                                    Largeur
                                    <select id="widthSelect">
                                        <option value="full">Plein √©cran</option>
                                        <option value="16:9">16/9</option>
                                        <option value="4:3">4/3</option>
                                        <option value="a4">A4</option>
                                    </select>
                                </label>
                                <label>
                                    Espacement
                                    <select id="spacingSelect">
                                        <option value="dense">Compact</option>
                                        <option value="normal">Normal</option>
                                        <option value="comfortable">Confortable</option>
                                    </select>
                                </label>
                                <label>
                                    Quadrillage
                                    <select id="borderLightSelect">
                                        <option value="blanc">Blanc</option>
                                        <option value="clair">Clair</option>
                                        <option value="sombre">Sombre</option>
                                    </select>
                                </label>
                                <label>
                                    Afficher les dur√©es
                                    <select id="itemDurationSelect">
                                        <option value="none" selected>Masquer</option>
                                        <option value="days">Afficher (jours)</option>
                                        <option value="weeks">Afficher (semaines)</option>
                                    </select>
                                </label>
                                <label>
                                    Afficher les week-ends
                                    <select id="weekendVisibilitySelect">
                                        <option value="show">Oui</option>
                                        <option value="hide">Non</option>
                                    </select>
                                </label>
                            </div>
                        </div>
                    </div>

                    <div class="menu-trigger">
                        <button class="btn" id="fileMenuBtn" aria-label="Capsule">‚¨† Capsule</button>
                        <div class="context-menu file-menu" id="fileMenu">
                            <div class="menu-panel">
                                <button id="newDocumentBtn" type="button" class="menu-panel-btn">üóã Nouveau</button>
                                <button id="saveDocumentBtn" type="button" class="menu-panel-btn">üñ´
                                    Enregistrer</button>
                                <button id="importJsonBtn" type="button" class="menu-panel-btn">‚§∑ Ouvrir</button>
                                <button id="exportJsonBtn" type="button" class="menu-panel-btn">‚≠≥ T√©l√©charger</button>
                                <button id="exportTextBtn" type="button" class="menu-panel-btn">¬∂ Texte</button>
                                <button id="exportImageBtn" type="button" class="menu-panel-btn">‚ó© Image</button>
                                <button id="exportExcelBtn" type="button" class="menu-panel-btn">‚ñ• Excel</button>
                                <button id="aboutTimelineBtn" type="button" class="menu-panel-btn">‚éâ Vaisseau</button>
                            </div>
                        </div>
                    </div>

                    <div class="menu-trigger">
                        <button id="shareBtn" class="btn btn-secondary" type="button" aria-label="Partager"
                            title="Lien de la capsule">‚òç Nexus</button>
                        <div data-share-menu-slot></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="app-main">
            <!-- TIMELINE + TOOLBAR -->
            <div class="timeline-card" data-spacing="dense" data-ratio="full">


                <div class="toolbar">
                    <div class="btn-group">
                        <button class="btn-small" id="btn-today">Aujourd'hui</button>
                    </div>

                    <div class="btn-group">
                        <button class="btn-small" id="btn-zoom-in">+</button>
                        <button class="btn-small" id="btn-fit">Auto</button>

                        <button class="btn-small" id="btn-zoom-out">‚àí</button>
                    </div>

                    <div class="btn-group">
                        <button class="btn-small" id="btn-scale-day">Jour</button>

                        <button class="btn-small btn-small-active" id="btn-scale-week">Semaine</button>
                        <button class="btn-small" id="btn-scale-month">Mois</button>
                    </div>
                    <div class="btn-group item-actions">
                        <button class="btn-small" id="btn-rename-selected" aria-label="Renommer l‚Äô√©l√©ment s√©lectionn√©">
                            ‚úé
                        </button>
                        <button class="btn-small" id="btn-delete-selected" aria-label="Supprimer l‚Äô√©l√©ment s√©lectionn√©">
                            √ó
                        </button>
                        <div class="type-selector btn" aria-label="Type d‚Äôaction" role="group">
                            <span class="type-selector-icon" aria-hidden="true">#</span>
                            <select id="itemTypeSelect" aria-label="Changer le type d‚Äôaction">
                                <option value="">Type d'action</option>
                            </select>
                        </div>
                    </div>
                    <div class="btn-group">
                        <button class="btn-small" id="btn-add-milestone" aria-label="Ajouter un rep√®re">
                            + Rep√®re
                        </button>
                        <button class="btn-small" id="btn-add-item" aria-label="Ajouter un √©l√©ment">
                            + Action
                        </button>
                        <button class="btn-small" id="btn-add-type" aria-label="Ajouter un type">
                            + Type
                        </button>
                        <button class="btn-small" id="btn-add-group" aria-label="Ajouter un groupe">
                            + Groupe
                        </button>
                    </div>
                    <div class="btn-group">
                        <button class="btn-small" id="openColorPaletteBtn" aria-label="G√©rer les types">‚öô
                            R√©glages</button>
                    </div>
                </div>
                <div class="timeline-header">
                    <div class="header-text">
                        <h1>Page 1</h1>
                    </div>
                    <div class="header-buttons">
                        <div class="type-filter-panel" id="typeFilterPanel" role="group" aria-label="Filtrer par type">
                        </div>
                    </div>
                </div>
                <div class="timeline-wrapper">
                    <div id="timeline"></div>
                    <div id="timelineEmptyState" class="timeline-empty-state" aria-hidden="true">
                        <p class="timeline-empty-text">Page vide. Remplir le Sc√©nario ‚Üí et cliquer sur ‚åò R√©pondre</p>

                    </div>
                </div>
            </div>

            <div class="gutenberg-card" id="gtContextModal" role="complementary"
                aria-label="Contexte" aria-hidden="true">

                <div class="ia-actions">
                    <div class="header-row ia-header-actions gutenberg-recette">
                        <div class="gutenberg-recette-header">
                            <label for="promptCreate">Sc√©nario</label>
                            <button class="btn" type="button" id="clearTimelineBtn"
                                aria-label="R√©initialiser la timeline et le script">‚äò Vider</button>
                            <button class="btn btn-primary" id="btn-call">
                                <span>‚åò R√©pondre</span>
                            </button>
                        </div>
                        <div class="ia-prompt-fields">
                            <div class="prompt-template-meta" id="promptTemplateMeta">Mod√®le : ‚Äî</div>
                            <div class="speech-field-wrapper">
                                <div class="speech-suggestion" data-speech-suggestion="promptCreate" aria-hidden="true">
                                </div>
                                <textarea id="promptCreate" class="ia-prompt-field" rows="16"
                                    placeholder="D√©cris ici ton objectif, ton √©ch√©ance et tes actions"></textarea>
                                <button class="speech-button" type="button" data-speech-target="promptCreate"
                                    title="Dict√©e vocale" aria-label="Activer la dict√©e vocale">‚óâ</button>
                            </div>
                        </div>
                    </div>
                    <div class="header-row ia-header-actions gutenberg-script">
                        <div class="gutenberg-recette-header">
                            <label for="promptModify"
                                style="margin-top:0;display:block;font-size:13px;color:var(--muted)">Script</label>
                            <button class="btn" type="button" id="restoreScriptBtn"
                                title="Restaurer la derni√®re r√©ponse IA">‚Ü∫ Restaurer</button>
                            <!-- `openModifyPromptBtn` removed: button hidden per user request -->
                        </div>
                        <div class="ia-prompt-fields">
                            <textarea id="promptModify" class="ia-prompt-field" rows="20"></textarea>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="modal-overlay gt-prompt-modal" id="gtPromptModal" role="dialog" aria-modal="true" aria-labelledby="gtPromptModalTitle">
            <div class="modal">
                <div class="modal-header">
                    <h3 id="gtPromptModalTitle" title="‚åò Prompt">‚åò Prompt</h3>
                    <button class="modal-close" id="gtPromptModalClose" type="button" aria-label="Fermer l'IA">√ó</button>
                </div>
                <div class="ia-actions">
                    <div class="header-row ia-header-actions">
                        <label for="iaTemplateEditor">Prompt</label>
                        <textarea id="iaTemplateEditor" rows="14"
                            style="font-family: Menlo, Consolas, 'Courier New', monospace; font-size:13px; line-height:1.2; height:350px; overflow:auto; resize:vertical; padding:8px;">
                        </textarea>
                    </div>
                    <div class="header-row ia-header-actions ia-key-row">
                        <label>
                            <a href="https://platform.openai.com/settings/organization/api-keys" target="_blank"
                                rel="noreferrer">OpenAI API key</a>
                            <input type="password" id="iaApiKeyInput" autocomplete="off" placeholder="sk-...">
                        </label>
                        <label>
                            <span>Vitesse</span>
                            <select id="reasoningEffortSelect"
                                style="border: 1px solid #d0c3ad; font-size: 13px; font-family: inherit; color: inherit;">
                                <option value="minimal">√âclair</option>
                                <option value="low" selected>Rapide</option>
                                <option value="medium">Fluide</option>
                                <option value="high">Turbo</option>
                            </select>
                        </label>
                    </div>
                    <div class="ia-actions-footer ia-template-footer">
                        <div class="modal-actions" style="width:100%; justify-content:flex-end;">
                            <button class="btn btn-secondary" type="button" id="resetTemplatesBtn">‚Ü∫
                                R√©initialiser</button>
                            <button class="btn-primary" type="button" id="iaApplyBtn">Appliquer</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="color-modal-overlay" id="colorModalOverlay" role="dialog" aria-modal="true"
            aria-labelledby="colorModalTitle">
            <div class="color-modal">
                <div class="modal-header">
                    <h3 id="colorModalTitle">Type</h3>
                    <button class="modal-close" id="colorModalClose" type="button"
                        aria-label="Fermer la palette">√ó</button>
                </div>
                <div class="color-modal-body">
                    <div class="color-types" id="colorTypeList"></div>
                </div>
                <div class="color-actions">
                    <button class="btn btn-secondary" type="button" id="randomizeColorsBtn">Reg√©n√©rer</button>
                    <button class="btn btn-primary" type="button" id="saveColorPreferencesBtn">Valider</button>
                </div>
            </div>
        </div>

        <div id="timelineInfoPopup" class="info-popup" role="dialog" aria-live="polite">
            <img src="logo.gif" alt="Logo Go-Toolkit">
            <strong>Module Timeline (Goal Digger)</strong>
            <span>Version 2025.12.07</span>
            <span>D√©velopp√© par Quang TRAN.</span>
            <span>Usage r√©serv√© √† Savane Consulting.</span>
            <div class="info-actions">
                <button id="timelineUpdateBtn" type="button" class="update-btn">R√©initialiser</button>
                <button id="timelineTourReplayBtn" type="button" class="secondary">Tour guid√©</button>
            </div>
        </div>

        <div id="timelineTourOverlay" class="tour-overlay" aria-hidden="true">
            <div class="tour-highlight hidden" aria-hidden="true"></div>
            <div class="tour-panel">
                <span class="tour-step-counter" id="timelineTourStepCounter"></span>
                <h4 id="timelineTourStepTitle"></h4>
                <p id="timelineTourStepDescription"></p>
                <div class="tour-step-footer">
                    <button id="timelineTourPrevBtn" type="button">Pr√©c√©dent</button>
                    <button id="timelineTourNextBtn" type="button" class="primary">Suivant</button>
                    <button id="timelineTourCloseBtn" type="button">Fermer</button>
                </div>
            </div>
            <button id="timelineTourSkipBtn" class="tour-skip" type="button">√ó</button>
        </div>

        <div data-toast-slot="copyToast" data-toast-class="toast" data-toast-aria-live="polite" data-toast-aria-atomic="true"></div>
        <div data-toast-slot="speechToast" data-toast-class="toast" data-toast-aria-live="polite" data-toast-aria-atomic="true"></div>

        <input type="file" id="importJsonInput" accept="application/json" style="display:none">
        <script>
            window.GO_TOOLKIT_SHARE_API_URL =
                window.GO_TOOLKIT_SHARE_API_URL || "https://share.gotoolkit.workers.dev/";
        </script>
        <script src="js/idb-doc-store.js"></script>
        <script src="js/storage-service.js"></script>
        <script src="js/shared-ui.js"></script>
        <script src="js/share-worker-client.js"></script>
        <script src="js/share-history.js"></script>
        <script src="js/capsule-drafts.js"></script>
        <script src="js/prompt.js?v=2025.12.25.1"></script>
        <script src="js/ia-client.js"></script>
        <script src="js/ia-config.js"></script>
        <script src="js/template-criteria.js"></script>
        <script>
            (async function () {
                // ============================================================
                // 1. Schema JSON ¬∑ planning-v1 (doc d√©veloppeur)
                // ============================================================
                /*
                    OpenAI doit renvoyer un objet de forme :
        
                    {
                      "timeline": {          // optionnel
                        "start": "2025-01-01",
                        "end":   "2025-03-31"
                      },
                      "groups": [
                        { "id": "markers", "label": "Rep√®res" },
                        { "id": "team-alpha", "label": "Team Alpha ‚Äì Core Engine" },
                        ...
                      ],
                      "markers": [
                        { "id": "jalon", "label": "Jalon" }
                      ],
                      "types": [
                        { "id": "feature", "label": "Feature" }
                      ],
                      "items": [
                        // jalon ponctuel
                        {
                          "id": "ms-1",
                          "groupId": "markers",
                          "label": "System Demo 1",
                          "kind": "jalon",
                          "date": "2025-01-15"
                        },
                        // t√¢che avec d√©but / fin
                        {
                          "id": "it-1",
                          "groupId": "team-alpha",
                          "label": "Feature X",
                          "kind": "feature",   // "feature" | "enabler" | "bug" | "other"
                          "start": "2025-01-05",
                          "end": "2025-02-02"
                        }
                      ]
                    }
        
                    ‚Üí Ce fichier se charge de mapper ce JSON vers vis-timeline,
                      et permet aussi de r√©exporter le planning dans ce format.
                */

                // ============================================================
                // 2. Setup vis-timeline (groups + items)
                // ============================================================
                var DataSet = vis.DataSet;
                var Timeline = vis.Timeline;
                if (window.moment && typeof moment.locale === "function") {
                    moment.locale("fr");
                }

                var container = document.getElementById("timeline");
                var timelineCard = document.querySelector(".timeline-card");
                var timelineWrapper = document.querySelector(".timeline-wrapper");
                var itemDurationSelect = document.getElementById("itemDurationSelect");
                var weekendVisibilitySelect = document.getElementById("weekendVisibilitySelect");
                var editTooltip = document.createElement("div");
                editTooltip.className = "edit-tooltip";
                if (timelineWrapper) {
                    timelineWrapper.appendChild(editTooltip);
                }
                var lastPointerPosition = { x: null, y: null };
                if (timelineWrapper) {
                    timelineWrapper.addEventListener("mousemove", function (event) {
                        lastPointerPosition.x = event.clientX;
                        lastPointerPosition.y = event.clientY;
                        if (editTooltip.classList.contains("visible")) {
                            positionEditTooltip(event.clientX, event.clientY);
                        }
                    });
                }

                var groups = new DataSet();
                var items = new DataSet();
                function handleDataMutation() {
                    persistCurrentPlanning();
                    updateEmptyViewMessage();
                }
                items.on("add", handleDataMutation);
                items.on("update", handleDataMutation);
                items.on("remove", handleDataMutation);
                groups.on("add", handleDataMutation);
                groups.on("update", handleDataMutation);
                groups.on("remove", handleDataMutation);
                var itemsView = new vis.DataView(items, {
                    filter: function (item) {
                        return matchesFilters(item, filterState);
                    }
                });

                var now = new Date();
                var oneDay = 24 * 60 * 60 * 1000;
                var oneWeek = 7 * oneDay;
                var snapMode = "week";
                var currentScaleMode = "week";
                var typeDefinitions = {};
                function getTypeDefinition(id) {
                    var key = sanitizeTypeId(id || "");
                    return key ? typeDefinitions[key] : null;
                }
                function isMarkerKind(kindId) {
                    var key = sanitizeTypeId(kindId || "");
                    if (!key) return false;
                    var def = getTypeDefinition(key);
                    if (def && def.isMarker) return true;
                    // Legacy support for previously hard-coded milestone id
                    return key === "milestone";
                }
                var filterState = { kinds: {} };
                var typeFilterPanel = document.getElementById("typeFilterPanel");
                var itemTypeSelect = document.getElementById("itemTypeSelect");
                var btnAddType = document.getElementById("btn-add-type");
                var typeSelectorControl = document.querySelector(".type-selector");
                var timeline = null;
                var emptyStateElement = document.getElementById("timelineEmptyState");
                var emptyStateAction = document.getElementById("timelineEmptyAction");
                var emptyStateTextEl = document.querySelector(".timeline-empty-text");
                var defaultEmptyText = emptyStateTextEl ? emptyStateTextEl.textContent.trim() : "";
                var defaultEmptyLinkText = emptyStateAction ? emptyStateAction.textContent.trim() : "";
                var OPENAI_PROXY_URL = "https://openai.gotoolkit.workers.dev/v1/responses";
                var OPENAI_MODEL = "gpt-5-nano";
                var OPENAI_TEMPERATURE = 1;
                var LOCAL_STORAGE_KEY = "timeline-planning-state";
                var typeStyleElement = document.createElement("style");
                typeStyleElement.id = "timeline-type-styles";
                document.head.appendChild(typeStyleElement);
                var persistenceLocked = false;
                var persistedTimelineBrief = "";
                var contextUiReady = false;
                var lastTimelineGenerationAt = 0;
                var AUTO_CONTEXT_SUPPRESSION_MS = 15000;
                var shouldOpenContextOnFirstLoad = false;
                var initialPromptModalOpened = false;
                var GUTENBERG_SEEN_KEY = "nuances-gutenberg-opened-timeline";
                var GUTENBERG_OPEN_STATE_KEY = "nuances-gutenberg-open-state-timeline";
                var DEFAULT_CONTEXT_STATE = {
                    prompts: {
                        create: "",
                        modify: null
                    },
                    templateId: "default"
                };
                var customSystemTemplates = {
                    create: ""
                };
                var allowedBackgroundValues = ["transparent", "#ffffff"];
                function deepClone(value) {
                    if (value === undefined || value === null) return value;
                    return JSON.parse(JSON.stringify(value));
                }
                function matchesFilters(item, state) {
                    if (!item || !state) return true;
                    var kind = sanitizeTypeId(item.kind || item.type || "");
                    if (!kind) return true;
                    return state.kinds[kind] !== false;
                }
                function ensureKindFilter(kind) {
                    if (!kind) return;
                    if (!Object.prototype.hasOwnProperty.call(filterState.kinds, kind)) {
                        filterState.kinds[kind] = true;
                    }
                }
                var DEMO_STATE = {
                    views: [],
                    displayPreferences: null
                };
                function sanitizeTypeId(raw) {
                    var id = (raw || "").toString().trim();
                    return id || "feature";
                }

                function hslToHex(h, s, l) {
                    var hue = ((h % 360) + 360) % 360;
                    var sat = Math.max(0, Math.min(100, s)) / 100;
                    var light = Math.max(0, Math.min(100, l)) / 100;
                    var c = (1 - Math.abs(2 * light - 1)) * sat;
                    var x = c * (1 - Math.abs(((hue / 60) % 2) - 1));
                    var m = light - c / 2;
                    var r = 0;
                    var g = 0;
                    var b = 0;
                    if (hue < 60) {
                        r = c;
                        g = x;
                    } else if (hue < 120) {
                        r = x;
                        g = c;
                    } else if (hue < 180) {
                        g = c;
                        b = x;
                    } else if (hue < 240) {
                        g = x;
                        b = c;
                    } else if (hue < 300) {
                        r = x;
                        b = c;
                    } else {
                        r = c;
                        b = x;
                    }
                    var red = Math.round((r + m) * 255);
                    var green = Math.round((g + m) * 255);
                    var blue = Math.round((b + m) * 255);
                    var toHex = function (value) {
                        var str = value.toString(16);
                        return str.length === 1 ? "0" + str : str;
                    };
                    return "#" + toHex(red) + toHex(green) + toHex(blue);
                }

                function clampColorValue(value) {
                    if (typeof value !== "number" || isNaN(value)) {
                        return 0;
                    }
                    return Math.max(0, Math.min(255, Math.round(value)));
                }

                function parseRgbColor(value) {
                    if (!value || typeof value !== "string") {
                        return null;
                    }
                    var input = value.trim().toLowerCase();
                    if (!input || input === "transparent") {
                        return null;
                    }
                    var hexMatch = input.match(/^#([a-f0-9]{3}|[a-f0-9]{6})$/i);
                    if (hexMatch) {
                        var hex = hexMatch[1];
                        if (hex.length === 3) {
                            return {
                                r: clampColorValue(parseInt(hex[0] + hex[0], 16)),
                                g: clampColorValue(parseInt(hex[1] + hex[1], 16)),
                                b: clampColorValue(parseInt(hex[2] + hex[2], 16)),
                                a: 1
                            };
                        }
                        return {
                            r: clampColorValue(parseInt(hex.slice(0, 2), 16)),
                            g: clampColorValue(parseInt(hex.slice(2, 4), 16)),
                            b: clampColorValue(parseInt(hex.slice(4, 6), 16)),
                            a: 1
                        };
                    }
                    var rgbMatch = input.match(/^rgba?\(([^)]+)\)$/);
                    if (rgbMatch) {
                        var parts = rgbMatch[1].split(",").map(function (part) {
                            return part.trim();
                        });
                        if (parts.length < 3) {
                            return null;
                        }
                        var r = parseInt(parts[0], 10);
                        var g = parseInt(parts[1], 10);
                        var b = parseInt(parts[2], 10);
                        var alpha = parts.length === 4 ? parseFloat(parts[3]) : 1;
                        return {
                            r: clampColorValue(r),
                            g: clampColorValue(g),
                            b: clampColorValue(b),
                            a: Math.max(0, Math.min(1, isNaN(alpha) ? 1 : alpha))
                        };
                    }
                    return null;
                }

                function rgbaToCss(components) {
                    if (!components) return null;
                    if (components.a === undefined || components.a === null || components.a >= 1) {
                        return "rgb(" + components.r + ", " + components.g + ", " + components.b + ")";
                    }
                    return (
                        "rgba(" +
                        components.r +
                        ", " +
                        components.g +
                        ", " +
                        components.b +
                        ", " +
                        components.a +
                        ")"
                    );
                }

                function getContrastingTextColor(value) {
                    var parsed = parseRgbColor(value);
                    if (!parsed) return null;
                    var alpha = parsed.a === undefined || parsed.a === null ? 1 : parsed.a;
                    if (alpha <= 0) {
                        return null;
                    }
                    if (alpha < 1) {
                        return "#0f172a";
                    }
                    var luminance = (parsed.r * 299 + parsed.g * 587 + parsed.b * 114) / 1000;
                    return luminance >= 180 ? "#0f172a" : "#ffffff";
                }

                function getDarkerColor(source, amount) {
                    var parsed = parseRgbColor(source);
                    if (!parsed) return source;
                    var factor = Math.max(0, Math.min(1, amount || 0));
                    var darkened = {
                        r: clampColorValue(parsed.r * (1 - factor)),
                        g: clampColorValue(parsed.g * (1 - factor)),
                        b: clampColorValue(parsed.b * (1 - factor)),
                        a: parsed.a
                    };
                    return rgbaToCss(darkened) || source;
                }

                function updateTypeShades(def) {
                    if (!def) return;
                    var accentBase = def.background && def.background !== "transparent"
                        ? def.background
                        : def.color && def.color !== "transparent"
                            ? def.color
                            : def.border || "#0f172a";
                    var borderSource = accentBase;
                    var textSource = def.color && def.color !== "transparent" ? def.color : accentBase;
                    def.darkBorder = getDarkerColor(borderSource, 0.28);
                    def.darkText = getDarkerColor(textSource, 0.45);
                    var contrastSource = accentBase;
                    var contrastColor = getContrastingTextColor(contrastSource);
                    def.contrastTextColor = contrastColor || def.darkText || def.color || "#0f172a";
                }

                function getRainbowColor() {
                    var hue = Math.random() * 360;
                    var saturation = 65 + Math.random() * 15;
                    var lightness = 76 + Math.random() * 6;
                    return hslToHex(hue, saturation, lightness);
                }

                function generateRainbowPalette(count) {
                    var palette = [];
                    var size = Math.max(1, count || 1);
                    var baseHue = Math.random() * 360;
                    var step = 360 / size;
                    for (var i = 0; i < size; i++) {
                        var hue = (baseHue + i * step) % 360;
                        var saturation = 65 + Math.random() * 15;
                        var lightness = 76 + Math.random() * 6;
                        palette.push(hslToHex(hue, saturation, lightness));
                    }
                    return palette;
                }

                function normalizeHexColor(value) {
                    if (!value || typeof value !== "string") return null;
                    var trimmed = value.trim().toLowerCase();
                    if (trimmed === "transparent") return "transparent";
                    if (trimmed[0] !== "#") trimmed = "#" + trimmed;
                    if (/^#([a-f0-9]{6})$/.test(trimmed)) {
                        return trimmed;
                    }
                    var shortMatch = trimmed.match(/^#([a-f0-9]{3})$/);
                    if (shortMatch) {
                        return (
                            "#" +
                            shortMatch[1]
                                .split("")
                                .map(function (char) { return char + char; })
                                .join("")
                        );
                    }
                    return null;
                }

                function setPreviewColor(preview, color) {
                    if (!preview) return;
                    if (color === "transparent") {
                        preview.style.backgroundImage =
                            "repeating-linear-gradient(45deg, rgba(15, 23, 42, 0.08) 0 6px, transparent 6px 12px)";
                        preview.style.backgroundColor = "transparent";
                    } else {
                        preview.style.backgroundImage = "none";
                        preview.style.backgroundColor = color;
                    }
                }

                function rebuildTypeStyles() {
                    var rules = Object.keys(typeDefinitions).map(function (key) {
                        var def = typeDefinitions[key];
                        var background = def.isMarker ? "transparent" : def.background;
                        var effectiveBorder = def.darkBorder || def.border;
                        var effectiveColor = def.contrastTextColor || def.darkText || def.color;
                        var ruleLines = [
                            ".vis-item.type-" + def.id + " {",
                            "  background: " + background + ";",
                            "  --marker-selected-background: " + (def.background || "var(--primary-color)") + ";",
                            "  --marker-selected-border: " + (def.border || "var(--primary-color)") + ";",
                            "  --marker-accent: " + (def.border || "var(--primary-color)") + ";"
                        ];
                        if (!def.isMarker) {
                            ruleLines.push("  color: " + effectiveColor + ";");
                        }
                        ruleLines.push("}");
                        if (def.isMarker) {
                            ruleLines.push([
                                ".vis-item.type-" + def.id + " .vis-item-content {",
                                "  color: var(--text);",
                                "}"
                            ].join("\n"));
                        }
                        return ruleLines.join("\n");
                    });
                    typeStyleElement.textContent = rules.join("\n");
                }

                function ensureTypeDefinition(def) {
                    var base = def || {};
                    var id = sanitizeTypeId(base.id || base.name || base.kind);
                    var colors = def && def.colors ? def.colors : {};
                    var existing = typeDefinitions[id] || {};
                    var background =
                        colors.background || base.background || existing.background || getRainbowColor();
                    var border = colors.border || base.border || existing.border || "var(--primary-color)";
                    var textColor = colors.text || base.color || existing.color || "#111827";
                    var originalLabel = typeof base.label === "string"
                        ? base.label
                        : (typeof base.name === "string"
                            ? base.name
                            : (existing.label || base.id || id));
                    var label = (originalLabel || "").trim() || id;
                    var isMarker = !!base.isMarker || id === "milestone" || existing.isMarker === true;
                    var entry = {
                        id: id,
                        label: label,
                        background: background,
                        border: border,
                        color: textColor,
                        isMarker: isMarker
                    };
                    updateTypeShades(entry);
                    typeDefinitions[id] = entry;
                    ensureKindFilter(id);
                    rebuildTypeStyles();
                    return id;
                }

                function ensureMarkerDefinition(def) {
                    var base = Object.assign({}, def, { isMarker: true });
                    return ensureTypeDefinition(base);
                }

                function formatKindLabel(def) {
                    if (!def) return "";
                    var label = def.label || def.id || "";
                    return def.isMarker ? label + "+" : label;
                }

                function getKindLabel(kindId) {
                    if (!kindId) return "";
                    var def = getTypeDefinition(kindId);
                    if (def) return formatKindLabel(def);
                    return kindId;
                }

                function parseKindLabelInput(raw) {
                    var input = (raw || "").trim();
                    var isMarker = false;
                    if (input.endsWith("+")) {
                        isMarker = true;
                        input = input.replace(/\++\s*$/, "").trim();
                    }
                    var id = sanitizeTypeId(input);
                    if (!id) {
                        id = sanitizeTypeId(raw);
                    }
                    return {
                        id: id,
                        label: input || id,
                        isMarker: isMarker
                    };
                }

                function normalizeTypeCollection(defs) {
                    if (Array.isArray(defs)) return defs;
                    if (defs && typeof defs === "object") {
                        return Object.keys(defs).map(function (key) {
                            var value = defs[key] || {};
                            return {
                                id: key,
                                label: value.label || value.name || value.title || key,
                                background: value.background,
                                border: value.border,
                                color: value.color,
                                isMarker: value.isMarker
                            };
                        });
                    }
                    return [];
                }

                function applyTypeDefinitions(defs, options) {
                    var list = normalizeTypeCollection(defs);
                    if (!Array.isArray(list)) return;
                    var forceMarker = options && options.isMarker;
                    list.forEach(function (def) {
                        var target = {
                            id: def.id,
                            label: def.label,
                            background: def.background,
                            border: def.border,
                            color: def.color,
                            isMarker: forceMarker || def.isMarker === true
                        };
                        if (target.isMarker) {
                            ensureMarkerDefinition(target);
                        } else {
                            ensureTypeDefinition(target);
                        }
                    });
                }

                function snapshotTypeDefinitions(isMarker) {
                    return Object.keys(typeDefinitions)
                        .map(function (key) {
                            var def = typeDefinitions[key];
                            if (!def) return null;
                            if (!!def.isMarker !== !!isMarker) return null;
                            return {
                                id: def.id,
                                label: def.label,
                                background: def.background,
                                border: def.border,
                                color: def.color,
                                isMarker: def.isMarker || undefined
                            };
                        })
                        .filter(Boolean);
                }

                function buildTimelineStatePayload() {
                    var primaryView = views[0] || {};
                    var primaryCtx = normalizeContextState(primaryView.context);
                    var tplMeta = getTemplateById(primaryCtx.templateId || selectedRoadmapPromptId || "");
                    return {
                        views: views.map(function (view) {
                            return {
                                name: view.name,
                                title: view.title,
                                planning: view.planning,
                                context: normalizeContextState(view.context)
                            };
                        }),
                        displayPreferences: Object.assign({}, displayPreferences),
                        types: snapshotTypeDefinitions(false),
                        markers: snapshotTypeDefinitions(true),
                        templates: {
                            create: customSystemTemplates.create
                        },
                        templateId: primaryCtx.templateId || selectedRoadmapPromptId || null,
                        templateName: primaryCtx.templateName || tplMeta?.title || tplMeta?.label || null,
                        brief: getTimelineBrief()
                    };
                }

                function getTimelineBrief() {
                    var context = getActiveViewContext();
                    if (context && context.prompts) {
                        var prompt = context.prompts.create || context.prompts.modify;
                        if (typeof prompt === "string") {
                            return prompt;
                        }
                    }
                    if (typeof txtPromptCreate !== "undefined" && txtPromptCreate && typeof txtPromptCreate.value === "string") {
                        return txtPromptCreate.value;
                    }
                    return persistedTimelineBrief || "";
                }

                function persistTimelineState() {
                    try {
                        var payload = buildTimelineStatePayload();
                        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(payload));
                        if (currentShareToken) {
                            writeShareDraft(currentShareToken, payload, new Date().toISOString());
                        }
                    } catch (err) {
                        console.warn("Impossible de sauvegarder le planning", err);
                    }
                    scheduleDraftSave();
                }

                function loadPersistedTimelineState() {
                    try {
                        var raw = localStorage.getItem(LOCAL_STORAGE_KEY);
                        if (!raw) return null;
                        var parsed = JSON.parse(raw);
                        if (parsed && typeof parsed.brief === "string") {
                            persistedTimelineBrief = parsed.brief;
                        } else {
                            persistedTimelineBrief = "";
                        }
                        return parsed;
                    } catch (err) {
                        console.warn("Impossible de lire le planning sauvegard√©", err);
                        persistedTimelineBrief = "";
                        return null;
                    }
                }

                var views = [];
                var activeViewIndex = 0;
                var displayPreferences = {
                    font: "Inter",
                    fontSize: 14,
                    background: "transparent",
                    ratio: "full",
                    itemDurationMode: "none",
                    spacing: "dense",
                    hideWeekends: true
                    , borderLightMode: DEFAULT_BORDER_LIGHT_MODE
                };
                var colorModalState = {
                    types: {},
                    labels: {},
                    timeline: displayPreferences.background || "#ffffff"
                };

                function cloneDefaultContext() {
                    return deepClone(DEFAULT_CONTEXT_STATE);
                }

                function normalizeContextState(context) {
                    var base = context && typeof context === "object"
                        ? deepClone(context)
                        : cloneDefaultContext();
                    if (!base.prompts || typeof base.prompts !== "object") {
                        base.prompts = { create: "", modify: null };
                    }
                    base.prompts.create = typeof base.prompts.create === "string" ? base.prompts.create : "";
                    base.prompts.modify = typeof base.prompts.modify === "string" ? base.prompts.modify : null;
                    var normalizedTemplateId = typeof base.templateId === "string" ? base.templateId.trim() : "";
                    base.templateId = normalizedTemplateId || "default";
                    base.templateName = typeof base.templateName === "string" ? base.templateName : null;
                    return base;
                }

                function ensureViewContext(view) {
                    if (!view) return cloneDefaultContext();
                    view.context = normalizeContextState(view.context);
                    return view.context;
                }

                function getActiveViewContext() {
                    var view = views[activeViewIndex];
                    if (!view) return cloneDefaultContext();
                    return ensureViewContext(view);
                }
                function padTwoDigits(value) {
                    return value < 10 ? "0" + value : "" + value;
                }

                function formatHiddenWeekDate(date) {
                    return (
                        date.getFullYear() +
                        "-" +
                        padTwoDigits(date.getMonth() + 1) +
                        "-" +
                        padTwoDigits(date.getDate()) +
                        " " +
                        padTwoDigits(date.getHours()) +
                        ":" +
                        padTwoDigits(date.getMinutes()) +
                        ":" +
                        padTwoDigits(date.getSeconds())
                    );
                }

                function buildWeekendHiddenDates() {
                    if (!displayPreferences.hideWeekends) {
                        return [];
                    }
                    var saturday = new Date();
                    var day = saturday.getDay();
                    var offsetToSaturday = (6 - day + 7) % 7;
                    saturday.setDate(saturday.getDate() + offsetToSaturday);
                    saturday.setHours(0, 0, 0, 0);
                    var monday = new Date(saturday);
                    monday.setDate(monday.getDate() + 2);
                    return [
                        {
                            start: formatHiddenWeekDate(saturday),
                            end: formatHiddenWeekDate(monday),
                            repeat: "weekly"
                        }
                    ];
                }
                var savedDraftRecord = null;
                var editDraftId = getEditIdFromUrl();
                if (editDraftId && capsuleDrafts) {
                    try {
                        savedDraftRecord = await capsuleDrafts.getRecord(editDraftId);
                    } catch (err) {
                        console.warn("Impossible de charger la capsule locale", err);
                    }
                }
                var persistedState = savedDraftRecord ? savedDraftRecord.payload : loadPersistedTimelineState();
                shouldOpenContextOnFirstLoad = !persistedState;
                if (savedDraftRecord && persistedState) {
                    currentDraftId = savedDraftRecord.id;
                    updateUrlWithEditId(savedDraftRecord.id);
                }
                if (persistedState) {
                    if (Array.isArray(persistedState.views) && persistedState.views.length) {
                        views = persistedState.views.map(function (view, index) {
                            return {
                                name: view.name || view.title || ("Page " + (index + 1)),
                                title: view.title || view.name || ("Page " + (index + 1)),
                                planning: view.planning || null,
                                context: normalizeContextState(view.context)
                            };
                        });
                    } else if (persistedState.groups) {
                        var defaultLabel = persistedState.label || persistedState.name || "";
                        views = [{
                            name: defaultLabel,
                            title: defaultLabel,
                            planning: persistedState,
                            context: cloneDefaultContext()
                        }];
                    }
                    if (persistedState.displayPreferences) {
                        Object.assign(displayPreferences, persistedState.displayPreferences);
                    }
                    if (Array.isArray(persistedState.types)) {
                        applyTypeDefinitions(persistedState.types);
                    }
                    if (Array.isArray(persistedState.markers)) {
                        applyTypeDefinitions(persistedState.markers, { isMarker: true });
                    }
                    if (persistedState.templates) {
                        if (typeof persistedState.templates.create === "string") {
                            customSystemTemplates.create = persistedState.templates.create;
                        }
                    }
                } else {
                    if (Array.isArray(DEMO_STATE.views) && DEMO_STATE.views.length) {
                        views = deepClone(DEMO_STATE.views);
                    }
                    if (DEMO_STATE.displayPreferences) {
                        var demoPrefs = deepClone(DEMO_STATE.displayPreferences);
                        demoPrefs.background = "#ffffff";
                        Object.assign(displayPreferences, demoPrefs);
                    }
                }
                if (!views.length) {
                    views = [{ name: "Page 1", title: "Page 1", planning: null, context: cloneDefaultContext() }];
                }
                views.forEach(ensureViewFilterState);
                views.forEach(ensureViewContext);
                if (persistedTimelineBrief && views.length) {
                    var firstContext = ensureViewContext(views[0]);
                    var persistedFirstScenario =
                        persistedState &&
                            Array.isArray(persistedState.views) &&
                            persistedState.views[0] &&
                            persistedState.views[0].context &&
                            persistedState.views[0].context.prompts &&
                            typeof persistedState.views[0].context.prompts.create === "string"
                            ? persistedState.views[0].context.prompts.create
                            : "";
                    if (
                        !firstContext.prompts.create &&
                        persistedFirstScenario &&
                        persistedTimelineBrief === persistedFirstScenario
                    ) {
                        firstContext.prompts.create = persistedTimelineBrief;
                    }
                }

                function persistCurrentPlanning() {
                    if (persistenceLocked) return;
                    if (!views[activeViewIndex]) return;
                    views[activeViewIndex].planning = exportPlanningToJson();
                    persistTimelineState();
                }

                function updateEmptyViewMessage() {
                    if (!emptyStateElement || !items || typeof items.get !== "function") return;
                    var isEmpty = items.get().length === 0;
                    emptyStateElement.classList.toggle("visible", isEmpty);
                    emptyStateElement.setAttribute("aria-hidden", isEmpty ? "false" : "true");
                }

                function setEmptyStateLoading(isLoading, counter) {
                    if (!emptyStateTextEl) return;
                    if (isLoading) {
                        var frames = ["‚ó¥", "‚ó∑", "‚ó∂", "‚óµ"];
                        var frame = frames[(typeof counter === "number" ? counter : 0) % frames.length];
                        var label = frame + " Attente" + (typeof counter === "number" ? " " + counter + "s" : "");
                        emptyStateTextEl.textContent = label;
                        if (emptyStateAction) {
                            emptyStateAction.style.display = "none";
                        }
                    } else {
                        emptyStateTextEl.textContent = defaultEmptyText;
                        if (emptyStateAction) {
                            emptyStateAction.textContent = defaultEmptyLinkText;
                            emptyStateAction.style.display = "";
                        }
                    }
                }

                function syncContextUIForActiveView() {
                    syncContextFieldsFromState({ refreshModify: true, skipPersist: true });
                }

                function readTimelineContextOpenState() {
                    try {
                        if (!window.localStorage) return null;
                        var value = localStorage.getItem(GUTENBERG_OPEN_STATE_KEY);
                        if (value === "open") {
                            return true;
                        }
                        if (value === "closed") {
                            return false;
                        }
                    } catch (err) {
                        console.warn("Impossible de lire l'√©tat de Gutenberg", err);
                    }
                    return null;
                }

                function persistTimelineContextOpenState(isOpen) {
                    try {
                        if (!window.localStorage) return;
                        localStorage.setItem(GUTENBERG_OPEN_STATE_KEY, isOpen ? "open" : "closed");
                    } catch (err) {
                        console.warn("Impossible de sauvegarder l'√©tat de Gutenberg", err);
                    }
                }

                function maybeAutoOpenContextModal() {
                    // Auto-open the context (Gutenberg) on desktop for first visit of timeline
                    if (!contextUiReady) return;
                    if (!contextModalOverlay) return;
                    if (contextModalOverlay.classList.contains("open")) return;
                    if (window.innerWidth < 900) return; // skip on responsive
                    var storedState = readTimelineContextOpenState();
                    if (storedState === true) {
                        openContextModal();
                        return;
                    }
                    if (storedState === false) {
                        return;
                    }
                    if (hasTimelineData()) return;
                    if (lastTimelineGenerationAt && Date.now() - lastTimelineGenerationAt < AUTO_CONTEXT_SUPPRESSION_MS) return;
                    try {
                        var seen = localStorage.getItem(GUTENBERG_SEEN_KEY);
                        if (!seen) {
                            openContextModal();
                            localStorage.setItem(GUTENBERG_SEEN_KEY, "1");
                        }
                    } catch (err) {
                        // ignore storage errors
                        openContextModal();
                    }
                }

                function getActiveTypeIds() {
                    return Object.keys(filterState.kinds).filter(function (key) {
                        return !!filterState.kinds[key];
                    });
                }

                function setKindEnabled(kind, enabled) {
                    filterState.kinds[kind] = enabled;
                    refreshTypeFilterUI(getVisibleViewTypeIds());
                    updateTimelineFilter();
                }

                function refreshTypeFilterUI(typeIds) {
                    if (!typeFilterPanel) return;
                    typeFilterPanel.innerHTML = "";
                    var usage = {};
                    if (items && typeof items.get === "function") {
                        items.get().forEach(function (item) {
                            var kind = sanitizeTypeId(item.kind || item.type || "");
                            if (!kind) return;
                            usage[kind] = (usage[kind] || 0) + 1;
                        });
                    }
                    var orderedIds = getOrderedKindIds(typeIds).filter(function (key) {
                        return usage[key] > 0;
                    });

                    if (!orderedIds.length) {
                        typeFilterPanel.style.display = "none";
                        return;
                    }
                    typeFilterPanel.style.display = "";

                    orderedIds.forEach(function (key) {
                        var def = typeDefinitions[key];
                        if (!def) return;
                        ensureKindFilter(key);
                        var isActive = filterState.kinds[key] !== false;
                        var option = document.createElement("label");
                        option.className = "type-filter-option" + (isActive ? " active" : "");
                        var checkbox = document.createElement("input");
                        checkbox.type = "checkbox";
                        checkbox.checked = isActive;
                        checkbox.dataset.kind = key;
                        var baseColor = def.background && def.background !== "transparent"
                            ? def.background
                            : "rgba(15, 23, 42, 0.08)";
                        var backgroundColor = isActive ? baseColor : "#ffffff";
                        var typeBorderColor = def.darkBorder || def.border || "#fff";
                        var typeTextColor = def.contrastTextColor || def.darkText || def.color || "#0f172a";
                        var borderColor = isActive ? typeBorderColor : "rgba(15, 23, 42, 0.15)";
                        var textColor = isActive ? typeTextColor : "var(--text)";
                        option.style.background = backgroundColor;
                        option.style.borderColor = borderColor;
                        option.style.color = textColor;
                        var labelText = document.createElement("span");
                        labelText.className = "type-filter-label";
                        labelText.textContent = formatKindLabel(def) || key;

                        checkbox.addEventListener("change", function () {
                            var enabled = checkbox.checked;
                            setKindEnabled(key, enabled);
                        });

                        option.appendChild(checkbox);
                        option.appendChild(labelText);
                        typeFilterPanel.appendChild(option);
                    });
                }

                function updateTimelineFilter() {
                    if (itemsView && typeof itemsView.refresh === "function") {
                        itemsView.refresh();
                    }
                    if (timeline && typeof timeline.redraw === "function") {
                        timeline.redraw();
                    }
                }

                function normalizeToDay(value) {
                    if (!value) return null;
                    var clone = new Date(value);
                    clone.setHours(0, 0, 0, 0);
                    return clone;
                }

                function countDaysBetween(startDate, endDate, excludeWeekends) {
                    var start = normalizeToDay(startDate);
                    var end = normalizeToDay(endDate);
                    if (!start || !end) return 0;
                    if (start > end) {
                        var swap = start;
                        start = end;
                        end = swap;
                    }
                    var count = 0;
                    var cursor = new Date(start);
                    while (cursor <= end) {
                        var day = cursor.getDay();
                        if (!excludeWeekends || (day !== 0 && day !== 6)) {
                            count++;
                        }
                        cursor.setDate(cursor.getDate() + 1);
                    }
                    return count;
                }

                function getItemDurationInDays(item) {
                    if (!item) return null;
                    var start = toDate(item.start || item.date);
                    if (!start) return null;
                    var end = toDate(item.end || item.start || item.date) || start;
                    var excludeWeekends = !!displayPreferences.hideWeekends;
                    var totalDays = countDaysBetween(start, end, excludeWeekends);
                    return totalDays || 1;
                }

                function formatItemDurationSuffix(item) {
                    var days = getItemDurationInDays(item);
                    if (!days) return null;
                    var mode = displayPreferences.itemDurationMode || "none";
                    if (mode === "weeks") {
                        var weeks = Math.max(1, Math.ceil(days / 7));
                        return "- " + weeks + " sem.";
                    }
                    return "- " + days + " j";
                }

                function appendDurationToContent(content, item) {
                    var mode = displayPreferences.itemDurationMode || "none";
                    if (isMarkerKind(item.kind)) return content || "";
                    if (mode === "none") return content || "";
                    var suffix = formatItemDurationSuffix(item);
                    if (!suffix) return content || "";
                    var trimmed = (content || "").trim();
                    return trimmed ? trimmed + " " + suffix : suffix;
                }

                function formatTooltipDate(value) {
                    var date = toDate(value);
                    if (!date) return "";
                    var day = date.getDate();
                    var month = date.getMonth() + 1;
                    var paddedDay = day < 10 ? "0" + day : day;
                    var paddedMonth = month < 10 ? "0" + month : month;
                    return paddedDay + "/" + paddedMonth;
                }

                function buildTooltipText(item) {
                    var startDate = formatTooltipDate(item.start || item.date);
                    var endDate = formatTooltipDate(item.end || item.start || item.date);
                    if (!startDate || !endDate) return null;
                    var label = (item.content || item.label || "").trim();
                    if (!label) return null;
                    var days = getItemDurationInDays(item);
                    var durationText = days ? " (" + days + " jours)" : "";
                    return label + " ‚Äî " + startDate + " ‚Üí " + endDate + durationText;
                }

                function positionEditTooltip(clientX, clientY) {
                    if (!timelineWrapper) return;
                    var rect = timelineWrapper.getBoundingClientRect();
                    var left = clientX - rect.left;
                    var top = clientY - rect.top;
                    left = Math.max(8, Math.min(rect.width - 8, left));
                    top = Math.max(8, top - 20);
                    editTooltip.style.left = left + "px";
                    editTooltip.style.top = top + "px";
                }

                function positionEditTooltipAtRect(rect) {
                    if (!timelineWrapper || !rect) return;
                    var wrapperRect = timelineWrapper.getBoundingClientRect();
                    var left = rect.left - wrapperRect.left + rect.width / 2;
                    var top = rect.top - wrapperRect.top;
                    left = Math.max(8, Math.min(wrapperRect.width - 8, left));
                    top = Math.max(8, top - 20);
                    editTooltip.style.left = left + "px";
                    editTooltip.style.top = top + "px";
                }

                function getTimelineItemRect(itemId) {
                    if (!timelineWrapper || !itemId) return null;
                    var element = timelineWrapper.querySelector('.vis-item[data-id="' + itemId + '"]');
                    return element ? element.getBoundingClientRect() : null;
                }

                function showEditTooltip(text, rect) {
                    if (!editTooltip || !text) return;
                    editTooltip.textContent = text;
                    editTooltip.classList.add("visible");
                    if (rect) {
                        positionEditTooltipAtRect(rect);
                    } else if (lastPointerPosition.x !== null && lastPointerPosition.y !== null) {
                        positionEditTooltip(lastPointerPosition.x, lastPointerPosition.y);
                    } else if (timelineWrapper) {
                        var wrapperRect = timelineWrapper.getBoundingClientRect();
                        editTooltip.style.left = wrapperRect.width / 2 + "px";
                        editTooltip.style.top = "10px";
                    }
                }

                function hideEditTooltip() {
                    if (!editTooltip) return;
                    editTooltip.classList.remove("visible");
                }

                function normalizeItemAfterResize(item) {
                    if (!item) return item;
                    var previous = items.get(item.id) || {};
                    var startDate = item.start ? new Date(item.start) : null;
                    var endDate = item.end ? new Date(item.end) : null;
                    var hasValidEnd = endDate && !isNaN(endDate.getTime());
                    var hasValidStart = startDate && !isNaN(startDate.getTime());
                    var durationMs = hasValidStart && hasValidEnd ? endDate.getTime() - startDate.getTime() : 0;
                    var isMilestone = isMarkerKind(previous.kind || item.kind);
                    var epsilon = 5 * 60 * 1000; // 5 minutes to avoid jitter around the threshold
                    var atOrBelowOneDay = hasValidStart && hasValidEnd && durationMs < (oneDay - epsilon);

                    // Constrain non-marker items resized to a single day into markers.
                    if (!isMilestone && atOrBelowOneDay) {
                        var milestoneDate = hasValidStart ? startDate : (previous.start ? new Date(previous.start) : new Date());
                        var markerKind = getFirstMarkerId() || ensureMarkerDefinition({ id: "marker", label: "Rep√®re" });
                        item.kind = markerKind;
                        item.type = "point";
                        item.className = "type-" + markerKind + " type-marker marker-class";
                        item.date = milestoneDate;
                        delete item.end;
                        delete item.start;
                        item.start = milestoneDate;
                        return item;
                    }

                    // Allow markers stretched beyond one day to become regular items.
                    var beyondOneDay = hasValidStart && hasValidEnd && durationMs > (oneDay + epsilon);
                    if (isMilestone && beyondOneDay) {
                        var nextKind = getFirstRegularTypeId();
                        ensureTypeDefinition({ id: nextKind });
                        item.kind = nextKind;
                        item.type = undefined;
                        item.className = "type-" + nextKind;
                        item.end = endDate && endDate > startDate
                            ? endDate
                            : new Date(startDate.getTime() + oneDay);
                        return item;
                    }

                    return item;
                }

                var options = {
                    stack: true,
                    orientation: "top",
                    groupHeightMode: "spacing",
                    editable: {
                        add: true,
                        updateTime: true,
                        updateGroup: true,
                        remove: false
                    },
                    selectable: true,
                    multiselect: false,
                    margin: { item: 8, axis: 10 },
                    locale: "fr",
                    snap: function (date) {
                        var d = new Date(date);
                        if (snapMode === "day") {
                            d.setHours(0, 0, 0, 0);
                            return d;
                        }
                        if (snapMode === "month") {
                            d.setDate(1);
                            d.setHours(0, 0, 0, 0);
                            return d;
                        }
                        var day = d.getDay();
                        var diff = (day + 6) % 7;
                        d.setDate(d.getDate() - diff);
                        d.setHours(0, 0, 0, 0);
                        return d;
                    },
                    template: function (item) {
                        if (isMarkerKind(item.kind)) {
                            var text = (item.content || "").trim() || "Rep√®re";
                            return (
                                '<div class="ms-pill">' +
                                '<span class="diamond"></span>' +
                                "<span>" + text + "</span>" +
                                "</div>"
                            );
                        }
                        return appendDurationToContent(item.content || "", item);
                    },
                    timeAxis: {
                        scale: "week",
                        step: 1
                    },
                    hiddenDates: buildWeekendHiddenDates(),
                    onMoving: function (item, callback) {
                        if (typeof callback === "function") {
                            callback(item);
                        }
                        var tooltipText = buildTooltipText(item);
                        if (tooltipText) {
                            showEditTooltip(tooltipText);
                        } else {
                            hideEditTooltip();
                        }
                    },
                    onMove: function (item, callback) {
                        item = normalizeItemAfterResize(item);
                        if (typeof callback === "function") {
                            callback(item);
                        }
                        hideEditTooltip();
                    }
                };

                timeline = new Timeline(container, itemsView, groups, options);
                window.addEventListener("resize", function () {
                    if (!timeline) return;
                    var currentRange = timeline.getWindow();
                });

                // No automatic seeding of timeline content. Show overlay when empty.

                var contextModalOverlay = document.getElementById("gtContextModal");
                var contextModalButton = document.getElementById("gtContextModalTrigger");
                var iaModalOverlay = document.getElementById("gtPromptModal");
                var iaModalButton = document.getElementById("gtPromptModalTrigger");
                var iaModalClose = document.getElementById("gtPromptModalClose");

                function openContextModal(options) {
                    ensureModifyPrompt({ refreshModify: true });
                    if (contextModalOverlay) {
                        contextModalOverlay.classList.add("open");
                        contextModalOverlay.setAttribute("aria-hidden", "false");
                    }
                    persistTimelineContextOpenState(true);
                }

                function closeContextModal() {
                    if (contextModalOverlay) {
                        contextModalOverlay.classList.remove("open");
                        contextModalOverlay.setAttribute("aria-hidden", "true");
                    }
                    persistTimelineContextOpenState(false);
                }

                function toggleContextModal(options) {
                    if (!contextModalOverlay) return;
                    if (contextModalOverlay.classList.contains("open")) {
                        closeContextModal();
                    } else {
                        openContextModal(options);
                    }
                }

                function openIaModal() {
                    if (iaModalOverlay) iaModalOverlay.classList.add("open");
                }

                function closeIaModal() {
                    if (iaModalOverlay) iaModalOverlay.classList.remove("open");
                }

                if (contextModalButton) {
                    contextModalButton.addEventListener("click", function () {
                        toggleContextModal();
                    });
                }
                if (iaModalButton) {
                    iaModalButton.addEventListener("click", openIaModal);
                }
                if (iaModalClose) {
                    iaModalClose.addEventListener("click", closeIaModal);
                }

                if (contextModalOverlay) {
                    contextModalOverlay.addEventListener("click", function (event) {
                        if (event.target === contextModalOverlay) {
                            closeContextModal();
                        }
                    });
                    // Close gutenberg drawer when clicking outside in narrow (drawer) mode
                    document.addEventListener("click", function (ev) {
                        try {
                            if ((window.innerWidth || 0) >= 900) return; // only in drawer mode
                            if (!contextModalOverlay || !contextModalOverlay.classList.contains('open')) return;
                            var t = ev.target;
                            // if click occurred inside the gutenberg card or on the open button, ignore
                            if (t && t.closest && (t.closest('.gutenberg-card') || t.closest('#gtContextModalTrigger'))) return;
                            closeContextModal();
                        } catch (err) {
                            /* noop */
                        }
                    }, true);
                }
                // Evaluate and show empty overlay if timeline has no items
                try { updateEmptyViewMessage(); } catch (e) { /* noop */ }
                var openModifyPromptBtn = document.getElementById("openModifyPromptBtn");
                if (openModifyPromptBtn) {
                    openModifyPromptBtn.addEventListener("click", function () {
                        // Instead of calling OpenAI, parse the current script textarea and apply it
                        try {
                            ensureModifyPrompt({ refreshModify: true });
                            var scriptText = txtPromptModify && txtPromptModify.value ? txtPromptModify.value.toString() : "";
                            if (!scriptText || !scriptText.trim()) {
                                alert("Le script est vide ‚Äî rien √† parser.");
                                return;
                            }
                            var parsedPlanning = null;
                            try {
                                parsedPlanning = parseScriptToPlanning(scriptText);
                            } catch (err) {
                                console.error('Erreur parsing script', err);
                                alert(err && err.message ? err.message : "Impossible de parser le script en planning. V√©rifie le format.");
                                parsedPlanning = null;
                            }
                            if (!parsedPlanning) {
                                return;
                            }
                            // If the parsed planning contains a page title, update view
                            if (parsedPlanning && typeof parsedPlanning.page === 'string' && parsedPlanning.page.trim()) {
                                var currentView = views[activeViewIndex];
                                if (currentView) {
                                    currentView.title = parsedPlanning.page.trim();
                                    refreshHeaderText();
                                }
                            }
                            applyPlanningFromJson(parsedPlanning);
                            // persist the parsed planning into the active view
                            persistCurrentPlanning();
                            // persist the script into context
                            try {
                                var ctx = ensureViewContext(views[activeViewIndex]);
                                ctx.prompts = ctx.prompts || {};
                                ctx.prompts.modify = scriptText;
                                persistTimelineState();
                            } catch (e) {
                                console.warn('Cannot persist context after modify-parse', e);
                            }
                        } catch (e) {
                            console.warn('Erreur lors du parsing local depuis Modifier', e);
                            alert('Erreur lors du parsing du script.');
                        }
                    });
                }
                if (emptyStateAction) {
                    emptyStateAction.addEventListener("click", function (event) {
                        event.preventDefault();
                        openContextModal();
                        if (contextModalButton) {
                            contextModalButton.focus();
                        }
                    });
                }

                /* Roadmap Prompt modal: 6 templates + selection/validate flow */
                var roadmapPromptOverlay = document.getElementById("gtTemplateModal");
                var roadmapPromptList = document.getElementById("gtTemplateModalList");
                var roadmapPromptClose = document.getElementById("gtTemplateModalClose");
                var roadmapPromptValidate = document.getElementById("gtTemplateModalApply");
                var openRoadmapPromptBtn = document.getElementById("gtTemplateModalTrigger");
                var iaApplyBtn = document.getElementById("iaApplyBtn");
                if (iaApplyBtn) {
                    iaApplyBtn.addEventListener("click", function () {
                        if (iaTemplateEditor) {
                            persistTemplateChange(iaTemplateEditor.value || "");
                        } else {
                            persistTimelineState();
                        }
                        try {
                            closeIaModal();
                        }
                        catch (e) {
                            // ignore
                        }
                    });
                }
                var selectedRoadmapPromptId = "default";

                var ROADMAP_PROMPTS =
                    (window.GoPrompts && Array.isArray(window.GoPrompts.timelinePrompts) && window.GoPrompts.timelinePrompts.length
                        ? window.GoPrompts.timelinePrompts
                        : []);


                function renderRoadmapPromptList() {
                    if (!roadmapPromptList) return;
                    roadmapPromptList.innerHTML = "";
                    ROADMAP_PROMPTS.forEach(function (tpl) {
                        var card = document.createElement("div");
                        card.className = "gt-template-card";
                        card.setAttribute("role", "button");
                        card.dataset.id = tpl.id;
                        if (tpl.id === selectedRoadmapPromptId) {
                            card.classList.add("gt-template-card--selected");
                        }
                        card.innerHTML = `<strong style="font-size:13px">${tpl.title}</strong><div style="font-size:12px;color:var(--muted);white-space:pre-wrap;word-break:break-word;margin-top:6px">${tpl.text}</div>`;
                        card.addEventListener("click", function () {
                            setSelectedTemplateId(tpl.id, { skipPersist: true });
                            // update visuals
                            Array.from(roadmapPromptList.children).forEach(function (c) { c.classList.remove("gt-template-card--selected"); });
                            card.classList.add("gt-template-card--selected");
                            // focus validate
                            if (roadmapPromptValidate) roadmapPromptValidate.focus();
                        });
                        roadmapPromptList.appendChild(card);
                    });
                }

                function openRoadmapPromptModal() {
                    if (!roadmapPromptOverlay) return;
                    if (timelineTourOverlay && timelineTourOverlay.classList.contains("visible")) return;
                    if (!selectedRoadmapPromptId) {
                        var ctx = getActiveViewContext();
                        if (ctx && ctx.templateId) {
                            setSelectedTemplateId(ctx.templateId, { skipPersist: true });
                        } else if (ROADMAP_PROMPTS.length) {
                            setSelectedTemplateId(ROADMAP_PROMPTS[0].id, { skipPersist: true });
                        }
                    }
                    renderRoadmapPromptList();
                    roadmapPromptOverlay.classList.add("open");
                }

                function closeRoadmapPromptModal() {
                    if (!roadmapPromptOverlay) return;
                    roadmapPromptOverlay.classList.remove("open");
                }

                if (openRoadmapPromptBtn) {
                    openRoadmapPromptBtn.addEventListener("click", function (e) {
                        e.preventDefault();
                        openRoadmapPromptModal();
                    });
                }
                if (roadmapPromptClose) roadmapPromptClose.addEventListener("click", closeRoadmapPromptModal);
                if (roadmapPromptOverlay) {
                    roadmapPromptOverlay.addEventListener("click", function (ev) {
                        if (ev.target === roadmapPromptOverlay) closeRoadmapPromptModal();
                    });
                }
                if (roadmapPromptValidate) {
                    roadmapPromptValidate.addEventListener("click", function () {
                        if (!selectedRoadmapPromptId) return;
                        var tpl = ROADMAP_PROMPTS.find(function (t) { return t.id === selectedRoadmapPromptId; });
                        if (tpl) {
                            // Persist into active view context so opening the Gutenberg modal won't overwrite values
                            if (typeof persistActiveContext === "function") {
                                persistActiveContext(function (ctx) {
                                    ctx.prompts = ctx.prompts || {};
                                    ctx.templateId = tpl.id || null;
                                    ctx.mode = "create";
                                });
                            }
                            setSelectedTemplateId(tpl.id, { skipPersist: true });
                            closeRoadmapPromptModal();
                            // open Gutenberg/context modal in 'create' mode to avoid refresh-overwrite of modify
                            if (typeof openContextModal === "function") {
                                openContextModal({ mode: "create" });
                                // focus the vision textarea
                                setTimeout(function () {
                                    var v = document.getElementById("promptCreate");
                                    if (v) v.focus();
                                }, 200);
                            }
                        }
                    });
                }

                var CREATE_SYSTEM_TEMPLATE =
                    (window.GoPrompts && window.GoPrompts.timelineCreateSystemTemplate) || "";

                customSystemTemplates.create = customSystemTemplates.create || CREATE_SYSTEM_TEMPLATE;

                var optionsBtn = document.getElementById("optionsBtn");
                var optionsMenu = document.getElementById("optionsMenu");
                var fontSizeInput = document.getElementById("fontSizeInput");
                var backgroundSelector = document.getElementById("backgroundSelector");
                var widthSelect = document.getElementById("widthSelect");
                var spacingSelect = document.getElementById("spacingSelect");
                var borderLightSelect = document.getElementById("borderLightSelect");
                var fileMenuBtn = document.getElementById("fileMenuBtn");
                var fileMenu = document.getElementById("fileMenu");
                var importJsonBtn = document.getElementById("importJsonBtn");
                var exportJsonBtn = document.getElementById("exportJsonBtn");
                var exportTextBtn = document.getElementById("exportTextBtn");
                var exportImageBtn = document.getElementById("exportImageBtn");
                var exportExcelBtn = document.getElementById("exportExcelBtn");
                var aboutTimelineBtn = document.getElementById("aboutTimelineBtn");
                var newDocumentBtn = document.getElementById("newDocumentBtn");
                var saveDocumentBtn = document.getElementById("saveDocumentBtn");
                var importJsonInput = document.getElementById("importJsonInput");
                var headerTitleElement = document.querySelector(".header-text h1");
                var infoPopup = document.getElementById("timelineInfoPopup");
                var timelineUpdateBtn = document.getElementById("timelineUpdateBtn");
                var copyToast = document.getElementById("copyToast");
                var copyToastTimer = null;
                var speechToast = document.getElementById("speechToast");
                var speechToastTimer = null;
                var shareMenu = document.getElementById("shareMenu");
                var shareBtn = document.getElementById("shareBtn");
                var shareLinkField = document.getElementById("shareLinkField");
                var shareMenuStatus = document.getElementById("shareMenuStatus");
                var shareCreateBtn = document.getElementById("shareCreateBtn");
                var shareUpdateBtn = document.getElementById("shareUpdateBtn");
                var shareHistory = window.goToolkitShareHistory;
                var capsuleDrafts = window.goToolkitCapsuleDrafts;
                var FIRESTORE_COLLECTION = "timelines";
                var SHARE_QUERY_PARAM = "share";
                var EDIT_QUERY_PARAM = "edit";
                var SHARE_WORKER_UNAVAILABLE_MESSAGE =
                    "Le partage priv√© n√©cessite le worker Cloudflare li√© √† Go-Toolkit (go-toolkit-share).";
                var shareWorkerService = window.goToolkitShareWorker;
                var shareWorkerAvailable = Boolean(shareWorkerService && shareWorkerService.isReady);
                var currentShareToken = null;
                var shareLoadedFromRemote = false;
                var shareStatusMessage = "";
                var shareStatusType = "";
                var shareRequestInProgress = false;
                var shareLastUpdatedAt = null;
                var currentDraftId = null;
                var draftSaveTimer = null;
                var isDraftSaving = false;

                function getShareDraftKey(token) {
                    return LOCAL_STORAGE_KEY + "-share-" + token;
                }

                function readShareDraft(token) {
                    if (!token || typeof window === "undefined" || !window.localStorage) return null;
                    try {
                        var raw = localStorage.getItem(getShareDraftKey(token));
                        if (!raw) return null;
                        var parsed = JSON.parse(raw);
                        if (!parsed || typeof parsed !== "object") return null;
                        return parsed;
                    } catch (err) {
                        console.warn("Impossible de lire le cache local de la capsule", err);
                        return null;
                    }
                }

                function writeShareDraft(token, payload, updatedAt) {
                    if (!token || typeof window === "undefined" || !window.localStorage) return;
                    try {
                        var value = {
                            payload: payload,
                            updatedAt: updatedAt || new Date().toISOString()
                        };
                        localStorage.setItem(getShareDraftKey(token), JSON.stringify(value));
                    } catch (err) {
                        console.warn("Impossible de sauvegarder le cache local de la capsule", err);
                    }
                }

                function getEditIdFromUrl() {
                    try {
                        var params = new URLSearchParams(window.location.search);
                        var value = params.get(EDIT_QUERY_PARAM);
                        return value ? value.trim() : null;
                    } catch (err) {
                        return null;
                    }
                }

                function updateUrlWithEditId(id) {
                    var url = new URL(window.location.href);
                    if (id) {
                        url.searchParams.set(EDIT_QUERY_PARAM, id);
                    } else {
                        url.searchParams.delete(EDIT_QUERY_PARAM);
                    }
                    history.replaceState(null, "", url.toString());
                }

                function createDraftId() {
                    if (capsuleDrafts && typeof capsuleDrafts.generateId === "function") {
                        return capsuleDrafts.generateId();
                    }
                    if (typeof createShareToken === "function") {
                        return createShareToken();
                    }
                    return "";
                }

                async function saveCapsuleDraft(options) {
                    options = options || {};
                    if (!capsuleDrafts || isDraftSaving) {
                        return null;
                    }
                    isDraftSaving = true;
                    try {
                        persistCurrentPlanning();
                        var payload = buildTimelineStatePayload();
                        var preview = getRoadmapSharePreview();
                        var id = currentDraftId || createDraftId();
                        if (!id) {
                            id = createShareToken();
                        }
                        var now = new Date().toISOString();
                        var record = await capsuleDrafts.upsertRecord({
                            id: id,
                            app: "plan",
                            payload: payload,
                            title: preview.title,
                            description: preview.description,
                            updatedAt: now
                        });
                        if (record) {
                            currentDraftId = record.id;
                            if (options.updateUrl !== false) {
                                updateUrlWithEditId(record.id);
                            }
                            if (options.showToast) {
                                showCopyToast("Capsule enregistr√©e");
                            }
                        }
                        return record;
                    } catch (err) {
                        console.error("Impossible de sauvegarder la capsule locale", err);
                        return null;
                    } finally {
                        isDraftSaving = false;
                    }
                }

                function scheduleDraftSave() {
                    if (!capsuleDrafts || !currentDraftId) {
                        return;
                    }
                    if (draftSaveTimer) {
                        clearTimeout(draftSaveTimer);
                    }
                    draftSaveTimer = window.setTimeout(function () {
                        draftSaveTimer = null;
                        saveCapsuleDraft({ updateUrl: false, showToast: false });
                    }, 600);
                }

                function cancelScheduledDraftSave() {
                    if (draftSaveTimer) {
                        clearTimeout(draftSaveTimer);
                        draftSaveTimer = null;
                    }
                }

                async function handleSaveDocumentClick() {
                    closeContextMenus();
                    if (!capsuleDrafts) {
                        alert("Impossible de sauvegarder localement.");
                        return null;
                    }
                    if (saveDocumentBtn) {
                        saveDocumentBtn.disabled = true;
                    }
                    cancelScheduledDraftSave();
                    try {
                        return await saveCapsuleDraft({ showToast: true });
                    } catch (err) {
                        console.error("Erreur lors de l'enregistrement local", err);
                        return null;
                    } finally {
                        if (saveDocumentBtn) {
                            saveDocumentBtn.disabled = false;
                        }
                    }
                }

                async function handleNewDocumentClick() {
                    closeContextMenus();
                    var needsPrompt = hasTimelineData() || Boolean(currentDraftId);
                    if (needsPrompt) {
                        var confirmSave = window.confirm(
                            "Sauvegarder la capsule actuelle avant d'ouvrir un nouveau document ?"
                        );
                        if (confirmSave) {
                            await handleSaveDocumentClick();
                        }
                    }
                    openNewTimelineDocument();
                }

                function openNewTimelineDocument() {
                    try {
                        if (window.localStorage) {
                            localStorage.removeItem(LOCAL_STORAGE_KEY);
                        }
                    } catch (err) {
                        console.warn("Impossible de r√©initialiser l'√©tat local", err);
                    }
                    if (currentShareToken) {
                        updateUrlWithShareToken(null);
                        currentShareToken = null;
                    }
                    updateUrlWithEditId(null);
                    var url = new URL(window.location.href);
                    url.searchParams.delete(SHARE_QUERY_PARAM);
                    url.searchParams.delete(EDIT_QUERY_PARAM);
                    url.hash = "";
                    window.location.href = url.toString();
                }

                function getRoadmapSharePreview() {
                    var firstView = Array.isArray(views) && views.length ? views[0] : null;
                    var title = (firstView && (firstView.title || firstView.name)) || "Planning";
                    var desc = getTimelineBrief()
                        .split(/\r?\n/)
                        .map(function (line) { return line.trim(); })
                        .filter(Boolean)
                        .slice(0, 2)
                        .join(" ¬∑ ");
                    return {
                        title: title,
                        description: desc || "Compl√®te le contexte pour l'afficher ici."
                    };
                }

                async function persistRoadmapShareRecord(token, updatedAt) {
                    if (!shareHistory || !token) {
                        return;
                    }
                    try {
                        var preview = getRoadmapSharePreview();
                        await shareHistory.upsertRecord("roadmap", {
                            token: token,
                            updatedAt: updatedAt || new Date().toISOString(),
                            title: preview.title,
                            description: preview.description
                        });
                    } catch (err) {
                        console.warn("Impossible d'archiver le lien", err);
                    }
                }
                var navSwitcherBtn = document.getElementById("navSwitcherBtn");
                var navSwitcherMenu = document.getElementById("navSwitcherMenu");
                var colorModalOverlay = document.getElementById("colorModalOverlay");
                var colorModalClose = document.getElementById("colorModalClose");
                var openColorPaletteBtn = document.getElementById("openColorPaletteBtn");
                var colorTypeList = document.getElementById("colorTypeList");
                var saveColorPreferencesBtn = document.getElementById("saveColorPreferencesBtn");
                var randomizeColorsBtn = document.getElementById("randomizeColorsBtn");
                var fontSizeChoices = [8, 9, 10, 11, 12, 13, 14, 15, 16];
                var borderLightModes = {
                    blanc: "#ffffff",
                    clair: "var(--border)",
                    sombre: "var(--border-strong)"
                };
                var DEFAULT_BORDER_LIGHT_MODE = "clair";

                function renderFontSizeOptions() {
                    if (!fontSizeInput) return;
                    fontSizeInput.innerHTML = "";
                    fontSizeChoices.forEach(function (size) {
                        var option = document.createElement("option");
                        option.value = size;
                        option.textContent = size + " px";
                        option.style.fontSize = size + "px";
                        fontSizeInput.appendChild(option);
                    });
                    if (displayPreferences.fontSize) {
                        fontSizeInput.value = displayPreferences.fontSize;
                    }
                }

                function closeContextMenus() {
                    if (optionsMenu) optionsMenu.classList.remove("open");
                    if (fileMenu) fileMenu.classList.remove("open");
                    if (shareMenu) shareMenu.classList.remove("open");
                }

                if (optionsBtn && optionsMenu) {
                    optionsBtn.addEventListener("click", function (event) {
                        event.stopPropagation();
                        closeContextMenus();
                        syncFontControls();
                        optionsMenu.classList.toggle("open");
                    });
                }

                if (fileMenuBtn && fileMenu) {
                    fileMenuBtn.addEventListener("click", function (event) {
                        event.stopPropagation();
                        closeContextMenus();
                        fileMenu.classList.toggle("open");
                    });
                }

                if (newDocumentBtn) {
                    newDocumentBtn.addEventListener("click", function (event) {
                        event.preventDefault();
                        event.stopPropagation();
                        handleNewDocumentClick();
                    });
                }

                if (saveDocumentBtn) {
                    saveDocumentBtn.addEventListener("click", function (event) {
                        event.preventDefault();
                        event.stopPropagation();
                        handleSaveDocumentClick();
                    });
                }

                if (shareBtn && shareMenu) {
                    shareBtn.addEventListener("click", function (event) {
                        event.stopPropagation();
                        // If timeline info popup is open, close it when opening the share menu
                        if (typeof closeTimelineInfoPopup === "function") try { closeTimelineInfoPopup(); } catch (e) { }
                        closeContextMenus();
                        shareMenu.classList.toggle("open");
                        updateShareMenuUI();
                    });
                }

                document.addEventListener("click", function (event) {
                    if (optionsMenu && !optionsMenu.contains(event.target) && optionsBtn !== event.target) {
                        optionsMenu.classList.remove("open");
                    }
                    if (fileMenu && !fileMenu.contains(event.target) && fileMenuBtn !== event.target) {
                        fileMenu.classList.remove("open");
                    }
                    if (shareMenu && !shareMenu.contains(event.target) && shareBtn !== event.target) {
                        shareMenu.classList.remove("open");
                    }
                });

                // D√©sactiver le menu contextuel uniquement sur la timeline (laisser le reste de la page libre)
                // mais autoriser en mode dev-tools (URL ?devtools=1 ou localStorage goToolkitDevTools=1)
                var isDevToolsMode = false;
                try {
                    var params = new URLSearchParams(window.location.search || "");
                    isDevToolsMode = params.has("devtools") || window.localStorage?.getItem("goToolkitDevTools") === "1";
                } catch (err) {
                    isDevToolsMode = false;
                }
                // Autoriser le menu contextuel partout (plus de blocage sur la timeline)

                // Permettre de fermer les modals avec la touche √âchap
                document.addEventListener("keydown", function (ev) {
                    if (!ev) return;
                    var key = ev.key || ev.keyIdentifier || ev.keyCode;
                    if (key === "Escape" || key === "Esc" || key === 27) {
                        if (typeof closeIaModal === "function") try { closeIaModal(); } catch (e) { }
                        if (typeof closeContextModal === "function") try { closeContextModal(); } catch (e) { }
                        if (typeof closeColorModal === "function") try { closeColorModal(); } catch (e) { }
                        if (typeof closeRoadmapPromptModal === "function") try { closeRoadmapPromptModal(); } catch (e) { }
                        if (typeof closeTimelineInfoPopup === "function") try { closeTimelineInfoPopup(); } catch (e) { }
                        if (typeof closeTimelineTour === "function") try { closeTimelineTour(true); } catch (e) { }
                    }
                });

                function getOrderedTypeIds(typeIds) {
                    var ids = Array.isArray(typeIds) ? typeIds : Object.keys(typeDefinitions);
                    var unique = {};
                    ids.forEach(function (id) {
                        if (id && typeDefinitions[id]) {
                            unique[id] = true;
                        }
                    });
                    var result = Object.keys(unique);
                    return result.sort(function (a, b) {
                        var labelA = (typeDefinitions[a] && typeDefinitions[a].label) || a;
                        var labelB = (typeDefinitions[b] && typeDefinitions[b].label) || b;
                        return labelA.localeCompare(labelB);
                    });
                }

                function getOrderedKindIds(typeIds) {
                    return getOrderedTypeIds(typeIds);
                }

                function getMarkerIds() {
                    return Object.keys(typeDefinitions).filter(function (id) {
                        var def = typeDefinitions[id];
                        return def && def.isMarker;
                    });
                }

                function getVisibleViewTypeIds() {
                    var seen = {};
                    Object.keys(typeDefinitions || {}).forEach(function (id) {
                        if (id) seen[id] = true;
                    });
                    if (items && typeof items.get === "function") {
                        items.get().forEach(function (item) {
                            var kind = sanitizeTypeId(item.kind || item.type || "");
                            if (kind) {
                                seen[kind] = true;
                            }
                        });
                    }
                    return Object.keys(seen);
                }

                function getFirstMarkerId() {
                    var markers = getMarkerIds();
                    if (markers.length) return markers[0];
                    // Legacy fallback: if a "milestone" type exists, treat it as marker
                    if (typeDefinitions["milestone"]) {
                        return "milestone";
                    }
                    return null;
                }

                function getFirstRegularTypeId() {
                    var ordered = getOrderedKindIds(Object.keys(typeDefinitions));
                    for (var i = 0; i < ordered.length; i++) {
                        if (!isMarkerKind(ordered[i])) {
                            return ordered[i];
                        }
                    }
                    return "feature";
                }

                function getFocusedItemKind() {
                    if (!selectedItemId) return "";
                    var focused = items.get(selectedItemId);
                    if (!focused) return "";
                    return sanitizeTypeId(focused.kind || focused.type || "");
                }

                function syncTypeSelectorDisabledState() {
                    if (!typeSelectorControl || !itemTypeSelect) return;
                    typeSelectorControl.classList.toggle("disabled", itemTypeSelect.disabled);
                }

                function renderTypeSwitcherOptions() {
                    if (!itemTypeSelect) return;
                    var focusedKind = getFocusedItemKind();
                    var typeIds = getVisibleViewTypeIds();
                    if (focusedKind && typeIds.indexOf(focusedKind) === -1) {
                        typeIds.push(focusedKind);
                    }
                    typeIds.forEach(function (typeId) {
                        if (!typeDefinitions[typeId]) {
                            ensureTypeDefinition({ id: typeId });
                        }
                    });
                    var orderedIds = getOrderedKindIds(typeIds);
                    itemTypeSelect.innerHTML = "";

                    if (!orderedIds.length) {
                        var emptyOption = document.createElement("option");
                        emptyOption.value = "";
                        emptyOption.textContent = " ";
                        emptyOption.disabled = true;
                        emptyOption.selected = true;
                        itemTypeSelect.appendChild(emptyOption);
                        itemTypeSelect.disabled = true;
                        syncTypeSelectorDisabledState();
                        return;
                    }

                    if (!selectedItemId) {
                        var placeholder = document.createElement("option");
                        placeholder.value = "";
                        placeholder.textContent = "-";
                        placeholder.disabled = true;
                        placeholder.selected = true;
                        itemTypeSelect.appendChild(placeholder);
                    }

                    orderedIds.forEach(function (typeId) {
                        var def = typeDefinitions[typeId];
                        if (!def) return;
                        var option = document.createElement("option");
                        option.value = def.id;
                        option.textContent = formatKindLabel(def) || def.id;
                        itemTypeSelect.appendChild(option);
                    });

                    if (selectedItemId) {
                        var targetValue =
                            focusedKind && orderedIds.indexOf(focusedKind) !== -1
                                ? focusedKind
                                : orderedIds[0];
                        itemTypeSelect.value = targetValue;
                        itemTypeSelect.disabled = false;
                    } else {
                        itemTypeSelect.disabled = true;
                    }
                    syncTypeSelectorDisabledState();
                }

                function applyTypeToSelectedItem(kindId) {
                    if (!selectedItemId) return;
                    var desiredKind = sanitizeTypeId(kindId);
                    if (!desiredKind) return;
                    var current = items.get(selectedItemId);
                    if (!current) return;
                    var currentKind = sanitizeTypeId(current.kind || current.type || "");
                    if (currentKind === desiredKind) return;

                    var isMarkerTarget = isMarkerKind(desiredKind);
                    if (isMarkerTarget) {
                        ensureMarkerDefinition({ id: desiredKind });
                    } else {
                        ensureTypeDefinition({ id: desiredKind });
                    }
                    ensureKindFilter(desiredKind);

                    var updatePayload = {
                        id: selectedItemId,
                        kind: desiredKind,
                        className:
                            isMarkerTarget
                                ? "type-" + desiredKind + " type-marker marker-class"
                                : "type-" + desiredKind,
                        type: isMarkerTarget ? "point" : null
                    };

                    if (isMarkerTarget) {
                        updatePayload.end = null;
                        var markerStart = current.start || current.date || getTimelineCenter();
                        updatePayload.start = updatePayload.start || markerStart;
                        updatePayload.date = dateToIso(updatePayload.start) || dateToIso(markerStart);
                    } else {
                        updatePayload.date = null;
                        if (!current.start && !updatePayload.start) {
                            updatePayload.start = getTimelineCenter();
                        }
                        if (!current.end && !updatePayload.end) {
                            updatePayload.end = computeDefaultEnd(current.start || updatePayload.start);
                        }
                    }

                    items.update(updatePayload);
                    refreshTypeFilterUI(getVisibleViewTypeIds());
                    renderTypeSwitcherOptions();
                    updateTimelineFilter();
                }

                function ensureViewFilterState(view) {
                    if (!view) return null;
                    if (!view.filterState) {
                        view.filterState = { kinds: {} };
                    }
                    return view.filterState;
                }

                function syncFiltersForActiveView(typeIds) {
                    var view = views[activeViewIndex];
                    if (!view) return;
                    var state = ensureViewFilterState(view);
                    if (state) {
                        filterState = state;
                    }
                    refreshTypeFilterUI(typeIds || getVisibleViewTypeIds());
                    renderTypeSwitcherOptions();
                }

                function captureColorPreferencesState() {
                    colorModalState.types = {};
                    colorModalState.labels = {};
                    var typeIds = getVisibleViewTypeIds();
                    colorModalState.typeIds = typeIds;
                    typeIds.forEach(function (typeId) {
                        var def = typeDefinitions[typeId];
                        if (!def) return;
                        colorModalState.types[typeId] = def.background || getRainbowColor();
                        colorModalState.labels[typeId] = def.label || typeId;
                    });
                    colorModalState.timeline = displayPreferences.background || "#ffffff";
                }

                function updateTypeColorValue(typeId, normalized, preview, picker, hexInput) {
                    if (!normalized) return;
                    colorModalState.types[typeId] = normalized;
                    setPreviewColor(preview, normalized);
                    if (picker) {
                        picker.value = normalized === "transparent" ? "#ffffff" : normalized;
                    }
                    if (hexInput) {
                        hexInput.value = normalized;
                    }
                }

                function renderColorModalContent() {
                    if (!colorTypeList) return;
                    colorTypeList.innerHTML = "";
                    var targetTypeIds = Array.isArray(colorModalState.typeIds) && colorModalState.typeIds.length
                        ? colorModalState.typeIds
                        : getVisibleViewTypeIds();
                    var typeIds = getOrderedKindIds(targetTypeIds);
                    typeIds.forEach(function (typeId) {
                        var def = typeDefinitions[typeId];
                        if (!def) return;
                        var colorValue = colorModalState.types[typeId] || def.background || "#ffffff";
                        colorModalState.types[typeId] = colorValue;
                        var row = document.createElement("div");
                        row.className = "color-row";
                        var labelValue = colorModalState.labels[typeId] || def.label || typeId;
                        colorModalState.labels[typeId] = labelValue;
                        var labelWrapper = document.createElement("div");
                        labelWrapper.className = "color-row-label";
                        var labelInput = document.createElement("input");
                        labelInput.type = "text";
                        labelInput.className = "color-row-label-input";
                        labelInput.value = labelValue;
                        labelInput.placeholder = typeId;
                        labelInput.setAttribute("aria-label", "Nom du type " + (def.label || typeId));
                        labelInput.readOnly = true;
                        labelInput.addEventListener("dblclick", function (event) {
                            if (labelInput.disabled) return;
                            event.stopPropagation();
                            labelInput.readOnly = false;
                            labelInput.focus();
                            if (labelInput.select) {
                                labelInput.select();
                            }
                        });
                        labelInput.addEventListener("blur", function () {
                            labelInput.readOnly = true;
                        });
                        labelInput.addEventListener("input", function () {
                            colorModalState.labels[typeId] = labelInput.value;
                        });
                        labelWrapper.appendChild(labelInput);
                        var controls = document.createElement("div");
                        controls.className = "color-row-controls";
                        var preview = document.createElement("span");
                        preview.className = "color-preview";
                        setPreviewColor(preview, colorValue);
                        var colorPicker = document.createElement("input");
                        colorPicker.type = "color";
                        colorPicker.value = colorValue === "transparent" ? "#ffffff" : colorValue;
                        var hexInput = document.createElement("input");
                        hexInput.type = "text";
                        hexInput.placeholder = "#ffffff";
                        hexInput.value = colorValue;
                        hexInput.addEventListener("input", function () {
                            var normalized = normalizeHexColor(hexInput.value);
                            if (!normalized) return;
                            updateTypeColorValue(typeId, normalized, preview, colorPicker, hexInput);
                        });
                        colorPicker.addEventListener("input", function () {
                            var normalized = normalizeHexColor(colorPicker.value);
                            if (!normalized) return;
                            updateTypeColorValue(typeId, normalized, preview, colorPicker, hexInput);
                        });
                        var deleteBtn = document.createElement("button");
                        deleteBtn.type = "button";
                        deleteBtn.className = "btn-small danger";
                        deleteBtn.textContent = "√ó";
                        deleteBtn.addEventListener("click", function () {
                            removeTypeFromColorModal(typeId);
                        });
                        controls.appendChild(deleteBtn);
                        controls.appendChild(preview);
                        controls.appendChild(colorPicker);
                        controls.appendChild(hexInput);
                        row.appendChild(labelWrapper);
                        row.appendChild(controls);
                        colorTypeList.appendChild(row);
                    });
                }

                function removeTypeFromColorModal(typeId) {
                    var typedItems = [];
                    if (items && typeof items.get === "function") {
                        typedItems = items.get().filter(function (it) {
                            var kind = sanitizeTypeId(it.kind || it.type || "");
                            return kind === typeId;
                        });
                    }

                    var names = typedItems.map(function (it) {
                        return (it.content || it.label || it.id || "").toString().trim() || it.id;
                    });
                    var listPreview = names.slice(0, 8).map(function (n) { return " - " + n; }).join("\n");
                    var extra = names.length > 8 ? "\n... (" + (names.length - 8) + " de plus)" : "";
                    var message = typedItems.length
                        ? "Supprimer le type \"" + typeId + "\" et " + typedItems.length + " √©l√©ment(s) ?\n" + listPreview + extra
                        : "Supprimer le type \"" + typeId + "\" ? (aucun √©l√©ment associ√©)";

                    if (!confirm(message)) return;

                    if (typedItems.length && items && typeof items.remove === "function") {
                        var idsToRemove = typedItems.map(function (it) { return it.id; });
                        items.remove(idsToRemove);
                        if (selectedItemId && idsToRemove.indexOf(selectedItemId) !== -1) {
                            selectedItemId = null;
                            updateSelectionButtons();
                            renderTypeSwitcherOptions();
                        }
                    }

                    delete typeDefinitions[typeId];
                    delete colorModalState.types[typeId];
                    delete colorModalState.labels[typeId];
                    views.forEach(function (view) {
                        if (!view.filterState || !view.filterState.kinds) return;
                        delete view.filterState.kinds[typeId];
                    });
                    if (filterState && filterState.kinds) {
                        delete filterState.kinds[typeId];
                    }
                    rebuildTypeStyles();
                    syncFiltersForActiveView(getVisibleViewTypeIds());
                    renderColorModalContent();
                    updateTimelineFilter();
                    updateEmptyViewMessage();
                    persistTimelineState();
                }

                function openColorModal() {
                    captureColorPreferencesState();
                    renderColorModalContent();
                    if (colorModalOverlay) {
                        colorModalOverlay.classList.add("open");
                    }
                }

                function closeColorModal() {
                    if (colorModalOverlay) {
                        colorModalOverlay.classList.remove("open");
                    }
                }

                function applyColorModalChanges() {
                    var renameCandidates = [];
                    Object.keys(colorModalState.types).forEach(function (typeId) {
                        var def = typeDefinitions[typeId];
                        if (!def) return;
                        var background = colorModalState.types[typeId];
                        if (background) {
                            def.background = background;
                            updateTypeShades(def);
                        }
                        var updatedLabel = colorModalState.labels[typeId];
                        if (typeof updatedLabel !== "string") return;
                        var normalizedLabel = updatedLabel.trim();
                        if (!normalizedLabel) return;
                        colorModalState.labels[typeId] = normalizedLabel;
                        var candidateId = sanitizeTypeId(normalizedLabel);
                        if (!candidateId) return;
                        if (candidateId === typeId) {
                            def.label = normalizedLabel;
                            return;
                        }
                        renameCandidates.push({
                            from: typeId,
                            label: normalizedLabel,
                            baseId: candidateId
                        });
                    });

                    var finalIdMap = {};
                    if (renameCandidates.length) {
                        var lockedIds = Object.keys(typeDefinitions).filter(function (id) {
                            return renameCandidates.every(function (task) {
                                return task.from !== id;
                            });
                        });
                        var reserved = {};
                        lockedIds.forEach(function (id) {
                            reserved[id] = true;
                        });
                        renameCandidates.forEach(function (task) {
                            var baseId = task.baseId || task.from;
                            var candidate = baseId;
                            var counter = 1;
                            while (reserved[candidate]) {
                                candidate = baseId + "-" + counter;
                                counter++;
                                if (counter > 100) {
                                    candidate = task.from;
                                    break;
                                }
                            }
                            finalIdMap[task.from] = candidate || task.from;
                            reserved[finalIdMap[task.from]] = true;
                        });
                    }

                    renameCandidates.forEach(function (task) {
                        var def = typeDefinitions[task.from];
                        if (!def) return;
                        var desiredId = finalIdMap[task.from];
                        if (!desiredId || desiredId === task.from) {
                            def.label = task.label;
                            return;
                        }
                        var preserved = {
                            id: desiredId,
                            label: task.label,
                            background: def.background,
                            border: def.border,
                            color: def.color,
                            isMarker: def.isMarker
                        };
                        delete typeDefinitions[task.from];
                        typeDefinitions[desiredId] = preserved;
                        updateTypeShades(preserved);
                        if (Array.isArray(colorModalState.typeIds)) {
                            colorModalState.typeIds = colorModalState.typeIds.map(function (id) {
                                return id === task.from ? desiredId : id;
                            });
                        }
                        var storedColor = colorModalState.types[task.from];
                        if (typeof storedColor !== "undefined") {
                            colorModalState.types[desiredId] = storedColor;
                            delete colorModalState.types[task.from];
                        }
                        colorModalState.labels[desiredId] = task.label;
                        delete colorModalState.labels[task.from];
                        views.forEach(function (view) {
                            if (!view.filterState || !view.filterState.kinds) return;
                            if (Object.prototype.hasOwnProperty.call(view.filterState.kinds, task.from)) {
                                view.filterState.kinds[desiredId] = view.filterState.kinds[task.from];
                                delete view.filterState.kinds[task.from];
                            }
                        });
                        if (filterState && filterState.kinds && Object.prototype.hasOwnProperty.call(filterState.kinds, task.from)) {
                            filterState.kinds[desiredId] = filterState.kinds[task.from];
                            delete filterState.kinds[task.from];
                        }
                        var updates = [];
                        items.get().forEach(function (item) {
                            var currentKind = sanitizeTypeId(item.kind || item.type || "");
                            if (!currentKind || currentKind !== task.from) return;
                            var targetDef = typeDefinitions[desiredId] || def;
                            var markerClass = targetDef && targetDef.isMarker
                                ? " type-marker marker-class"
                                : "";
                            updates.push({
                                id: item.id,
                                kind: desiredId,
                                className: "type-" + desiredId + markerClass
                            });
                        });
                        if (updates.length) {
                            items.update(updates);
                        }
                    });

                    rebuildTypeStyles();
                    syncFiltersForActiveView(getVisibleViewTypeIds());
                    if (colorModalState.timeline) {
                        applyBackground(colorModalState.timeline);
                    }
                    persistCurrentPlanning();
                    closeColorModal();
                }

                if (openColorPaletteBtn) {
                    openColorPaletteBtn.addEventListener("click", function (event) {
                        event.stopPropagation();
                        closeContextMenus();
                        openColorModal();
                    });
                }
                if (colorModalClose) {
                    colorModalClose.addEventListener("click", closeColorModal);
                }
                if (colorModalOverlay) {
                    colorModalOverlay.addEventListener("click", function (event) {
                        if (event.target === colorModalOverlay) {
                            closeColorModal();
                        }
                    });
                }
                if (randomizeColorsBtn) {
                    randomizeColorsBtn.addEventListener("click", function () {
                        var typeIds = colorModalState.typeIds || getVisibleViewTypeIds();
                        if (!typeIds.length) return;
                        var palette = generateRainbowPalette(typeIds.length);
                        typeIds.forEach(function (typeId, index) {
                            colorModalState.types[typeId] = palette[index % palette.length];
                        });
                        renderColorModalContent();
                    });
                }
                if (saveColorPreferencesBtn) {
                    saveColorPreferencesBtn.addEventListener("click", applyColorModalChanges);
                }

                function downloadJson(filename, payload) {
                    var blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
                    var url = URL.createObjectURL(blob);
                    var anchor = document.createElement("a");
                    anchor.href = url;
                    anchor.download = filename;
                    document.body.appendChild(anchor);
                    anchor.click();
                    document.body.removeChild(anchor);
                    setTimeout(function () {
                        URL.revokeObjectURL(url);
                    }, 1000);
                }

                function getExportFilename(ext) {
                    try {
                        var rawTitle = (document.title || "export").toString().trim();
                        var safe = rawTitle.replace(/[^a-z0-9\-_.]/gi, "_").replace(/_+/g, "_");
                        var ts = new Date().toISOString().replace(/[:.]/g, "-");
                        return safe + "_" + ts + "." + ext;
                    } catch (e) {
                        return "export_" + Date.now() + "." + ext;
                    }
                }

                function gatherExportState() {
                    persistCurrentPlanning();
                    return buildTimelineStatePayload();
                }

                function exportTimelineState() {
                    var payload = gatherExportState();
                    downloadJson(getExportFilename('json'), payload);
                }

                async function exportTimelineImage() {
                    if (!timelineCard || !exportImageBtn) return;
                    closeContextMenus();
                    var initialLabel = exportImageBtn.textContent;
                    exportImageBtn.disabled = true;
                    const frames = ["‚ó¥", "‚ó∑", "‚ó∂", "‚óµ"];
                    let frameIndex = 0;
                    exportImageBtn.textContent = frames[frameIndex];
                    try {
                        var canvas = await html2canvas(timelineCard, { scale: 2, backgroundColor: null, useCORS: true });
                        var link = document.createElement("a");
                        link.href = canvas.toDataURL("image/png");
                        link.download = getExportFilename('png');
                        link.click();
                    } catch (err) {
                        console.error("Export image impossible", err);
                        alert("Export image impossible. R√©essaie.");
                    } finally {
                        exportImageBtn.textContent = initialLabel;
                        exportImageBtn.disabled = false;
                    }
                }

                function buildExcelRows(planning) {
                    if (!planning || !Array.isArray(planning.items)) return [];
                    var groupMap = {};
                    (planning.groups || []).forEach(function (group) {
                        if (group && group.id) {
                            groupMap[group.id] = group.label || "";
                        }
                    });
                    return planning.items.map(function (item) {
                        var isMarker = isMarkerKind(item.kind);
                        var endValue = isMarker ? "" : (item.end || "");
                        var durationValue = "";
                        if (!isMarker && item.start) {
                            var startDate = isoToDate(item.start);
                            var len = parseInt(item.length, 10);
                            if (!endValue && startDate && !isNaN(len) && len > 0) {
                                var inclusiveEnd = new Date(startDate.getTime());
                                inclusiveEnd.setDate(inclusiveEnd.getDate() + (len - 1));
                                endValue = dateToIso(inclusiveEnd);
                            }
                            var durationDays = !isNaN(len) && len > 0 ? len : getItemDurationInDays(item);
                            if (durationDays && durationDays > 0) {
                                durationValue = durationDays;
                            }
                        }
                        return {
                            Ligne: groupMap[item.groupId] || item.groupId || "",
                            Activit√©: item.label || "",
                            Type: getKindLabel(item.kind) || item.kind || "",
                            D√©but: item.start || "",
                            Fin: endValue,
                            Dur√©e: durationValue,
                            Date: item.date || ""
                        };
                    });
                }

                function computeDaySpan(start, end) {
                    if (!start || !end) {
                        return null;
                    }
                    var startDate = new Date(start);
                    var endDate = new Date(end);
                    if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
                        return null;
                    }
                    var msPerDay = 1000 * 60 * 60 * 24;
                    var diff = Math.round((endDate - startDate) / msPerDay);
                    if (diff < 0) {
                        return null;
                    }
                    return diff + 1; // include both endpoints
                }

                function exportTimelineExcel() {
                    if (!exportExcelBtn) return;
                    closeContextMenus();
                    exportExcelBtn.disabled = true;
                    var initialLabel = exportExcelBtn.textContent;
                    const frames = ["‚ó¥", "‚ó∑", "‚ó∂", "‚óµ"];
                    let frameIndex = 0;
                    exportExcelBtn.textContent = frames[frameIndex];
                    try {
                        persistCurrentPlanning();
                        var currentView = views[activeViewIndex];
                        var planning = (currentView && currentView.planning) || exportPlanningToJson();
                        var rows = buildExcelRows(planning);
                        if (!rows.length) {
                            alert("Aucun √©l√©ment √† exporter.");
                            return;
                        }
                        var worksheet = XLSX.utils.json_to_sheet(rows, {
                            header: ["Ligne", "Activit√©", "Type", "D√©but", "Fin", "Dur√©e", "Date"]
                        });
                        var workbook = XLSX.utils.book_new();
                        XLSX.utils.book_append_sheet(workbook, worksheet, "Planning");
                        XLSX.writeFile(workbook, getExportFilename('xlsx'));
                    } catch (err) {
                        console.error("Export Excel failed", err);
                        alert("Export Excel impossible. R√©essaie.");
                    } finally {
                        exportExcelBtn.textContent = initialLabel;
                        exportExcelBtn.disabled = false;
                    }
                }

                function getTypeLabelListForPlanning(planning) {
                    var items = Array.isArray(planning && planning.items) ? planning.items : [];
                    var usedKinds = {};
                    items.forEach(function (item) {
                        var k = sanitizeTypeId(item.kind || item.type || "");
                        if (k) usedKinds[k] = true;
                    });
                    var labels = [];
                    var added = {};
                    var candidates = []
                        .concat(Array.isArray(planning && planning.types) ? planning.types : [])
                        .concat(Array.isArray(planning && planning.markers) ? planning.markers : []);
                    candidates.forEach(function (def) {
                        if (!def || !def.id) return;
                        if (!usedKinds[sanitizeTypeId(def.id)]) return;
                        var text = def.label || def.name || def.id;
                        if (!text) return;
                        var suffix = def.isMarker ? "+" : "";
                        var finalLabel = text.trim() + suffix;
                        if (added[def.id]) return;
                        added[def.id] = true;
                        labels.push(finalLabel);
                    });
                    Object.keys(usedKinds).forEach(function (kindId) {
                        if (added[kindId]) return;
                        var def = typeDefinitions[kindId];
                        var label = formatKindLabel(def) || kindId;
                        added[kindId] = true;
                        labels.push(label);
                    });
                    return labels;
                }

                function buildTextExport(planning, viewTitle) {
                    var lines = [];
                    if (viewTitle) {
                        lines.push("Bloc : " + viewTitle);
                    }
                    if (planning && planning.timeline) {
                        var start = planning.timeline.start || "";
                        var end = planning.timeline.end || "";
                        var rangeParts = [];
                        if (start) rangeParts.push(start);
                        if (end) rangeParts.push(end);
                        if (rangeParts.length) {
                            lines.push("P√©riode : " + rangeParts.join(" ‚Üí "));
                        }
                    }
                    var groupMap = {};
                    (planning && Array.isArray(planning.groups) ? planning.groups : []).forEach(function (group) {
                        if (group && group.id) {
                            var label = group.label || group.name || group.id;
                            groupMap[group.id] = label.trim() || group.id;
                        }
                    });
                    var groupLabels = Object.keys(groupMap).map(function (id) {
                        return groupMap[id];
                    }).filter(Boolean);
                    if (groupLabels.length) {
                        lines.push("Groupes : " + groupLabels.join(", "));
                    }
                    var typeLabels = getTypeLabelListForPlanning(planning);
                    if (typeLabels.length) {
                        lines.push("Types : " + typeLabels.join(", "));
                    }
                    var items = planning && Array.isArray(planning.items) ? planning.items : [];
                    if (!items.length) {
                        return "";
                    }
                    lines.push("");
                    lines.push("Actions :");
                    items.forEach(function (item, index) {
                        if (index) {
                            lines.push("");
                        }
                        var label = item.label || "Sans titre";
                        lines.push(label);
                        var days = null;
                        if (isMarkerKind(item.kind)) {
                            if (item.date) {
                                days = 1;
                                lines.push("Date: " + item.date + " (1 jour)");
                            }
                        } else {
                            var parsedLength = parseInt(item.length, 10);
                            if (!isNaN(parsedLength) && parsedLength > 0) {
                                days = parsedLength;
                            } else if (item.start && item.end) {
                                days = computeDaySpan(item.start, item.end);
                            }
                            if (item.start) {
                                var dayLabel = days === 1 ? " jour" : " jours";
                                lines.push("Date: " + item.start + (days ? " (" + days + dayLabel + ")" : ""));
                            }
                        }
                        var groupLabel = groupMap[item.groupId] || item.groupId;
                        if (groupLabel) {
                            lines.push("Groupe: " + groupLabel);
                        }
                        if (item.kind) {
                            lines.push("Type: " + getKindLabel(item.kind));
                        }
                    });
                    return lines.join("\n");
                }

                function buildPlanningJsonString(planning, viewTitle) {
                    if (!planning) {
                        return "";
                    }
                    var cloned = deepClone(planning);
                    try {
                        if (!cloned.page) {
                            var activeView = views && views[activeViewIndex] ? views[activeViewIndex] : null;
                            var title = viewTitle || (activeView && (activeView.title || activeView.name));
                            if (title) {
                                cloned.page = title;
                            }
                        }
                    } catch (e) {
                        /* noop */
                    }
                    try {
                        return JSON.stringify(cloned, null, 2);
                    } catch (err) {
                        console.warn("Impossible de s√©rialiser le planning en JSON", err);
                        return "";
                    }
                }

                var lastAiPlanningJson = null;

                function copyTextToClipboard(text) {
                    if (navigator.clipboard && typeof navigator.clipboard.writeText === "function") {
                        return navigator.clipboard.writeText(text);
                    }
                    return new Promise(function (resolve, reject) {
                        var textarea = document.createElement("textarea");
                        textarea.value = text;
                        textarea.setAttribute("readonly", "");
                        textarea.style.position = "absolute";
                        textarea.style.left = "-9999px";
                        document.body.appendChild(textarea);
                        textarea.select();
                        textarea.setSelectionRange(0, textarea.value.length);
                        var success = document.execCommand("copy");
                        document.body.removeChild(textarea);
                        if (success) {
                            resolve();
                        } else {
                            reject(new Error("Fallback copy failed"));
                        }
                    });
                }

                function showCopyToast(message) {
                    if (!copyToast) return;
                    copyToast.textContent = message;
                    copyToast.classList.add("visible");
                    if (copyToastTimer) {
                        clearTimeout(copyToastTimer);
                    }
                    copyToastTimer = setTimeout(function () {
                        copyToast.classList.remove("visible");
                        copyToastTimer = null;
                    }, 2200);
                }

                function showSpeechToast(message) {
                    if (!speechToast) return;
                    speechToast.textContent = message;
                    speechToast.classList.add("visible");
                    if (speechToastTimer) {
                        clearTimeout(speechToastTimer);
                    }
                    speechToastTimer = setTimeout(function () {
                        speechToast.classList.remove("visible");
                        speechToastTimer = null;
                    }, 2200);
                }

                async function exportTimelineText() {
                    if (!exportTextBtn) return;
                    closeContextMenus();
                    exportTextBtn.disabled = true;
                    try {
                        persistCurrentPlanning();
                        var currentView = views[activeViewIndex];
                        var planning = (currentView && currentView.planning) || exportPlanningToJson();
                        var text = buildTextExport(planning, currentView && currentView.title);
                        await copyTextToClipboard(text);
                        showCopyToast("Texte copi√© dans le presse-papier");
                    } catch (err) {
                        console.error("Copie texte impossible", err);
                        alert("Impossible de copier le texte. R√©essaie.");
                    } finally {
                        exportTextBtn.disabled = false;
                    }
                }

                function applyImportedState(state, options) {
                    if (!state) return false;
                    options = options || {};
                    var importedViews = [];
                    if (Array.isArray(state.views) && state.views.length) {
                        importedViews = state.views.map(function (view, index) {
                            var label = view.name || view.title || ("Bloc " + (index + 1));
                            return {
                                name: label,
                                title: view.title || view.name || label,
                                planning: view.planning || null,
                                context: normalizeContextState(view.context)
                            };
                        });
                    } else if (state.groups) {
                        var label = state.label || state.name || "Bloc 1";
                        importedViews = [{ name: label, title: label, planning: state, context: cloneDefaultContext() }];
                    }
                    if (!importedViews.length) {
                        if (options.alertOnEmpty !== false) {
                            alert("Aucune vue valide √† importer.");
                        }
                        return false;
                    }
                    views = importedViews;
                    if (Array.isArray(state.types)) {
                        applyTypeDefinitions(state.types);
                    }
                    if (state.displayPreferences) {
                        Object.assign(displayPreferences, state.displayPreferences);
                    }
                    if (typeof state.brief === "string") {
                        persistedTimelineBrief = state.brief;
                        if (importedViews.length) {
                            var migratedContext = ensureViewContext(importedViews[0]);
                            if (!migratedContext.prompts.create) {
                                migratedContext.prompts.create = state.brief;
                            }
                        }
                        syncContextFieldsFromState({ refreshModify: true, skipPersist: true });
                    }
                    if (state.templates) {
                        if (typeof state.templates.create === "string") {
                            customSystemTemplates.create = state.templates.create;
                        }
                    }
                    importedViews.forEach(ensureViewContext);
                    syncTemplateEditor();
                    renderFontSizeOptions();
                    applyDisplayPreferences();
                    syncFontControls();
                    renderViewTabs();
                    activateView(0, true);
                    persistTimelineState();
                    return true;
                }

                function initShareWorkerService() {
                    shareWorkerAvailable = Boolean(window.goToolkitShareWorker && window.goToolkitShareWorker.isReady);
                }

                function setShareStatus(message, type) {
                    shareStatusMessage = message || "";
                    shareStatusType = type || "";
                }

                function formatRelativeTime(isoString) {
                    if (!isoString) return "";
                    var value = new Date(isoString).getTime();
                    if (Number.isNaN(value)) return "";
                    var deltaSeconds = Math.max(0, Math.floor((Date.now() - value) / 1000));
                    if (deltaSeconds < 60) {
                        return "Mis √† jour √† l'instant";
                    }
                    var deltaMinutes = Math.floor(deltaSeconds / 60);
                    if (deltaMinutes < 60) {
                        return "Mis √† jour il y a " + deltaMinutes + " minute" + (deltaMinutes > 1 ? "s" : "");
                    }
                    var deltaHours = Math.floor(deltaMinutes / 60);
                    if (deltaHours < 24) {
                        return "Mis √† jour il y a " + deltaHours + " heure" + (deltaHours > 1 ? "s" : "");
                    }
                    var deltaDays = Math.floor(deltaHours / 24);
                    return "Mis √† jour il y a " + deltaDays + " jour" + (deltaDays > 1 ? "s" : "");
                }

                function formatFullDate(isoString) {
                    var value = new Date(isoString);
                    if (Number.isNaN(value.getTime())) return "";
                    var formatter = new Intl.DateTimeFormat("fr-FR", {
                        day: "2-digit",
                        month: "short",
                        year: "numeric",
                        hour: "2-digit",
                        minute: "2-digit"
                    });
                    return formatter.format(value);
                }

                function getShareTokenFromUrl() {
                    var params = new URLSearchParams(window.location.search);
                    var value = params.get(SHARE_QUERY_PARAM);
                    return value ? value.trim() : null;
                }

                function buildShareUrl(token) {
                    if (!token) {
                        return "";
                    }
                    var url = new URL(window.location.href);
                    url.searchParams.set(SHARE_QUERY_PARAM, token);
                    return url.toString();
                }

                function updateUrlWithShareToken(token) {
                    var url = new URL(window.location.href);
                    if (token) {
                        url.searchParams.set(SHARE_QUERY_PARAM, token);
                    } else {
                        url.searchParams.delete(SHARE_QUERY_PARAM);
                    }
                    history.replaceState(null, "", url.toString());
                }

                function createShareToken() {
                    if (typeof crypto !== "undefined" && typeof crypto.randomUUID === "function") {
                        return crypto.randomUUID();
                    }
                    var bytes = new Uint8Array(16);
                    if (typeof crypto !== "undefined" && typeof crypto.getRandomValues === "function") {
                        crypto.getRandomValues(bytes);
                    } else {
                        for (var i = 0; i < bytes.length; i++) {
                            bytes[i] = Math.floor(Math.random() * 256);
                        }
                    }
                    return Array.from(bytes)
                        .map(function (byte) {
                            return byte.toString(16).padStart(2, "0");
                        })
                        .join("");
                }

                async function fetchSharePayload(token) {
                    if (!shareWorkerAvailable || !shareWorkerService) {
                        throw new Error(SHARE_WORKER_UNAVAILABLE_MESSAGE);
                    }
                    return shareWorkerService.fetchSharePayload(FIRESTORE_COLLECTION, token);
                }

                async function tryLoadSharedStateFromUrl() {
                    var token = getShareTokenFromUrl();
                    if (!token) {
                        return false;
                    }
                    if (!shareWorkerAvailable) {
                        setShareStatus(SHARE_WORKER_UNAVAILABLE_MESSAGE, "error");
                        return false;
                    }

                    var localDraft = readShareDraft(token);
                    var remoteResult = null;
                    try {
                        remoteResult = await fetchSharePayload(token);
                    } catch (err) {
                        console.error("Erreur de chargement distant du lien partag√© :", err);
                    }

                    var remotePayload = remoteResult && remoteResult.payload;
                    var remoteUpdatedAt = remoteResult && remoteResult.meta && remoteResult.meta.updatedAt;
                    var localPayload = localDraft && localDraft.payload;
                    var localUpdatedAt = localDraft && localDraft.updatedAt;

                    var remoteDate = remoteUpdatedAt ? new Date(remoteUpdatedAt).getTime() : 0;
                    var localDate = localUpdatedAt ? new Date(localUpdatedAt).getTime() : 0;
                    var payloadsMatch = remotePayload && localPayload
                        ? JSON.stringify(remotePayload) === JSON.stringify(localPayload)
                        : false;
                    var timestampsEqual = remoteUpdatedAt && localUpdatedAt && remoteDate === localDate;

                    var chosenPayload = null;
                    var chosenUpdatedAt = null;

                    if (remotePayload && localPayload && (payloadsMatch || timestampsEqual)) {
                        chosenPayload = localPayload;
                        chosenUpdatedAt = localUpdatedAt || remoteUpdatedAt;
                    } else if (localPayload && localDate > remoteDate) {
                        chosenPayload = localPayload;
                        chosenUpdatedAt = localUpdatedAt;
                    } else if (remotePayload && remoteDate > localDate && localPayload) {
                        var confirmed = window.confirm(
                            "Mettre √† jour avec les modifications du " + formatFullDate(remoteUpdatedAt) + " ?"
                        );
                        if (confirmed) {
                            chosenPayload = remotePayload;
                            chosenUpdatedAt = remoteUpdatedAt;
                        } else {
                            chosenPayload = localPayload;
                            chosenUpdatedAt = localUpdatedAt || remoteUpdatedAt || new Date().toISOString();
                        }
                    } else if (remotePayload) {
                        chosenPayload = remotePayload;
                        chosenUpdatedAt = remoteUpdatedAt || new Date().toISOString();
                    } else if (localPayload) {
                        chosenPayload = localPayload;
                        chosenUpdatedAt = localUpdatedAt || new Date().toISOString();
                    }

                    if (!chosenPayload) {
                        setShareStatus("Lien de la capsule introuvable.", "error");
                        return false;
                    }

                    var imported = applyImportedState(chosenPayload, { alertOnEmpty: false });
                    if (!imported) {
                        setShareStatus("Lien de la capsule introuvable.", "error");
                        return false;
                    }
                    currentShareToken = token;
                    shareLoadedFromRemote = true;
                    shareLastUpdatedAt = chosenUpdatedAt || new Date().toISOString();
                    setShareStatus(formatRelativeTime(shareLastUpdatedAt));
                    await persistRoadmapShareRecord(token, shareLastUpdatedAt);
                    writeShareDraft(token, chosenPayload, shareLastUpdatedAt);
                    updateShareMenuUI();
                    return true;
                }

                async function saveSharePayload(token, payload) {
                    if (!shareWorkerAvailable || !shareWorkerService) {
                        throw new Error(SHARE_WORKER_UNAVAILABLE_MESSAGE);
                    }
                    var meta = await shareWorkerService.saveSharePayload(FIRESTORE_COLLECTION, token, payload);
                    return (meta && meta.updatedAt) || new Date().toISOString();
                }

                function getShareDefaultStatusText() {
                    if (!shareWorkerAvailable) {
                        return SHARE_WORKER_UNAVAILABLE_MESSAGE;
                    }
                    if (shareLastUpdatedAt) {
                        return formatRelativeTime(shareLastUpdatedAt);
                    }
                    if (shareLoadedFromRemote && currentShareToken) {
                        return "Ce lien charge la version enregistr√©e via le worker Cloudflare.";
                    }
                    if (currentShareToken) {
                        return "Un lien priv√© existe d√©j√† pour cette session.";
                    }
                    return "Seules les personnes disposant du lien peuvent y acc√©der.";
                }

                function updateShareMenuUI() {
                    var hasToken = Boolean(currentShareToken);
                    if (shareLinkField) {
                        shareLinkField.value = hasToken ? buildShareUrl(currentShareToken) : "";
                        shareLinkField.placeholder = hasToken ? "" : "Appuie sur Cr√©er pour g√©n√©rer un lien priv√©.";
                    }
                    if (shareUpdateBtn) {
                        shareUpdateBtn.hidden = !hasToken;
                        shareUpdateBtn.disabled = shareRequestInProgress || !hasToken || !shareWorkerAvailable;
                        shareUpdateBtn.classList.toggle("btn-primary", hasToken);
                        shareUpdateBtn.classList.toggle("primary", hasToken);
                    }
                    if (shareCreateBtn) {
                        shareCreateBtn.disabled = shareRequestInProgress || !shareWorkerAvailable;
                        shareCreateBtn.classList.toggle("btn-primary", !hasToken);
                        shareCreateBtn.classList.toggle("primary", !hasToken);
                    }
                    if (shareMenuStatus) {
                        var text = shareStatusMessage || getShareDefaultStatusText();
                        shareMenuStatus.textContent = text;
                        var isError =
                            (shareStatusType === "error" && Boolean(text)) ||
                            (!shareWorkerAvailable && !shareStatusMessage);
                        shareMenuStatus.classList.toggle("error", isError);
                    }
                }

                async function copyCurrentShareLinkToClipboard() {
                    if (!currentShareToken) return false;
                    var link = buildShareUrl(currentShareToken);
                    if (!link) return false;
                    try {
                        await copyTextToClipboard(link);
                        showCopyToast("Lien priv√© copi√©");
                        return true;
                    } catch (err) {
                        console.error("Copie du lien priv√© impossible", err);
                        return false;
                    }
                }

                async function handleShareCreateClick() {
                    if (!shareWorkerAvailable) {
                        setShareStatus(SHARE_WORKER_UNAVAILABLE_MESSAGE, "error");
                        updateShareMenuUI();
                        return;
                    }
                    if (shareRequestInProgress) return;
                    shareRequestInProgress = true;
                    updateShareMenuUI();
                    try {
                        persistCurrentPlanning();
                        var token = createShareToken();
                        var payload = buildTimelineStatePayload();
                        var updatedAt = await saveSharePayload(token, payload);
                        currentShareToken = token;
                        shareLoadedFromRemote = true;
                        shareLastUpdatedAt = updatedAt;
                        updateUrlWithShareToken(token);
                        setShareStatus(formatRelativeTime(updatedAt));
                        updateShareMenuUI();
                        await persistRoadmapShareRecord(token, updatedAt);
                        writeShareDraft(token, payload, updatedAt);
                        await copyCurrentShareLinkToClipboard();
                    } catch (err) {
                        console.error("Erreur lors de la cr√©ation du lien partag√© :", err);
                        setShareStatus("Impossible de cr√©er le lien partag√©.", "error");
                        updateShareMenuUI();
                    } finally {
                        shareRequestInProgress = false;
                        updateShareMenuUI();
                    }
                }

                async function handleShareUpdateClick() {
                    if (!shareWorkerAvailable) {
                        setShareStatus(SHARE_WORKER_UNAVAILABLE_MESSAGE, "error");
                        updateShareMenuUI();
                        return;
                    }
                    if (!currentShareToken) {
                        setShareStatus("Pas de lien priv√© √† mettre √† jour.", "error");
                        updateShareMenuUI();
                        return;
                    }
                    if (shareRequestInProgress) return;
                    shareRequestInProgress = true;
                    updateShareMenuUI();
                    try {
                        persistCurrentPlanning();
                        var payload = buildTimelineStatePayload();
                        var updatedAt = await saveSharePayload(currentShareToken, payload);
                        shareLoadedFromRemote = true;
                        shareLastUpdatedAt = updatedAt;
                        setShareStatus(formatRelativeTime(updatedAt));
                        updateShareMenuUI();
                        await persistRoadmapShareRecord(currentShareToken, updatedAt);
                        writeShareDraft(currentShareToken, payload, updatedAt);
                        await copyCurrentShareLinkToClipboard();
                    } catch (err) {
                        console.error("Erreur lors de la mise √† jour du lien partag√© :", err);
                        setShareStatus("Impossible de mettre √† jour le lien partag√©.", "error");
                        updateShareMenuUI();
                    } finally {
                        shareRequestInProgress = false;
                        updateShareMenuUI();
                    }
                }

                function triggerImportJson() {
                    if (!importJsonInput) return;
                    importJsonInput.value = "";
                    importJsonInput.click();
                }

                if (importJsonInput) {
                    importJsonInput.addEventListener("change", function (event) {
                        var file = event.target.files && event.target.files[0];
                        if (!file) return;
                        var reader = new FileReader();
                        reader.onload = function () {
                            try {
                                var payload = JSON.parse(reader.result);
                                applyImportedState(payload);
                            } catch (err) {
                                alert("Fichier JSON invalide.");
                            }
                        };
                        reader.readAsText(file);
                        importJsonInput.value = "";
                    });
                }
                if (importJsonBtn) {
                    importJsonBtn.addEventListener("click", function () {
                        triggerImportJson();
                        closeContextMenus();
                    });
                }
                if (exportJsonBtn) {
                    exportJsonBtn.addEventListener("click", function () {
                        exportTimelineState();
                        closeContextMenus();
                    });
                }
                if (exportImageBtn) {
                    exportImageBtn.addEventListener("click", exportTimelineImage);
                }
                if (exportExcelBtn) {
                    exportExcelBtn.addEventListener("click", exportTimelineExcel);
                }
                if (exportTextBtn) {
                    exportTextBtn.addEventListener("click", exportTimelineText);
                }
                if (shareCreateBtn) {
                    shareCreateBtn.addEventListener("click", function (event) {
                        event.stopPropagation();
                        handleShareCreateClick();
                    });
                }
                if (shareUpdateBtn) {
                    shareUpdateBtn.addEventListener("click", function (event) {
                        event.stopPropagation();
                        handleShareUpdateClick();
                    });
                }
                if (shareLinkField) {
                    shareLinkField.addEventListener("focus", function () {
                        this.select();
                    });
                    shareLinkField.addEventListener("click", function () {
                        this.select();
                    });
                }

                function closeTimelineInfoPopup() {
                    if (!infoPopup) return;
                    infoPopup.classList.remove("open");
                }

                function toggleTimelineInfoPopup(event) {
                    if (!infoPopup) return;
                    event.stopPropagation();
                    closeContextMenus();
                    infoPopup.classList.toggle("open");
                }

                function clearTimelineStorageAndReload() {
                    try {
                        // Preserve admin token and OpenAI key across reset
                        var __preservedOpenAiKey = null;
                        var __preservedAdminToken = null;
                        try { __preservedOpenAiKey = localStorage.getItem('go-toolkit-api-key'); } catch (e) { }
                        try { __preservedAdminToken = localStorage.getItem('feedback-admin-token'); } catch (e) { }
                        localStorage.clear();
                        if (__preservedOpenAiKey) {
                            try { localStorage.setItem('go-toolkit-api-key', __preservedOpenAiKey); } catch (e) { }
                        }
                        if (__preservedAdminToken) {
                            try { localStorage.setItem('feedback-admin-token', __preservedAdminToken); } catch (e) { }
                        }
                    } catch (err) {
                        console.warn("Impossible de vider localStorage", err);
                    }
                    try {
                        sessionStorage.clear();
                    } catch (err) {
                        console.warn("Impossible de vider sessionStorage", err);
                    }
                    try {
                        if (window.sessionStorage) {
                            window.sessionStorage.setItem(timelineTourSkipFlag, "1");
                        }
                    } catch (err) {
                        console.warn("Impossible de pr√©parer l'indicateur de mise √† jour", err);
                    }
                    var cookies = (document.cookie || "").split(";");
                    cookies.forEach(function (cookie) {
                        var eqPos = cookie.indexOf("=");
                        var name = eqPos > -1 ? cookie.substr(0, eqPos) : cookie;
                        name = name.trim();
                        if (!name) return;
                        document.cookie = name + "=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/";
                    });
                    var reload = function () {
                        window.location.reload();
                    };
                    if (window.caches && typeof window.caches.keys === "function") {
                        window.caches
                            .keys()
                            .then(function (keys) {
                                return Promise.all(
                                    keys.map(function (key) {
                                        return window.caches.delete(key);
                                    })
                                );
                            })
                            .catch(function () { })
                            .finally(reload);
                    } else {
                        reload();
                    }
                }

                function promptTimelineUpdate() {
                    var warning =
                        "La mise √† jour effacera les donn√©es locales (cache, cookies, pr√©f√©rences). Continuer ?";
                    if (!confirm(warning)) return;
                    closeTimelineInfoPopup();
                    clearTimelineStorageAndReload();
                }

                function hideTimelineAbout() {
                    closeTimelineInfoPopup();
                }

                if (aboutTimelineBtn) {
                    aboutTimelineBtn.addEventListener("click", toggleTimelineInfoPopup);
                }

                if (timelineUpdateBtn) {
                    timelineUpdateBtn.addEventListener("click", function (event) {
                        event.stopPropagation();
                        promptTimelineUpdate();
                    });
                }

                document.addEventListener("click", function (event) {
                    if (!infoPopup || infoPopup.contains(event.target) || event.target === aboutTimelineBtn) {
                        return;
                    }
                    closeTimelineInfoPopup();
                });
                if (navSwitcherBtn && navSwitcherMenu) {
                    navSwitcherBtn.addEventListener("click", function (event) {
                        event.stopPropagation();
                        var isOpen = navSwitcherMenu.classList.toggle("open");
                        navSwitcherBtn.setAttribute("aria-expanded", isOpen ? "true" : "false");
                    });
                    navSwitcherMenu.addEventListener("click", function (event) {
                        event.stopPropagation();
                    });
                    document.addEventListener("click", function (event) {
                        if (!navSwitcherMenu.contains(event.target) && event.target !== navSwitcherBtn) {
                            navSwitcherMenu.classList.remove("open");
                            navSwitcherBtn.setAttribute("aria-expanded", "false");
                        }
                    });
                }

                function applyFont(font) {
                    document.documentElement.style.setProperty("--app-font", font);
                    document.body.style.fontFamily = font;
                    if (timelineCard) {
                        timelineCard.style.fontFamily = font;
                    }
                    if (container) {
                        container.style.fontFamily = font;
                    }
                    displayPreferences.font = font;
                }

                function updateFontSize(size) {
                    var normalized = parseInt(size, 10);
                    if (isNaN(normalized)) {
                        normalized = 11;
                    }
                    var value = normalized + "px";
                    document.documentElement.style.setProperty("--global-font-size", value);
                    document.body.style.fontSize = value;
                    if (timelineCard) timelineCard.style.fontSize = value;
                    if (container) container.style.fontSize = value;
                    displayPreferences.fontSize = normalized;
                }

                function syncFontControls() {
                    var computed = getComputedStyle(document.documentElement);
                    if (fontSizeInput) {
                        var rawSize = computed.getPropertyValue("--global-font-size").trim();
                        var calculated = parseInt(rawSize, 10);
                        if (isNaN(calculated)) {
                            calculated = parseInt(window.getComputedStyle(document.body).fontSize, 10);
                        }
                        if (!isNaN(calculated)) {
                            fontSizeInput.value = calculated;
                        }
                    }
                }

                function applyBackground(value) {
                    var normalized = (typeof value === "string" ? value.trim() : "") || "#ffffff";
                    var bodyValue = normalized === "transparent" ? "#f7f7f7" : normalized;
                    var cardValue = normalized === "transparent" ? "rgba(255, 255, 255, 0.6)" : normalized;
                    document.body.style.background = bodyValue;
                    document.documentElement.style.setProperty("--timeline-background", cardValue);
                    if (timelineCard) {
                        timelineCard.style.background = cardValue;
                    }
                    displayPreferences.background = normalized;
                    if (backgroundSelector) {
                        var selectorValue = allowedBackgroundValues.indexOf(normalized) >= 0
                            ? normalized
                            : allowedBackgroundValues[0];
                        backgroundSelector.value = selectorValue;
                    }
                }

                function updateTimelineAspect(ratio) {
                    if (!timelineCard || !ratio) return;
                    timelineCard.dataset.ratio = ratio;
                }

                function applySpacingMode(mode, shouldPersist) {
                    if (!timelineCard) return;
                    var normalized = typeof mode === "string" ? mode.trim().toLowerCase() : "";
                    if (!normalized) normalized = "dense";
                    var allowed = ["dense", "normal", "comfortable"];
                    if (allowed.indexOf(normalized) === -1) {
                        normalized = "dense";
                    }
                    timelineCard.dataset.spacing = normalized;
                    displayPreferences.spacing = normalized;
                    if (spacingSelect) {
                        spacingSelect.value = normalized;
                    }
                    if (shouldPersist) {
                        persistTimelineState();
                    }
                }

                function applyBorderLightMode(mode, shouldPersist) {
                    var normalized = typeof mode === "string" ? mode.trim() : "";
                    if (!normalized || !borderLightModes.hasOwnProperty(normalized)) {
                        normalized = DEFAULT_BORDER_LIGHT_MODE;
                    }
                    document.documentElement.style.setProperty("--border-light", borderLightModes[normalized]);
                    displayPreferences.borderLightMode = normalized;
                    if (borderLightSelect) {
                        borderLightSelect.value = normalized;
                    }
                    if (shouldPersist) {
                        persistTimelineState();
                    }
                }

                function applyRatio(ratio, shouldPersist) {
                    if (!timelineCard) return;
                    var normalized = typeof ratio === "string" ? ratio.trim() : "";
                    var allowed = ["full", "16:9", "4:3", "a4"];
                    if (!normalized || allowed.indexOf(normalized) === -1) {
                        normalized = "full";
                    }
                    displayPreferences.ratio = normalized;
                    updateTimelineAspect(normalized);
                    if (widthSelect) {
                        widthSelect.value = normalized;
                    }
                    if (shouldPersist) {
                        persistTimelineState();
                    }
                }

                function applyDisplayPreferences() {
                    if (displayPreferences.font) {
                        applyFont(displayPreferences.font);
                    }
                    if (fontSizeInput && displayPreferences.fontSize) {
                        fontSizeInput.value = displayPreferences.fontSize;
                        updateFontSize(displayPreferences.fontSize);
                    }
                    var backgroundValue = displayPreferences.background || "#ffffff";
                    applyBackground(backgroundValue);
                    applyRatio(displayPreferences.ratio || "full");
                    applySpacingMode(displayPreferences.spacing || "dense");
                    applyBorderLightMode(displayPreferences.borderLightMode || DEFAULT_BORDER_LIGHT_MODE);
                    applyWeekendVisibilityPreference(false);
                }

                function applyWeekendVisibilityPreference(shouldPersist) {
                    if (weekendVisibilitySelect) {
                        weekendVisibilitySelect.value = displayPreferences.hideWeekends ? "hide" : "show";
                    }
                    if (timeline) {
                        timeline.setOptions({
                            hiddenDates: buildWeekendHiddenDates()
                        });
                    }
                    if (shouldPersist) {
                        persistTimelineState();
                    }
                }

                function hideEmptyGroups() {
                    document.querySelectorAll("#timeline .vis-group").forEach((group) => {
                        const hasItem = Boolean(group.querySelector(".vis-item"));
                        group.style.display = hasItem ? "" : "none";
                    });
                }
                timeline.on("change", hideEmptyGroups);
                timeline.on("rangechanged", hideEmptyGroups);
                hideEmptyGroups(); // call once after initial render


                function setItemDurationMode(mode, shouldPersist) {
                    var normalized = typeof mode === "string" ? mode : "none";
                    var allowed = ["none", "days", "weeks"];
                    if (allowed.indexOf(normalized) === -1) {
                        normalized = "none";
                    }
                    displayPreferences.itemDurationMode = normalized;
                    if (itemDurationSelect) {
                        itemDurationSelect.value = normalized;
                    }
                    if (shouldPersist) {
                        persistTimelineState();
                    }
                    if (timeline && typeof timeline.redraw === "function") {
                        timeline.redraw();
                    }
                }

                renderFontSizeOptions();

                if (fontSizeInput) fontSizeInput.addEventListener("change", function () {
                    updateFontSize(this.value);
                });
                applyDisplayPreferences();
                syncFontControls();
                if (backgroundSelector) {
                    backgroundSelector.addEventListener("change", function () {
                        applyBackground(this.value);
                    });
                }
                if (itemDurationSelect) {
                    itemDurationSelect.addEventListener("change", function () {
                        setItemDurationMode(this.value, true);
                    });
                }
                if (widthSelect) {
                    widthSelect.addEventListener("change", function () {
                        applyRatio(this.value, true);
                    });
                }
                if (spacingSelect) {
                    spacingSelect.addEventListener("change", function () {
                        applySpacingMode(this.value, true);
                    });
                }
                if (borderLightSelect) {
                    borderLightSelect.addEventListener("change", function () {
                        applyBorderLightMode(this.value, true);
                    });
                }
                if (weekendVisibilitySelect) {
                    weekendVisibilitySelect.addEventListener("change", function () {
                        displayPreferences.hideWeekends = this.value === "hide";
                        applyWeekendVisibilityPreference(true);
                    });
                }
                setItemDurationMode(displayPreferences.itemDurationMode || "none", false);

                var viewTabs = document.getElementById("viewTabs");
                var addViewBtn = document.getElementById("addViewBtn");
                var deleteViewBtn = document.getElementById("deleteViewBtn");

                function ensureViewName(index) {
                    var view = views[index];
                    if (!view) return "Bloc " + (index + 1);
                    if (view.name !== undefined && view.name !== null) return view.name;
                    if (view.title !== undefined && view.title !== null) return view.title;
                    return "Bloc " + (index + 1);
                }

                function refreshHeaderText() {
                    if (!headerTitleElement) return;
                    var currentView = views[activeViewIndex];
                    var label = "";
                    if (currentView) {
                        var ctx = ensureViewContext(currentView);
                        var hasContent =
                            (ctx.prompts && ((ctx.prompts.create || "").trim() || (ctx.prompts.modify || "").trim())) ||
                            hasTimelineData();
                        label = currentView.title || currentView.name;
                        if (!hasContent && !currentView.planning) {
                            label = "";
                        }
                    }
                    headerTitleElement.textContent = label || "";
                }

                function resetTimelineForEmptyView() {
                    persistenceLocked = true;
                    groups.clear();
                    items.clear();
                    persistenceLocked = false;
                    timeline.setWindow(
                        new Date(now.getTime() - 2 * oneWeek),
                        new Date(now.getTime() + 6 * oneWeek),
                        { animation: false }
                    );
                    syncFiltersForActiveView(getVisibleViewTypeIds());
                    updateTimelineFilter();
                    persistCurrentPlanning();
                    updateEmptyViewMessage();
                }

                function activateView(index, skipSave) {
                    if (index < 0 || index >= views.length) return;
                    if (!skipSave) {
                        persistCurrentPlanning();
                    }
                    activeViewIndex = index;
                    var view = views[index];
                    ensureViewFilterState(view);
                    if (view && view.filterState) {
                        filterState = view.filterState;
                    }
                    if (view && view.planning) {
                        applyPlanningFromJson(view.planning);
                    } else {
                        resetTimelineForEmptyView();
                    }
                    ensureViewContext(view);
                    selectedRoadmapPromptId = view && view.context ? (view.context.templateId || null) : null;
                    refreshHeaderText();
                    renderViewTabs();
                    updateEmptyViewMessage();
                    syncContextUIForActiveView();
                }

                function clearActiveView(options) {
                    var clearRecit = options && options.clearRecit;
                    var view = views[activeViewIndex];
                    if (!view) return;
                    ensureViewContext(view);
                    var ctx = view.context || {};
                    ctx.prompts = ctx.prompts || {};
                    if (clearRecit) {
                        ctx.prompts.create = "";
                        if (txtPromptCreate) txtPromptCreate.value = "";
                    }
                    ctx.prompts.modify = "";
                    ctx.templateId = null;
                    selectedRoadmapPromptId = null;
                    if (txtPromptModify) txtPromptModify.value = "";
                    view.context = ctx;
                    view.planning = null;
                    view.filterState = { kinds: {} };
                    filterState = view.filterState;
                    typeDefinitions = {};
                    rebuildTypeStyles();
                    persistenceLocked = true;
                    groups.clear();
                    items.clear();
                    persistenceLocked = false;
                    syncFiltersForActiveView(getVisibleViewTypeIds());
                    resetTimelineForEmptyView();
                    updateEmptyViewMessage();
                    persistTimelineState();
                }

                function clearPromptsForActiveView() {
                    var ctx = ensureViewContext(views[activeViewIndex]);
                    if (ctx && ctx.prompts) {
                        ctx.prompts.create = "";
                        ctx.prompts.modify = "";
                    }
                    if (ctx) {
                        ctx.templateId = null;
                    }
                    selectedRoadmapPromptId = null;
                    if (txtPromptCreate) txtPromptCreate.value = "";
                    if (txtPromptModify) txtPromptModify.value = "";
                    updatePromptTemplateMeta();
                    persistTimelineState();
                }

                if (headerTitleElement) {
                    headerTitleElement.addEventListener("dblclick", function () {
                        var currentLabel = (headerTitleElement.textContent || "").trim();
                        var label = window.prompt("Nom de la vue", currentLabel);
                        if (label === null) return;
                        label = label.trim();
                        if (!label) return;
                        var view = views[activeViewIndex];
                        if (!view) return;
                        view.title = label;
                        refreshHeaderText();
                        persistTimelineState();
                        renderViewTabs();
                    });
                }

                function renderViewTabs() {
                    if (!viewTabs) return;
                    viewTabs.innerHTML = "";
                    views.forEach(function (view, index) {
                        var btn = document.createElement("button");
                        btn.type = "button";
                        btn.className = "tab" + (index === activeViewIndex ? " active" : "");
                        btn.textContent = ensureViewName(index);
                        btn.dataset.index = index;
                        btn.addEventListener("click", function () {
                            activateView(Number(this.dataset.index));
                        });
                        btn.addEventListener("dblclick", function () {
                            var idx = Number(this.dataset.index);
                            var currentName = ensureViewName(idx);
                            var newName = window.prompt("Nom de l'onglet", currentName);
                            if (newName === null) return;
                            newName = newName.trim();
                            if (!newName) return;
                            var targetView = views[idx];
                            if (!targetView) return;
                            targetView.name = newName;
                            this.textContent = newName;
                            persistTimelineState();
                        });
                        viewTabs.appendChild(btn);
                    });
                    if (viewTabs.children.length > 0) {
                        var last = viewTabs.children[viewTabs.children.length - 1];
                        last.scrollIntoView({ behavior: "smooth", inline: "end" });
                    }
                }

                function addView() {
                    persistCurrentPlanning();
                    var label = "Bloc " + (views.length + 1);
                    var newView = { name: label, title: label, planning: null, context: cloneDefaultContext() };
                    ensureViewFilterState(newView);
                    views.push(newView);
                    persistTimelineState();
                    activateView(views.length - 1, true);
                    clearPromptsForActiveView();
                    openContextModal({ mode: "create" });
                }

                function deleteView() {
                    var view = views[activeViewIndex];
                    if (!view || views.length <= 1) return;
                    views.splice(activeViewIndex, 1);
                    if (activeViewIndex >= views.length) {
                        activeViewIndex = views.length - 1;
                    }
                    persistTimelineState();
                    activateView(activeViewIndex, true);
                }

                addViewBtn && addViewBtn.addEventListener("click", addView);
                if (deleteViewBtn) {
                    deleteViewBtn.addEventListener("click", function () {
                        if (!views || views.length <= 1) return;
                        var name = (views[activeViewIndex] && (views[activeViewIndex].title || views[activeViewIndex].name)) || ("Bloc " + (activeViewIndex + 1));
                        var ok = confirm("Supprimer la vue '" + name + "' ? Cette action est irr√©versible.");
                        if (ok) deleteView();
                    });
                }

                renderViewTabs();
                activateView(activeViewIndex, true);
                // ============================================================
                // 3. Inline labeling via prompt (double-clic)
                // ============================================================
                var renameGuard = false;
                function editItemLabel(itemId) {
                    if (renameGuard) return;
                    renameGuard = true;
                    setTimeout(function () {
                        renameGuard = false;
                    }, 300);
                    var it = items.get(itemId);
                    if (!it) return;
                    var current = (it.content || "").trim();
                    var label = window.prompt("Saisis un libell√© ou vide pour supprimer", current);
                    if (label === null) return;
                    label = label.trim();
                    if (!label) {
                        items.remove(itemId);
                        return;
                    }
                    items.update({ id: itemId, content: label });
                }

                function editGroupLabel(groupId) {
                    if (!groupId) return;
                    var group = groups.get(groupId);
                    if (!group) return;
                    var current = (group.content || group.label || group.id || "").trim();
                    var label = window.prompt("Nom du groupe. Vider pour supprimer", current);
                    if (label === null) return;
                    label = label.trim();
                    if (!label) {
                        if (!confirm("Supprimer ce groupe et tous les √©l√©ments associ√©s ?")) {
                            return;
                        }
                        var relatedItems = items.get({
                            filter: function (item) {
                                return item.group === groupId;
                            }
                        });
                        relatedItems.forEach(function (item) {
                            items.remove(item.id);
                        });
                        groups.remove(groupId);
                        return;
                    }
                    groups.update({ id: groupId, content: label, label: label });
                }

                // Double-clic : √©diter un groupe ou un √©l√©ment
                timeline.on("doubleClick", function (props) {
                    if (props.what === "group-label" && props.group) {
                        editGroupLabel(props.group);
                        return;
                    }
                    if (props.item) {
                        editItemLabel(props.item);
                    }
                });

                // Ajout natif vis ‚Üí on force notre logique + label prompt
                options.onAdd = function (item, callback) {
                    callback(null);
                    var start = item.start || item.end || new Date();
                    var groupId = item.group || getDefaultGroupId();
                    var id, newItem;

                    var isMarkerGroup = groupId === "markers" || groupId === "milestones";
                    if (isMarkerGroup) {
                        var markerKind = getFirstMarkerId() || ensureMarkerDefinition({ id: "marker", label: "Rep√®re" });
                        ensureMarkerDefinition({ id: markerKind });
                        id = "ms-" + Date.now();
                        newItem = {
                            id: id,
                            group: groupId === "milestones" ? "milestones" : "markers",
                            content: "",
                            start: start,
                            type: "point",
                            kind: markerKind,
                            className: "type-" + markerKind + " type-marker marker-class"
                        };
                    } else {
                        var defaultKind = getFirstRegularTypeId();
                        ensureTypeDefinition({ id: defaultKind });
                        id = "it-" + Date.now();
                        newItem = {
                            id: id,
                            group: groupId,
                            content: "",
                            start: start,
                            end: new Date(start.getTime() + oneWeek),
                            kind: defaultKind,
                            className: "type-" + defaultKind
                        };
                    }
                    items.add(newItem);
                    setTimeout(function () { editItemLabel(id); }, 30);
                };

                timeline.setOptions(options);
                updateTimelineFilter();

                // ============================================================
                // 4. S√©lection et suppression simple
                // ============================================================
                var selectedItemId = null;
                var btnAddMilestone = document.getElementById("btn-add-milestone");
                var btnRenameSelected = document.getElementById("btn-rename-selected");
                var btnAddItem = document.getElementById("btn-add-item");
                var btnDeleteSelected = document.getElementById("btn-delete-selected");
                var btnAddGroup = document.getElementById("btn-add-group");

                if (btnAddGroup) {
                    btnAddGroup.addEventListener("click", function () {
                        createAndEditGroup();
                    });
                }

                function getDefaultGroupId() {
                    if (!groups || typeof groups.get !== "function") {
                        return null;
                    }
                    var currentGroups = groups.get();
                    if (currentGroups && currentGroups.length) {
                        // Prefer an explicitly named 'groupe' as the default target for new items
                        try {
                            if (groups.get("groupe")) return "groupe";
                        } catch (e) {
                            /* noop */
                        }
                        return currentGroups[0].id;
                    }
                    var fallbackId = "groupe";
                    if (typeof groups.add === "function") {
                        groups.add({ id: fallbackId, content: "Groupe" });
                    }
                    return fallbackId;
                }

                function addSansGroupIfNeeded() {
                    if (!groups || typeof groups.get !== "function") return;
                    if (groups.get("(sans)")) {
                        ensureSansGroupFirst();
                        return;
                    }
                    if (typeof groups.add === "function") {
                        groups.add({ id: "(sans)", content: "(sans)" });
                        ensureSansGroupFirst();
                    }
                }

                function ensureSansGroupFirst() {
                    if (!groups || typeof groups.get !== "function") return;
                    var all = groups.get();
                    if (!all || !all.length) return;
                    if (all[0] && all[0].id === "(sans)") return;
                    var sans = groups.get("(sans)");
                    if (!sans) return;
                    var others = all.filter(function (g) {
                        return g.id !== "(sans)";
                    });
                    // Rebuild groups with '(sans)' first
                    groups.clear();
                    groups.add([sans].concat(others));
                }

                // Inline modal for creating / renaming items and groups
                function showInlineInputModal(defaultValue, options) {
                    options = options || {};
                    var modal = document.getElementById("inline-input-modal");
                    if (!modal) {
                        modal = document.createElement("div");
                        modal.id = "inline-input-modal";
                        modal.style.position = "fixed";
                        modal.style.left = "0";
                        modal.style.top = "0";
                        modal.style.width = "100%";
                        modal.style.height = "100%";
                        modal.style.display = "none";
                        modal.style.alignItems = "center";
                        modal.style.justifyContent = "center";
                        modal.style.background = "rgba(0,0,0,0.3)";
                        modal.innerHTML = '<div style="background:#fff;padding:12px;border-radius:6px;min-width:260px;box-shadow:0 6px 18px rgba(0,0,0,0.2)"><input id="inline-input-field" style="width:100%;box-sizing:border-box;padding:8px;font-size:14px;margin-bottom:8px"/><div style="text-align:right"><button id="inline-input-cancel">Annuler</button> <button id="inline-input-ok">OK</button></div></div>';
                        document.body.appendChild(modal);
                    }
                    var input = modal.querySelector('#inline-input-field');
                    var btnOk = modal.querySelector('#inline-input-ok');
                    var btnCancel = modal.querySelector('#inline-input-cancel');
                    input.value = defaultValue || "";
                    input.placeholder = (options.placeholder || "");
                    modal.style.display = "flex";
                    setTimeout(function () {
                        try {
                            input.focus();
                            input.select();
                        } catch (e) { }
                    }, 10);

                    function cleanup() {
                        modal.style.display = "none";
                        btnOk.removeEventListener('click', onOk);
                        btnCancel.removeEventListener('click', onCancel);
                        input.removeEventListener('keydown', onKeydown);
                    }

                    function onOk() {
                        var val = input.value == null ? "" : input.value.toString().trim();
                        cleanup();
                        if (typeof options.onConfirm === "function") options.onConfirm(val);
                    }

                    function onCancel() {
                        cleanup();
                        if (typeof options.onCancel === "function") options.onCancel();
                    }

                    function onKeydown(e) {
                        if (e.key === "Enter") {
                            e.preventDefault();
                            onOk();
                        } else if (e.key === "Escape") {
                            e.preventDefault();
                            onCancel();
                        }
                    }

                    btnOk.addEventListener('click', onOk);
                    btnCancel.addEventListener('click', onCancel);
                    input.addEventListener('keydown', onKeydown);
                }

                function nextNumberForPrefix(prefix, source) {
                    var re = new RegExp('^' + prefix.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\s*(\\d+)$', 'i');
                    var max = 0;
                    try {
                        var all = (source === 'groups') ? groups.get() : items.get();
                        (all || []).forEach(function (it) {
                            var content = (it && it.content) ? it.content.toString().trim() : '';
                            var m = content.match(re);
                            if (m && m[1]) {
                                var n = parseInt(m[1], 10);
                                if (!isNaN(n) && n > max) max = n;
                            }
                        });
                    } catch (e) { }
                    return max + 1;
                }

                function sanitizeIdFromName(name) {
                    return (name || '').toString().toLowerCase().replace(/[^a-z0-9\-\_]+/g, '-').replace(/^-+|-+$/g, '') || ('id-' + Date.now());
                }

                function createAndEditGroup() {
                    var base = 'Groupe';
                    var n = nextNumberForPrefix(base, 'groups');
                    var defaultName = base + ' ' + n;
                    var id = sanitizeIdFromName(defaultName);
                    if (groups.get(id)) {
                        id = id + '-' + Date.now();
                    }
                    groups.add({ id: id, content: defaultName });
                    if (groups.get('(sans)')) ensureSansGroupFirst();
                    // Open the existing group rename flow instead of inline modal
                    // Persist initial state so the group is available to the editor
                    try { persistTimelineState(); } catch (e) { /* noop */ }
                    setTimeout(function () { editGroupLabel(id); }, 30);
                }

                function createAndEditTimelineItem(kind) {
                    if (!items) return;
                    var isMarker = kind === 'marker' || isMarkerKind(kind);
                    // ensure (sans) exists and prefer it for new items
                    addSansGroupIfNeeded();
                    var groupId = groups.get('(sans)') ? '(sans)' : getGroupForNewItem(isMarker);
                    if (!groupId) return;
                    var baseStart = getTimelineCenter();
                    var newItemId = (isMarker ? 'ms-' : 'it-') + Date.now();
                    var resolvedKind = isMarker
                        ? (isMarkerKind(kind) ? kind : (getFirstMarkerId() || ensureMarkerDefinition({ id: 'marker', label: 'Rep√®re' })))
                        : (kind && !isMarkerKind(kind) ? kind : getFirstRegularTypeId());
                    if (isMarker) {
                        ensureMarkerDefinition({ id: resolvedKind });
                    } else {
                        ensureTypeDefinition({ id: resolvedKind });
                    }

                    var baseLabel = isMarker ? 'Rep√®re' : 'Action';
                    var n = nextNumberForPrefix(baseLabel, 'items');
                    var defaultName = baseLabel + ' ' + n;

                    var newItem = {
                        id: newItemId,
                        group: groupId,
                        content: defaultName,
                        start: baseStart,
                        kind: resolvedKind,
                        className: isMarker ? ('type-' + resolvedKind + ' type-marker marker-class') : ('type-' + resolvedKind)
                    };
                    if (isMarker) {
                        newItem.type = 'point';
                    } else {
                        newItem.end = computeDefaultEnd(baseStart);
                    }
                    items.add(newItem);
                    if (timeline && typeof timeline.setSelection === 'function') {
                        timeline.setSelection(newItemId);
                    }
                    selectedItemId = newItemId;
                    updateSelectionButtons();
                    // Use the existing edit dialog/prompt for items (same behavior as native add)
                    try { persistTimelineState(); } catch (e) { /* noop */ }
                    setTimeout(function () { editItemLabel(newItemId); }, 30);
                }

                function getTimelineCenter() {
                    if (!timeline || typeof timeline.getWindow !== "function") {
                        return new Date();
                    }
                    var windowBounds = timeline.getWindow();
                    if (!windowBounds) {
                        return new Date();
                    }
                    var start = windowBounds.start ? new Date(windowBounds.start) : new Date();
                    var end = windowBounds.end ? new Date(windowBounds.end) : new Date(start.getTime() + oneWeek);
                    var mid = (start.getTime() + end.getTime()) / 2;
                    return new Date(mid);
                }

                function getGroupForNewItem(isMarkerItem) {
                    if (!groups || typeof groups.get !== "function") {
                        return null;
                    }
                    if (isMarkerItem) {
                        var markerGroup = groups.get("markers") || groups.get("milestones");
                        if (markerGroup) {
                            return markerGroup.id;
                        }
                        var fallbackMarkerId = "markers";
                        groups.add({ id: fallbackMarkerId, content: "Jalons" });
                        return fallbackMarkerId;
                    }
                    if (selectedItemId) {
                        var selectedItem = items.get(selectedItemId);
                        if (selectedItem && selectedItem.group) {
                            return selectedItem.group;
                        }
                    }
                    return getDefaultGroupId();
                }

                function computeDefaultEnd(start) {
                    if (!start) return new Date();
                    var end = new Date(start);
                    if (currentScaleMode === "day") {
                        end.setDate(end.getDate() + 10);
                        return end;
                    }
                    if (currentScaleMode === "month") {
                        end.setMonth(end.getMonth() + 2);
                        return end;
                    }
                    end.setDate(end.getDate() + 14);
                    return end;
                }

                function createTimelineItem(kind) {
                    if (!items) return;
                    var isMarker = kind === "marker" || isMarkerKind(kind);
                    var groupId = getGroupForNewItem(isMarker);
                    if (!groupId) return;
                    var baseStart = getTimelineCenter();
                    var newItemId = (isMarker ? "ms-" : "it-") + Date.now();
                    var resolvedKind = isMarker
                        ? (isMarkerKind(kind) ? kind : (getFirstMarkerId() || ensureMarkerDefinition({ id: "marker", label: "Rep√®re" })))
                        : (kind && !isMarkerKind(kind) ? kind : getFirstRegularTypeId());
                    if (isMarker) {
                        ensureMarkerDefinition({ id: resolvedKind });
                    } else {
                        ensureTypeDefinition({ id: resolvedKind });
                    }
                    var newItem = {
                        id: newItemId,
                        group: groupId,
                        content: "",
                        start: baseStart,
                        kind: resolvedKind,
                        className: isMarker ? ("type-" + resolvedKind + " type-marker marker-class") : ("type-" + resolvedKind)
                    };
                    if (isMarker) {
                        newItem.type = "point";
                    } else {
                        newItem.end = computeDefaultEnd(baseStart);
                    }
                    items.add(newItem);
                    if (timeline && typeof timeline.setSelection === "function") {
                        timeline.setSelection(newItemId);
                    }
                    selectedItemId = newItemId;
                    updateSelectionButtons();
                    setTimeout(function () {
                        editItemLabel(newItemId);
                    }, 30);
                }

                timeline.on("select", function (props) {
                    var selectedId = (props.items && props.items.length) ? props.items[0] : null;
                    selectedItemId = selectedId;
                    if (selectedId) {
                        var selectedItem = items.get(selectedId);
                        var tooltipText = buildTooltipText(selectedItem);
                        if (tooltipText) {
                            var rect = getTimelineItemRect(selectedId);
                            showEditTooltip(tooltipText, rect);
                        } else {
                            hideEditTooltip();
                        }
                    } else {
                        hideEditTooltip();
                    }
                    updateSelectionButtons();
                    renderTypeSwitcherOptions();
                });

                timeline.on("itemover", function (props) {
                    if (props.item !== selectedItemId) return;
                    var item = items.get(props.item);
                    var tooltipText = buildTooltipText(item);
                    if (tooltipText) {
                        var rect = getTimelineItemRect(props.item);
                        showEditTooltip(tooltipText, rect);
                    }
                });

                timeline.on("itemout", function (props) {
                    if (props.item === selectedItemId) {
                        hideEditTooltip();
                    }
                });

                if (btnAddMilestone) {
                    btnAddMilestone.addEventListener("click", function () {
                        createAndEditTimelineItem("marker");
                    });
                }
                if (btnAddType) {
                    btnAddType.addEventListener("click", function () {
                        var label = window.prompt("Nom du nouveau type (ajoute un + √† la fin pour un rep√®re)");
                        if (label === null) return;
                        var parsed = parseKindLabelInput(label);
                        if (!parsed.id) return;
                        if (parsed.isMarker) {
                            ensureMarkerDefinition({ id: parsed.id, label: parsed.label });
                        } else {
                            ensureTypeDefinition({ id: parsed.id, label: parsed.label });
                        }
                        ensureKindFilter(parsed.id);
                        rebuildTypeStyles();
                        syncFiltersForActiveView(getVisibleViewTypeIds());
                        renderColorModalContent();
                        persistTimelineState();
                    });
                }
                if (btnRenameSelected) {
                    btnRenameSelected.addEventListener("click", function () {
                        if (!selectedItemId) return;
                        editItemLabel(selectedItemId);
                    });
                }
                if (btnAddItem) {
                    btnAddItem.addEventListener("click", function () {
                        createAndEditTimelineItem("feature");
                    });
                }

                if (itemTypeSelect) {
                    itemTypeSelect.addEventListener("change", function () {
                        applyTypeToSelectedItem(itemTypeSelect.value);
                    });
                }

                function updateSelectionButtons() {
                    var hasSelection = !!selectedItemId;
                    if (btnDeleteSelected) {
                        btnDeleteSelected.disabled = !hasSelection;
                    }
                    if (btnRenameSelected) {
                        btnRenameSelected.disabled = !hasSelection;
                    }
                }

                updateSelectionButtons();
                renderTypeSwitcherOptions();

                if (btnDeleteSelected) {
                    btnDeleteSelected.addEventListener("click", function () {
                        deleteSelectedItemWithConfirmation();
                    });
                }

                document.addEventListener("keydown", function (event) {
                    if (!selectedItemId) return;
                    var tag = (event.target && event.target.tagName) ? event.target.tagName.toLowerCase() : "";
                    if (tag === "input" || tag === "textarea" || (event.target && event.target.isContentEditable)) {
                        return;
                    }
                    if (event.key === "Delete" || event.key === "Backspace") {
                        event.preventDefault();
                        deleteSelectedItemWithConfirmation();
                    }
                });

                function deleteSelectedItemWithConfirmation() {
                    if (!selectedItemId) return;
                    var it = items.get(selectedItemId);
                    var label = (it && it.content) ? it.content : selectedItemId;
                    if (confirm("Supprimer ¬´ " + label + " ¬ª ?")) {
                        items.remove(selectedItemId);
                        selectedItemId = null;
                        updateSelectionButtons();
                        renderTypeSwitcherOptions();
                    }
                }

                // ============================================================
                // 5. Fonctions JSON <-> vis-timeline
                // ============================================================
                function isoToDate(str) {
                    if (!str) return null;
                    var value = typeof str === "string" ? str.trim() : (str + "");
                    if (!value) return null;
                    // Parse plain YYYY-MM-DD as local midnight to avoid timezone shifts
                    var dateOnlyMatch = value.match(/^(\d{4})-(\d{2})-(\d{2})$/);
                    if (dateOnlyMatch) {
                        var y = parseInt(dateOnlyMatch[1], 10);
                        var m = parseInt(dateOnlyMatch[2], 10) - 1;
                        var d = parseInt(dateOnlyMatch[3], 10);
                        var localDate = new Date(y, m, d, 0, 0, 0, 0);
                        return isNaN(localDate.getTime()) ? null : localDate;
                    }
                    var d2 = new Date(value);
                    return isNaN(d2.getTime()) ? null : d2;
                }

                function toDate(iso) {
                    var d = isoToDate(iso);
                    if (d) return d;
                    var fallback = new Date(iso);
                    return isNaN(fallback.getTime()) ? new Date() : fallback;
                }

                function daysBetween(start, end) {
                    if (!start || !end) return 0;
                    return Math.round((end.getTime() - start.getTime()) / (1000 * 60 * 60 * 24));
                }

                function dateToIso(d) {
                    if (!d) return null;
                    var local = new Date(d);
                    if (isNaN(local.getTime())) return null;
                    return (
                        local.getFullYear() +
                        "-" +
                        padTwoDigits(local.getMonth() + 1) +
                        "-" +
                        padTwoDigits(local.getDate())
                    );
                }

                function applyPlanningFromJson(planning) {
                    if (!planning) return;

                    persistenceLocked = true;
                    try {
                        applyTypeDefinitions(planning.types);
                        applyTypeDefinitions(planning.markers, { isMarker: true });
                        // groups
                        if (Array.isArray(planning.groups)) {
                            groups.clear();
                            planning.groups.forEach(function (g, idx) {
                                groups.add({
                                    id: g.id,
                                    content: g.label || g.id || ("Group " + (idx + 1))
                                });
                            });
                            // If planning included an orphan group '(sans)', ensure it is listed first
                            if (groups.get("(sans)")) {
                                ensureSansGroupFirst();
                            }
                        }

                        // items
                        if (Array.isArray(planning.items)) {
                            items.clear();
                            planning.items.forEach(function (it) {
                                var kind = sanitizeTypeId(it.type || it.kind || "feature");
                                var base = {
                                    id: it.id || ("it-" + Date.now() + Math.random()),
                                    group: it.groupId,
                                    content: it.label || "",
                                    kind: kind
                                };
                                var isMarkerItem = isMarkerKind(kind) || it.isMarker || (!!it.date && !it.end);
                                if (isMarkerItem) {
                                    ensureMarkerDefinition({ id: kind });
                                    base.start = isoToDate(it.date || it.start) || new Date();
                                    base.type = "point";
                                    base.className = "type-" + kind + " type-marker marker-class";
                                } else {
                                    ensureTypeDefinition({ id: kind });
                                    base.start = isoToDate(it.start) || new Date();
                                    var lengthDays = parseInt(it.length, 10);
                                    var inclusiveEnd = isoToDate(it.end);
                                    if (!isNaN(lengthDays) && lengthDays > 0) {
                                        base.end = new Date(base.start.getTime() + lengthDays * oneDay);
                                    } else if (inclusiveEnd) {
                                        inclusiveEnd = new Date(inclusiveEnd.getTime() + oneDay);
                                        base.end = inclusiveEnd;
                                    } else {
                                        base.end = new Date(base.start.getTime() + oneDay);
                                    }
                                    if (base.end < base.start) {
                                        base.end = new Date(base.start.getTime() + oneDay);
                                    }
                                    base.className = "type-" + base.kind;
                                }
                                // Ensure item has a valid group; if missing/invalid assign to '(sans)'
                                try {
                                    if (!base.group || !groups.get(base.group)) {
                                        base.group = "(sans)";
                                        addSansGroupIfNeeded();
                                    }
                                } catch (e) {
                                    base.group = "(sans)";
                                    addSansGroupIfNeeded();
                                }
                                items.add(base);
                            });
                        }

                        // timeline range
                        var rangeStart = planning.timeline && planning.timeline.start
                            ? isoToDate(planning.timeline.start)
                            : null;
                        var rangeEnd = planning.timeline && planning.timeline.end
                            ? isoToDate(planning.timeline.end)
                            : null;

                        if (rangeStart && rangeEnd) {
                            timeline.setWindow(rangeStart, rangeEnd, { animation: false });
                        } else {
                            timeline.fit({ animation: false });
                        }
                        syncFiltersForActiveView(getVisibleViewTypeIds());
                        updateTimelineFilter();
                    } finally {
                        persistenceLocked = false;
                    }
                    persistCurrentPlanning();
                    updateEmptyViewMessage();
                }

                function exportPlanningToJson() {
                    var g = groups.get();
                    var it = items.get();

                    var minStart = null;
                    var maxEnd = null;

                    var outGroups = g.map(function (gr) {
                        return {
                            id: gr.id,
                            label: gr.content
                        };
                    });

                    var outItems = it.map(function (item) {
                        var itemKind = item.kind || "feature";
                        if (isMarkerKind(itemKind)) {
                            if (item.start) {
                                var ds = new Date(item.start);
                                if (!minStart || ds < minStart) minStart = ds;
                                if (!maxEnd || ds > maxEnd) maxEnd = ds;
                            }
                            return {
                                id: item.id,
                                groupId: item.group,
                                label: item.content || "",
                                kind: itemKind,
                                date: dateToIso(item.start)
                            };
                        } else {
                            var ds2 = item.start ? new Date(item.start) : null;
                            var durationDays = getItemDurationInDays(item) || 1;
                            if (ds2) {
                                if (!minStart || ds2 < minStart) minStart = ds2;
                                var inclusiveEnd = new Date(ds2.getTime());
                                inclusiveEnd.setDate(inclusiveEnd.getDate() + (durationDays - 1));
                                if (!maxEnd || inclusiveEnd > maxEnd) {
                                    maxEnd = inclusiveEnd;
                                }
                            }
                            var kind = itemKind;
                            return {
                                id: item.id,
                                groupId: item.group,
                                label: item.content || "",
                                kind: kind,
                                start: dateToIso(item.start),
                                length: durationDays
                            };
                        }
                    });

                    var typeEntries = snapshotTypeDefinitions(false);
                    var markerEntries = snapshotTypeDefinitions(true);

                    var planning = {
                        timeline: {
                            start: dateToIso(minStart) || dateToIso(new Date()),
                            end: dateToIso(maxEnd) || dateToIso(new Date())
                        },
                        groups: outGroups,
                        items: outItems
                    };

                    if (typeEntries.length) {
                        planning.types = typeEntries;
                    }
                    if (markerEntries.length) {
                        planning.markers = markerEntries;
                    }

                    return planning;
                }

                // ============================================================
                // 6. Toolbar timeline
                // ============================================================
                document.getElementById("btn-today").addEventListener("click", function () {
                    var range = 4 * oneWeek;
                    var center = new Date();
                    timeline.setWindow(
                        new Date(center.getTime() - range / 2),
                        new Date(center.getTime() + range / 2),
                        { animation: true }
                    );
                });

                document.getElementById("btn-fit").addEventListener("click", function () {
                    timeline.fit({ animation: true });
                });

                document.getElementById("btn-zoom-in").addEventListener("click", function () {
                    var r = timeline.getWindow();
                    var interval = r.end - r.start;
                    var newStart = new Date(r.start.getTime() + interval * 0.25);
                    var newEnd = new Date(r.end.getTime() - interval * 0.25);
                    timeline.setWindow(newStart, newEnd, { animation: true });
                });

                document.getElementById("btn-zoom-out").addEventListener("click", function () {
                    var r = timeline.getWindow();
                    var interval = r.end - r.start;
                    var newStart = new Date(r.start.getTime() - interval * 0.5);
                    var newEnd = new Date(r.end.getTime() + interval * 0.5);
                    timeline.setWindow(newStart, newEnd, { animation: true });
                });

                function zoomTimelineByFactor(factor) {
                    if (!timeline || typeof timeline.getWindow !== "function") return;
                    var r = timeline.getWindow();
                    var interval = r.end - r.start;
                    if (interval <= 0) return;
                    var newInterval = interval * factor;
                    var center = (r.start.getTime() + r.end.getTime()) / 2;
                    var newStart = new Date(center - newInterval / 2);
                    var newEnd = new Date(center + newInterval / 2);
                    timeline.setWindow(newStart, newEnd, { animation: false });
                }

                var btnWeek = document.getElementById("btn-scale-week");
                var btnDay = document.getElementById("btn-scale-day");
                var btnMonth = document.getElementById("btn-scale-month");

                function setScale(mode) {
                    var normalized = (mode === "day" || mode === "month") ? mode : "week";
                    currentScaleMode = normalized;
                    snapMode = normalized;

                    btnWeek.classList.toggle("btn-small-active", normalized === "week");
                    btnDay.classList.toggle("btn-small-active", normalized === "day");
                    btnMonth.classList.toggle("btn-small-active", normalized === "month");

                    var timeAxis = (normalized === "day")
                        ? { scale: "day", step: 1 }
                        : (normalized === "month")
                            ? { scale: "month", step: 1 }
                            : { scale: "week", step: 1 };

                    timeline.setOptions({
                        timeAxis: timeAxis,
                        snap: options.snap
                    });
                }

                btnWeek.addEventListener("click", function () { setScale("week"); });
                btnDay.addEventListener("click", function () { setScale("day"); });
                btnMonth.addEventListener("click", function () { setScale("month"); });

                // Global wheel zoom (Ctrl/Meta + wheel anywhere) targeting the timeline
                window.addEventListener("wheel", function (event) {
                    if (!(event.ctrlKey || event.metaKey)) return; // avoid hijacking normal scroll
                    if (!timeline) return;
                    event.preventDefault();
                    event.stopPropagation();
                    var zoomFactor = event.deltaY < 0 ? 0.8 : 1.25;
                    zoomTimelineByFactor(zoomFactor);
                }, { passive: false, capture: true });

                function detectScaleFromRange(start, end) {
                    if (!start || !end) return null;
                    var diff = end.getTime() - start.getTime();
                    if (diff <= 0) return null;
                    var days = diff / oneDay;

                    var viewportWidth = container ? container.clientWidth : 0;
                    var pixelsPerDay = viewportWidth > 0 && days > 0 ? viewportWidth / days : 0;

                    // Prefer a finer scale when there is enough pixel budget per day.
                    if (pixelsPerDay >= 18) return "day";
                    if (pixelsPerDay >= 4) return "week";

                    if (days <= 7) return "day";
                    if (days <= 14) return "week";
                    return "month";
                }

                timeline.on("rangechanged", function (props) {
                    var autoMode = detectScaleFromRange(props.start, props.end);
                    if (autoMode && autoMode !== currentScaleMode) {
                        setScale(autoMode);
                    }
                });

                // ============================================================
                // 7. Panneau OpenAI
                // ============================================================
                var txtPromptCreate = document.getElementById("promptCreate");
                var txtPromptModify = document.getElementById("promptModify");
                var promptTemplateMeta = document.getElementById("promptTemplateMeta");
                var templateCriteriaStatus = {};
                var lastAnalyzedSentenceCount = 0;
                var lastAnalyzedTemplateId = null;
                var criteriaAnalysisAbortController = null;
                // Tooltip element shown under the scenario textarea on focus
                var scenarioTooltip = document.createElement('div');
                scenarioTooltip.className = 'scenario-template-tooltip';
                scenarioTooltip.style.display = 'none';
                document.body.appendChild(scenarioTooltip);
                var scenarioTooltipTimer = null;
                var btnCall = document.getElementById("btn-call");
                var clearTimelineBtn = document.getElementById("clearTimelineBtn");
                var iaTemplateEditor = document.getElementById("iaTemplateEditor");
                var resetTemplatesBtn = document.getElementById("resetTemplatesBtn");
                var SpeechRecognitionCtor = window.SpeechRecognition || window.webkitSpeechRecognition;
                var activeSpeechRecognition = null;
                var activeSpeechButton = null;
                var activeSpeechWrapper = null;
                var activeSpeechField = null;
                var lastSpeechInterim = "";

                function escapeHtml(value) {
                    return String(value || "")
                        .replace(/&/g, "&amp;")
                        .replace(/</g, "&lt;")
                        .replace(/>/g, "&gt;")
                        .replace(/"/g, "&quot;")
                        .replace(/'/g, "&#39;");
                }

                function appendSpeechText(field, transcript) {
                    if (!field || !transcript) {
                        return;
                    }
                    var normalized = transcript.trim();
                    if (!normalized) {
                        return;
                    }
                    var separator = field.value ? (/\s$/.test(field.value) ? "" : " ") : "";
                    field.value = field.value + (field.value ? separator : "") + normalized;
                    field.dispatchEvent(new Event("input", { bubbles: true }));
                    clearSpeechSuggestion(field);
                }

                function getSpeechSuggestionElement(field) {
                    if (!field) {
                        return null;
                    }
                    return document.querySelector('[data-speech-suggestion="' + field.id + '"]');
                }

                function updateSpeechSuggestion(field, partial) {
                    var suggestionEl = getSpeechSuggestionElement(field);
                    if (!suggestionEl) {
                        return;
                    }
                    if (!partial) {
                        suggestionEl.classList.remove("visible");
                        suggestionEl.innerHTML = "";
                        return;
                    }
                    var safeCurrent = escapeHtml(field.value);
                    var safePartial = escapeHtml(partial);
                    suggestionEl.innerHTML =
                        '<span class="speech-suggestion-current">' + safeCurrent + '</span>' +
                        '<span class="speech-suggestion-partial">' + safePartial + '</span>';
                    suggestionEl.classList.add("visible");
                    if (field === activeSpeechField) {
                        lastSpeechInterim = partial || "";
                    }
                    // hide placeholder while interim speech suggestion is visible
                    try {
                        if (field && field.setAttribute) {
                            var existing = field.getAttribute('placeholder') || '';
                            if (existing) field.setAttribute('data-original-placeholder', existing);
                            field.setAttribute('placeholder', '');
                        }
                    } catch (e) { /* noop */ }
                }

                function clearSpeechSuggestion(field) {
                    updateSpeechSuggestion(field, "");
                    if (field === activeSpeechField) {
                        lastSpeechInterim = "";
                    }
                    // restore placeholder if it was hidden for speech
                    try {
                        if (field && field.setAttribute) {
                            var saved = field.getAttribute('data-original-placeholder');
                            if (saved !== null) {
                                field.setAttribute('placeholder', saved || '');
                                field.removeAttribute('data-original-placeholder');
                            }
                        }
                    } catch (e) { /* noop */ }
                }

                function deactivateSpeechUiClasses() {
                    if (activeSpeechButton) {
                        activeSpeechButton.classList.remove("speech-button--active");
                        activeSpeechButton = null;
                    }
                    if (activeSpeechWrapper) {
                        activeSpeechWrapper.classList.remove("speech-active");
                        activeSpeechWrapper = null;
                    }
                }

                function stopActiveSpeechSession(options) {
                    options = options || {};
                    var flushInterim = Boolean(options.flushInterim);
                    var skipAbort = Boolean(options.skipAbort);
                    var field = activeSpeechField;
                    if (flushInterim && field && lastSpeechInterim) {
                        appendSpeechText(field, lastSpeechInterim);
                    }
                    lastSpeechInterim = "";
                    if (activeSpeechRecognition) {
                        if (!skipAbort) {
                            activeSpeechRecognition.abort();
                        }
                        activeSpeechRecognition = null;
                    }
                    deactivateSpeechUiClasses();
                    if (field) {
                        clearSpeechSuggestion(field);
                    }
                    if (txtPromptCreate) {
                        clearSpeechSuggestion(txtPromptCreate);
                    }
                    // Hide scenario tooltip when speech recognition ends
                    try {
                        if (typeof hideScenarioTooltip === 'function') hideScenarioTooltip();
                    } catch (e) { /* noop */ }

                    activeSpeechField = null;
                }

                function startSpeechRecognition(field, button) {
                    if (!SpeechRecognitionCtor) {
                        alert("Reconnaissance vocale non disponible dans ce navigateur.");
                        return;
                    }
                    if (!field) {
                        return;
                    }
                    if (activeSpeechButton === button) {
                        stopActiveSpeechSession();
                        return;
                    }
                    stopActiveSpeechSession();
                    var recognition = new SpeechRecognitionCtor();
                    recognition.lang = "fr-FR";
                    recognition.interimResults = true;
                    recognition.maxAlternatives = 1;
                    recognition.continuous = true;
                    var wrapper = button && typeof button.closest === "function" ? button.closest(".speech-field-wrapper") : null;
                    recognition.addEventListener("start", function () {
                        if (button) button.classList.add("speech-button--active");
                        activeSpeechRecognition = recognition;
                        activeSpeechButton = button;
                        activeSpeechField = field;
                        lastSpeechInterim = "";
                        field.focus();
                        clearSpeechSuggestion(field);
                        if (wrapper) {
                            wrapper.classList.add("speech-active");
                            activeSpeechWrapper = wrapper;
                        }
                    });
                    recognition.addEventListener("result", function (event) {
                        var interimText = "";
                        for (var i = event.resultIndex; i < event.results.length; i++) {
                            var result = event.results[i];
                            var transcript = (result[0] && result[0].transcript ? result[0].transcript : "").trim();
                            if (!transcript) continue;
                            if (result.isFinal) {
                                appendSpeechText(field, transcript);
                            } else {
                                interimText += (interimText ? " " : "") + transcript;
                            }
                        }
                        if (interimText) {
                            updateSpeechSuggestion(field, interimText);
                        } else {
                            var lastResult = event.results[event.results.length - 1];
                            if (lastResult && !lastResult.isFinal) {
                                clearSpeechSuggestion(field);
                            }
                        }
                    });
                    recognition.addEventListener("error", function () {
                        console.warn("Speech recognition error");
                        clearSpeechSuggestion(field);
                        stopActiveSpeechSession();
                    });
                    recognition.addEventListener("end", function () {
                        if (activeSpeechRecognition === recognition) {
                            stopActiveSpeechSession({ skipAbort: true });
                        }
                    });
                    try {
                        recognition.start();
                    } catch (err) {
                        console.error("Speech recognition start failed", err);
                        alert("Impossible de d√©marrer la dict√©e vocale.");
                    }
                }

                document.addEventListener("click", function (event) {
                    var targetButton =
                        event && event.target && typeof event.target.closest === "function"
                            ? event.target.closest(".speech-button")
                            : null;
                    if (!targetButton) {
                        return;
                    }
                    event.preventDefault();
                    var targetId = targetButton.getAttribute("data-speech-target");
                    var field = targetId ? document.getElementById(targetId) : null;
                    if (field) {
                        startSpeechRecognition(field, targetButton);
                    }
                });

                const SPEECH_MODE_STORAGE_KEY = "go-toolkit-speech-mode";

                function getSpeechModePreference() {
                    if (typeof window === "undefined" || typeof window.localStorage === "undefined") {
                        return "manual";
                    }
                    try {
                        const stored = window.localStorage.getItem(SPEECH_MODE_STORAGE_KEY);
                        return stored === "auto" ? "auto" : "manual";
                    } catch (error) {
                        return "manual";
                    }
                }

                function isSpeechAutoEnabled() {
                    return getSpeechModePreference() === "auto";
                }

                function maybeAutoStartSpeechForField(fieldId) {
                    if (!SpeechRecognitionCtor) {
                        return;
                    }
                    var field = document.getElementById(fieldId);
                    if (!field || field.value.trim()) {
                        return;
                    }
                    var button = document.querySelector('[data-speech-target="' + fieldId + '"]');
                    if (!button) {
                        return;
                    }
                    startSpeechRecognition(field, button);
                }

                function initAutoSpeechOnTimelineLoad() {
                    if (!isSpeechAutoEnabled()) return;
                    maybeAutoStartSpeechForField("promptCreate");
                }

                if (document.readyState === "loading") {
                    document.addEventListener("DOMContentLoaded", initAutoSpeechOnTimelineLoad);
                } else {
                    initAutoSpeechOnTimelineLoad();
                }

                function isSpeechTypingKey(event) {
                    if (!event || !event.key) return false;
                    if (event.metaKey || event.ctrlKey || event.altKey) return false;
                    var key = event.key;
                    if (key.length === 1) return true;
                    return key === "Backspace" || key === "Delete" || key === "Enter";
                }

                function handleSpeechKeydown(event) {
                    if (!activeSpeechRecognition || !activeSpeechField) return;
                    if (event.target !== activeSpeechField) return;
                    if (!isSpeechTypingKey(event)) return;
                    stopActiveSpeechSession({ flushInterim: true });
                }
                document.addEventListener("keydown", handleSpeechKeydown, true);

                function getTemplateById(id) {
                    if (!id) return null;
                    return ROADMAP_PROMPTS.find(function (tpl) { return tpl.id === id; }) || null;
                }

                function updatePromptTemplateMeta() {
                    if (!promptTemplateMeta) return;
                    var ctx = getActiveViewContext();
                    var currentId = (ctx && typeof ctx.templateId === "string" && ctx.templateId.trim()) ? ctx.templateId.trim() : (selectedRoadmapPromptId || "");
                    var tpl = getTemplateById(currentId);
                    var label = tpl ? tpl.title : "‚Äî";
                    promptTemplateMeta.textContent = "Mod√®le : " + label;
                    renderScenarioTooltip(tpl, tpl && tpl.id ? templateCriteriaStatus[tpl.id] : null);
                    if (document.activeElement === txtPromptCreate) {
                        showScenarioTooltip(txtPromptCreate);
                    }
                    if (txtPromptCreate) {
                        txtPromptCreate.title = "";
                    }
                    triggerScenarioCriteriaAnalysis({ force: true });
                }

                function positionScenarioTooltipForTextarea(textarea) {
                    if (!textarea || !scenarioTooltip) return;
                    var rect = textarea.getBoundingClientRect();
                    scenarioTooltip.dataset.targetLeft = (rect.left + window.scrollX).toString();
                    scenarioTooltip.dataset.targetTop = (rect.top + window.scrollY).toString();
                    scenarioTooltip.dataset.targetHeight = rect.height.toString();
                    var maxW = Math.min(rect.width, 420);
                    scenarioTooltip.style.maxWidth = maxW + 'px';
                }

                function showScenarioTooltip(textarea) {
                    if (!textarea || !scenarioTooltip) return;
                    var tooltipText = (scenarioTooltip.textContent || "").trim();
                    if (!tooltipText || scenarioTooltip.getAttribute("aria-hidden") === "true") {
                        hideScenarioTooltip();
                        return;
                    }
                    positionScenarioTooltipForTextarea(textarea);
                    scenarioTooltip.style.display = 'block';
                    scenarioTooltip.style.transform = 'translateX(8px)';
                    requestAnimationFrame(function () {
                        var tipRect = scenarioTooltip.getBoundingClientRect();
                        var baseLeft = parseFloat(scenarioTooltip.dataset.targetLeft || '0') || 0;
                        var baseTop = parseFloat(scenarioTooltip.dataset.targetTop || '0') || 0;
                        var targetHeight = parseFloat(scenarioTooltip.dataset.targetHeight || '0') || 0;
                        var gap = 10;
                        var maxLeft = Math.max(gap, window.innerWidth - tipRect.width - gap);
                        var left = Math.min(maxLeft, Math.max(gap, baseLeft));
                        var maxTop = Math.max(gap, window.innerHeight - tipRect.height - gap);
                        var topCandidate = baseTop + targetHeight + gap;
                        var top = Math.min(maxTop, Math.max(gap, topCandidate));
                        scenarioTooltip.style.left = left + 'px';
                        scenarioTooltip.style.top = top + 'px';
                        scenarioTooltip.classList.add('visible');
                        scenarioTooltip.style.transform = 'translateY(0)';
                    });
                    // reset timer
                    if (scenarioTooltipTimer) {
                        clearTimeout(scenarioTooltipTimer);
                    }
                    scenarioTooltipTimer = setTimeout(function () {
                        hideScenarioTooltip();
                    }, 5000);
                }

                function hideScenarioTooltip() {
                    if (scenarioTooltipTimer) {
                        clearTimeout(scenarioTooltipTimer);
                        scenarioTooltipTimer = null;
                    }
                    scenarioTooltip.classList.remove('visible');
                    // allow transition then hide
                    setTimeout(function () {
                        scenarioTooltip.style.display = 'none';
                    }, 140);
                }

                function renderScenarioTooltip(template, statusMap) {
                    if (!scenarioTooltip) return;
                    const lines = GoToolkitTemplateCriteria.renderTooltipLines(template, statusMap);
                    if (lines.length) {
                        scenarioTooltip.innerHTML = lines.join("<br>");
                        scenarioTooltip.setAttribute("aria-hidden", "false");
                        return;
                    }
                    const fallback = template ? template.text || template.description || "" : "";
                    scenarioTooltip.textContent = fallback;
                    scenarioTooltip.setAttribute("aria-hidden", fallback ? "false" : "true");
                }

                async function analyzeScenarioCriteria(text, template) {
                    if (!template || !template.id) return;
                    if (criteriaAnalysisAbortController) {
                        try { criteriaAnalysisAbortController.abort(); } catch (e) { /* noop */ }
                    }
                    const controller = new AbortController();
                    criteriaAnalysisAbortController = controller;
                    const storedKey = (iaApiKeyInput?.value || "").trim() || readSharedTimelineApiKey();
                    const useProxy = !storedKey;
                    const endpoint = useProxy ? OPENAI_PROXY_URL : GoToolkitTemplateCriteria.DEFAULT_DIRECT_ENDPOINT;
                    try {
                        const normalized = await GoToolkitTemplateCriteria.analyzeCriteria({
                            text,
                            template,
                            apiKey: useProxy ? "" : storedKey,
                            endpoint,
                            signal: controller.signal,
                            model: "gpt-5-nano"
                        });
                        templateCriteriaStatus[template.id] = normalized;
                        renderScenarioTooltip(template, normalized);
                    } catch (err) {
                        if (err?.name === "AbortError") return;
                        console.warn("Analyse des crit√®res impossible", err);
                    } finally {
                        if (criteriaAnalysisAbortController === controller) {
                            criteriaAnalysisAbortController = null;
                        }
                    }
                }

                function triggerScenarioCriteriaAnalysis(options) {
                    var force = options && options.force;
                    var template = getTemplateById(selectedRoadmapPromptId || "");
                    var templateId = template?.id || null;
                    if (templateId && !templateCriteriaStatus[templateId]) {
                        templateCriteriaStatus[templateId] = {};
                    }
                    if (templateId !== lastAnalyzedTemplateId) {
                        lastAnalyzedSentenceCount = 0;
                        lastAnalyzedTemplateId = templateId;
                    }
                    var status = templateId ? templateCriteriaStatus[templateId] : null;
                    renderScenarioTooltip(template, status);
                    if (!txtPromptCreate) return;
                    var text = txtPromptCreate.value || "";
                    var trimmed = text.trim();
                    var criteria = GoToolkitTemplateCriteria.getTemplateCriteria(template);
                    if (!trimmed || !criteria.length) {
                        lastAnalyzedSentenceCount = GoToolkitTemplateCriteria.countCompletedSentences(text);
                        if (templateId) {
                            templateCriteriaStatus[templateId] = {};
                            renderScenarioTooltip(template, templateCriteriaStatus[templateId]);
                        }
                        if (criteriaAnalysisAbortController) {
                            try { criteriaAnalysisAbortController.abort(); } catch (e) { /* noop */ }
                            criteriaAnalysisAbortController = null;
                        }
                        return;
                    }
                    var sentenceCount = GoToolkitTemplateCriteria.countCompletedSentences(text);
                    if (!force && sentenceCount === lastAnalyzedSentenceCount) {
                        return;
                    }
                    lastAnalyzedSentenceCount = sentenceCount;
                    analyzeScenarioCriteria(trimmed, template);
                }

                function setSelectedTemplateId(id, options) {
                    selectedRoadmapPromptId = id || null;
                    var ctx = getActiveViewContext();
                    if (ctx) {
                        ctx.templateId = selectedRoadmapPromptId;
                        var tplMeta = getTemplateById(selectedRoadmapPromptId || "");
                        ctx.templateName = tplMeta?.title || tplMeta?.label || selectedRoadmapPromptId || null;
                    }
                    updatePromptTemplateMeta();
                    if (!options || !options.skipPersist) {
                        persistTimelineState();
                    }
                }

                function ensureModifyPrompt(options) {
                    var context = getActiveViewContext();
                    context.prompts = context.prompts || {};
                    // If la timeline est vide, le script reste vide.
                    if (!hasTimelineData()) {
                        context.prompts.modify = "";
                        if (txtPromptModify) {
                            txtPromptModify.value = "";
                        }
                        if (!options || !options.skipPersist) {
                            persistTimelineState();
                        }
                        return;
                    }
                    var shouldRefresh = options && options.refreshModify;
                    var hasExisting = typeof context.prompts.modify === "string" && context.prompts.modify.trim() !== "";
                    if ((shouldRefresh && !hasExisting) || context.prompts.modify === undefined || context.prompts.modify === null) {
                        context.prompts.modify = getModifyPromptContent();
                    }
                    if (txtPromptModify) {
                        txtPromptModify.value = context.prompts.modify || "";
                    }
                    if (!options || !options.skipPersist) {
                        persistTimelineState();
                    }
                }

                // Show tooltip under the Sc√©nario textarea on focus; hide after 5s inactivity.
                if (txtPromptCreate) {
                    txtPromptCreate.addEventListener('focus', function () {
                        var tpl = getTemplateById(selectedRoadmapPromptId || "");
                        renderScenarioTooltip(tpl, tpl && tpl.id ? templateCriteriaStatus[tpl.id] : null);
                        showScenarioTooltip(txtPromptCreate);
                    });
                    txtPromptCreate.addEventListener('input', function () {
                        hideScenarioTooltip();
                        clearSpeechSuggestion(txtPromptCreate);
                        triggerScenarioCriteriaAnalysis();
                    });
                    txtPromptCreate.addEventListener('keydown', function () {
                        hideScenarioTooltip();
                    });
                    txtPromptCreate.addEventListener('blur', function () {
                        hideScenarioTooltip();
                    });
                }

                function syncContextFieldsFromState(options) {
                    var context = getActiveViewContext();
                    if (context && typeof context.templateId === "string") {
                        selectedRoadmapPromptId = context.templateId || null;
                    }
                    var isEmptyTimeline = !hasTimelineData();
                    if (isEmptyTimeline) {
                        if (context.prompts) {
                            context.prompts.create = "";
                            context.prompts.modify = "";
                        }
                        if (txtPromptCreate) txtPromptCreate.value = "";
                        if (txtPromptModify) txtPromptModify.value = "";
                    }
                    if (txtPromptCreate) {
                        if (!isEmptyTimeline && context.prompts && typeof context.prompts.create === "string" && context.prompts.create.trim() !== "") {
                            txtPromptCreate.value = context.prompts.create;
                        } else {
                            txtPromptCreate.value = "";
                            if (context.prompts) context.prompts.create = "";
                        }
                    }
                    ensureModifyPrompt({
                        refreshModify: options && options.refreshModify,
                        skipPersist: true
                    });
                    updatePromptTemplateMeta();
                    if (!options || !options.skipPersist) {
                        persistTimelineState();
                    }
                }

                function persistActiveContext(updateFn) {
                    var context = getActiveViewContext();
                    if (typeof updateFn === "function") {
                        updateFn(context);
                    }
                    persistedTimelineBrief = context.prompts.create || context.prompts.modify || "";
                    persistTimelineState();
                }

                syncContextFieldsFromState({ skipPersist: true, refreshModify: true });
                contextUiReady = true;

                (function ensureGutenbergDefaultVisibility() {
                    var el = document.getElementById("gtContextModal");
                    if (!el) return;
                    var isDrawer = false;
                    try {
                        isDrawer = window.matchMedia && window.matchMedia("(max-width: 900px)").matches;
                    } catch (e) {
                        isDrawer = (window.innerWidth || 0) <= 900;
                    }
                    // Keep Gutenberg/context modal closed by default on first load
                    el.classList.remove("open");
                    el.setAttribute("aria-hidden", "true");
                })();

                if (shouldOpenContextOnFirstLoad && !hasTimelineData()) {
                    // Do not auto-open Gutenberg at first load ‚Äî open the Prompt modal instead
                    if (typeof openRoadmapPromptModal === "function") {
                        openRoadmapPromptModal();
                        initialPromptModalOpened = true;
                    } else if (typeof openContextModal === "function") {
                        // fallback
                        openContextModal({ mode: "create" });
                    }
                }

                if (!initialPromptModalOpened) {
                    maybeAutoOpenContextModal();
                }

                if (txtPromptCreate) {
                    txtPromptCreate.addEventListener("input", function () {
                        persistActiveContext(function (ctx) {
                            ctx.prompts.create = txtPromptCreate.value || "";
                        });
                    });
                }
                if (txtPromptModify) {
                    txtPromptModify.addEventListener("input", function () {
                        persistActiveContext(function (ctx) {
                            ctx.prompts.modify = txtPromptModify.value || "";
                        });
                    });
                    // Refresh modify prompt content when user clicks the script textarea
                    txtPromptModify.addEventListener("click", function () {
                        try {
                            ensureModifyPrompt({ refreshModify: true });
                        } catch (e) { }
                    });

                    // On focus, export the latest planning as JSON into the script textarea
                    txtPromptModify.addEventListener("focus", function () {
                        try {
                            persistCurrentPlanning();
                            var currentView = views && views[activeViewIndex] ? views[activeViewIndex] : null;
                            var planning = exportPlanningToJson();
                            var viewTitle = currentView && (currentView.title || currentView.name);
                            var jsonText = buildPlanningJsonString(planning, viewTitle);
                            if (txtPromptModify) {
                                txtPromptModify.value = jsonText || "";
                                persistActiveContext(function (ctx) {
                                    ctx.prompts = ctx.prompts || {};
                                    ctx.prompts.modify = txtPromptModify.value || "";
                                });
                            }
                        } catch (e) {
                            console.warn("Erreur lors de la g√©n√©ration du JSON pour le script", e);
                        }
                    });
                    txtPromptModify.addEventListener("blur", function () {
                        try {
                            var text = txtPromptModify.value || "";
                            if (!text.trim()) return;
                            var previousRange = null;
                            try {
                                if (timeline && typeof timeline.getWindow === "function") {
                                    var w = timeline.getWindow();
                                    if (w && w.start && w.end) {
                                        previousRange = { start: new Date(w.start), end: new Date(w.end) };
                                    }
                                }
                            } catch (e) { /* noop */ }
                            var parsed = JSON.parse(text);
                            if (parsed && typeof parsed === "object") {
                                applyPlanningFromJson(parsed);
                                persistActiveContext(function (ctx) {
                                    ctx.prompts.modify = txtPromptModify.value || "";
                                });
                                if (previousRange && timeline && typeof timeline.setWindow === "function") {
                                    try {
                                        timeline.setWindow(previousRange.start, previousRange.end, { animation: false });
                                    } catch (e) { /* noop */ }
                                }
                            }
                        } catch (e) {
                            console.warn("JSON invalide dans le script, aucune mise √† jour de la timeline", e);
                        }
                    });
                }

                function getSystemTemplate() {
                    return customSystemTemplates.create || CREATE_SYSTEM_TEMPLATE;
                }

                function resetSystemTemplates() {
                    customSystemTemplates.create = CREATE_SYSTEM_TEMPLATE;
                    syncTemplateEditor();
                }

                function persistTemplateChange(value) {
                    customSystemTemplates.create = value || getSystemTemplate();
                    persistTimelineState();
                }

                function syncTemplateEditor() {
                    if (iaTemplateEditor) {
                        iaTemplateEditor.value = getSystemTemplate();
                    }
                }

                if (resetTemplatesBtn) {
                    resetTemplatesBtn.addEventListener("click", function () {
                        resetSystemTemplates();
                    });
                }

                syncTemplateEditor();

                var IA_API_KEY_STORAGE_KEY = "go-toolkit-api-key";
                var iaApiKeyInput = document.getElementById("iaApiKeyInput");
                var reasoningEffortSelect = document.getElementById("reasoningEffortSelect");
                var REASONING_EFFORT_KEY = "plan-reasoning-effort";
                var REASONING_EFFORTS = ["minimal", "low", "medium", "high"];
                var OPENAI_MESSAGE_MAX_CHARS = 3000;

                function buildChunkedPayloadMessages(jsonText) {
                    if (!jsonText) {
                        return [{ role: "user", content: "" }];
                    }
                    if (jsonText.length <= OPENAI_MESSAGE_MAX_CHARS) {
                        return [{ role: "user", content: jsonText }];
                    }
                    var parts = [];
                    for (var i = 0; i < jsonText.length; i += OPENAI_MESSAGE_MAX_CHARS) {
                        parts.push(jsonText.slice(i, i + OPENAI_MESSAGE_MAX_CHARS));
                    }
                    var total = parts.length;
                    return parts.map(function (chunk, index) {
                        var header = "Partie " + (index + 1) + " / " + total + " du JSON du planning actuel.\n";
                        var footer = index === total - 1 ? "\n(Fin du JSON de planning.)" : "";
                        return { role: "user", content: header + chunk + footer };
                    });
                }

                function readSharedTimelineApiKey() {
                    if (window.GoToolkitIAConfig) {
                        return window.GoToolkitIAConfig.getApiKey();
                    }
                    if (typeof window === "undefined" || !window.localStorage) {
                        return "";
                    }
                    try {
                        return localStorage.getItem(IA_API_KEY_STORAGE_KEY) || "";
                    } catch (err) {
                        console.warn("Impossible de lire la cl√© OpenAI stock√©e localement", err);
                        return "";
                    }
                }

                function persistSharedTimelineApiKey(value) {
                    if (window.GoToolkitIAConfig) {
                        window.GoToolkitIAConfig.setApiKey(value);
                        return;
                    }
                    if (typeof window === "undefined" || !window.localStorage) {
                        return;
                    }
                    try {
                        if (value) {
                            localStorage.setItem(IA_API_KEY_STORAGE_KEY, value);
                        } else {
                            localStorage.removeItem(IA_API_KEY_STORAGE_KEY);
                        }
                    } catch (err) {
                        console.warn("Impossible de sauvegarder la cl√© OpenAI localement", err);
                    }
                }

                var storedApiKey = readSharedTimelineApiKey();
                if (iaApiKeyInput && storedApiKey) {
                    iaApiKeyInput.value = storedApiKey;
                }

                (function initializeReasoningEffort() {
                    if (!reasoningEffortSelect) return;
                    var stored = localStorage.getItem(REASONING_EFFORT_KEY) || "low";
                    if (REASONING_EFFORTS.indexOf(stored) === -1) {
                        stored = "low";
                    }
                    reasoningEffortSelect.value = stored;
                    reasoningEffortSelect.addEventListener("change", function () {
                        var value = reasoningEffortSelect.value;
                        if (REASONING_EFFORTS.indexOf(value) !== -1) {
                            localStorage.setItem(REASONING_EFFORT_KEY, value);
                        }
                    });
                })();

                if (iaApiKeyInput) {
                    iaApiKeyInput.addEventListener("input", function () {
                        persistSharedTimelineApiKey(iaApiKeyInput.value.trim());
                    });
                }
                var waitingTimerId = null;
                var waitingCounter = 60;
                var activeIaAbortController = null;
                var iaModalButtonDefaultLabel = iaModalButton
                    ? iaModalButton.textContent.trim()
                    : "‚åò";
                var EMPTY_MODIFY_PROMPT_TEXT = "";

                function hasTimelineData() {
                    if (!items || typeof items.get !== "function") {
                        return false;
                    }
                    return items.get().length > 0;
                }

                function getModifyPromptContent() {
                    persistCurrentPlanning();
                    var currentView = views[activeViewIndex];
                    var planning = exportPlanningToJson();
                    var title =
                        currentView && (currentView.title || currentView.name)
                            ? currentView.title || currentView.name
                            : "";
                    if (!planning.page && title) {
                        planning.page = title;
                    }
                    // Ensure page is first in the object for readability
                    var reordered = {};
                    if (planning.page) reordered.page = planning.page;
                    Object.keys(planning).forEach(function (key) {
                        if (key === "page") return;
                        reordered[key] = planning[key];
                    });
                    return buildPlanningJsonString(reordered, title);
                }

                function determineGenerationMode() {
                    var scriptText = (txtPromptModify && txtPromptModify.value ? txtPromptModify.value.trim() : "");
                    return scriptText ? "modify" : "create";
                }

                var waitingTarget = null;
                var waitingTargetOriginalLabel = null;

                function updateIaButtonLabel(isLoading, counter, targetEl) {
                    var displayCounter = typeof counter === "number" ? counter : waitingCounter;
                    if (targetEl) {
                        try {
                            const frames = ["‚ó¥", "‚ó∑", "‚ó∂", "‚óµ"];
                            const frame = frames[displayCounter % frames.length];
                            targetEl.textContent = frame + " " + displayCounter + "s";
                        } catch (e) { }
                        return;
                    }
                    if (!iaModalButton) return;
                    if (isLoading) {
                        const frames = ["‚ó¥", "‚ó∑", "‚ó∂", "‚óµ"];
                        const frame = frames[displayCounter % frames.length];
                        iaModalButton.textContent = frame + " Attente " + displayCounter + "s";
                    } else {
                        iaModalButton.textContent = iaModalButtonDefaultLabel;
                    }
                }

                function stopWaitingTimer() {
                    if (waitingTimerId) {
                        clearInterval(waitingTimerId);
                        waitingTimerId = null;
                    }
                    if (waitingTarget) {
                        try {
                            waitingTarget.textContent = waitingTargetOriginalLabel || "";
                        } catch (e) { }
                        waitingTarget = null;
                        waitingTargetOriginalLabel = null;
                    } else {
                        updateIaButtonLabel(false);
                    }
                    setEmptyStateLoading(false);
                }

                function startWaitingTimer(targetEl) {
                    stopWaitingTimer();
                    waitingCounter = 30;
                    if (targetEl) {
                        waitingTarget = targetEl;
                        try {
                            waitingTargetOriginalLabel = waitingTarget.textContent;
                        } catch (e) {
                            waitingTargetOriginalLabel = null;
                        }
                        updateIaButtonLabel(true, waitingCounter, waitingTarget);
                    } else {
                        updateIaButtonLabel(true, waitingCounter);
                    }
                    setEmptyStateLoading(true, waitingCounter);
                    waitingTimerId = setInterval(function () {
                        waitingCounter--;
                        if (waitingCounter < 0) {
                            waitingCounter = 30;
                        }
                        if (waitingTarget) {
                            updateIaButtonLabel(true, waitingCounter, waitingTarget);
                        } else {
                            updateIaButtonLabel(true, waitingCounter);
                        }
                        setEmptyStateLoading(true, waitingCounter);
                    }, 1000);
                }

                function fillPromptTemplate(template, instructions, existingData, mode) {
                    var text = template || "";
                    var INLINE_JSON_LIMIT = 2000;
                    var inlinePlanning = "";
                    if (existingData && existingData.length <= INLINE_JSON_LIMIT) {
                        inlinePlanning = existingData;
                    } else if (existingData) {
                        inlinePlanning = "(JSON/script complet fourni dans le champ existingData du payload utilisateur)";
                    }
                    // Replace explicit placeholders with the appropriate textarea contents
                    try {
                        if (text.indexOf("{{contenu_script}}") >= 0) {
                            var createContent = txtPromptCreate && txtPromptCreate.value ? txtPromptCreate.value : "";
                            if (createContent.length > INLINE_JSON_LIMIT) {
                                createContent = createContent.slice(0, INLINE_JSON_LIMIT) + "... (texte complet fourni dans le champ prompt du payload utilisateur)";
                            }
                            text = text.replace(/\{\{contenu_script\}\}/g, createContent);
                        }
                        if (text.indexOf("{{contenu_recit}}") >= 0) {
                            var modifyContent = txtPromptModify && txtPromptModify.value ? txtPromptModify.value : "";
                            if (modifyContent.length > INLINE_JSON_LIMIT) {
                                modifyContent = modifyContent.slice(0, INLINE_JSON_LIMIT) + "... (texte complet fourni dans le champ existingData du payload utilisateur)";
                            }
                            text = text.replace(/\{\{contenu_recit\}\}/g, modifyContent);
                        }
                        // Backwards compatibility: replace old generic placeholder
                        if (text.indexOf("{{(contenu du id=\"prompt\") }}") >= 0) {
                            text = text.replace("{{(contenu du id=\"prompt\") }}", instructions || "");
                        }
                    } catch (e) {
                        console.warn("Erreur lors du remplissage du template", e);
                    }

                    var placeholder = "{{(contenu au format JSON du planning existant)}}";
                    if (text.indexOf(placeholder) >= 0) {
                        var planningContent = inlinePlanning || "(aucun planning existant)";
                        text = text.replace(placeholder, planningContent);
                    }
                    return text;
                }

                // Centralized generator used by both buttons
                async function generateFromMode(triggerButton, mode) {
                    if (activeIaAbortController) {
                        try { activeIaAbortController.abort(); } catch (e) { }
                        activeIaAbortController = null;
                        stopWaitingTimer();
                        if (triggerButton) triggerButton.disabled = false;
                        try { showCopyToast("Requ√™te IA annul√©e."); } catch (e) { }
                        return;
                    }
                    stopActiveSpeechSession({ flushInterim: true });
                    if (!triggerButton) triggerButton = null;
                    if (mode === "modify") {
                        ensureModifyPrompt({ refreshModify: true });
                    }
                    var promptField = txtPromptCreate;
                    var promptText = (promptField && promptField.value ? promptField.value.trim() : "");

                    if (!promptText) {
                        alert("Ajoute un prompt avant d'appeler OpenAI üôÇ");
                        promptField && promptField.focus();
                        return;
                    }

                    var systemContent = fillPromptTemplate(
                        getSystemTemplate(),
                        promptText,
                        trimmedScript || "",
                        mode
                    );

                    var scriptContent = txtPromptModify ? (txtPromptModify.value || "") : "";
                    var trimmedScript = scriptContent.trim();
                    var payload = {
                        schema: "planning-v1",
                        mode: mode,
                        prompt: promptText,
                        script: trimmedScript
                    };
                    var trimmedExisting = trimmedScript;
                    if (trimmedExisting) {
                        payload.existingData = trimmedExisting;
                    }

                    var payloadText = JSON.stringify(payload);
                    var payloadMessages = buildChunkedPayloadMessages(payloadText);
                    var messages = [{ role: "system", content: systemContent }].concat(payloadMessages);

                    var controller = new AbortController();
                    activeIaAbortController = controller;
                    lastTimelineGenerationAt = Date.now();
                    startWaitingTimer(triggerButton);
                    closeIaModal();
                    try {
                        var aiResponse = await callOpenAI(messages, controller);
                        if (!aiResponse) return;
                        var normalized = aiResponse.trim();
                        if (txtPromptModify) {
                            txtPromptModify.value = normalized;
                            persistActiveContext(function (ctx) {
                                ctx.prompts.modify = normalized;
                            });
                        }

                        var planning = null;
                        // Try parse as JSON first
                        try {
                            planning = JSON.parse(normalized);
                        } catch (err) {
                            // If modify mode, try to parse a human-readable script into planning
                            if (mode === "modify") {
                                try {
                                    var parsed = parseScriptToPlanning(normalized);
                                    if (parsed) {
                                        planning = parsed;
                                    } else {
                                        throw new Error("Parsing script failed");
                                    }
                                } catch (err2) {
                                    console.error("Impossible de parser la r√©ponse IA en JSON ou script structur√©", err2);
                                    alert(err2 && err2.message ? err2.message : "R√©ponse IA invalide : JSON attendu ou script structur√©.");
                                    return;
                                }
                            } else {
                                console.error("JSON OpenAI invalide", err);
                                alert("R√©ponse OpenAI invalide : JSON attendu.");
                                return;
                            }
                        }

                        try {
                            if (planning) {
                                lastAiPlanningJson = JSON.stringify(planning, null, 2);
                            }
                        } catch (e) {
                            lastAiPlanningJson = null;
                        }

                        if (planning && typeof planning.page === "string") {
                            var pageTitle = planning.page.trim();
                            if (pageTitle) {
                                var currentView = views[activeViewIndex];
                                if (currentView) {
                                    currentView.title = pageTitle;
                                    refreshHeaderText();
                                    persistTimelineState();
                                }
                            }
                        }

                        applyPlanningFromJson(planning);
                    } finally {
                        stopWaitingTimer();
                        activeIaAbortController = null;
                    }
                }

                // Parse a human-readable script (as produced by buildTextExport) into a planning object.
                function parseScriptToPlanning(text) {
                    if (!text || !text.toString) return null;
                    var raw = text.toString().replace(/\r\n/g, "\n").replace(/\r/g, "\n");
                    var lines = raw.split(/\n/).map(function (l) { return (l || "").trim(); });
                    // Remove leading/trailing empty lines
                    while (lines.length && lines[0] === "") lines.shift();
                    while (lines.length && lines[lines.length - 1] === "") lines.pop();

                    var planning = { page: "", timeline: {}, groups: [], types: [], markers: [], items: [] };
                    var groupsMap = {};
                    var groupOrder = [];
                    var typesMap = {};
                    var typeOrder = [];
                    var markersMap = {};
                    var markerOrder = [];
                    var hasDeclaredGroups = false;
                    var hasDeclaredTypes = false;
                    var hasDeclaredMarkers = false;
                    var unknownReferences = [];

                    function registerGroup(label) {
                        var name = (label || "").toString().trim();
                        if (!name) return null;
                        var id = sanitizeTypeId(name) || name.replace(/\s+/g, "_").toLowerCase();
                        if (!groupsMap[id]) {
                            groupsMap[id] = { id: id, label: name };
                            groupOrder.push(id);
                        }
                        return id;
                    }

                    function registerType(label) {
                        var name = (label || "").toString().trim();
                        if (!name) return null;
                        var id = sanitizeTypeId(name) || name.replace(/\s+/g, "_").toLowerCase();
                        if (!typesMap[id]) {
                            typesMap[id] = { id: id, label: name };
                            typeOrder.push(id);
                        }
                        return id;
                    }

                    function registerMarker(label) {
                        var name = (label || "").toString().trim();
                        if (!name) return null;
                        var id = sanitizeTypeId(name) || name.replace(/\s+/g, "_").toLowerCase();
                        if (!markersMap[id]) {
                            markersMap[id] = { id: id, label: name, isMarker: true };
                            markerOrder.push(id);
                        }
                        return id;
                    }

                    // Parse header lines
                    var i = 0;
                    for (; i < lines.length; i++) {
                        var line = lines[i];
                        if (!line) continue;
                        var mPage = line.match(/^(?:Page|Bloc)\s*[:\-‚Äì]?\s*(.+)$/i);
                        if (mPage) {
                            planning.page = mPage[1].trim();
                            continue;
                        }
                        var mPeriod = line.match(/^P[e√©]riode\s*[:]\s*(.+)$/i);
                        if (mPeriod) {
                            var range = mPeriod[1].split(/‚Üí|->|-|‚Äî/).map(function (s) { return s.trim(); }).filter(Boolean);
                            if (range.length) {
                                planning.timeline.start = range[0] || undefined;
                                planning.timeline.end = range[1] || range[0] || undefined;
                            }
                            continue;
                        }
                        var mGroups = line.match(/^Groupes?\s*[:]\s*(.+)$/i);
                        if (mGroups) {
                            hasDeclaredGroups = true;
                            var parts = mGroups[1].split(/,|;/).map(function (s) { return s.trim(); }).filter(Boolean);
                            parts.forEach(function (p) {
                                registerGroup(p);
                            });
                            continue;
                        }
                        var mMarkers = line.match(/^Rep[e√®]res?\s*[:]\s*(.+)$/i);
                        if (mMarkers) {
                            hasDeclaredMarkers = true;
                            var markerParts = mMarkers[1].split(/,|;/).map(function (s) { return s.trim(); }).filter(Boolean);
                            markerParts.forEach(function (p) {
                                registerMarker(p);
                            });
                            continue;
                        }
                        var mTypes = line.match(/^(Types?|Cat[√©e]gories?)\s*[:]\s*(.+)$/i);
                        if (mTypes) {
                            hasDeclaredTypes = true;
                            var typeParts = mTypes[2].split(/,|;/).map(function (s) { return s.trim(); }).filter(Boolean);
                            typeParts.forEach(function (p) {
                                registerType(p);
                            });
                            continue;
                        }
                        if (/^\s*(?:Actions?|√âl[e√©]ments?)\s*[:]?\s*$/i.test(line)) {
                            i++;
                            break;
                        }
                    }

                    // Now parse items blocks until end
                    var currentBlock = [];
                    for (; i <= lines.length; i++) {
                        var line = lines[i] || "";
                        if (line === "") {
                            if (currentBlock.length) {
                                // process block
                                var label = (currentBlock[0] || "").trim();
                                var item = { id: null, groupId: null, label: label, kind: "", start: null, end: null, date: null };
                                for (var j = 1; j < currentBlock.length; j++) {
                                    var l = currentBlock[j];
                                    var mDate = l.match(/^Date\s*[:]\s*(.+)$/i);
                                    if (mDate) {
                                        var val = mDate[1].trim();
                                        var durationMatch = val.match(/\((\d+)\s*jour[s]?\)/i);
                                        var durationDays = durationMatch ? parseInt(durationMatch[1], 10) : null;
                                        var cleaned = val.replace(/\s*\([^)]+\)\s*$/i, "").trim();
                                        var range = cleaned.split(/‚Üí|->|-|‚Äî/).map(function (s) { return s.trim(); }).filter(Boolean);
                                        if (range.length === 1) {
                                            item.date = range[0];
                                            item.start = range[0];
                                            item.end = range[0];
                                            if (durationDays && durationDays > 1) {
                                                var parsedStart = new Date(range[0]);
                                                if (!isNaN(parsedStart.getTime())) {
                                                    var calculatedEnd = new Date(parsedStart.getTime());
                                                    calculatedEnd.setDate(calculatedEnd.getDate() + (durationDays - 1));
                                                    item.end = calculatedEnd.toISOString().slice(0, 10);
                                                }
                                            }
                                        } else if (range.length >= 2) {
                                            item.start = range[0] || null;
                                            item.end = range[1] || null;
                                        }
                                        continue;
                                    }
                                    var mGroup = l.match(/^Groupe\s*[:]\s*(.+)$/i);
                                    if (mGroup) {
                                        var rawGroup = (mGroup[1] || "").trim();
                                        var gid = sanitizeTypeId(rawGroup || "");
                                        item.groupId = gid;
                                        item.rawGroupLabel = rawGroup;
                                        if (gid) {
                                            if (hasDeclaredGroups && !groupsMap[gid]) {
                                                unknownReferences.push({
                                                    action: label,
                                                    group: rawGroup,
                                                    type: item.kind || ""
                                                });
                                            } else if (!groupsMap[gid]) {
                                                registerGroup(rawGroup);
                                            }
                                        }
                                        continue;
                                    }
                                    var mType = l.match(/^Type\s*[:]\s*(.+)$/i);
                                    if (mType) {
                                        var rawType = (mType[1] || "").trim();
                                        var parsedType = parseKindLabelInput(rawType);
                                        var kind = parsedType.id;
                                        if (kind) {
                                            item.kind = kind;
                                            item.isMarker = parsedType.isMarker;
                                            if (parsedType.isMarker) {
                                                if (hasDeclaredMarkers && !markersMap[kind]) {
                                                    unknownReferences.push({
                                                        action: label,
                                                        group: item.rawGroupLabel || item.groupId || "",
                                                        type: rawType
                                                    });
                                                } else if (!markersMap[kind]) {
                                                    registerMarker(rawType);
                                                }
                                            } else {
                                                if (hasDeclaredTypes && !typesMap[kind]) {
                                                    unknownReferences.push({
                                                        action: label,
                                                        group: item.rawGroupLabel || item.groupId || "",
                                                        type: rawType
                                                    });
                                                } else if (!typesMap[kind]) {
                                                    registerType(rawType);
                                                }
                                            }
                                        }
                                        continue;
                                    }
                                }
                                // default group if missing
                                if (!item.groupId) {
                                    // assign to first group if exists or create 'default'
                                    var keys = Object.keys(groupsMap);
                                    if (keys.length) item.groupId = groupsMap[keys[0]].id;
                                    else {
                                        var gid = registerGroup("G√©n√©ral");
                                        item.groupId = gid;
                                    }
                                }
                                // default kind
                                if (!item.kind) {
                                    var defaultMarkerId = markerOrder.length ? markerOrder[0] : registerMarker("Rep√®re") || "repere";
                                    var defaultTypeId = typeOrder.length ? typeOrder[0] : registerType("feature") || "feature";
                                    if (item.date && item.start && item.end && item.start === item.end) {
                                        item.kind = defaultMarkerId;
                                        item.isMarker = true;
                                    } else {
                                        item.kind = defaultTypeId;
                                        item.isMarker = false;
                                    }
                                }
                                // generate id
                                item.id = "item-" + Math.random().toString(36).slice(2, 9);
                                // if start/end equal, set date for markers
                                var itemIsMarker = item.isMarker || markersMap[item.kind];
                                if (itemIsMarker) {
                                    item.date = item.date || (item.start || null);
                                    item.start = null;
                                    item.end = null;
                                }
                                planning.items.push(item);
                                currentBlock = [];
                            }
                            continue;
                        }
                        currentBlock.push(line);
                    }

                    if (unknownReferences.length) {
                        var message = ["Groupes ou types inconnus d√©tect√©s :"];
                        unknownReferences.forEach(function (ref) {
                            message.push(
                                "- Action \"" + (ref.action || "Sans titre") + "\" (Groupe : " + (ref.group || "non pr√©cis√©") + ", Type : " + (ref.type || "non pr√©cis√©") + ")"
                            );
                        });
                        throw new Error(message.join("\n"));
                    }

                    planning.groups = (groupOrder.length ? groupOrder : Object.keys(groupsMap)).map(function (k) {
                        return groupsMap[k];
                    }).filter(Boolean);

                    // Ensure every used type exists in definitions
                    planning.items.forEach(function (it) {
                        var kid = sanitizeTypeId(it.kind || it.type || "");
                        if (!kid) return;
                        var looksLikeMarker = it.isMarker || (it.date && (!it.end || it.start === it.end)) || markersMap[kid];
                        if (!typesMap[kid] && !markersMap[kid]) {
                            if (looksLikeMarker) {
                                registerMarker(kid);
                            } else {
                                registerType(kid);
                            }
                        }
                    });
                    planning.types = (typeOrder.length ? typeOrder : Object.keys(typesMap)).map(function (k) {
                        return typesMap[k];
                    }).filter(Boolean);
                    planning.markers = (markerOrder.length ? markerOrder : Object.keys(markersMap)).map(function (k) {
                        return markersMap[k];
                    }).filter(Boolean);
                    if (!planning.types || !planning.types.length) {
                        planning.types = [{ id: "feature", label: "feature" }];
                    }
                    if (!planning.markers || !planning.markers.length) {
                        planning.markers = [{ id: "repere", label: "Rep√®re", isMarker: true }];
                    }
                    return planning;
                }

                async function callOpenAI(messages, controller) {
                    try {
                        if (!window.GoToolkitIA || typeof window.GoToolkitIA.chatCompletion !== "function") {
                            throw new Error("Client IA indisponible");
                        }
                        var reasoningEffort = (function () {
                            var value = reasoningEffortSelect ? reasoningEffortSelect.value : "low";
                            return REASONING_EFFORTS.indexOf(value) !== -1 ? value : "low";
                        })();
                        var payload = {
                            model:
                                window.GoToolkitIAConfig && typeof window.GoToolkitIAConfig.getOpenAiModel === "function"
                                    ? window.GoToolkitIAConfig.getOpenAiModel()
                                    : OPENAI_MODEL,
                            temperature: OPENAI_TEMPERATURE,
                            messages: messages,
                            reasoning: {
                                effort: reasoningEffort
                            },
                            stream: true
                        };
                        var messageText = await window.GoToolkitIA.chatCompletion({
                            payload: payload,
                            signal: controller && controller.signal
                        });
                        return messageText;
                    } catch (err) {
                        console.error("Erreur OpenAI", err);
                        if (err && err.name === "AbortError") {
                            try { showCopyToast("Requ√™te annul√©e."); } catch (e) { }
                            return null;
                        }
                        if (err && (err.message === "OllamaUnavailable" || (err.backendInfo && err.backendInfo.type === "ollama-unavailable"))) {
                            try { showCopyToast("Ollama indisponible ‚Äî v√©rifie l'URL ou la connexion."); } catch (e) { alert("Ollama indisponible ‚Äî v√©rifie l'URL ou la connexion."); }
                        } else {
                            alert("Impossible de contacter OpenAI. V√©rifie que le proxy est accessible.");
                        }
                        return null;
                    }
                }

                btnCall.addEventListener("click", async function () {
                    var mode = determineGenerationMode();
                    await generateFromMode(btnCall, mode);
                });

                if (clearTimelineBtn) {
                    clearTimelineBtn.addEventListener("click", function () {
                        clearActiveView({ clearRecit: false });
                    });
                }

                var restoreScriptBtn = document.getElementById("restoreScriptBtn");
                if (restoreScriptBtn) {
                    restoreScriptBtn.addEventListener("click", function () {
                        if (!lastAiPlanningJson) {
                            alert("Aucune r√©ponse IA JSON r√©cente √† restaurer.");
                            return;
                        }
                        try {
                            txtPromptModify.value = lastAiPlanningJson;
                            persistActiveContext(function (ctx) {
                                ctx.prompts.modify = txtPromptModify.value || "";
                            });
                            var parsed = JSON.parse(lastAiPlanningJson);
                            applyPlanningFromJson(parsed);
                        } catch (e) {
                            console.warn("Impossible de restaurer la r√©ponse IA", e);
                            alert("Impossible de restaurer la r√©ponse IA.");
                        }
                    });
                }



                var timelineTourSteps = [
                    {
                        title: "Ton copilote planning",
                        description: "Goal Digger aide √† identifier les prochaines √©tapes et l'organisation de leurs projets pour atteindre leurs objectifs.",
                        selectors: []
                    },
                    {
                        title: "D√©cris ton contexte librement",
                        description: "Utiliser le bouton ‚åò pour g√©n√©rer le planning, le script permet de le modifier rapidement √©galement.",
                        selectors: [".gutenberg-recette"]
                    },
                    {
                        title: "Affiche, zoome, navigue",
                        description: "Le planning appara√Æt, tu peux zoomer, te d√©placer dans le temps et jongler avec les boutons de la barre d‚Äôoutils.",
                        selectors: [
                            ".toolbar .btn-group:nth-of-type(1)",
                            ".toolbar .btn-group:nth-of-type(2)",
                            ".toolbar .btn-group:nth-of-type(3)"
                        ]
                    },
                    {
                        title: "Modifie librement le contenu",
                        description: "Ajoute, renomme, d√©place, ajuste les dur√©es ou supprime n‚Äôimporte quel √©l√©ment directement dans la timeline.",
                        selectors: [".toolbar .item-actions", "#btn-add-milestone", "#btn-add-item", "#btn-add-type", "#openColorPaletteBtn"]
                    },
                    {
                        title: "Exporte ta timeline",
                        description: "Le menu ‚¨† Capsule permet de t√©l√©charger la vue courante en texte, image ou Excel et le bouton ‚òç Nexus g√©n√®re un lien priv√© pour la partager rapidement.",
                        selectors: ["#fileMenuBtn"]
                    }
                ];
                var timelineTourOverlay = document.getElementById("timelineTourOverlay");
                // Load runtime config synchronously so tour behavior can be controlled
                window.GoToolkitConfig = window.GoToolkitConfig || { enableTours: false };
                try {
                    var __cfg_xhr = new XMLHttpRequest();
                    __cfg_xhr.open('GET', '/config.json', false);
                    __cfg_xhr.send(null);
                    if (__cfg_xhr.status >= 200 && __cfg_xhr.status < 300) {
                        try { window.GoToolkitConfig = Object.assign({}, window.GoToolkitConfig, JSON.parse(__cfg_xhr.responseText)); } catch (e) { }
                    }
                } catch (e) { }
                document.addEventListener('DOMContentLoaded', function () {
                    if (window.GoToolkitConfig && window.GoToolkitConfig.enableTours === false) {
                        var btn = document.getElementById('timelineTourReplayBtn');
                        if (btn) btn.style.display = 'none';
                        var overlay = document.getElementById('timelineTourOverlay');
                        if (overlay) {
                            overlay.setAttribute('aria-hidden', 'true');
                            overlay.style.display = 'none';
                        }
                    }
                });
                var timelineTourHighlight = timelineTourOverlay && timelineTourOverlay.querySelector(".tour-highlight");
                var timelineTourPanel = timelineTourOverlay && timelineTourOverlay.querySelector(".tour-panel");
                var timelineTourTitle = document.getElementById("timelineTourStepTitle");
                var timelineTourDescription = document.getElementById("timelineTourStepDescription");
                var timelineTourCounter = document.getElementById("timelineTourStepCounter");
                var timelineTourPrevBtn = document.getElementById("timelineTourPrevBtn");
                var timelineTourNextBtn = document.getElementById("timelineTourNextBtn");
                var timelineTourCloseBtn = document.getElementById("timelineTourCloseBtn");
                var timelineTourSkipBtn = document.getElementById("timelineTourSkipBtn");
                var timelineTourReplayBtn = document.getElementById("timelineTourReplayBtn");
                var timelineTourStorageKey = "goTimelineTourSeen";
                var timelineTourSkipFlag = "goTimelineTourSkipAfterUpdate";
                var timelineCurrentTourIndex = 0;

                function getSelectorsFromStep(step) {
                    if (!step) return [];
                    if (Array.isArray(step.selectors)) return step.selectors;
                    if (step.selector) return [step.selector];
                    return [];
                }

                function getSelectorsBoundingRect(selectors) {
                    if (!selectors || !selectors.length) {
                        return null;
                    }
                    let unionRect = null;
                    selectors.forEach(function (selector) {
                        var target = document.querySelector(selector);
                        if (!target) return;
                        var rect = target.getBoundingClientRect();
                        if (!unionRect) {
                            unionRect = {
                                top: rect.top,
                                left: rect.left,
                                right: rect.right,
                                bottom: rect.bottom
                            };
                        } else {
                            unionRect.top = Math.min(unionRect.top, rect.top);
                            unionRect.left = Math.min(unionRect.left, rect.left);
                            unionRect.right = Math.max(unionRect.right, rect.right);
                            unionRect.bottom = Math.max(unionRect.bottom, rect.bottom);
                        }
                    });
                    if (!unionRect) return null;
                    unionRect.width = unionRect.right - unionRect.left;
                    unionRect.height = unionRect.bottom - unionRect.top;
                    return unionRect;
                }

                function positionTourPanel(selectors) {
                    if (!timelineTourPanel) return;
                    var spacing = 14;
                    var defaults = {
                        top: "auto",
                        bottom: "28px",
                        left: "50%",
                        right: "auto",
                        transform: "translateX(-50%)"
                    };
                    Object.assign(timelineTourPanel.style, defaults);
                    var rect = getSelectorsBoundingRect(selectors);
                    if (!rect) return;
                    var panelRect = timelineTourPanel.getBoundingClientRect();
                    var top = rect.bottom + spacing;
                    if (top + panelRect.height > window.innerHeight - spacing) {
                        top = rect.top - panelRect.height - spacing;
                    }
                    var left = rect.left + rect.width / 2 - panelRect.width / 2;
                    left = Math.max(spacing, Math.min(left, window.innerWidth - panelRect.width - spacing));
                    timelineTourPanel.style.top = Math.max(spacing, top) + "px";
                    timelineTourPanel.style.left = left + "px";
                    timelineTourPanel.style.bottom = "auto";
                    timelineTourPanel.style.right = "auto";
                    timelineTourPanel.style.transform = "none";
                }

                function updateHighlight(selectors) {
                    if (!timelineTourHighlight || !timelineTourOverlay) return;
                    var rect = getSelectorsBoundingRect(selectors);
                    if (!rect) {
                        timelineTourHighlight.classList.add("hidden");
                        timelineTourOverlay.classList.add("dimmed");
                        return;
                    }
                    timelineTourOverlay.classList.remove("dimmed");
                    timelineTourHighlight.classList.remove("hidden");
                    var offset = 10;
                    timelineTourHighlight.style.width = rect.width + offset * 2 + "px";
                    timelineTourHighlight.style.height = rect.height + offset * 2 + "px";
                    timelineTourHighlight.style.left = rect.left - offset + "px";
                    timelineTourHighlight.style.top = rect.top - offset + "px";
                }

                function renderTimelineTourStep() {
                    if (!timelineTourOverlay || !timelineTourSteps.length) return;
                    var step = timelineTourSteps[timelineCurrentTourIndex];
                    if (!step) return;
                    timelineTourTitle.textContent = step.title;
                    timelineTourDescription.textContent = step.description;
                    timelineTourCounter.textContent = "√âtape " + (timelineCurrentTourIndex + 1) + " / " + timelineTourSteps.length;
                    timelineTourPrevBtn.disabled = timelineCurrentTourIndex === 0;
                    timelineTourNextBtn.textContent = timelineCurrentTourIndex === timelineTourSteps.length - 1 ? "Termin√©" : "Suivant";
                    var selectors = getSelectorsFromStep(step);
                    updateHighlight(selectors);
                    positionTourPanel(selectors);
                }

                function openTimelineTour(startIndex) {
                    hideTimelineAbout();
                    if (!timelineTourOverlay) return;
                    closeRoadmapPromptModal();
                    timelineCurrentTourIndex = typeof startIndex === "number" ? startIndex : 0;
                    timelineTourOverlay.classList.add("visible");
                    timelineTourOverlay.setAttribute("aria-hidden", "false");
                    renderTimelineTourStep();
                }

                function closeTimelineTour(markSeen) {
                    if (markSeen && window.localStorage) {
                        window.localStorage.setItem(timelineTourStorageKey, "1");
                    }
                    if (!timelineTourOverlay) return;
                    timelineTourOverlay.classList.remove("visible");
                    timelineTourOverlay.setAttribute("aria-hidden", "true");
                    timelineTourOverlay.classList.remove("dimmed");
                    if (timelineTourHighlight) {
                        timelineTourHighlight.classList.add("hidden");
                    }
                }

                if (timelineTourPrevBtn) {
                    timelineTourPrevBtn.addEventListener("click", function () {
                        if (timelineCurrentTourIndex === 0) return;
                        timelineCurrentTourIndex--;
                        renderTimelineTourStep();
                    });
                }
                if (timelineTourNextBtn) {
                    timelineTourNextBtn.addEventListener("click", function () {
                        if (timelineCurrentTourIndex >= timelineTourSteps.length - 1) {
                            closeTimelineTour(true);
                            return;
                        }
                        timelineCurrentTourIndex++;
                        renderTimelineTourStep();
                    });
                }
                if (timelineTourCloseBtn) {
                    timelineTourCloseBtn.addEventListener("click", function () {
                        closeTimelineTour(true);
                    });
                }
                if (timelineTourSkipBtn) {
                    timelineTourSkipBtn.addEventListener("click", function () {
                        closeTimelineTour(true);
                    });
                }
                if (timelineTourReplayBtn) {
                    timelineTourReplayBtn.addEventListener("click", function () {
                        if (window.GoToolkitConfig && window.GoToolkitConfig.enableTours === false) {
                            setStatus && setStatus("Tours guid√©s d√©sactiv√©s");
                            return;
                        }
                        if (window.localStorage) {
                            window.localStorage.removeItem(timelineTourStorageKey);
                        }
                        openTimelineTour(0);
                    });
                }

                window.addEventListener("resize", function () {
                    if (!timelineTourOverlay || !timelineTourOverlay.classList.contains("visible")) return;
                    renderTimelineTourStep();
                });

                var timelineTourSeen = window.localStorage && window.localStorage.getItem(timelineTourStorageKey);
                var timelineTourSkipAfterUpdateValue =
                    window.sessionStorage && window.sessionStorage.getItem(timelineTourSkipFlag);
                if (timelineTourSkipAfterUpdateValue && window.sessionStorage) {
                    window.sessionStorage.removeItem(timelineTourSkipFlag);
                }
                if (!timelineTourSeen && !timelineTourSkipAfterUpdateValue && (window.GoToolkitConfig?.enableTours !== false)) {
                    setTimeout(function () {
                        openTimelineTour(0);
                    }, 200);
                }

                initShareWorkerService();
                updateShareMenuUI();
                tryLoadSharedStateFromUrl();

                setScale("week");
                if (txtPromptCreate) {
                    txtPromptCreate.focus();
                }

            })();
        </script>
        <script>
            (function removeVersionQueryParam() {
                try {
                    const url = new URL(window.location.href);
                    if (!url.searchParams.has("v")) return;
                    url.searchParams.delete("v");
                    const search = url.searchParams.toString();
                    const newUrl = url.pathname + (search ? `?${search}` : "") + url.hash;
                    window.history.replaceState({}, "", newUrl);
                } catch (err) {
                    /* noop */
                }
            })();
        </script>
        <script>
            window.GoToolkitAppFeedbackConfig = {
                appId: "timeline",
                appName: "Timeline",
                defaultType: "bug-timeline",
                shareCollection: "timelines",
                buildSharePayload: () => ({
                    app: "timeline",
                    url: window.location.href,
                    payload: typeof buildTimelineStatePayload === "function" ? buildTimelineStatePayload() : {}
                })
            };
        </script>
        <script src="js/feedback-app.js"></script>
</body>

</html>
