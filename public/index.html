<!DOCTYPE html>
<html lang="fr">

<head>
    <script>window.GO_TOOLKIT_SHARE_API_URL = 'https://gotoolkit.workers.dev'</script>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Go-Toolkit</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=Sora:wght@400;500;600&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --bg: #f5f2eb;
            --surface: #ffffff;
            --surface-soft: #fdfbf6;
            --border-soft: #dfd5c7;
            --border-strong: #d0c3ad;
            --text: #2f2922;
            --muted: #8b8173;
            --primary: #2a7a57;
            --shadow-soft: 0 18px 40px rgba(47, 41, 34, 0.08);
        }

        * {
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
        }

        body {
            margin: 0;
            font-family: "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
            background: radial-gradient(circle at top, rgba(255, 255, 255, 0.4), transparent 55%), var(--bg);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            padding: 8px 6px 12px;
            font-size: 0.95rem;
        }

        .page {
            width: 100%;
            max-width: 1180px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            height: 100%;
            max-height: 100%;
            overflow-y: auto;
        }

        .hero,
        .section {
            border-radius: 12px;
            border: 1px solid var(--border-soft);
            background: var(--surface);
            padding: 12px;
            box-shadow: var(--shadow-soft);
        }

        .hero {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 12px;
            text-align: left;
            background-image: linear-gradient(135deg, rgba(42, 122, 87, 0.06), rgba(255, 255, 255, 0));
            min-height: 50px;
            flex-wrap: wrap;
        }

        .hero-logo-wrapper {
            width: 80px;
            height: 52px;
            border-radius: 14px;
            background: transparent;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .hero-logo-wrapper img {
            width: 90px;
        }

        h1 {
            margin: 0;
            font-size: clamp(1.4rem, 2.8vw, 1.9rem);
            letter-spacing: -0.02em;
        }

        .hero p {
            margin: 0;
            max-width: 420px;
            color: var(--muted);
            line-height: 1.3;
            font-size: 0.85rem;
        }

        .section-title-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            margin-bottom: 0px;
        }

        .section-label {
            font-size: 0.7rem;
            font-weight: 600;
            letter-spacing: 0.16em;
            text-transform: uppercase;
            color: var(--muted);
            margin: 5px 5px 15px 5px;
        }

        .section-helper {
            font-size: 0.75rem;
            color: var(--muted);
            margin: 0;
        }

        .label-link {
            border-bottom: 1px dashed currentColor;
            cursor: pointer;
            display: inline-flex;
            gap: 4px;
            padding-bottom: 2px;
        }

        .label-link:hover,
        .label-link:focus-visible {
            color: var(--primary);
            border-bottom-color: var(--primary);
            outline: none;
        }

        .ia-status {
            margin-left: 6px;
            font-size: 15px;
            color: var(--text);
            min-width: 1ch;
            display: inline-flex;
            justify-content: center;
            align-items: center;
            transition: color 0.2s ease;
        }

        .ia-status--error {
            color: #B11226;
        }



        .ghost-button {
            border: 1px solid var(--border-strong);
            border-radius: 999px;
            background: transparent;
            color: var(--text);
            font-size: 0.8rem;
            padding: 2px 6px;
            cursor: pointer;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }

        .ghost-button:hover,
        .ghost-button:focus-visible {
            border-color: var(--primary);
            box-shadow: 0 12px 30px rgba(42, 122, 87, 0.15);
            outline: none;
        }

        .launcher-grid {
            display: grid;
            gap: 8px;
            grid-template-columns: repeat(3, minmax(0, 1fr));
            min-height: 30px;
        }

        .launcher {
            flex: 1 1 180px;
            min-width: 150px;
            text-decoration: none;
            color: var(--text);
            border-radius: 8px;
            padding: 25px 10px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            border: 1px solid var(--border-soft);
            background: var(--surface-soft);
            transition: box-shadow 0.2s ease, transform 0.2s ease;
            min-height: 30px;
            height: 30px;
        }

        .launcher:hover,
        .launcher:focus-visible {
            transform: translateY(-2px);
            box-shadow: 0 20px 34px rgba(42, 122, 87, 0.12);
            outline: none;
        }

        .launcher-emoji {
            font-size: 28px;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @media (max-width: 640px) {
            .launcher-grid {
                grid-template-columns: 1fr;
            }

            .launcher {
                flex: 1 1 100%;
                padding: 14px;
                gap: 10px;
                height: auto;
            }

            .launcher-emoji {
                font-size: 22px;
                width: 28px;
                height: 28px;
            }
        }

        .launcher-name {
            font-size: 15px;
            font-weight: 600;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .launcher-desc {
            font-size: 0.85rem;
            color: var(--muted);
            font-weight: 400;
            letter-spacing: 0;
        }

        .share-gallery {
            display: grid;
            grid-template-columns: repeat(3, minmax(0, 1fr));
            gap: 12px;
        }

        .share-card {
            display: flex;
            flex-direction: column;
            gap: 10px;
            border-radius: 8px;
            padding: 6px;
            border: 1px solid var(--border-soft);
            background: var(--surface-soft);
            text-decoration: none;
            color: var(--text);
            min-height: 120px;
            transition: box-shadow 0.2s ease;
            position: relative;
            padding-bottom: 28px;
        }

        .share-card:hover,
        .share-card:focus-visible {
            box-shadow: 0 18px 28px rgba(47, 41, 34, 0.12);
            outline: none;
        }

        .share-card-title {
            font-size: 1rem;
            font-weight: 600;
            margin: 0;
        }

        .share-card-meta {
            margin: 0;
            color: var(--muted);
            font-size: 0.82rem;
        }

        .share-card-desc {
            margin: 0;
            color: var(--muted);
            line-height: 1.3;
            min-height: 2em;
            font-size: 0.85rem;
        }

        .share-card-date {
            margin: 4px 0 0;
            font-size: 0.75rem;
            color: rgba(47, 41, 34, 0.6);
        }

        .share-card-action {
            position: absolute;
            bottom: 6px;
            border: 1px solid var(--border-strong);
            background: #fff;
            border-radius: 12px;
            width: 24px;
            height: 24px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            cursor: pointer;
            box-shadow: 0 6px 14px rgba(0, 0, 0, 0.08);
            transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
        }

        .share-card-action:hover,
        .share-card-action:focus-visible {
            transform: translateY(-1px);
            box-shadow: 0 10px 18px rgba(0, 0, 0, 0.12);
            border-color: var(--primary);
            outline: none;
        }

        .share-card-delete {
            right: 8px;
        }

        .share-card-pin {
            right: 38px;
        }

        .share-helper {
            margin: 8px 0 0;
            color: var(--muted);
            font-size: 0.8rem;
        }

        .share-helper[hidden] {
            display: none;
        }

        .share-helper-error {
            color: #b43a3f;
        }

        .feedback-button {
            margin-left: auto;
            border: 1px solid var(--border-strong);
            border-radius: 8px;
            background: #fff;
            color: var(--text);
            font-weight: 500;
            font-size: 14px;
            padding: 3px 9px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            box-shadow: none;
            transition: border-color 0.15s ease, color 0.15s ease;
        }

        .feedback-button:hover,
        .feedback-button:focus-visible {
            border-color: var(--primary);
            color: var(--primary);
            outline: none;
        }

        .feedback-modal-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.25);
            display: none;
            align-items: center;
            justify-content: center;
            padding: 12px;
            z-index: 50;
        }

        .feedback-modal-backdrop.open {
            display: flex;
        }

        .feedback-modal {
            width: min(720px, 100%);
            background: #fff;
            border-radius: 12px;
            border: 1px solid var(--border-soft);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.12);
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .feedback-modal header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .feedback-modal h3 {
            margin: 0;
            font-size: 1.05rem;
        }

        .superpower-modal {
            width: min(640px, 90vw);
            background: #fff;
            border-radius: 18px;
            box-shadow: 0 22px 45px rgba(15, 23, 42, 0.25);
            padding: 10px 14px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 80vh;
            overflow-y: auto;
            font-size: 0.78rem;
        }

        .superpower-modal header {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .superpower-modal h3 {
            font-size: 1.4rem;
            margin: 0;
        }

        .superpower-list {
            display: flex;
            flex-direction: column;
            gap: 14px;
        }

        .superpower-intro {
            margin: 0;
            font-size: 0.85rem;
            color: var(--muted);
            line-height: 1.4;
        }

        .superpower-head {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* In the modal, show name and tag on the same row */
        .superpower-modal .superpower-head {
            flex-direction: row;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .superpower-tag-row {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .superpower-tag {
            display: inline-flex;
            align-items: center;
            font-size: 0.65rem;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            padding: 2px 8px;
            border-radius: 999px;
            border: 1px solid #2a7a57;
            background: rgba(42, 122, 87, 0.08);
            color: #2a7a57;
        }

        .superpower-tag--development {
            border-color: #f5c04c;
            background: rgba(245, 192, 76, 0.2);
            color: #a56d00;
        }

        .superpower-tag--soon {
            border-color: rgba(15, 23, 42, 0.35);
            background: rgba(15, 23, 42, 0.08);
            color: #373b43;
        }

        .superpower-tag--cockpit {
            border-color: #b43a3f;
            background: rgba(180, 58, 63, 0.12);
            color: #b43a3f;
        }

        .superpower-tag--satellite {
            border-color: #7a4bc0;
            background: rgba(122, 75, 192, 0.12);
            color: #5a2ea6;
        }

        .superpower-list section {
            border-bottom: 1px dashed rgba(0, 0, 0, 0.16);
            padding-bottom: 6px;
        }

        .superpower-list section:last-child {
            border-bottom: none;
        }

        .superpower-list h4 {
            margin: 0 0 4px;
            font-size: 1.1rem;
            font-weight: 700;
        }

        .superpower-subtitle {
            margin: 0;
            color: #1f2a56;
            font-size: 0.78rem;
            line-height: 1.4;
        }

        .nexus-modal {
            width: min(900px, 90vw);
            background: #fff;
            border-radius: 16px;
            box-shadow: 0 22px 45px rgba(15, 23, 42, 0.25);
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-height: 75vh;
            overflow-y: auto;
            font-size: 0.9rem;
        }

        .nexus-modal header {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 12px;
            position: relative;
        }

        .nexus-modal header button {
            position: absolute;
            top: 0;
            right: 0;
        }

        .nexus-content {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .nexus-content p {
            margin: 0;
            line-height: 1.4;
        }

        .feedback-form {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .feedback-form label {
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 0.78rem;
            color: var(--text);
        }

        .feedback-form input,
        .feedback-form select,
        .feedback-form textarea {
            border-radius: 10px;
            border: 1px solid var(--border-soft);
            padding: 10px 12px;
            font-family: inherit;
            font-size: 0.83rem;
            background: var(--surface-soft);
            color: var(--text);
        }


        .feedback-form textarea {
            resize: vertical;
            min-height: 160px;
        }

        input:focus,
        textarea:focus {
            outline: none;
            border: 1px solid var(--primary);
            box-shadow: 0 0 0 1px var(--primary);
        }

        .feedback-form .field-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .feedback-form .field-row label {
            flex: 1 1 220px;
        }

        .feedback-helper {
            margin: 4px 0 0 0;
            color: var(--muted);
            font-size: 0.75rem;
        }

        .requests-button {
            position: fixed;
            right: 10px;
            bottom: 12px;
            z-index: 60;
            border: 1px solid var(--border-soft);
            background: var(--surface);
            color: var(--text);
            border-radius: 999px;
            padding: 4px 10px;
            font-size: 13px;
            box-shadow: var(--shadow-soft);
            cursor: pointer;
        }

        .requests-modal {
            min-width: 1200px;
            max-width: 95vw;
            background: var(--surface);
            border-radius: 12px;
            box-shadow: var(--shadow-soft);
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .requests-body {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 10px;
            min-height: 480px;
            max-height: 80vh;
        }

        .requests-list-panel {
            border: 1px solid var(--border-soft);
            border-radius: 10px;
            background: var(--surface-soft);
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .requests-filter {
            padding: 8px 10px;
            border-bottom: 1px solid var(--border-soft);
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: space-between;
        }

        .requests-filter select {
            border-radius: 8px;
            border: 1px solid var(--border-soft);
            padding: 4px 6px;
            font-size: 0.8rem;
            background: #fff;
        }

        .requests-list {
            overflow-y: auto;
            padding: 4px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .requests-item {
            border: 1px solid var(--border-soft);
            border-radius: 10px;
            padding: 6px;
            background: #fff;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .requests-item.active {
            border-color: var(--primary);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.08);
        }

        .requests-item-title {
            margin: 0;
            font-weight: 600;
            font-size: 14px;
        }

        .requests-item-meta {
            color: var(--muted);
            font-size: 13px;
            display: flex;
            gap: 0px;
            align-items: center;
            margin: 0;
        }

        .requests-item-message {
            margin: 0;
            font-size: 0.76rem;
            color: var(--text);
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .requests-content {
            border: 1px solid var(--border-soft);
            border-radius: 10px;
            background: #fff;
            padding: 8px;
            display: grid;
            grid-template-rows: auto 1fr auto;
            gap: 8px;
            min-height: 0;
        }

        .requests-content h4 {
            margin: 0;
            font-size: 0.9rem;
        }

        .request-title-input {
            width: 100%;
            font-size: 0.9rem;
            font-weight: 700;
            border: none;
            background: transparent;
            padding: 0;
            margin: 0 0 4px 0;
        }

        .request-title-input[readonly] {
            color: inherit;
        }

        .request-content-body {
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .request-content-body label {
            display: flex;
            flex-direction: column;
            gap: 3px;
            font-size: 0.8rem;
        }

        .request-content-body input,
        .request-content-body textarea,
        .request-content-body select {
            border: 1px solid var(--border-soft);
            border-radius: 8px;
            padding: 6px;
            font-size: 13px;
            margin: 3px;
        }

        .requests-actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }

        .feedback-actions {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 8px;
        }

        .btn-secondary {
            border: 1px solid var(--border-soft);
            background: transparent;
            color: var(--text);
            border-radius: 10px;
            padding: 6px 10px;
            cursor: pointer;
            font-size: 13px;
        }

        .btn-primary {
            border: none;
            background: #2a7a57;
            color: #fff;
            border-radius: 8px;
            padding: 6px 10px;
            cursor: pointer;
            box-shadow: 0 12px 24px rgba(42, 122, 87, 0.25);
            font-size: 13px;
        }

        .btn-primary:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            box-shadow: none;
        }

        .toast {
            position: fixed;
            right: 16px;
            bottom: 16px;
            padding: 12px 14px;
            border-radius: 10px;
            color: #fff;
            background: #2a7a57;
            box-shadow: 0 12px 28px rgba(0, 0, 0, 0.14);
            display: none;
            z-index: 60;
            min-width: 240px;
        }

        .toast.error {
            background: #b43a3f;
        }

        .toast.show {
            display: block;
        }

        .required-asterisk {
            color: #b43a3f;
            font-weight: 700;
            margin-left: 4px;
        }

        .label-title {
            margin-top: 6px;
            display: inline-flex;
            align-items: center;
            gap: 4px;

        }



        .label-subtitle {
            display: block;
            margin-top: 2px;
            color: var(--muted);
            font-size: 11px;
            line-height: 1.2;
        }

        .hero-meta {
            margin-left: auto;
            display: flex;
            flex-direction: row-reverse;
            align-items: flex-end;
            gap: 2px;
        }

        .hero-version {
            color: var(--muted);
            font-size: 0.56rem;
            font-weight: 700;
            line-height: 1.2;
        }

        @media (max-width: 720px) {
            body {
                padding: 8px;
            }

            .hero,
            .section {
                padding: 10px;
            }

            .launcher-grid {
                grid-template-columns: 1fr;
            }

            .launcher {
                width: 100%;
            }

            .share-gallery {
                grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            }
        }
    </style>
</head>

<body>
    <div class="page">
        <header class="hero">
            <div class="hero-logo-wrapper">
                <img src="logo.gif" alt="Logo Go-Toolkit">
            </div>
            <h1>Go-Toolkit</h1>
            <p>Le vaisseau spatial des super-POs</p>
            <span class="hero-version">v2025.12.25.1</span>

            <div class="hero-meta">
                <button id="openFeedbackBtn" class="feedback-button" type="button">☄ Feedback</button>
                <button id="openSettingsBtn" class="feedback-button" type="button">⌘ Paramètres</button>
            </div>
        </header>

        <section class="section">
            <div class="section-title-row">
                <p class="section-label superpower-label label-link" id="superpowerToggle">⚡︎ Super-pouvoirs</p>
            </div>
            <div class="launcher-grid">
                <a class="launcher" href="canvas.html?v=2025.12.25.1">
                    <span class="launcher-emoji">◍</span>
                    <span class="launcher-name">
                        Canvas (50 Nuances)
                        <div class="launcher-desc">Varie ton vocabulaire</div>
                    </span>
                </a>
                <a class="launcher" href="timeline.html?v=2025.12.25.1">
                    <span class="launcher-emoji">⇥</span>
                    <span class="launcher-name">
                        Timeline (Goal Digger)
                        <div class="launcher-desc">Trace ta feuille de route</div>
                    </span>
                </a>
                <a class="launcher" href="draw.html?v=2025.12.25.1">
                    <span class="launcher-emoji">◇</span>
                    <span class="launcher-name">
                        Draw (Indélébile)
                        <div class="launcher-desc">Modélise tes idées</div>
                    </span>
                </a>
                <a class="launcher" href="voice.html?v=2025.12.25.1">
                    <span class="launcher-emoji">▷</span>
                    <span class="launcher-name">
                        Voice (Goal Digger)
                        <div class="launcher-desc">Pilote tes réunions</div>
                    </span>
                </a>
                <a class="launcher" href="grid.html?v=2025.12.25.1">
                    <span class="launcher-emoji">▦</span>
                    <span class="launcher-name">
                        Grid (Le Cardinal)
                        <div class="launcher-desc">Clarifie tes données</div>
                    </span>
                </a>
            </div>
        </section>

        <section class="section">
            <div id="pinnedBlock" hidden>
                <div class="section-title-row" style="margin-top: 4px;">
                    <p class="section-label">⚲ Capsules Favorites</p>
                </div>
                <div id="pinnedGallery" class="share-gallery" aria-live="polite"></div>
            </div>
            <div class="section-title-row">
                <p class="section-label nexus-label label-link" id="nexusToggle" tabindex="0">☍ Station Nexus</p>
            </div>

            <div id="shareGallery" class="share-gallery" aria-live="polite"></div>
            <p id="shareLoading" class="share-helper">Chargement des galeries...</p>
            <p id="shareEmpty" class="share-helper" hidden>Aucune capsule enregistrée en ligne.</p>
            <p id="shareError" class="share-helper share-helper-error" hidden></p>
            <div class="section-title-row" style="margin-top: 12px;">
                <p class="section-label">⬠ Mes capsules</p>
            </div>
            <div id="savedGallery" class="share-gallery" aria-live="polite"></div>
            <p id="savedEmpty" class="share-helper" hidden>Aucune capsule enregistrée localement.</p>
        </section>

        <button id="openRequestsBtn" class="requests-button" type="button">☄ Demandes (<span
                id="requestsCount">0</span>)</button>

        <div id="feedbackModal" class="feedback-modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
            <div class="feedback-modal">
                <header>
                    <h3>☄ Feedback</h3>
                    <button id="closeFeedbackBtn" class="btn-secondary" type="button" aria-label="Fermer">✕</button>
                </header>
                <form id="feedbackForm" class="feedback-form">
                    <div class="field-row">
                        <label>
                            <span class="label-title">Nom</span>
                            <input id="feedbackName" name="name" type="text" autocomplete="name"
                                placeholder="Ton nom" />
                        </label>
                    </div>
                    <label>
                        <span class="label-title">Type <span class="required-asterisk"
                                aria-hidden="true">*</span></span>
                        <select id="feedbackType" name="type" required>
                            <option value="bug-general" selected>Bug Général</option>
                            <option value="bug-canvas">Bug Canvas</option>
                            <option value="bug-draw">Bug Draw</option>
                            <option value="bug-grid">Bug Grid</option>
                            <option value="bug-timeline">Bug Timeline</option>
                            <option value="bug-voice">Bug Voice</option>
                            <option value="suggestion">Suggestion</option>
                        </select>
                    </label>
                    <input type="text" id="feedbackWebsite" name="website"
                        style="position:absolute;left:-9999px;opacity:0;" tabindex="-1" aria-hidden="true"
                        autocomplete="off">
                    <label>
                        <span class="label-title">Sujet</span>
                        <input id="feedbackSubject" name="subject" type="text" placeholder="Titre de la demande"
                            required />
                    </label>
                    <label>
                        <span class="label-title">Message<span class="required-asterisk"
                                aria-hidden="true">*</span></span>
                        <textarea id="feedbackMessage" name="message" rows="10" required
                            placeholder="Décris ton retour"></textarea>
                        <p class="feedback-helper">Pour toute demande de partenariat ou autre, veuillez envoyer un mail
                            à <a href="mailto:quang.tran@savane-group.com">quang.tran@savane-group.com</a>.</p>
                    </label>
                    <div class="feedback-actions">
                        <button type="button" id="cancelFeedbackBtn" class="btn-secondary">Annuler</button>
                        <button type="submit" id="submitFeedbackBtn" class="btn-primary">Envoyer</button>
                    </div>
                </form>
            </div>
        </div>

        <div id="requestsModal" class="feedback-modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
            <div class="requests-modal">
                <header style="display:flex;align-items:center;justify-content:space-between;gap:8px;">
                    <h3 style="margin:0;font-size:1rem;">☄ Demandes</h3>
                    <button id="closeRequestsBtn" class="btn-secondary" type="button" aria-label="Fermer">✕</button>
                </header>
                <div class="requests-body">
                    <aside class="requests-list-panel">
                        <div class="requests-filter">
                            <label style="display:flex;align-items:center;gap:6px;font-size:0.85rem;">
                                Statut
                                <select id="requestsFilter">
                                    <option value="recue">Reçues</option>
                                    <option value="traitee">Traitées</option>
                                    <option value="planifiee">Planifiées</option>
                                    <option value="reportee">Reportées</option>
                                </select>
                            </label>

                        </div>
                        <div id="requestsList" class="requests-list" aria-live="polite"></div>
                    </aside>
                    <section class="requests-content">
                        <div class="request-content-body">
                            <label>
                                Sujet
                                <input id="requestSubject" type="text" readonly />
                            </label>
                            <label>
                                Type
                                <input id="requestType" type="text" readonly />
                            </label>
                            <label id="requestStatusWrapper">
                                Statut
                                <select id="requestStatus" disabled>
                                    <option value="recue">Reçue</option>
                                    <option value="traitee">Traitée</option>
                                    <option value="planifiee">Planifiée</option>
                                    <option value="reportee">Reportée</option>
                                </select>
                            </label>
                            <label>
                                Message
                                <textarea id="requestMessage" rows="12" readonly></textarea>
                            </label>
                            <label>
                                Lien partagé
                                <input id="requestShareUrl" type="text" readonly />
                            </label>
                        </div>
                        <div class="requests-actions">
                            <button id="saveRequestBtn" class="btn-primary" type="button" disabled>Sauvegarder</button>
                        </div>
                    </section>
                </div>
            </div>
        </div>

        <div id="superpowerModal" class="feedback-modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
            <div class="superpower-modal">
                <header>
                    <h3>⚡︎ Super-pouvoirs Go-Live</h3>
                    <button id="closeSuperpowerBtn" class="btn-secondary" type="button" aria-label="Fermer">✕</button>
                </header>
                <div class="superpower-list">
                    <p class="superpower-intro">
                        La Go-Toolkit est un vaisseau des compétences-clés du Product Owner,.
                        Certains ont leur module dédié, d’autres permettent de piloter (cockpit) ou d'accélérer
                        (propulseur) les
                        autres modules, d'autres enfin sont encore en proximité (en orbite).
                    </p>
                    <section>
                        <div class="superpower-head">
                            <h4>◇ Le Cardinal</h4>
                            <div class="superpower-tag-row">
                                <span class="superpower-tag">Module</span>
                            </div>
                        </div>
                        <div class="superpower-subtitle">Le pouvoir de modéliser avec clarté. Vulgariser des structures
                            complexes, expliquer la cardinalité avec pédagogie, et co-créer des schémas métiers
                            structurés. Transformer des brainstorms flous en artefacts limpides.</div>
                    </section>
                    <section>

                        <div class="superpower-head">
                            <h4>◍ 50 nuances de vrai</h4>
                            <div class="superpower-tag-row">
                                <span class="superpower-tag">Module</span>
                            </div>
                        </div>
                        <div class="superpower-subtitle">Varier sincèrement les messages. Dire une même vérité de
                            plusieurs façons, sans trahir son intention. Adapter sa voix à chaque contexte, avec
                            justesse, empathie et cohérence.</div>
                    </section>
                    <section>

                        <div class="superpower-head">
                            <h4>⊞ Le Petit Robert Downey Jr</h4>
                            <div class="superpower-tag-row">
                                <span class="superpower-tag superpower-tag--soon">En orbite</span>
                            </div>
                        </div>
                        <div class="superpower-subtitle">Le pouvoir du discernement sémantique. Rétablir la clarté quand
                            les mots se confondent. Forger un vocabulaire métier partagé, documenté et stable.</div>
                    </section>
                    <section>
                        <div class="superpower-head">
                            <h4>⸙ Gutenberg</h4>
                            <div class="superpower-tag-row">
                                <span class="superpower-tag superpower-tag--cockpit">Cockpit</span>
                            </div>
                        </div>
                        <div class="superpower-subtitle">Le pouvoir de raconter le produit. Documenter le projet au fil
                            de l’eau et le rendre lisible et inspirant. Transformer l’ordinaire du delivery en récit
                            engageant.</div>
                    </section>
                    <section>
                        <div class="superpower-head">
                            <h4>ʃ Indélébile</h4>
                            <div class="superpower-tag-row">
                                <span class="superpower-tag superpower-tag">Module</span>
                            </div>
                        </div>
                        <div class="superpower-subtitle">Le pouvoir de l’ancrage visuel. Facilitation graphique en
                            réunion, ateliers et supports. Faire durer les idées grâce à l’image.</div>
                    </section>
                    <section>
                        <div class="superpower-head">
                            <h4>Ϟ Protocop</h4>
                            <div class="superpower-tag-row">
                                <span class="superpower-tag superpower-tag--soon">En orbite</span>
                            </div>
                        </div>
                        <div class="superpower-subtitle">Le pouvoir de prototyper vite et bien. Donner corps à l’idée
                            avant le développement. Transformer l'intuition en objet de projection et d'envie.</div>
                    </section>
                    <section>
                        <div class="superpower-head">
                            <h4>⌲ Tuto Tarantino</h4>
                            <div class="superpower-tag-row">
                                <span class="superpower-tag superpower-tag--soon">En orbite</span>
                            </div>
                        </div>
                        <div class="superpower-subtitle">Le pouvoir de captiver par des tutoriels vidéo percutants.
                            Rythme, narration, pédagogie : transmettre devient un art.</div>
                    </section>
                    <section>
                        <div class="superpower-head">
                            <h4>⇥ Goal Digger</h4>
                            <div class="superpower-tag-row">
                                <span class="superpower-tag">Module</span>
                            </div>
                        </div>
                        <div class="superpower-subtitle">Le pouvoir de creuser au bon endroit pour faire émerger une
                            vraie roadmap de valeur. Tracer une route claire autour d’objectifs d’impact.</div>
                    </section>
                    <section>
                        <div class="superpower-head">
                            <h4>⛶ Promptzilla</h4>
                            <div class="superpower-tag-row">
                                <span class="superpower-tag superpower-tag--cockpit">Cockpit</span>
                                </span>
                            </div>
                        </div>
                        <div class="superpower-subtitle">Le pouvoir d'invoquer l'IA avec précision et créativité.
                            Utiliser
                            l'IA pour accélérer la production sans sacrifier la rigueur.</div>
                    </section>
                    <section>
                        <div class="superpower-head">
                            <h4>⌘ Soulgorithm</h4>
                            <div class="superpower-tag-row">
                                <span class="superpower-tag superpower-tag--development">Propulseur</span>
                            </div>
                        </div>
                        <div class="superpower-subtitle">Le pouvoir d’imaginer des fonctionnalités IA qui font vraiment
                            sens. Prioriser l’impact utilisateur avant la techno.</div>
                    </section>
                    <section>
                        <div class="superpower-head">
                            <h4>⌬ Pôlène</h4>
                            <div class="superpower-tag-row">
                                <span class="superpower-tag superpower-tag--soon">En orbite</span>
                            </div>
                        </div>
                        <div class="superpower-subtitle">Le pouvoir de concevoir des produits qui exposent leur valeur
                            par la donnée. Anticiper APIs, événements métiers et données pivots pour polliniser
                            l’écosystème.</div>
                    </section>
                </div>
            </div>
        </div>

        <div id="settingsModal" class="feedback-modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
            <div class="feedback-modal">
                <header>
                    <h3>⌘ Paramètres</h3>
                    <button id="closeSettingsBtn" class="btn-secondary" type="button" aria-label="Fermer">✕</button>
                </header>
                <form class="feedback-form" onsubmit="return false;">
                    <div class="field-row">
                        <label style="width:100%">
                            <span class="label-title">Moteur vocal</span>
                            <select id="speechEngineSelect">
                                <option value="web-speech">Web Speech (natif)</option>
                                <option value="whisperer">Whisperer (dev)</option>
                            </select>
                        </label>
                    </div>
                    <div class="field-row">
                        <label style="width:100%">
                            <span class="label-title">Commande vocale</span>
                            <select id="speechModeSelect">
                                <option value="manual">Manuel (par défaut)</option>
                                <option value="auto">Auto (au lancement)</option>
                            </select>
                            <span class="label-subtitle">
                                Désactive l'activation automatique dans chaque module (Grid, Canvas, Draw, Timeline)
                            </span>
                        </label>
                    </div>
                    <div class="field-row">
                        <label>
                            <span class="label-title">Moteur IA</span>
                            <select id="aiBackendSelect">
                                <option value="openai">OpenAI (recommandé)</option>
                                <option value="webllm">WebLLM </option>
                            </select>
                        </label>
                    </div>

                    <div id="openaiSettings">
                        <div class="field-row">
                            <label>
                            </label>
                        </div>
                        <div class="field-row">
                            <label style="width:100%">
                                <div
                                    style="display:flex; align-items:center; justify-content:space-between; gap:0.75rem;">
                                    <div>
                                        <a href="https://platform.openai.com/settings/organization/api-keys"
                                            class="label-title dashed-link" target="_blank"
                                            rel="noopener noreferrer">Clé
                                            API
                                            OpenAI</a>
                                        <span class="ia-status" id="openaiStatus" aria-hidden="true"></span>
                                    </div>
                                    <div style="display:flex; gap:0.35rem;">
                                        <button id="openaiVerifyBtn" type="button"
                                            class="btn-secondary">Vérifier</button>
                                    </div>
                                </div>
                                <span class="label-subtitle">Réponse plus rapide et retranscription avancée (<2€ /mois
                                        en usage normal)</span>
                                        <input id="iaApiKeyInput" type="password" placeholder="sk-..." />
                            </label>
                        </div>

                        <div class="field-row">
                            <label>
                                <span class="label-title">Modèle OpenAI</span>
                                <select id="openaiModelSelect">
                                    <option value="gpt-5-nano">gpt-5-nano</option>
                                    <option value="gpt-5-mini">gpt-5-mini</option>
                                </select>
                            </label>
                        </div>
                        <div class="field-row">
                            <label>
                                <span class="label-title">Effort de raisonnement OpenAI</span>
                                <select id="reasoningEffortSelect">
                                    <option value="minimal">Minimal</option>
                                    <option value="low">Faible</option>
                                    <option value="medium">Moyen </option>
                                    <option value="high">Élevé</option>
                                </select>
                            </label>
                        </div>
                    </div>

                    <div id="webllmSettings" style="display:none;">
                        <div class="field-row">
                            <label style="width:100%">
                                <div
                                    style="display:flex; align-items:center; justify-content:space-between; gap:0.75rem;">
                                    <div>
                                        <span class="label-title">WebLLM</span>
                                        <span class="ia-status" id="webllmStatus" aria-hidden="true"></span>
                                    </div>
                                    <div style="display:flex; gap:0.35rem;">
                                        <button id="webllmInstallBtn" type="button"
                                            class="btn-secondary">Installer</button>
                                        <button id="webllmClearBtn" type="button" class="btn-secondary">Vider</button>
                                        <button id="webllmVerifyBtn" type="button"
                                            class="btn-secondary">Vérifier</button>
                                    </div>
                                </div>
                            </label>
                        </div>

                        <div class="field-row" style="margin-top:8px;">
                            <label>
                                <select id="webllmModelSelect"></select>
                            </label>
                        </div>
                    </div>

                    <div class="field-row" style="margin-top:8px;">
                        <label style="width:100%">
                            <span class="label-title">Token Admin</span>
                            <input id="adminTokenInput" type="text" placeholder="Token pour l'Authorization Bearer" />
                        </label>
                    </div>

                    <div class="feedback-actions">
                        <button id="cancelSettingsBtn" type="button" class="btn-secondary">Annuler</button>
                        <button id="saveSettingsBtn" type="button" class="btn-primary">Sauvegarder</button>
                    </div>
                </form>
            </div>
        </div>

        <div id="nexusModal" class="feedback-modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
            <div class="nexus-modal">
                <header>
                    <h2> ☍ Fonctionnement de la Station Nexus</h2>
                    <button id="closeNexusBtn" class="btn-secondary" type="button" aria-label="Fermer">✕</button>
                </header>
                <div class="nexus-content">

                    <p><strong>⌬ Cas d'usages </strong><br>
                        Go-Toolkit est conçu pour un usage professionnel : animation d’ateliers, cadrages, documentation
                        produit et collaboration avec la technique ou le métier</p>

                    <p><strong>⛒ Anonymité et confidentialité</strong><br>
                        Aucun compte n’est requis pour utiliser l'outil. Vous êtes responsable du contenu que
                        vous saisissez, notamment s’il contient des données personnelles ou confidentielles.</p>

                    <p><strong>⚲ Données personnelles</strong><br>
                        Go-Toolkit ne collecte aucune donnée personnelle automatiquement. Les seules informations
                        personnelles pouvant être traitées le sont uniquement à des fins d'amélioration du produit
                        (feedback).</p>

                    <p><strong>⌘ Intelligence Artificielle (OpenAI)</strong><br>
                        Vos données restent dans votre navigateur sauf lorsque vous déclenchez un appel IA. Dans ce cas,
                        seules les informations strictement nécessaires sont envoyées à OpenAI. Ne transmettez jamais de
                        données
                        sensibles.</p>

                    <p><strong>⟐ Accès privé ou partagé</strong><br>
                        Vous pouvez utiliser votre propre clé OpenAI (accès privé) ou l’accès partagé par défaut (avec
                        quotas). Dans les deux cas, seules les informations isolées et utiles sont transmises.</p>

                    <p><strong>⧉ Données dans le cloud</strong><br>
                        Vous pouvez partager vos capsules via des liens URL uniques. Les capsules sont alors
                        stockées dans le cloud et modifiables par les personnes disposant du lien. Elles peuvent
                        également être supprimés par son créateur depuis sa station Nexus. Aucun backup n’est
                        réalisée.</p>

                    <p><strong>⚠ Risques de perte de données</strong><br>
                        Les capsules locales peuvent être perdues en cas de nettoyage de navigateur, navigation privée
                        ou
                        crash. Firestore ou le proxy public OpenAI peuvent connaître des indisponibilités. Go-Live ne
                        peut être tenu
                        responsable des pertes ou interruptions liées à ces services tiers.</p>

                    <p><strong>⇧ Exportation et réutilisation</strong><br>
                        Vos données peuvent être exportées librement pour archivage, partage ou intégration dans
                        d’autres outils métiers.
                        Cela renforce l’usage professionnel : traçabilité, capitalisation, documentation.</p>


                </div>
            </div>
        </div>

        <div id="feedbackToast" class="toast" role="status" aria-live="polite"></div>
    </div>

    <script>
        window.GO_TOOLKIT_SHARE_API_URL =
            window.GO_TOOLKIT_SHARE_API_URL || "https://share.gotoolkit.workers.dev/";
    </script>
    <script src="js/idb-doc-store.js"></script>
    <script src="js/storage-service.js"></script>
    <script src="js/shared-ui.js"></script>
    <script src="js/share-worker-client.js"></script>
    <script src="js/share-history.js"></script>
    <script src="js/capsule-drafts.js"></script>
    <script src="js/ia-config.js"></script>
    <script>
        (function () {
            const modal = document.getElementById("superpowerModal");
            const openBtn = document.getElementById("superpowerToggle");
            const closeBtn = document.getElementById("closeSuperpowerBtn");
            function close() {
                if (!modal) return;
                modal.classList.remove("open");
                modal.setAttribute("aria-hidden", "true");
            }
            function open() {
                if (!modal) return;
                modal.classList.add("open");
                modal.setAttribute("aria-hidden", "false");
            }
            openBtn?.addEventListener("click", open);
            closeBtn?.addEventListener("click", close);
            modal?.addEventListener("click", event => {
                if (event.target === modal) {
                    close();
                }
            });
        })();
    </script>
    <script>
        (function () {
            const modal = document.getElementById("nexusModal");
            const openBtn = document.getElementById("nexusToggle");
            const closeBtn = document.getElementById("closeNexusBtn");
            function close() {
                if (!modal) return;
                modal.classList.remove("open");
                modal.setAttribute("aria-hidden", "true");
            }
            function open() {
                if (!modal) return;
                modal.classList.add("open");
                modal.setAttribute("aria-hidden", "false");
            }
            openBtn?.addEventListener("click", open);
            openBtn?.addEventListener("keypress", event => {
                if (event.key === "Enter" || event.key === " ") {
                    event.preventDefault();
                    open();
                }
            });
            closeBtn?.addEventListener("click", close);
            modal?.addEventListener("click", event => {
                if (event.target === modal) {
                    close();
                }
            });
        })();
    </script>
    <script>
        (function () {
            function closeModalById(id) {
                const el = document.getElementById(id);
                if (!el) return;
                el.classList.remove("open");
                el.setAttribute("aria-hidden", "true");
            }
            document.addEventListener("keydown", event => {
                if (event.key !== "Escape" && event.key !== "Esc") return;
                closeModalById("superpowerModal");
                closeModalById("nexusModal");
            });
        })();
    </script>
    <script>
        (function () {
            const gallery = document.getElementById("shareGallery");
            const pinnedGallery = document.getElementById("pinnedGallery");
            const pinnedBlock = document.getElementById("pinnedBlock");
            const loadingLabel = document.getElementById("shareLoading");
            const emptyLabel = document.getElementById("shareEmpty");
            const errorLabel = document.getElementById("shareError");
            const refreshBtn = document.getElementById("refreshShares");
            const shareHistory = window.goToolkitShareHistory;
            const shareService = window.goToolkitShareWorker;
            const savedGallery = document.getElementById("savedGallery");
            const savedEmpty = document.getElementById("savedEmpty");
            const capsuleDrafts = window.goToolkitCapsuleDrafts;

            const APP_DEFINITIONS = {
                nuances: { emoji: "◍", name: "Canvas", page: "canvas.html?v=2025.12.25.1", collection: "slides" },
                plan: { emoji: "⇥", name: "Timeline", page: "timeline.html?v=2025.12.25.1", collection: "timelines" },
                draw: { emoji: "◇", name: "Draw", page: "draw.html?v=2025.12.25.1", collection: "diagrams" },
                grid: { emoji: "▦", name: "Grid", page: "grid.html?v=2025.12.25.1", collection: "grids" },
                voice: { emoji: "▷", name: "Voice", page: "voice.html?v=2025.12.25.1", collection: "voices" }
            };
            const GRID_TEMPLATE_LABELS = {
                "tree-structure": "Structure de données",
                "data-mapping": "Mapping de données",
                "data-mock": "Données fictives"
            };
            let refreshGalleryPromise = null;
            let refreshSavedPromise = null;

            function setState({ loading = false, hasData = false, hasPinned = false, hasRegular = false, error = "" }) {
                if (loadingLabel) {
                    loadingLabel.hidden = !loading;
                }
                if (emptyLabel) {
                    emptyLabel.hidden = loading || hasRegular || Boolean(error) || hasPinned;
                }
                if (pinnedBlock) {
                    pinnedBlock.hidden = !hasPinned;
                }
                if (errorLabel) {
                    errorLabel.hidden = !error;
                    errorLabel.textContent = error || "";
                }
            }

            function formatFriendlyDate(isoString) {
                if (!isoString) return "Mis à jour";
                try {
                    const value = new Date(isoString).getTime();
                    if (Number.isNaN(value)) return "Mis à jour";
                    const deltaSeconds = Math.max(0, Math.floor((Date.now() - value) / 1000));
                    if (deltaSeconds < 60) return "À l'instant";
                    const deltaMinutes = Math.floor(deltaSeconds / 60);
                    if (deltaMinutes < 60) return `Il y a ${deltaMinutes} min`;
                    const deltaHours = Math.floor(deltaMinutes / 60);
                    if (deltaHours < 24) return `Il y a ${deltaHours} h`;
                    const deltaDays = Math.floor(deltaHours / 24);
                    if (deltaDays < 30) return `Il y a ${deltaDays} j`;
                    const formatter = new Intl.DateTimeFormat("fr-FR", {
                        day: "2-digit",
                        month: "short",
                        hour: "2-digit",
                        minute: "2-digit"
                    });
                    return formatter.format(new Date(value));
                } catch (err) {
                    return "Mis à jour";
                }
            }

            function normalizeLines(value) {
                if (!value) return [];
                return value
                    .split(/\r?\n/)
                    .map(line => line.trim())
                    .filter(Boolean)
                    .slice(0, 2);
            }

            const DRAW_TYPE_LABELS = {
                sequence: "Échange",
                flow: "Processus",
                class: "Structure"
            };

            function stripEmojiPrefix(text) {
                if (!text || typeof text !== "string") return "";
                try {
                    return text.replace(/^[\p{Emoji_Presentation}\p{Emoji}\u200d\ufe0f]+\s*/u, "").trim();
                } catch (e) {
                    return text.trim();
                }
            }

            function buildMetaBadge(label) {
                if (!label) return "";
                const clean = stripEmojiPrefix(label);
                if (!clean) return "";
                const safe = clean.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                return `<span class="superpower-tag">${safe}</span>`;
            }

            function extractPreview(app, payload) {
                let templateLabel = "";
                if (app === "nuances") {
                    const firstSlide = payload?.slides?.[0];
                    const tabName = firstSlide?.title || "Sans titre";
                    const context = payload?.settings?.globalContext || payload?.settings?.context || "";
                    templateLabel =
                        payload?.settings?.templateName ||
                        payload?.settings?.defaultTemplateId ||
                        firstSlide?.templateName ||
                        firstSlide?.templateId ||
                        "";
                    return { tabName, lines: normalizeLines(context), templateLabel };
                }
                if (app === "plan") {
                    const firstView = payload?.views?.[0];
                    const tabName = firstView?.title || firstView?.name || "Planning";
                    const brief = payload?.brief || "";
                    templateLabel =
                        payload?.templateName ||
                        firstView?.context?.templateName ||
                        firstView?.context?.templateId ||
                        "";
                    return { tabName, lines: normalizeLines(brief), templateLabel };
                }
                if (app === "draw") {
                    const firstPage = payload?.pages?.[0];
                    const tabName = firstPage?.title || firstPage?.label || "Page 1";
                    const context = firstPage?.input || "";
                    templateLabel =
                        payload?.templateName ||
                        payload?.templateId ||
                        payload?.template?.name ||
                        payload?.template?.id ||
                        "";
                    const drawType = firstPage?.drawType || payload?.drawType || "";
                    const drawTypeLabel = DRAW_TYPE_LABELS[drawType] || drawType || "";
                    return { tabName, lines: normalizeLines(context), templateLabel, drawTypeLabel };
                }
                if (app === "grid") {
                    const tabName = payload?.title || "Tableau";
                    const context = payload?.scenario || "";
                    const templateLabel =
                        payload?.templateLabel ||
                        GRID_TEMPLATE_LABELS[payload?.templateId] ||
                        payload?.templateId ||
                        "";
                    return { tabName, lines: normalizeLines(context), templateLabel };
                }
                if (app === "voice") {
                    const firstPage = payload?.pages?.[0];
                    const tabName = firstPage?.title || "Voice";
                    const summary = firstPage?.summary || "";
                    const transcript = firstPage?.transcript || "";
                    const scenario = firstPage?.scenario || "";
                    const lines = normalizeLines(summary || scenario || transcript);
                    const templateLabel = firstPage?.templateName || firstPage?.templateId || "";
                    return { tabName, lines, templateLabel };
                }
                return { tabName: "Sans titre", lines: [], templateLabel: "" };
            }

            async function getStoredRecords() {
                if (!shareHistory) {
                    return [];
                }
                const records = await shareHistory.getRecords() || {};
                return Object.entries(records)
                    .filter(([app, record]) => APP_DEFINITIONS[app] && record?.token)
                    .map(([app, record]) => ({ app, record }));
            }

            function buildShareUrl(definition, token) {
                const url = new URL(definition.page, window.location.origin);
                url.searchParams.set("share", token);
                return url.toString();
            }

            function createShareCardElement(cardInfo, target = "_blank") {
                const { definition, preview, formattedDate, href, app, record } = cardInfo;
                const card = document.createElement("a");
                card.className = "share-card";
                card.href = href;
                card.target = target;
                card.rel = target === "_self" ? "noopener" : "noopener noreferrer";
                card.setAttribute("data-app", app);
                const metaHtml = buildMetaBadge(preview.templateLabel || preview.drawTypeLabel);
                card.innerHTML = `
                    <p class="share-card-title">${definition.emoji} ${preview.tabName}</p>
                    ${metaHtml}
                    <p class="share-card-desc">${preview.lines.join(" · ") || "(sans contexte)"}</p>
                    <p class="share-card-date">${formattedDate}</p>
                `;
                const pinBtn = document.createElement("button");
                pinBtn.type = "button";
                pinBtn.className = "share-card-action share-card-pin";
                const isPinned = Boolean(record.pinned);
                pinBtn.title = isPinned ? "Retirer des favoris" : "Ajouter aux favoris";
                pinBtn.textContent = isPinned ? "⚲" : "⚲";
                pinBtn.addEventListener("click", async event => {
                    event.preventDefault();
                    event.stopPropagation();
                    const nextPinned = !isPinned;
                    await shareHistory?.upsertRecord?.(app, { ...record, pinned: nextPinned });
                    refreshGallery().catch(() => { /* noop */ });
                });
                const deleteBtn = document.createElement("button");
                deleteBtn.type = "button";
                deleteBtn.className = "share-card-action share-card-delete";
                deleteBtn.title = "Supprimer cette capsule";
                deleteBtn.textContent = "×";
                deleteBtn.addEventListener("click", async event => {
                    event.preventDefault();
                    event.stopPropagation();
                    const confirmed = window.confirm("Supprimer cette capsule ?");
                    if (!confirmed) return;
                    try {
                        await shareService?.deleteSharePayload?.(definition.collection, record.token);
                    } catch (err) {
                        console.warn("Suppression distante impossible", err);
                    }
                    await shareHistory?.removeRecord?.(app);
                    refreshGallery().catch(() => { /* noop */ });
                });
                card.appendChild(pinBtn);
                card.appendChild(deleteBtn);
                return card;
            }

            async function buildShareCard(app, record) {
                const definition = APP_DEFINITIONS[app];
                if (!definition || !shareService?.isReady) {
                    return null;
                }
                let result;
                try {
                    result = await shareService.fetchSharePayload(definition.collection, record.token);
                } catch (err) {
                    console.error(`Impossible de récupérer la capsule ${app}`, err);
                    return null;
                }
                if (!result || !result.payload) {
                    await shareHistory?.removeRecord?.(app);
                    return null;
                }
                const preview = extractPreview(app, result.payload);
                const updatedAt = record.updatedAt || result.meta?.updatedAt || new Date().toISOString();
                const formattedDate = formatFriendlyDate(updatedAt);
                const href = buildShareUrl(definition, record.token);
                const isPinned = Boolean(record.pinned);
                const cardInfo = { app, definition, record, preview, formattedDate, href };
                const card = createShareCardElement(cardInfo);
                return { ...cardInfo, card, updatedAt, isPinned };
            }

            function buildSavedCard(record) {
                if (!record || !capsuleDrafts) {
                    return null;
                }
                const definition = APP_DEFINITIONS[record.app];
                if (!definition) {
                    return null;
                }
                const preview = extractPreview(record.app, record.payload || {});
                const formattedDate = formatFriendlyDate(record.updatedAt);
                const url = new URL(definition.page, window.location.origin);
                url.searchParams.set("edit", record.id);
                const card = document.createElement("a");
                card.className = "share-card";
                card.href = url.toString();
                card.target = "_self";
                card.rel = "noopener";
                card.setAttribute("data-app", record.app);
                const metaHtml = buildMetaBadge(preview.templateLabel || preview.drawTypeLabel);
                card.innerHTML = `
                    <p class="share-card-title">${definition.emoji} ${preview.tabName}</p>
                    ${metaHtml}
                    <p class="share-card-desc">${preview.lines.join(" · ") || "Complète le contexte pour l'afficher ici."}</p>
                    <p class="share-card-date">${formattedDate}</p>
                `;
                const pinBtn = document.createElement("button");
                pinBtn.type = "button";
                pinBtn.className = "share-card-action share-card-pin";
                const isPinned = Boolean(record.pinned);
                pinBtn.title = isPinned ? "Retirer des favoris" : "Ajouter aux favoris";
                pinBtn.textContent = "⚲";
                pinBtn.addEventListener("click", async event => {
                    event.preventDefault();
                    event.stopPropagation();
                    const nextPinned = !isPinned;
                    await capsuleDrafts.setPinned?.(record.id, nextPinned);
                    refreshSavedGallery().catch(() => { /* noop */ });
                });
                const deleteBtn = document.createElement("button");
                deleteBtn.type = "button";
                deleteBtn.className = "share-card-action share-card-delete";
                deleteBtn.title = "Supprimer cette capsule";
                deleteBtn.textContent = "×";
                deleteBtn.addEventListener("click", async event => {
                    event.preventDefault();
                    event.stopPropagation();
                    const confirmed = window.confirm("Supprimer cette capsule ?");
                    if (!confirmed) return;
                    if (record.app === "voice") {
                        await deleteVoiceAudio(record.id);
                    }
                    await capsuleDrafts.removeRecord?.(record.id);
                    refreshSavedGallery().catch(() => { /* noop */ });
                });
                card.appendChild(pinBtn);
                card.appendChild(deleteBtn);
                return { card, isPinned, updatedAt: record.updatedAt, preview };
            }

            async function refreshSavedGallery() {
                if (refreshSavedPromise) {
                    return refreshSavedPromise;
                }
                refreshSavedPromise = (async () => {
                    if (!savedGallery) {
                        return;
                    }
                    savedGallery.innerHTML = "";
                    if (!capsuleDrafts || typeof capsuleDrafts.getAllRecords !== "function") {
                        if (savedEmpty) savedEmpty.hidden = false;
                        return;
                    }
                    const records = await capsuleDrafts.getAllRecords();
                    const seenIds = new Set();
                    const entries = records.filter(record => {
                        const definition = APP_DEFINITIONS[record.app];
                        if (!definition) return false;
                        const key = `${record.app}::${record.id}`;
                        if (seenIds.has(key)) return false;
                        seenIds.add(key);
                        return true;
                    });
                    const staleIds = [];
                    const filtered = entries.filter(record => {
                        const hasPayload = record && record.payload && typeof record.payload === "object";
                        if (!hasPayload && record?.id) {
                            staleIds.push(record.id);
                        }
                        return hasPayload;
                    });
                    if (staleIds.length) {
                        await Promise.all(staleIds.map(id => capsuleDrafts.removeRecord?.(id)));
                    }
                    if (!filtered.length) {
                        if (savedEmpty) savedEmpty.hidden = false;
                        return;
                    }
                    if (savedEmpty) savedEmpty.hidden = true;
                    // Deduplicate saved drafts that are already present in shared gallery
                    const sharedKeys = window.__goToolkitSharedPreviewKeys || new Set();
                    // Deduplicate both against shared and within saved
                    const seenSavedKeys = new Set();
                    const cards = filtered
                        .map(buildSavedCard)
                        .filter(Boolean)
                        .filter(item => {
                            try {
                                const definition = APP_DEFINITIONS[item.card.getAttribute("data-app")];
                                const key = `${definition.collection}::${item.preview.tabName}::${(item.preview.lines || []).join("|")}`;
                                if (sharedKeys.has(key)) return false;
                                if (seenSavedKeys.has(key)) return false;
                                seenSavedKeys.add(key);
                                return true;
                            } catch (e) {
                                return true;
                            }
                        });
                    // Front dedupe: avoid duplicate hrefs
                    const hrefSeen = new Set();
                    const uniqueCards = cards.filter(item => {
                        const href = item.card?.getAttribute("href");
                        if (!href) return true;
                        if (hrefSeen.has(href)) return false;
                        hrefSeen.add(href);
                        return true;
                    });
                    const pinned = uniqueCards
                        .filter(card => card.isPinned)
                        .sort((a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime());
                    const regular = uniqueCards
                        .filter(card => !card.isPinned)
                        .sort((a, b) => {
                            const nameA = (a.preview?.tabName || "").toLowerCase();
                            const nameB = (b.preview?.tabName || "").toLowerCase();
                            if (nameA && nameB) return nameA.localeCompare(nameB, "fr");
                            return 0;
                        });
                    pinned.forEach(item => savedGallery.appendChild(item.card));
                    regular.forEach(item => savedGallery.appendChild(item.card));
                    if (savedEmpty) savedEmpty.hidden = pinned.length + regular.length > 0;
                })().finally(() => {
                    refreshSavedPromise = null;
                });
                return refreshSavedPromise;
            }

            async function refreshGallery() {
                if (refreshGalleryPromise) {
                    return refreshGalleryPromise;
                }
                refreshGalleryPromise = (async () => {
                    if (!shareHistory) {
                        setState({ loading: false, hasData: false, error: "Historique des capsules indisponible." });
                        return;
                    }
                    if (!shareService?.isReady) {
                        setState({ loading: false, hasData: false, error: "Service de capsules indisponible." });
                        return;
                    }
                    setState({ loading: true, hasData: false, error: "", hasPinned: false, hasRegular: false });
                    gallery.innerHTML = "";
                    if (pinnedGallery) pinnedGallery.innerHTML = "";
                    const entries = await getStoredRecords();
                    if (!entries.length) {
                        setState({ loading: false, hasData: false, error: "", hasPinned: false, hasRegular: false });
                        return;
                    }
                    const cards = await Promise.all(entries.map(({ app, record }) => buildShareCard(app, record)));
                    const validCards = cards.filter(Boolean);
                    // Build a quick set of preview keys to help deduplicate saved drafts that refer to the same content
                    try {
                        const previewKeys = new Set(validCards.map(item => {
                            const coll = item.definition.collection || String(item.definition.name || item.app);
                            const tab = item.preview?.tabName || "";
                            const lines = (item.preview?.lines || []).join("|");
                            return `${coll}::${tab}::${lines}`;
                        }));
                        window.__goToolkitSharedPreviewKeys = previewKeys;
                    } catch (e) {
                        window.__goToolkitSharedPreviewKeys = new Set();
                    }
                    if (!validCards.length) {
                        setState({ loading: false, hasData: false, error: "", hasPinned: false, hasRegular: false });
                        return;
                    }
                    const pinned = validCards
                        .filter(item => item.isPinned)
                        .sort((a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime());
                    const regular = validCards
                        .filter(card => !card.isPinned)
                        .sort((a, b) => {
                            const nameA = (a.preview?.tabName || "").toLowerCase();
                            const nameB = (b.preview?.tabName || "").toLowerCase();
                            if (nameA && nameB) return nameA.localeCompare(nameB, "fr");
                            return 0;
                        });

                    if (pinnedGallery) {
                        pinned.forEach(item => pinnedGallery.appendChild(item.card));
                    }
                    regular.forEach(item => gallery.appendChild(item.card));
                    const hasPinned = pinned.length > 0;
                    const hasRegular = regular.length > 0;
                    setState({ loading: false, hasData: hasPinned || hasRegular, hasPinned, hasRegular, error: "" });
                })().finally(() => {
                    refreshGalleryPromise = null;
                });
                return refreshGalleryPromise;
            }

            refreshBtn?.addEventListener("click", () => {
                (async () => {
                    try {
                        await shareHistory?.refreshFromStore?.();
                    } catch (err) {
                        console.warn("Impossible de rafraîchir les capsules partagées", err);
                    }
                    refreshGallery().catch(() => { /* noop */ });
                    refreshSavedGallery().catch(() => { /* noop */ });
                })();
            });

            (async () => {
                try {
                    await shareHistory?.refreshFromStore?.();
                } catch (err) {
                    console.warn("Impossible de rafraîchir les capsules partagées", err);
                }
                refreshGallery().catch(() => { /* noop */ });
                refreshSavedGallery().catch(() => { /* noop */ });
            })();
            window.addEventListener("pageshow", () => {
                refreshGallery().catch(() => { /* noop */ });
                refreshSavedGallery().catch(() => { /* noop */ });
            });
            window.addEventListener("storage", () => refreshSavedGallery().catch(() => { /* noop */ }));
        })();
    </script>
    <script type="module">
        const feedbackModal = document.getElementById("feedbackModal");
        const openFeedbackBtn = document.getElementById("openFeedbackBtn");
        const closeFeedbackBtn = document.getElementById("closeFeedbackBtn");
        const cancelFeedbackBtn = document.getElementById("cancelFeedbackBtn");
        const feedbackForm = document.getElementById("feedbackForm");
        const feedbackType = document.getElementById("feedbackType");
        const feedbackMessage = document.getElementById("feedbackMessage");
        const feedbackSubject = document.getElementById("feedbackSubject");
        const submitFeedbackBtn = document.getElementById("submitFeedbackBtn");
        const toastEl = document.getElementById("feedbackToast");
        const messagePlaceholders = {
            bug: "Décris le bug, les étapes pour reproduire, le résultat attendu et le résultat observé.",
            suggestion: "Décris la suggestion, le contexte et l'impact attendu."
        };
        const requestsBtn = document.getElementById("openRequestsBtn");
        const requestsModal = document.getElementById("requestsModal");
        const closeRequestsBtn = document.getElementById("closeRequestsBtn");
        const requestsList = document.getElementById("requestsList");
        const requestsFilter = document.getElementById("requestsFilter");
        const requestsCountLabel = document.getElementById("requestsCount");
        const requestSubject = document.getElementById("requestSubject");
        const requestTypeField = document.getElementById("requestType");
        const requestStatusSelect = document.getElementById("requestStatus");
        const requestStatusWrapper = document.getElementById("requestStatusWrapper");
        const requestMessageField = document.getElementById("requestMessage");
        const requestShareUrl = document.getElementById("requestShareUrl");
        const saveRequestBtn = document.getElementById("saveRequestBtn");
        const feedbackWebsite = document.getElementById("feedbackWebsite");
        const adminTokenInput = document.getElementById("adminTokenInput");
        const REQUEST_STATUS_LABELS = {
            recue: "Reçue",
            traitee: "Traitée",
            planifiee: "Planifiée",
            reportee: "Reportée"
        };
        let requestsState = { items: [], canEdit: false };
        let activeRequestId = null;

        function showToast(message, isError = false) {
            if (!toastEl) return;
            toastEl.textContent = message;
            toastEl.classList.toggle("error", Boolean(isError));
            toastEl.classList.add("show");
            setTimeout(() => toastEl.classList.remove("show"), 3200);
        }

        function updateMessagePlaceholder(type) {
            const normalized = type && String(type).toLowerCase().startsWith("bug") ? "bug" : type;
            const placeholder = messagePlaceholders[normalized] || messagePlaceholders.bug;
            feedbackMessage.placeholder = placeholder;
        }

        function renderRequestDetail(item) {
            const hasItem = Boolean(item);
            if (requestSubject) requestSubject.value = hasItem ? (item.subject || "") : "";
            if (requestTypeField) requestTypeField.value = hasItem ? (item.type || "") : "";
            if (requestStatusSelect) requestStatusSelect.value = hasItem ? (item.status || "recue") : "recue";
            if (requestMessageField) requestMessageField.value = hasItem ? (item.message || "") : "";
            if (requestShareUrl) requestShareUrl.value = hasItem ? (item.shareUrl || "") : "";
            if (requestsState.canEdit && hasItem) {
                requestSubject?.removeAttribute("readonly");
                requestMessageField?.removeAttribute("readonly");
                requestStatusSelect?.removeAttribute("disabled");
                saveRequestBtn.disabled = false;
            } else {
                requestSubject?.setAttribute("readonly", "true");
                requestMessageField?.setAttribute("readonly", "true");
                requestStatusSelect?.setAttribute("disabled", "true");
                saveRequestBtn.disabled = true;
            }
        }

        function renderRequestsList() {
            if (!requestsList) return;
            requestsList.innerHTML = "";
            const filter = requestsFilter?.value || "recue";
            const items = requestsState.items
                .filter(item => item.status === filter)
                .sort((a, b) => new Date(b.createdAt || 0).getTime() - new Date(a.createdAt || 0).getTime());
            if (!items.length) {
                const empty = document.createElement("p");
                empty.textContent = "Aucune demande pour ce statut.";
                empty.className = "share-helper";
                requestsList.appendChild(empty);
                return;
            }
            items.forEach(item => {
                const el = document.createElement("div");
                el.className = "requests-item";
                if (item.id === activeRequestId) el.classList.add("active");
                const title = document.createElement("p");
                title.className = "requests-item-title";
                title.textContent = item.subject || "(sans sujet)";
                const meta = document.createElement("p");
                meta.className = "requests-item-meta";
                meta.textContent = `${REQUEST_STATUS_LABELS[item.status] || "Reçue"} · ${(item.type || "").toUpperCase()} · ${item.name || "Anonyme"}`;
                const msg = document.createElement("p");
                el.appendChild(title);
                el.appendChild(meta);
                el.addEventListener("click", () => {
                    activeRequestId = item.id;
                    renderRequestsList();
                    renderRequestDetail(item);
                });
                requestsList.appendChild(el);
            });
        }

        function updateRequestCounters() {
            const total = requestsState.items.length;
            const filter = requestsFilter?.value || "recue";
            const statusCounts = requestsState.items.reduce((acc, item) => {
                const key = item.status || "recue";
                acc[key] = (acc[key] || 0) + 1;
                return acc;
            }, {});
            if (requestsCountLabel) requestsCountLabel.textContent = statusCounts.recue || 0;
            if (requestsFilter) {
                Array.from(requestsFilter.options).forEach(opt => {
                    const key = opt.value;
                    const count = statusCounts[key] || 0;
                    opt.textContent = `${REQUEST_STATUS_LABELS[key] || key} (${count})`;
                });
            }
        }

        async function fetchRequests() {
            try {
                const endpoint = (window.GO_TOOLKIT_FEEDBACK_API_URL || "https://feedback.gotoolkit.workers.dev/v1/feedback") + "";
                const response = await fetch(endpoint, { method: "GET" });
                if (!response.ok) {
                    throw new Error("HTTP " + response.status);
                }
                const data = await response.json();
                const items = Array.isArray(data.items) ? data.items : [];
                // Ignore server-side IP-based admin flag and allow editing in the UI
                requestsState = { items, canEdit: true };
                if (requestStatusWrapper) {
                    requestStatusWrapper.style.display = "";
                }
                updateRequestCounters();
                renderRequestsList();
                if (items.length) {
                    activeRequestId = items[0].id;
                    renderRequestDetail(items[0]);
                } else {
                    activeRequestId = null;
                    renderRequestDetail(null);
                }
            } catch (err) {
                console.warn("Impossible de charger les demandes", err);
                if (requestsList) {
                    requestsList.innerHTML = "";
                    const p = document.createElement("p");
                    p.className = "share-helper share-helper-error";
                    p.textContent = "Impossible de charger les demandes : " + (err && err.message ? err.message : "erreur");
                    requestsList.appendChild(p);
                }
                if (requestsCountLabel) requestsCountLabel.textContent = "0";
            }
        }

        async function saveCurrentRequest() {
            if (!requestsState.canEdit || !activeRequestId) return;
            saveRequestBtn.disabled = true;
            saveRequestBtn.textContent = "Sauvegarde...";
            try {
                const endpoint = (window.GO_TOOLKIT_FEEDBACK_API_URL || "https://feedback.gotoolkit.workers.dev/v1/feedback") + "/" + encodeURIComponent(activeRequestId);
                const current = requestsState.items.find(i => i.id === activeRequestId) || {};
                const payload = {
                    subject: (requestSubject?.value || "").trim(),
                    message: (requestMessageField?.value || "").trim(),
                    status: (requestStatusSelect?.value || "recue"),
                    type: (requestTypeField?.value || "").toLowerCase(),
                    name: current.name || null
                };
                const headers = { "Content-Type": "application/json" };
                try {
                    const token = (adminTokenInput?.value || localStorage.getItem("feedback-admin-token") || "").trim();
                    if (token) headers["Authorization"] = "Bearer " + token;
                } catch (e) { /* noop */ }
                const response = await fetch(endpoint, {
                    method: "PUT",
                    headers,
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                    const text = await response.text().catch(() => "");
                    throw new Error(text || "Sauvegarde impossible");
                }
                await fetchRequests();
                showToast("Demande mise à jour.");
            } catch (err) {
                console.error("Sauvegarde demande impossible", err);
                showToast("Sauvegarde impossible", true);
            } finally {
                saveRequestBtn.disabled = false;
                saveRequestBtn.textContent = "Sauvegarder";
            }
        }
        function updateStatusIcon(el, state) {
            if (!el) {
                return;
            }
            const icons = {
                ready: "🗹",
                verifying: "⌛",
                error: "✕"
            };
            if (!state) {
                el.textContent = "";
                el.classList.remove("ia-status--error");
                return;
            }
            el.textContent = icons[state] || "";
            if (state === "error") {
                el.classList.add("ia-status--error");
            } else {
                el.classList.remove("ia-status--error");
            }
        }

        function getWebllmModelLabel(modelId) {
            if (!modelId) return "WebLLM";
            const models = window.GoToolkitIAConfig?.WEBLLM_MODELS || [];
            const match = models.find(entry => entry.id === modelId);
            return (match && match.label) || modelId || "WebLLM";
        }

        function isSupportedWebllmModel(modelId) {
            const models = window.GoToolkitIAConfig?.WEBLLM_MODELS || [];
            return models.some(entry => entry.id === modelId);
        }

        function formatWebllmOptionLabel(entry, installed, meta, rawLabel) {
            const base = rawLabel || entry.label || entry.id;
            const parts = [];
            if (meta?.features?.length) parts.push(meta.features.join(","));
            const suffix = parts.length ? ` (${parts.join(" · ")})` : "";
            const icon = installed === false ? "⭳ " : "";
            return icon + base + suffix;
        }

        async function detectGpuCapabilities() {
            if (!navigator.gpu || typeof navigator.gpu.requestAdapter !== "function") {
                return { adapter: null, features: new Set(), limits: {} };
            }
            try {
                const adapter = await navigator.gpu.requestAdapter();
                if (!adapter) return { adapter: null, features: new Set(), limits: {} };
                const features = new Set(adapter.features ? Array.from(adapter.features) : []);
                const limits = adapter.limits ? { ...adapter.limits } : {};
                return { adapter, features, limits };
            } catch (err) {
                console.warn("GPU capability detection failed", err);
                return { adapter: null, features: new Set(), limits: {} };
            }
        }

        function meetsModelRequirements(model, gpuInfo) {
            if (!model) return true;
            const features = gpuInfo.features || new Set();
            const limits = gpuInfo.limits || {};
            const requiredFeatures = model.required_features || [];
            for (const feat of requiredFeatures) {
                if (!features.has(feat)) return false;
            }
            if (model.buffer_size_required_bytes && limits.maxStorageBufferBindingSize) {
                if (limits.maxStorageBufferBindingSize < model.buffer_size_required_bytes) {
                    return false;
                }
            }
            return true;
        }

        async function buildWebllmModelOptions() {
            if (!webllmModelSelect) return;
            webllmModelSelect.innerHTML = "";
            const appConfig = await (window.GoToolkitWebLLM?.getAppConfig?.() || window.GoToolkitIAConfig?.WEBLLM_MODELS);
            const gpuInfo = await detectGpuCapabilities();
            const prebuiltList = appConfig?.model_list || [];
            const fallbackList = window.GoToolkitIAConfig?.WEBLLM_MODELS || [];
            const mappedPrebuilt = prebuiltList.map(item => ({
                id: item.model_id,
                label: item.model_id,
                required_features: item.required_features,
                buffer_size_required_bytes: item.buffer_size_required_bytes,
                vram_required_MB: item.vram_required_MB
            }));
            const mappedFallback = fallbackList.map(entry => ({
                id: entry.id,
                label: entry.label,
                required_features: entry.required_features || [],
                buffer_size_required_bytes: entry.buffer_size_required_bytes,
                vram_required_MB: entry.vram_required_MB
            }));
            const mergedMap = new Map();
            [...mappedPrebuilt, ...mappedFallback].forEach(entry => {
                if (entry.id && !mergedMap.has(entry.id)) {
                    mergedMap.set(entry.id, entry);
                }
            });
            const list = Array.from(mergedMap.values());
            const options = [];
            let hasModelInCacheFn = null;
            try {
                const mod = await import("https://esm.sh/@mlc-ai/web-llm");
                hasModelInCacheFn = mod.hasModelInCache || (mod.default && mod.default.hasModelInCache);
            } catch (err) {
                /* ignore */
            }
            for (const entry of list) {
                const opt = document.createElement("option");
                opt.value = entry.id;
                const label = entry.label || entry.id;
                const meta = [];
                if (entry.required_features && entry.required_features.length) {
                    meta.push(entry.required_features.join(","));
                }
                opt.textContent = meta.length ? `${label} (${meta.join(" · ")})` : label;
                const supported = meetsModelRequirements(entry, gpuInfo);
                if (!supported) {
                    opt.disabled = true;
                    opt.textContent += " — non supporté";
                }
                opt.dataset.metaVram = entry.vram_required_MB ? Math.round(entry.vram_required_MB) + "MB" : "";
                opt.dataset.metaFeatures = entry.required_features ? entry.required_features.join(",") : "";
                opt.dataset.installed = "0";
                options.push(opt);
            }
            if (typeof hasModelInCacheFn === "function") {
                for (const opt of options) {
                    try {
                        const installed = await hasModelInCacheFn(opt.value);
                        opt.dataset.installed = installed ? "1" : "0";
                        opt.textContent = formatWebllmOptionLabel(
                            { id: opt.value, label: opt.textContent.replace(/^⭳\s*/, "") },
                            installed === true ? true : false,
                            {
                                features: opt.dataset.metaFeatures ? opt.dataset.metaFeatures.split(",").filter(Boolean) : []
                            },
                            opt.textContent.replace(/^⭳\s*/, "")
                        );
                    } catch (err) {
                        /* ignore per option */
                    }
                }
            }
            options
                .sort((a, b) => {
                    const ai = a.dataset.installed === "1" ? 0 : 1;
                    const bi = b.dataset.installed === "1" ? 0 : 1;
                    if (ai !== bi) return ai - bi;
                    return String(a.value).localeCompare(String(b.value));
                })
                .forEach(opt => webllmModelSelect.appendChild(opt));
            const preferred = getSelectedWebllmModel();
            if (preferred) {
                webllmModelSelect.value = preferred;
            }
            webllmModelSelect.dataset.initialized = "1";
        }

        function populateWebllmModelSelect() {
            if (!webllmModelSelect) return;
            webllmModelSelect.dataset.initialized = "";
            webllmModelSelect.innerHTML = "";
            buildWebllmModelOptions().catch(() => {
                const models = window.GoToolkitIAConfig?.WEBLLM_MODELS || [];
                if (!models.length) {
                    const option = document.createElement("option");
                    option.textContent = "Modèles WebLLM indisponibles";
                    option.disabled = true;
                    webllmModelSelect.appendChild(option);
                    return;
                }
                models.forEach(entry => {
                    const option = document.createElement("option");
                    option.value = entry.id;
                    option.textContent = entry.label || entry.id;
                    webllmModelSelect.appendChild(option);
                });
            });
        }

        function getSelectedWebllmModel() {
            if (webllmModelSelect && webllmModelSelect.value) {
                const val = webllmModelSelect.value;
                return isSupportedWebllmModel(val) ? val : (window.GoToolkitIAConfig?.DEFAULTS?.WEBLLM_MODEL || "");
            }
            if (window.GoToolkitIAConfig && typeof window.GoToolkitIAConfig.getWebllmModel === "function") {
                const stored = window.GoToolkitIAConfig.getWebllmModel();
                return isSupportedWebllmModel(stored)
                    ? stored
                    : (window.GoToolkitIAConfig?.DEFAULTS?.WEBLLM_MODEL || "");
            }
            return window.GoToolkitIAConfig?.DEFAULTS?.WEBLLM_MODEL || "";
        }

        async function installWebllmModel() {
            if (!window.GoToolkitWebLLM) {
                showToast("WebLLM indisponible dans ce navigateur.", true);
                return;
            }
            const model = getSelectedWebllmModel();
            if (!model) {
                showToast("Sélectionne un moteur WebLLM.", true);
                return;
            }
            const baseLabel = "Installer";
            if (webllmInstallBtn) {
                webllmInstallBtn.disabled = true;
                let lastPercent = -1;
                webllmInstallBtn.textContent = `${baseLabel} (0%)`;
                try {
                    await window.GoToolkitWebLLM.installModel(model, progress => {
                        const percent = Math.min(
                            100,
                            Math.max(0, Math.round((progress?.progress ?? 0) * 100))
                        );
                        if (percent !== lastPercent) {
                            lastPercent = percent;
                            webllmInstallBtn.textContent = `${baseLabel} (${percent}%)`;
                        }
                    });
                    updateStatusIcon(webllmStatusEl, "ready");
                    showToast("Modèle WebLLM prêt (" + getWebllmModelLabel(model) + ")");
                } catch (err) {
                    console.warn("WebLLM install failed", err);
                    updateStatusIcon(webllmStatusEl, "error");
                    showToast(
                        "Échec de l'installation WebLLM (" + ((err && err.message) || "erreur") + ")",
                        true
                    );
                } finally {
                    webllmInstallBtn.disabled = false;
                    webllmInstallBtn.textContent = baseLabel;
                }
            } else {
                await window.GoToolkitWebLLM.installModel(model);
            }
        }

        async function verifyWebllmModel({ showToasts = true } = {}) {
            if (!window.GoToolkitWebLLM) {
                if (showToasts) {
                    showToast("WebLLM indisponible dans ce navigateur.", true);
                }
                return false;
            }
            const model = getSelectedWebllmModel();
            if (!model) {
                if (showToasts) {
                    showToast("Sélectionne un moteur WebLLM.", true);
                }
                return false;
            }
            if (webllmVerifyBtn) {
                webllmVerifyBtn.disabled = true;
            }
            updateStatusIcon(webllmStatusEl, "verifying");
            try {
                await window.GoToolkitWebLLM.verifyModel(model);
                updateStatusIcon(webllmStatusEl, "ready");
                if (showToasts) {
                    showToast("WebLLM prêt (" + getWebllmModelLabel(model) + ")");
                }
                return true;
            } catch (err) {
                console.warn("WebLLM verify failed", err);
                updateStatusIcon(webllmStatusEl, "error");
                if (showToasts) {
                    showToast(
                        "Échec de la vérification WebLLM (" + ((err && err.message) || "erreur") + ")",
                        true
                    );
                }
                return false;
            } finally {
                if (webllmVerifyBtn) {
                    webllmVerifyBtn.disabled = false;
                }
            }
        }
        function extractOllamaModelNames(payload) {
            if (!payload) {
                return [];
            }
            const candidates = [];
            const pushArray = value => {
                if (Array.isArray(value)) {
                    candidates.push(...value);
                }
            };
            pushArray(payload.tags);
            pushArray(payload.models);
            pushArray(payload.items);
            if (payload.data) {
                pushArray(payload.data.tags);
                pushArray(payload.data.models);
                pushArray(payload.data.items);
            }
            if (Array.isArray(payload)) {
                pushArray(payload);
            }
            const normalized = [];
            const seen = new Set();
            for (const item of candidates) {
                if (!item) {
                    continue;
                }
                let name = "";
                if (typeof item === "string") {
                    name = item;
                } else if (typeof item.name === "string") {
                    name = item.name;
                } else if (typeof item.tag === "string") {
                    name = item.tag;
                } else if (typeof item.model === "string") {
                    name = item.model;
                } else if (typeof item.id === "string") {
                    name = item.id;
                }
                name = name.trim();
                if (name && !seen.has(name)) {
                    seen.add(name);
                    normalized.push(name);
                }
            }
            return normalized;
        }
        function populateOllamaModelSelect(models, preferred) {
            if (!settingsOllamaModelSelect || !Array.isArray(models) || !models.length) {
                return;
            }
            const current = preferred || (window.GoToolkitIAConfig?.getOllamaModel?.() || settingsOllamaModelSelect.value || "");
            settingsOllamaModelSelect.innerHTML = "";
            let matched = false;
            for (const model of models) {
                const option = document.createElement("option");
                option.value = model;
                option.textContent = model;
                settingsOllamaModelSelect.appendChild(option);
                if (model === current) {
                    matched = true;
                }
            }
            if (matched) {
                settingsOllamaModelSelect.value = current;
            } else {
                settingsOllamaModelSelect.value = models[0];
            }
            const selectedModel = settingsOllamaModelSelect.value;
            if (
                selectedModel &&
                window.GoToolkitIAConfig &&
                typeof window.GoToolkitIAConfig.setOllamaModel === "function"
            ) {
                window.GoToolkitIAConfig.setOllamaModel(selectedModel);
            }
        }
        async function refreshOllamaModels({ showErrors = false } = {}) {
            var config = window.GoToolkitIAConfig;
            var url = "";
            var addressSelection = settingsOllamaAddressSelect ? settingsOllamaAddressSelect.value : "";
            if (addressSelection === "local") {
                url = "http://localhost:11434";
            } else if (addressSelection === "cloud") {
                url = "https://ollama.com";
            } else if (settingsOllamaUrlInput && settingsOllamaUrlInput.value) {
                url = settingsOllamaUrlInput.value;
            } else if (config && typeof config.getOllamaUrl === "function") {
                url = config.getOllamaUrl();
            }
            // keep config/storage in sync with the selection so future calls use the right base URL
            if (config && typeof config.setOllamaUrl === "function" && url) {
                config.setOllamaUrl(url);
            }
            if (!url) {
                if (showErrors) {
                    showToast("URL Ollama manquante pour récupérer les modèles.", true);
                }
                return [];
            }
            var normalizedUrl = url.replace(/\/+$/, "");
            var apiKey = config && typeof config.getOllamaApiKey === "function" ? config.getOllamaApiKey() : "";
            try {
                var response = await fetch(normalizedUrl + "/api/tags", {
                    method: "GET",
                    headers: buildOllamaHeaders(apiKey, { targetUrl: normalizedUrl }),
                    cache: "no-cache"
                });
                if (!response.ok) {
                    throw new Error("HTTP " + response.status + " " + (response.statusText || ""));
                }
                var payload = await response.json().catch(() => null);
                var models = extractOllamaModelNames(payload);
                if (models.length) {
                    populateOllamaModelSelect(models);
                } else if (showErrors) {
                    showToast("Aucun modèle Ollama détecté dans /api/tags.", true);
                }
                return models;
            } catch (err) {
                console.warn("Ollama tags fetch failed", err);
                if (showErrors) {
                    var message = (err && err.message) || "erreur inconnue";
                    showToast("Échec de la récupération des modèles Ollama (" + message + ")", true);
                }
                return [];
            }
        }
        function isLocalOllama(url) {
            if (!url || typeof url !== "string") return false;
            return /^https?:\/\/(localhost|127(?:\.\d+){3})(:\d+)?/i.test(url.trim());
        }
        function buildOllamaHeaders(apiKey, options) {
            var headers = {};
            if (options?.json) {
                headers["Content-Type"] = "application/json";
            }
            // Avoid adding custom auth headers for local Ollama to dodge CORS preflight blocks.
            if (apiKey && !isLocalOllama(options?.targetUrl)) {
                headers.Authorization = "Bearer " + apiKey;
                headers["Ollama-Api-Key"] = apiKey;
                headers["X-Ollama-Api-Key"] = apiKey;
            }
            return headers;
        }

        async function testOpenAiConnection({ showToasts = true } = {}) {
            var config = window.GoToolkitIAConfig;
            var apiKey = config && typeof config.getApiKey === "function" ? config.getApiKey() : "";
            if (!apiKey) {
                updateStatusIcon(openaiStatusEl, "error");
                if (showToasts) {
                    showToast("Clé OpenAI requise pour tester la connexion.", true);
                }
                return false;
            }
            updateStatusIcon(openaiStatusEl, "verifying");
            try {
                var response = await fetch("https://api.openai.com/v1/models", {
                    method: "GET",
                    headers: {
                        Authorization: "Bearer " + apiKey
                    }
                });
                if (!response.ok) {
                    throw new Error("HTTP " + response.status + " " + (response.statusText || ""));
                }
                if (showToasts) {
                    showToast("Connexion OpenAI prête");
                }
                updateStatusIcon(openaiStatusEl, "ready");
                return true;
            } catch (err) {
                console.warn("OpenAI test failed", err);
                var message = (err && err.message) || String(err) || "erreur inconnue";
                if (showToasts) {
                    showToast("Échec de la connexion OpenAI (" + message + ")", true);
                }
                updateStatusIcon(openaiStatusEl, "error");
                return false;
            }
        }

        async function testOllamaConnection({ showToasts = true } = {}) {
            var config = window.GoToolkitIAConfig;
            var url = config && typeof config.getOllamaUrl === "function" ? config.getOllamaUrl() : "";
            if (!url) {
                updateStatusIcon(ollamaStatusEl, "error");
                if (showToasts) {
                    showToast("URL Ollama manquante pour tester la connexion.", true);
                }
                return false;
            }
            var normalizedUrl = url.replace(/\/+$/, "");
            var apiKey = config && typeof config.getOllamaApiKey === "function" ? config.getOllamaApiKey() : "";
            updateStatusIcon(ollamaStatusEl, "verifying");
            const models = await refreshOllamaModels({ showErrors: showToasts });
            if (!models.length) {
                updateStatusIcon(ollamaStatusEl, "error");
                return false;
            }
            if (showToasts) {
                showToast("Modèles Ollama détectés (" + normalizedUrl + ")");
            }
            updateStatusIcon(ollamaStatusEl, "ready");
            return true;
        }
        function openModal() {
            if (!feedbackModal) return;
            feedbackModal.classList.add("open");
            feedbackModal.setAttribute("aria-hidden", "false");
            feedbackType?.focus();
        }

        function openRequestsModal() {
            if (!requestsModal) return;
            requestsModal.classList.add("open");
            requestsModal.setAttribute("aria-hidden", "false");
            fetchRequests();
        }

        function closeRequestsModal() {
            if (!requestsModal) return;
            requestsModal.classList.remove("open");
            requestsModal.setAttribute("aria-hidden", "true");
        }

        function closeModal() {
            if (!feedbackModal) return;
            feedbackModal.classList.remove("open");
            feedbackModal.setAttribute("aria-hidden", "true");
            feedbackForm?.reset();
            updateMessagePlaceholder("bug");
        }

        async function handleSubmit(event) {
            event.preventDefault();
            if (!feedbackForm.checkValidity()) {
                feedbackForm.reportValidity();
                return;
            }
            if (feedbackWebsite && feedbackWebsite.value.trim()) {
                showToast("Formulaire invalide.", true);
                return;
            }
            const type = feedbackType.value || "bug";
            const message = feedbackMessage.value.trim();
            const name = (document.getElementById("feedbackName")?.value || "").trim();
            const subject = (feedbackSubject?.value || "").trim();
            submitFeedbackBtn.disabled = true;
            submitFeedbackBtn.textContent = "Envoi...";
            try {
                const endpoint = window.GO_TOOLKIT_FEEDBACK_API_URL || "https://feedback.gotoolkit.workers.dev/v1/feedback";
                const response = await fetch(endpoint, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({
                        name: name || null,
                        type,
                        message,
                        subject: subject || null,
                        page: "index",
                        userAgent: navigator.userAgent || ""
                    })
                });
                if (!response.ok) {
                    const body = await response.text().catch(() => "");
                    throw new Error(body || "Envoi impossible");
                }
                showToast("Merci pour ton avis !");
                closeModal();
            } catch (err) {
                console.error("Feedback non envoyé", err);
                showToast("Impossible d'enregistrer le feedback (config ?)", true);
            } finally {
                submitFeedbackBtn.disabled = false;
                submitFeedbackBtn.textContent = "Envoyer";
            }
        }

        // Settings modal (global Réglages)
        const openSettingsBtn = document.getElementById("openSettingsBtn");
        const settingsModal = document.getElementById("settingsModal");
        const closeSettingsBtn = document.getElementById("closeSettingsBtn");
        const cancelSettingsBtn = document.getElementById("cancelSettingsBtn");
        const saveSettingsBtn = document.getElementById("saveSettingsBtn");
        const settingsApiKeyInput = document.getElementById("iaApiKeyInput");
        const settingsReasoningSelect = document.getElementById("reasoningEffortSelect");
        const settingsOpenAiModelSelect = document.getElementById("openaiModelSelect");
        const settingsSpeechEngineSelect = document.getElementById("speechEngineSelect");
        const settingsSpeechModeSelect = document.getElementById("speechModeSelect");
        const settingsOllamaUrlInput = document.getElementById("ollamaUrlInput");
        const settingsOllamaApiKeyInput = document.getElementById("ollamaApiKeyInput");
        const settingsOllamaAddressSelect = document.getElementById("ollamaAddressSelect");
        const settingsOllamaUrlRow = document.getElementById("ollamaUrlRow");
        const settingsOllamaApiKeyRow = document.getElementById("ollamaApiKeyRow");
        const settingsOllamaModelSelect = document.getElementById("ollamaModelSelect");
        const openaiStatusEl = document.getElementById("openaiStatus");
        const ollamaStatusEl = document.getElementById("ollamaStatus");
        const webllmStatusEl = document.getElementById("webllmStatus");
        const openaiVerifyBtn = document.getElementById("openaiVerifyBtn");
        const ollamaVerifyBtn = document.getElementById("ollamaVerifyBtn");
        const webllmInstallBtn = document.getElementById("webllmInstallBtn");
        const webllmClearBtn = document.getElementById("webllmClearBtn");
        const webllmVerifyBtn = document.getElementById("webllmVerifyBtn");
        const aiBackendSelect = document.getElementById("aiBackendSelect");
        const openaiSettingsEl = document.getElementById("openaiSettings");
        const ollamaSettingsEl = document.getElementById("ollamaSettings");
        const webllmSettingsEl = document.getElementById("webllmSettings");
        const webllmModelSelect = document.getElementById("webllmModelSelect");
        const SPEECH_ENGINE_STORAGE_KEY = "go-toolkit-speech-engine";
        const VOICE_AUDIO_DB = { name: "go-toolkit-voice-audio", store: "recordings" };

        try {
            const storedSpeechEngine = localStorage.getItem(SPEECH_ENGINE_STORAGE_KEY) || "web-speech";
            const hasApiKey = typeof config?.getApiKey === "function" ? Boolean(config.getApiKey()) : Boolean(localStorage.getItem("go-toolkit-api-key") || "");
            const speechEngine = storedSpeechEngine === "whisperer" && hasApiKey ? "whisperer" : "web-speech";
            window.GoToolkitSpeechEngine = speechEngine;
        } catch (e) {
            window.GoToolkitSpeechEngine = "web-speech";
        }

        function updateBackendVisibility() {
            const val = (aiBackendSelect && aiBackendSelect.value) || "openai";
            if (openaiSettingsEl) openaiSettingsEl.style.display = val === "openai" ? "" : "none";
            if (ollamaSettingsEl) ollamaSettingsEl.style.display = val === "ollama" ? "" : "none";
            if (webllmSettingsEl) webllmSettingsEl.style.display = val === "webllm" ? "" : "none";
            window.GoToolkitSelectedAIBackend = val;
        }

        function updateOllamaAddressUI() {
            if (!settingsOllamaAddressSelect) return;
            const val = settingsOllamaAddressSelect.value || 'local';
            if (settingsOllamaUrlRow) {
                settingsOllamaUrlRow.style.display = (val === 'custom') ? '' : 'none';
            }
            if (settingsOllamaUrlInput) {
                if (val === 'local') {
                    settingsOllamaUrlInput.value = 'http://localhost:11434';
                } else if (val === 'cloud') {
                    settingsOllamaUrlInput.value = 'https://ollama.com';
                }
            }
            if (settingsOllamaApiKeyRow) {
                settingsOllamaApiKeyRow.style.display = (val === 'local') ? 'none' : '';
            }
        }

        settingsOllamaAddressSelect?.addEventListener('change', () => {
            updateOllamaAddressUI();
        });

        (function initOllamaAddressSelection() {
            const configUrl = (window.GoToolkitIAConfig && typeof window.GoToolkitIAConfig.getOllamaUrl === 'function') ? window.GoToolkitIAConfig.getOllamaUrl() : (settingsOllamaUrlInput?.value || '');
            if (!settingsOllamaAddressSelect) return;
            if (configUrl.startsWith('http://localhost') || configUrl.startsWith('https://localhost')) {
                settingsOllamaAddressSelect.value = 'local';
            } else if (configUrl.startsWith('https://ollama.com')) {
                settingsOllamaAddressSelect.value = 'cloud';
            } else if (configUrl) {
                settingsOllamaAddressSelect.value = 'custom';
                if (settingsOllamaUrlInput && !settingsOllamaUrlInput.value) settingsOllamaUrlInput.value = configUrl;
            } else {
                settingsOllamaAddressSelect.value = 'local';
            }
            updateOllamaAddressUI();
        })();

        aiBackendSelect?.addEventListener("change", function () {
            try {
                localStorage.setItem("go-toolkit-ai-backend", aiBackendSelect.value);
            } catch (e) { }
            updateBackendVisibility();
        });

        webllmInstallBtn?.addEventListener("click", () => {
            installWebllmModel().catch(() => { /* noop */ });
        });
        webllmClearBtn?.addEventListener("click", async () => {
            if (!window.GoToolkitWebLLM || typeof window.GoToolkitWebLLM.getAppConfig !== "function") {
                showToast("WebLLM indisponible pour vider le cache.", true);
                return;
            }
            try {
                const mod = await import("https://esm.sh/@mlc-ai/web-llm");
                const deleteModelAllInfoInCache = mod.deleteModelAllInfoInCache || (mod.default && mod.default.deleteModelAllInfoInCache);
                if (!deleteModelAllInfoInCache) {
                    showToast("Nettoyage WebLLM indisponible.", true);
                    return;
                }
                const appConfig = await (window.GoToolkitWebLLM.getAppConfig());
                const models = appConfig?.model_list || [];
                for (const m of models) {
                    try { await deleteModelAllInfoInCache(m.model_id); } catch (err) { /* ignore individual failures */ }
                }
                if (window.GoToolkitWebLLM && typeof window.GoToolkitWebLLM.resetEngine === "function") {
                    window.GoToolkitWebLLM.resetEngine();
                }
                updateStatusIcon(webllmStatusEl);
                showToast("Cache WebLLM vidé.");
            } catch (err) {
                console.warn("WebLLM clear cache failed", err);
                showToast("Échec du nettoyage WebLLM.", true);
            }
        });
        webllmVerifyBtn?.addEventListener("click", () => {
            verifyWebllmModel().catch(() => { /* noop */ });
        });
        webllmModelSelect?.addEventListener("change", () => {
            if (window.GoToolkitWebLLM && typeof window.GoToolkitWebLLM.resetEngine === "function") {
                window.GoToolkitWebLLM.resetEngine();
            }
            updateStatusIcon(webllmStatusEl);
        });

        function openSettings() {
            if (!settingsModal) return;
            // populate current values from localStorage
            try {
                const config = window.GoToolkitIAConfig;
                var storedKey = "";
                if (config && typeof config.getApiKey === "function") {
                    storedKey = config.getApiKey()?.trim() || "";
                } else {
                    storedKey = localStorage.getItem("go-toolkit-api-key") || "";
                }
                if (settingsApiKeyInput) settingsApiKeyInput.value = storedKey;
                var storedOpenAiModel = (config && typeof config.getOpenAiModel === "function" ? config.getOpenAiModel() : "") || "gpt-5-nano";
                if (settingsOpenAiModelSelect) {
                    settingsOpenAiModelSelect.value = storedOpenAiModel;
                }
                var storedContextWindow = (config && typeof config.getContextWindow === "function" ? config.getContextWindow() : "") || "4000";
                var storedOllamaUrl = (config && typeof config.getOllamaUrl === "function" ? config.getOllamaUrl() : "") || "http://localhost:11434";
                if (settingsOllamaUrlInput) {
                    settingsOllamaUrlInput.value = storedOllamaUrl;
                }
                var storedOllamaApiKey = (config && typeof config.getOllamaApiKey === "function" ? config.getOllamaApiKey() : "") || "";
                if (settingsOllamaApiKeyInput) {
                    settingsOllamaApiKeyInput.value = storedOllamaApiKey;
                }
                var storedOllamaModel = (config && typeof config.getOllamaModel === "function" ? config.getOllamaModel() : "") || "genma3";
                if (settingsOllamaModelSelect) {
                    settingsOllamaModelSelect.value = storedOllamaModel;
                }
                populateWebllmModelSelect();
                var storedWebllmModel = (config && typeof config.getWebllmModel === "function" ? config.getWebllmModel() : "") || window.GoToolkitIAConfig?.DEFAULTS?.WEBLLM_MODEL || "";
                if (!isSupportedWebllmModel(storedWebllmModel)) {
                    storedWebllmModel = window.GoToolkitIAConfig?.DEFAULTS?.WEBLLM_MODEL || "";
                }
                if (webllmModelSelect && storedWebllmModel) {
                    webllmModelSelect.value = storedWebllmModel;
                }
                var storedBackend = (config && typeof config.getBackend === "function" ? config.getBackend() : null) || localStorage.getItem("go-toolkit-ai-backend") || "openai";
                // Ollama access is disabled on the launcher; if it was previously selected, migrate to OpenAI.
                if (storedBackend === "ollama") {
                    storedBackend = "openai";
                    try { localStorage.setItem("go-toolkit-ai-backend", storedBackend); } catch (e) { }
                    try { config && typeof config.setBackend === "function" && config.setBackend(storedBackend); } catch (e) { }
                }
                if (aiBackendSelect) aiBackendSelect.value = storedBackend;
                updateBackendVisibility();
                const storedReasoning = localStorage.getItem("plan-reasoning-effort") || localStorage.getItem("nuances-reasoning-effort") || "low";
                if (settingsReasoningSelect) settingsReasoningSelect.value = storedReasoning;
                const storedSpeechEngine = localStorage.getItem(SPEECH_ENGINE_STORAGE_KEY) || "web-speech";
                const hasApiKey = (config && typeof config.getApiKey === "function" ? config.getApiKey() : localStorage.getItem("go-toolkit-api-key")) || "";
                const canUseWhisperer = Boolean(hasApiKey);
                if (settingsSpeechEngineSelect) {
                    settingsSpeechEngineSelect.value = canUseWhisperer && storedSpeechEngine === "whisperer" ? "whisperer" : "web-speech";
                    settingsSpeechEngineSelect.querySelectorAll('option[value="whisperer"]').forEach(opt => {
                        opt.disabled = !canUseWhisperer;
                    });
                }
                try {
                    window.GoToolkitSpeechEngine = settingsSpeechEngineSelect?.value || "web-speech";
                } catch (e) { /* noop */ }
                const storedSpeechMode = localStorage.getItem("go-toolkit-speech-mode") || "manual";
                if (settingsSpeechModeSelect) {
                    settingsSpeechModeSelect.value = storedSpeechMode === "auto" ? "auto" : "manual";
                }
            } catch (e) { /* noop */ }
            try {
                const storedAdmin = localStorage.getItem("feedback-admin-token");
                if (adminTokenInput && storedAdmin) adminTokenInput.value = storedAdmin;
            } catch (e) { /* noop */ }
            settingsModal.classList.add("open");
            settingsModal.setAttribute("aria-hidden", "false");
            settingsReasoningSelect?.focus();
        }

        function closeSettings() {
            if (!settingsModal) return;
            settingsModal.classList.remove("open");
            settingsModal.setAttribute("aria-hidden", "true");
        }

        async function deleteVoiceAudio(draftId) {
            if (!draftId || !("indexedDB" in window)) return;
            try {
                const req = indexedDB.open(VOICE_AUDIO_DB.name, 1);
                const db = await new Promise((resolve, reject) => {
                    req.onupgradeneeded = () => {
                        const db = req.result;
                        if (!db.objectStoreNames.contains(VOICE_AUDIO_DB.store)) {
                            db.createObjectStore(VOICE_AUDIO_DB.store);
                        }
                    };
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => reject(req.error || new Error("IndexedDB audio KO"));
                });
                const tx = db.transaction(VOICE_AUDIO_DB.store, "readwrite");
                tx.objectStore(VOICE_AUDIO_DB.store).delete(draftId);
            } catch (err) {
                console.warn("Suppression audio voice", err);
            }
        }

        async function persistSettings({ skipClose = false, showSavedToast = true } = {}) {
            let selectedBackend = (aiBackendSelect && aiBackendSelect.value) || "openai";
            try {
                const apiKey = (settingsApiKeyInput?.value || "").trim();
                const reasoning = settingsReasoningSelect?.value || "low";
                const iaConfig = window.GoToolkitIAConfig;
                if (iaConfig && typeof iaConfig.setApiKey === "function") {
                    iaConfig.setApiKey(apiKey);
                } else {
                    if (apiKey) {
                        localStorage.setItem("go-toolkit-api-key", apiKey);
                    } else {
                        localStorage.removeItem("go-toolkit-api-key");
                    }
                }
                const openaiModelValue = (settingsOpenAiModelSelect?.value || "").trim();
                if (iaConfig && typeof iaConfig.setOpenAiModel === "function" && openaiModelValue) {
                    iaConfig.setOpenAiModel(openaiModelValue);
                }
                selectedBackend = (aiBackendSelect && aiBackendSelect.value) || "openai";
                if (iaConfig && typeof iaConfig.setBackend === "function") {
                    iaConfig.setBackend(selectedBackend);
                } else {
                    try { localStorage.setItem("go-toolkit-ai-backend", selectedBackend); } catch (e) { }
                }
                const speechModeValue = (settingsSpeechModeSelect?.value || "manual") === "auto" ? "auto" : "manual";
                try {
                    localStorage.setItem("go-toolkit-speech-mode", speechModeValue);
                } catch (e) { }
                const speechEngineValue =
                    (settingsSpeechEngineSelect?.value === "whisperer" && Boolean(apiKey)) ? "whisperer" : "web-speech";
                try {
                    localStorage.setItem(SPEECH_ENGINE_STORAGE_KEY, speechEngineValue);
                } catch (e) { /* noop */ }
                try { window.GoToolkitSpeechEngine = speechEngineValue; } catch (e) { /* noop */ }
                // expose immediate selection to runtime
                try { window.GoToolkitSelectedAIBackend = selectedBackend; } catch (e) { }
                const ollamaUrlValue = (settingsOllamaUrlInput?.value || "").trim();
                if (iaConfig && typeof iaConfig.setOllamaUrl === "function") {
                    iaConfig.setOllamaUrl(ollamaUrlValue);
                }
                const ollamaApiKeyValue = (settingsOllamaApiKeyInput?.value || "").trim();
                if (iaConfig && typeof iaConfig.setOllamaApiKey === "function") {
                    iaConfig.setOllamaApiKey(ollamaApiKeyValue);
                }
                const adminTokenValue = (adminTokenInput?.value || "").trim();
                try {
                    if (adminTokenValue) {
                        localStorage.setItem("feedback-admin-token", adminTokenValue);
                    } else {
                        localStorage.removeItem("feedback-admin-token");
                    }
                } catch (e) { /* noop */ }
                const ollamaModelValue = (settingsOllamaModelSelect?.value || "").trim();
                if (iaConfig && typeof iaConfig.setOllamaModel === "function" && ollamaModelValue) {
                    iaConfig.setOllamaModel(ollamaModelValue);
                }
                const webllmModelValue = (webllmModelSelect?.value || "").trim();
                if (iaConfig && typeof iaConfig.setWebllmModel === "function" && webllmModelValue) {
                    iaConfig.setWebllmModel(webllmModelValue);
                }
                if (window.GoToolkitWebLLM && typeof window.GoToolkitWebLLM.resetEngine === "function") {
                    window.GoToolkitWebLLM.resetEngine();
                }
                localStorage.setItem("plan-reasoning-effort", reasoning);
                try { localStorage.setItem("nuances-reasoning-effort", reasoning); } catch (e) { }
                // If user selected Ollama, validate Ollama is reachable
                if (selectedBackend === "ollama") {
                    try {
                        if (!window.GoToolkitAIBackend || typeof window.GoToolkitAIBackend.getBackend !== "function") {
                            const models = await refreshOllamaModels({ showErrors: true });
                            if (!models || !models.length) {
                                showToast("Impossible de contacter Ollama — vérifie l'URL ou la connexion.", true);
                                return { success: false, selectedBackend };
                            }
                            if (showSavedToast) showToast("Réglages sauvegardés");
                            if (!skipClose) closeSettings();
                            checkIaConnection();
                            return { success: true, selectedBackend };
                        }
                        const probe = await GoToolkitAIBackend.getBackend("responses");
                        if (!probe || probe.type !== "ollama") {
                            showToast("Impossible de contacter Ollama — vérifie l'URL ou la connexion.", true);
                            return { success: false, selectedBackend };
                        }
                        if (showSavedToast) showToast("Réglages sauvegardés");
                        if (!skipClose) closeSettings();
                        checkIaConnection();
                        return { success: true, selectedBackend };
                    } catch (err) {
                        console.warn("Ollama check failed", err);
                        showToast("Impossible de contacter Ollama — vérifie l'URL ou la connexion.", true);
                        return { success: false, selectedBackend };
                    }
                }

                // For non-Ollama backends (OpenAI or default), optionally validate OpenAI key but do not block save.
                if (apiKey && showSavedToast) {
                    var openaiKeyPattern = /^sk-[A-Za-z0-9\-_]{20,}$/;
                    if (openaiKeyPattern.test(apiKey)) {
                        showToast("Clé OpenAI valide — réglages sauvegardés");
                    } else {
                        showToast("Clé OpenAI invalide — vérifie la clé", true);
                    }
                } else if (selectedBackend !== "ollama" && showSavedToast) {
                    showToast("Réglages sauvegardés");
                }
                if (!skipClose) closeSettings();
                checkIaConnection();
                return { success: true, selectedBackend };
            } catch (e) {
                showToast("Impossible de sauvegarder les réglages", true);
                return { success: false, selectedBackend };
            }
        }

        async function saveSettings() {
            await persistSettings({ skipClose: false, showSavedToast: true });
        }

        if (openSettingsBtn) openSettingsBtn.addEventListener("click", openSettings);
        if (closeSettingsBtn) closeSettingsBtn.addEventListener("click", closeSettings);
        if (cancelSettingsBtn) cancelSettingsBtn.addEventListener("click", closeSettings);
        if (saveSettingsBtn) saveSettingsBtn.addEventListener("click", saveSettings);
        if (openaiVerifyBtn) openaiVerifyBtn.addEventListener("click", async () => {
            const result = await persistSettings({ skipClose: true, showSavedToast: true });
            if (result?.success) {
                testOpenAiConnection({ showToasts: true }).catch(() => { /* noop */ });
            }
        });
        if (ollamaVerifyBtn) ollamaVerifyBtn.addEventListener("click", async () => {
            const result = await persistSettings({ skipClose: true, showSavedToast: true });
            if (result?.success) {
                testOllamaConnection({ showToasts: true }).catch(() => { /* noop */ });
            }
        });

        openFeedbackBtn?.addEventListener("click", openModal);
        closeFeedbackBtn?.addEventListener("click", closeModal);
        cancelFeedbackBtn?.addEventListener("click", closeModal);
        feedbackModal?.addEventListener("click", event => {
            if (event.target === feedbackModal) {
                closeModal();
            }
        });
        document.addEventListener("keydown", event => {
            if (event.key === "Escape" || event.key === "Esc") {
                closeModal();
            }
        });
        feedbackType?.addEventListener("change", event => {
            const value = event.target.value;
            updateMessagePlaceholder(value);
        });
        feedbackForm?.addEventListener("submit", handleSubmit);
        requestsBtn?.addEventListener("click", openRequestsModal);
        closeRequestsBtn?.addEventListener("click", closeRequestsModal);
        requestsModal?.addEventListener("click", event => {
            if (event.target === requestsModal) closeRequestsModal();
        });
        requestsFilter?.addEventListener("change", () => {
            renderRequestsList();
            updateRequestCounters();
        });
        saveRequestBtn?.addEventListener("click", () => {
            saveCurrentRequest();
        });

        updateMessagePlaceholder("bug");
        fetchRequests().catch(() => { /* noop */ });

        function setIaStatus(backend) {
            if (openaiStatusEl) {
                const ready = backend?.type === "openai";
                updateStatusIcon(openaiStatusEl, ready ? "ready" : null);
                openaiStatusEl.setAttribute("aria-hidden", ready ? "false" : "true");
            }
            if (ollamaStatusEl) {
                const ready = backend?.type === "ollama";
                updateStatusIcon(ollamaStatusEl, ready ? "ready" : null);
                ollamaStatusEl.setAttribute("aria-hidden", ready ? "false" : "true");
            }
        }

        function checkIaConnection(showNotifications = false) {
            if (!window.GoToolkitAIBackend || typeof window.GoToolkitAIBackend.getBackend !== "function") {
                setIaStatus(null);
                return;
            }
            GoToolkitAIBackend.getBackend("responses")
                .then(backend => {
                    setIaStatus(backend);
                    console.log("IA backend detected:", backend?.type || "none", backend?.endpoint || "[missing]");
                    if (!showNotifications || !backend) {
                        return;
                    }
                    if (backend.type === "openai") {
                        showToast(`Connexion OpenAI prête (${backend.model})`);
                    } else if (backend.type === "ollama") {
                        const host =
                            window.GoToolkitIAConfig && typeof window.GoToolkitIAConfig.getOllamaUrl === "function"
                                ? window.GoToolkitIAConfig.getOllamaUrl()
                                : backend.endpoint;
                        const label = backend.model ? `${host} · ${backend.model}` : host;
                        showToast(`Connexion Ollama prête (${label})`);
                    }
                })
                .catch(err => {
                    setIaStatus(null);
                    console.warn("IA backend detection failed", err);
                });
        }
        checkIaConnection(true);

        // Indélébile launcher: open external tool with a one-time confirmation
        (function () {
            const indelebileLauncher = document.getElementById("indelebileLauncher");
            const STORAGE_KEY = "indelebile_confirmed_v1";
            const TARGET_URL = "https://teach.tldraw.com/";
            if (!indelebileLauncher) return;
            indelebileLauncher.addEventListener("click", function (e) {
                e.preventDefault();
                try {
                    const already = localStorage.getItem(STORAGE_KEY) === "1";
                    if (already) {
                        window.open(TARGET_URL, "_blank", "noopener");
                        return;
                    }
                }
                catch (err) {
                    // ignore storage errors and proceed to confirmation
                }

                const message = "Tu vas ouvrir un outil externe (https://teach.tldraw.com/).\nCe service est géré par un tiers et est soumis à des conditions d'utilisation différentes. Continuer ?";
                const ok = window.confirm(message);
                if (!ok) return;
                try {
                    localStorage.setItem(STORAGE_KEY, "1");
                }
                catch (err) {
                    // ignore
                }
                window.open(TARGET_URL, "_blank", "noopener");
            });
        })();
    </script>
</body>

</html>
