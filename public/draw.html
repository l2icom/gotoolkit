<!DOCTYPE html>
<html lang="fr">

<head>
    <script>window.GO_TOOLKIT_SHARE_API_URL = 'https://share.gotoolkit.workers.dev/'</script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Draw | Go-Toolkit</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap">
    <link rel="stylesheet" href="styles/app-shell.css">
    <link rel="stylesheet" href="https://unpkg.com/@excalidraw/excalidraw@0.17.6/dist/excalidraw.min.css">
    <style>
        .template-tooltip {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.06);
            padding: 8px 10px;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            z-index: 2200;
            max-width: 360px;
            font-size: 12px;
            color: #ffffff;
            line-height: 1.3;
            backdrop-filter: blur(2px);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s ease;
        }

        .template-tooltip[aria-hidden="false"]:not(:empty) {
            display: block;
            opacity: 1;
        }

        :root {
            font-size: 12px;
            --app-text: #101428;
            --app-bg: #f3f4f6;
            --app-border: #cdd4ed;
            --app-border-strong: #cdd4ed;
            --app-primary-strong: #1f2a56;
        }

        .tabs-actions {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
            flex-wrap: nowrap;
        }

        #promptTemplateField,
        #systemPromptField {
            min-height: 200px;
        }


        .connect-layout {
            flex: 1;
            padding: 5px 10px;
            display: flex;
            gap: 10px;
        }

        .connect-left {
            background: #ffffff;
            border-radius: 8px;
            padding: 10px;
            border: 1px solid #dfe3f5;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .connect-left.collapsed {
            display: none;
        }

        .connect-right.full-width {
            flex: 1 1 100%;
            width: 100%;
        }


        .connect-right {
            background: #ffffff;
            border-radius: 8px;
            padding: 0px;
            border: 1px solid #dfe3f5;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .connect-left,
        .connect-right {
            flex: 1;
        }

        /* Gutenberg card defaults (monospace, smaller text) */
        .connect-left textarea {
            font-size: 12px;
            font-family: var(--app-font, "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif);
        }

        .connect-left {
            flex: 0 0 350px;
            max-width: 350px;
            width: 100%;
        }

        .prompt-input-wrapper {
            position: relative;
        }

        .prompt-input-wrapper textarea {
            position: relative;
            background: #fbfbff;
            z-index: 1;
            padding: 8px;
            margin: 0;
            border: 1px solid #d6dbf2;
            border-radius: 4px;
            color: #101428;
            box-sizing: border-box;
        }

        .speech-field-wrapper {
            position: relative;
            height: 100%;
        }

        .speech-field-wrapper textarea {
            padding-right: 40px;
            position: relative;
            z-index: 2;
        }

        .speech-button {
            position: absolute;
            top: 6px;
            right: 6px;
            width: 24px;
            height: 24px;
            background: rgba(255, 255, 255, 0.85);
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border: none;
            color: var(--app-muted);
            border-radius: 999px;
            transition: box-shadow 0.2s ease, opacity 0.2s ease;
            opacity: 1;
            pointer-events: auto;
            z-index: 3;
            transform: translateX(2px);
        }

        .speech-button--active,
        .speech-button:active {
            color: #B11226;
            animation: speech-blink 2s infinite linear;
            opacity: 1;
        }

        @keyframes speech-blink {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.4;
            }
        }

        .speech-suggestion {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            bottom: 10px;
            pointer-events: none;
            font: inherit;
            line-height: 1.4;
            white-space: pre-wrap;
            word-break: break-word;
            z-index: 3;
        }

        .speech-suggestion span {
            display: inline;
        }

        .speech-suggestion-current {
            color: transparent;
        }

        .speech-suggestion-partial {
            color: rgba(15, 23, 42, 0.45);
        }

        .speech-suggestion:not(.visible) {
            visibility: hidden;
        }

        @keyframes speech-border {

            0%,
            100% {
                box-shadow: 0 0 0 0 rgba(177, 18, 38, 0.2);
            }

            50% {
                box-shadow: 0 0 0 6px rgba(177, 18, 38, 0.12);
            }
        }

        .speech-field-wrapper.speech-active textarea {
            border: 2px solid #B11226;
            animation: speech-border 2s infinite ease-in-out;
        }

        .speech-field-wrapper.speech-active textarea:focus {
            border-color: #B11226;
        }

        .prompt-suggestion {
            pointer-events: none;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            padding: 0;
            box-sizing: border-box;
            white-space: pre-wrap;
            word-break: break-word;
            font-family: inherit;
            font-size: inherit;
            line-height: inherit;
            color: #c8cee8;
            overflow: hidden;
            z-index: 40;
        }

        .prompt-suggestion .prompt-suggestion-mask {
            color: transparent;
        }

        .prompt-suggestion .prompt-suggestion-hint {
            color: #c8cee8;
        }

        .prompt-alt-row {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }

        .prompt-alt-badge {
            border: 1px solid #d6dbf2;
            background: #ffffff;
            color: #1f2a56;
            border-radius: 12px;
            padding: 3px 6px;
            font-size: 11px;
            cursor: pointer;
            transition: background 0.15s ease, border-color 0.15s ease;
            text-transform: capitalize;
        }

        .prompt-alt-badge:hover,
        .prompt-alt-badge:focus-visible {
            background: #f0f4ff;
            border-color: #c0c8ee;
            outline: none;
        }

        .drawer-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.25);
            backdrop-filter: blur(2px);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 60;
        }

        .card-title {
            font-size: 13px;
            font-weight: 600;
        }

        .card-title-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0px;
            margin-bottom: 0px;
        }

        textarea {
            width: 100%;
            border-radius: 4px;
            border: 1px solid #d6dbf2;
            padding: 8px;
            resize: none;
            font-family: inherit;
            font-size: 12px;
            line-height: 1.5;
            background: #fbfbff;
            color: #101428;
        }

        textarea:focus {
            outline: none;
            border-color: var(--app-primary);
            scrollbar-width: thin;
        }

        .prompt-input-card {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .prompt-input-card textarea {
            height: 260px;
            margin-bottom: 0px;
        }

        .draw-type-control {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .draw-type-control-label {
            font-size: 12px;
            color: #566188;
        }

        .draw-type-selector {
            display: flex;
            gap: 6px;
        }

        .draw-type-btn {
            flex: 1;
            border-radius: 20px;
            border: 1px solid #d6dbf2;
            background: #ffffff;
            padding: 6px 10px;
            font-size: 12px;
            font-weight: 500;
            color: #1f2a56;
            cursor: pointer;
            transition: background 0.2s ease, border-color 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
        }

        .draw-type-btn.active {
            background: #ffffff;
            border: 2px solid #2a7a57;
            color: #0f172a;
            box-shadow: none;
        }

        .draw-type-btn:focus-visible {
            outline: 2px solid #2a7a57;
        }

        .mermaid-output-card {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-height: 0;
        }

        .mermaid-output-card textarea {
            flex: 1;
            min-height: 0;
        }

        .generate-btn,
        .refresh-btn {
            align-self: flex-start;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        /* Primary style for generate button */
        .generate-btn {
            border: none;
            background: #2a7a57;
            color: #ffffff;
            box-shadow: none;
            border-radius: 8px;
            padding: 6px 10px;
        }

        .generate-btn:disabled {
            opacity: 0.6;
        }

        .status-label {
            font-size: 12px;
            color: #566188;
            min-height: 18px;
        }

        .status-toast {
            position: fixed;
            left: 24px;
            bottom: 24px;
            max-width: 280px;
            background: rgba(16, 20, 40, 0.92);
            color: #ffffff;
            padding: 12px 16px;
            border-radius: 8px;
            box-shadow: 0 12px 24px rgba(16, 20, 40, 0.35);
            font-size: 13px;
            line-height: 1.4;
            opacity: 0;
            transform: translateY(8px);
            transition: opacity 0.2s ease, transform 0.2s ease;
            pointer-events: none;
            z-index: 100;
        }

        .status-toast.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .excalidraw-card {
            flex: 1;
            border-radius: 4px;
            border: 1px dashed #cfd5ef;
            background: #fdfdff;
            padding: 12px;
            display: flex;
            flex-direction: column;
            min-height: 320px;
            overflow: hidden;
        }

        .diagram-title-row {
            margin: 0 10px 2px 0;
        }

        .diagram-title-input {
            width: 100%;
            padding: 6px 6px;
            font-size: 14px;
            font-weight: 700;
            border: 1px solid transparent;
            border-radius: 8px;
            background: #ffffff;
            color: #0f172a;
        }

        #excalidrawHost {
            flex: 1;
            border-radius: 4px;
            background: #ffffff;
            min-height: 360px;
            height: 100%;
            width: 100%;
            position: relative;
            overflow: hidden;
            --bar-padding: 5px;
        }

        #excalidrawHost .App-bottom-bar {
            margin: 5px !important;
        }

        #excalidrawHost .layer-ui__wrapper__top-left {
            left: auto;
            right: 12px;
            flex-direction: row-reverse;
        }

        #excalidrawHost .layer-ui__wrapper__bottom-left {
            left: auto;
            right: 12px;
        }

        #excalidrawHost .layer-ui__wrapper__top-right,
        #excalidrawHost .layer-ui__wrapper__bottom-right {
            right: 12px;
        }

        #excalidrawHost a[href*="excalidraw"],
        #excalidrawHost button[title*="Excalidraw" i],
        #excalidrawHost [aria-label*="Excalidraw" i],
        #excalidrawHost a[href*="discord" i],
        #excalidrawHost button[title*="Discord" i],
        #excalidrawHost [aria-label*="Discord" i] {
            display: none !important;
        }

        /* Permanently hide library trigger, footer help and links group */
        #excalidrawHost .default-sidebar-trigger,
        #excalidrawHost .default-sidebar-trigger .sidebar-trigger__label,
        #excalidrawHost .layer-ui__wrapper__footer-right .help-icon,
        #excalidrawHost .dropdown-menu-group,
        #excalidrawHost .dropdown-menu-group-title {
            display: none !important;
            visibility: hidden !important;
        }

        .placeholder {
            color: #9ca3c7;
            font-size: 14px;
            margin: 0;
        }

        .info-popup {
            position: absolute;
            top: 56px;
            right: 12px;
            width: 280px;
            background: #fff;
            border-radius: 14px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            padding: 15px;
            display: none;
            flex-direction: column;
            gap: 6px;
            font-size: 12px;
            z-index: 60;
        }

        .info-popup.open {
            display: flex;
        }

        .info-popup img {
            width: 48px;
            height: 48px;
            object-fit: contain;
            align-self: center;
        }

        .info-popup a {
            color: #2a7a57;
            text-decoration: none;
            font-weight: 600;
        }

        .info-popup button {
            border-radius: 8px;
            border: 1px solid rgba(15, 23, 42, 0.15);
            background: #fff;
            color: #0f172a;
            padding: 6px 10px;
            font-size: 12px;
            cursor: pointer;
            min-width: 110px;
        }

        .info-popup button.update-btn {
            background: #2a7a57;
            border-color: #2a7a57;
            color: #fff;
        }

        .info-popup button.secondary {
            background: #fff;
            border-color: rgba(15, 23, 42, 0.15);
            color: #0f172a;
        }

        .info-actions {
            display: flex;
            justify-content: space-between;
            gap: 8px;
            flex-wrap: wrap;
        }

        /* Harmonized tour styles */
        .tour-overlay {
            position: fixed;
            inset: 0;
            background: rgba(15, 23, 42, 0.55);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 80;
        }

        .tour-overlay.open {
            display: flex;
        }

        .tour-overlay.has-highlight {
            background: transparent;
        }

        .tour-highlight {
            position: absolute;
            border: 2px solid #2a7a57;
            border-radius: 12px;
            background: transparent;
            box-shadow: 0 0 0 9999px rgba(15, 23, 42, 0.55);
            pointer-events: none;
            transition: all 0.2s ease;
        }

        .tour-panel {
            position: relative;
            z-index: 2;
            background: #fff;
            border-radius: 14px;
            padding: 16px;
            width: min(480px, 92vw);
            box-shadow: 0 16px 32px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .tour-step-counter {
            font-size: 12px;
            color: #6b7280;
        }

        .tour-panel h4 {
            margin: 0;
            font-size: 16px;
        }

        .tour-panel p {
            margin: 0;
            font-size: 13px;
            color: #374151;
        }

        .tour-step-footer {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            flex-wrap: wrap;
        }

        .tour-step-footer button {
            border-radius: 10px;
            border: 1px solid rgba(15, 23, 42, 0.15);
            background: #fff;
            color: #0f172a;
            padding: 8px 12px;
            font-size: 12px;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        .tour-step-footer button:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 6px 18px rgba(15, 23, 42, 0.12);
        }

        .tour-step-footer button.primary {
            background: #2a7a57;
            color: #fff;
            border-color: #2a7a57;
        }

        .tour-step-footer button:disabled {
            opacity: 0.55;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .tour-skip {
            position: absolute;
            top: 12px;
            right: 12px;
            border: none;
            background: transparent;
            color: #fff;
            font-size: 18px;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        .tour-skip:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
        }

        /* Ajuste le menu lat√©ral Excalidraw (selected-shape-actions) */
        .excalidraw-card .Island.App-menu__left {
            --padding: 2px;
            padding: 4px;
            max-height: 500px;
            max-width: 95px;
        }

        /* Tweak panel column spacing inside Excalidraw */
        .excalidraw .panelColumn {
            row-gap: 2px;
        }

        @media (max-width: 1200px) {
            .connect-layout {
                position: relative;
                gap: 6px;
            }

            .connect-right {
                width: 100%;
            }

            .connect-left {
                position: fixed;
                top: 0;
                right: 0;
                height: 100vh;
                max-width: min(420px, 90vw);
                width: 90vw;
                box-shadow: -12px 0 30px rgba(16, 20, 40, 0.25);
                transform: translateX(110%);
                transition: transform 0.22s ease;
                z-index: 70;
                overflow-y: auto;
            }

            .connect-left.open {
                transform: translateX(0);
            }

            .drawer-overlay.visible {
                opacity: 1;
                pointer-events: all;
            }

            .excalidraw-card,
            #excalidrawHost {
                min-height: 70vh;
                height: 70vh;
            }
        }
    </style>
</head>


<body class="app-body">
    <div class="app">
        <header class="app-header">
            <a class="app-home-link" href="index.html" title="Revenir √† l'accueil">‚òç</a>
            <div class="nav-switch">
                <button id="navSwitcherBtn" class="nav-switch-btn" type="button">‚óá Draw ‚ñæ</button>
                <div id="navSwitcherMenu" class="nav-switch-menu">
                    <a class="nav-switch-link" href="canvas.html?v=2025.12.25.1">‚óç Canvas</a>
                    <a class="nav-switch-link" href="grid.html?v=2025.12.25.1">‚ñ¶ Grid</a>
                    <a class="nav-switch-link" href="timeline.html?v=2025.12.25.1">‚á• Timeline</a>
                    <a class="nav-switch-link" href="voice.html?v=2025.12.25.1">‚ñ∑ Voice</a>
                </div>
            </div>

            <!-- Prompt modal: 9 diagram choices -->
            <div class="modal-overlay gt-template-modal" id="gtTemplateModal" role="dialog" aria-modal="true"
                aria-labelledby="gtTemplateModalTitle">
                <div class="modal gt-template-modal__dialog">
                    <header class="modal-header">
                        <h3 id="gtTemplateModalTitle" title="‚äû Mod√®le">‚äû Mod√®le</h3>
                        <button id="gtTemplateModalClose" class="btn-secondary" type="button">‚úï</button>
                    </header>
                    <div class="blueprint-grid gt-template-modal__list" id="gtTemplateModalList" role="listbox"
                        aria-label="Prompt de diagrammes">
                        <!-- cards rendered by JS -->
                    </div>
                    <div class="modal-actions">
                        <button id="gtTemplateModalApply" class="btn-primary" type="button">Appliquer</button>
                    </div>
                </div>
            </div>
            <div class="tabs-actions">
                <div id="pageTabs" class="tabs"></div>
                <button id="addPageBtn" class="tab-action" title="Ajouter une page">+</button>
                <button id="deletePageBtn" class="tab-action" title="Supprimer la page">√ó</button>
            </div>
            <div class="global-actions">
                <button id="gtTemplateModalTrigger" class="btn drawer-toggle-btn" type="button"
                    title="‚äû Mod√®le">‚äû Mod√®le</button>
                <button id="gtContextModalTrigger" class="btn drawer-toggle-btn" type="button" title="‚∏ô Gutenberg">‚∏ô
                    Contexte</button>
                <button id="gtPromptModalTrigger" class="btn ai-button" type="button" title="‚åò Prompt">‚åò Prompt</button>
                <div class="menu-trigger" id="capsuleMenuTrigger">
                    <button id="capsuleMenuBtn" class="btn" type="button" title="Capsule">‚¨† Capsule</button>
                    <div class="context-menu" id="capsuleMenu">
                        <div class="menu-panel">
                            <button id="capsuleNewDocBtn" type="button" class="menu-panel-btn">üóã Nouveau</button>
                            <button id="capsuleDraftSaveBtn" type="button" class="menu-panel-btn">üñ´
                                Enregistrer</button>
                            <button id="capsuleOpenBtn" type="button" class="menu-panel-btn">‚§∑ Ouvrir</button>
                            <button id="capsuleSaveBtn" type="button" class="menu-panel-btn">‚≠≥ T√©l√©charger</button>
                            <button id="infoButton" type="button" class="menu-panel-btn">‚éâ Vaisseau</button>
                        </div>
                    </div>
                </div>
                <div class="share-menu-wrapper">
                    <button id="shareBtn" class="btn btn-secondary" type="button" title="Lien de la capsule">‚òç
                        Nexus</button>
                    <div data-share-menu-slot></div>
                </div>

            </div>
        </header>

            <div id="gtContextModalBackdrop" class="drawer-overlay" aria-hidden="true"></div>

        <div id="infoPopup" class="info-popup" role="dialog" aria-live="polite">
            <img src="logo.gif" alt="Logo Go-Toolkit">
            <strong>Module Draw (Le Cardinal)</strong>
            <span>Version 2025.12.17</span>
            <span>D√©velopp√© par Quang TRAN.</span>
            <span>Usage r√©serv√© √† Savane Consulting.</span>
            <div class="info-actions">
                <button id="updateAppBtn" type="button" class="update-btn">R√©initialiser</button>
                <button id="tourReplayBtn" type="button" class="secondary">Tour guid√©</button>
            </div>
        </div>

        <main class="connect-layout">
            <section class="connect-right">
                <div class="diagram-title-row">
                    <input id="diagramTitleInput" class="diagram-title-input" type="text" readonly
                        placeholder="Titre de la page">
                </div>
                <div class="excalidraw-card">
                    <div id="excalidrawHost"></div>
                </div>
            </section>

            <section class="connect-left">
                <div class="prompt-input-card" id="prompt-input-card">
                    <div class="card-title-row">
                        <label>Sc√©nario</label>
                        <button id="clearMermaidBtn" class="btn" type="button">‚äò Vider</button>
                        <button id="generateBtn" class="btn-primary" type="button">‚åò R√©pondre</button>
                    </div>
                    <div class="draw-type-control">
                        <span class="draw-type-control-label">Mod√®le <span id="selectedTemplateLabel"
                                aria-live="polite"></span></span>
                        <div class="draw-type-selector" role="group" aria-label="Type de diagramme">
                            <button class="draw-type-btn active" type="button" data-draw-type="sequence"
                                aria-pressed="true">‚áÑ √âchange</button>
                            <button class="draw-type-btn" type="button" data-draw-type="flow" aria-pressed="false">‚óá
                                Processus</button>
                            <button class="draw-type-btn" type="button" data-draw-type="class" aria-pressed="false">‚ÅÇ
                                Structure</button>
                        </div>
                    </div>
                    <div class="prompt-input-wrapper">
                        <div id="promptSuggestion" class="prompt-suggestion" aria-hidden="true"></div>
                        <div id="templateTooltip" class="template-tooltip" aria-hidden="true"></div>
                        <div class="speech-field-wrapper">
                            <div class="speech-suggestion" data-speech-suggestion="promptInput" aria-hidden="true">
                            </div>
                            <textarea id="promptInput" rows="5"
                                placeholder="D√©cris ton contexte produit, tes utilisateurs, ta probl√©matique..."></textarea>
                            <button class="speech-button" type="button" data-speech-target="promptInput"
                                title="Dict√©e vocale" aria-label="Activer la dict√©e vocale">‚óâ</button>
                        </div>
                    </div>
                    <div id="promptAltRow" class="prompt-alt-row" aria-live="polite"></div>
                </div>
                <div class="mermaid-output-card">
                    <div class="card-title-row">
                        <label>Script</label>

                        <button id="refreshExcalidrawBtn" class="btn" type="button">‚Ü∫ Restaurer</button>
                    </div>
                    <textarea id="mermaidOutput"></textarea>
                </div>
            </section>
        </main>
    </div>

    <div data-toast-slot="statusToast" data-toast-class="status-toast" data-toast-role="status"></div>

    <div id="tourOverlay" class="tour-overlay" aria-hidden="true">
        <div class="tour-highlight" aria-hidden="true"></div>
        <div class="tour-panel">
            <span class="tour-step-counter" id="tourStepCounter"></span>
            <h4 id="tourStepTitle"></h4>
            <p id="tourStepDescription"></p>
            <div class="tour-step-footer">
                <button id="tourPrevBtn" type="button">Pr√©c√©dent</button>
                <button id="tourNextBtn" type="button" class="primary">Suivant</button>
                <button id="tourCloseBtn" type="button">Fermer</button>
            </div>
        </div>
        <button id="tourSkipBtn" class="tour-skip" type="button" aria-label="Fermer">√ó</button>
    </div>

    <div class="modal-overlay gt-prompt-modal" id="gtPromptModal" role="dialog" aria-modal="true" aria-labelledby="gtPromptModalTitle">
        <div class="modal">
            <header class="modal-header">
                <h3 id="gtPromptModalTitle" title="‚åò Prompt">‚åò Prompt</h3>
                <button id="gtPromptModalClose" class="btn-secondary" type="button" data-close="gtPromptModal">‚úï</button>
            </header>
            <!-- API key and reasoning settings are global (R√©glages) and moved to index.html -->
            <label>
                <span>Prompt personnalis√©</span>
                <textarea id="promptTemplateField" rows="6"
                    style="font-family: Menlo, Consolas, 'Courier New', monospace;"></textarea>
            </label>
            <div class="modal-actions">
                <button id="resetPromptBtn" class="btn" type="button">‚Ü∫ R√©initialiser</button>
                <button id="applyAiSettingsBtn" class="btn-primary" type="button">Appliquer</button>
            </div>
        </div>
    </div>

    <script>
        window.GO_TOOLKIT_SHARE_API_URL =
            window.GO_TOOLKIT_SHARE_API_URL || "https://share.gotoolkit.workers.dev/";
    </script>
    <script src="js/idb-doc-store.js"></script>
    <script src="js/storage-service.js"></script>
    <script src="js/shared-ui.js"></script>
    <script src="js/share-worker-client.js"></script>
    <script src="js/share-history.js"></script>
    <script src="js/capsule-drafts.js"></script>
    <script src="js/prompt.js?v=2025.12.25.1"></script>
    <script src="js/ia-client.js"></script>
    <script src="js/ia-config.js"></script>
    <script src="js/template-criteria.js"></script>
    <script>
        var process = window.process || {};
        (function () {
            process.env = process.env || {};
            if (!process.env.NODE_ENV) {
                process.env.NODE_ENV = "production";
            }
            process.browser = true;
            window.process = process;
        })();
    </script>
    <script src="js/connect.bundle.js" data-excalidraw-bundle="true"></script>
    <script>
        // Load runtime config synchronously so tour behavior can be controlled
        window.GoToolkitConfig = window.GoToolkitConfig || { enableTours: false };
        try {
            var __cfg_xhr = new XMLHttpRequest();
            __cfg_xhr.open('GET', '/config.json', false);
            __cfg_xhr.send(null);
            if (__cfg_xhr.status >= 200 && __cfg_xhr.status < 300) {
                try { window.GoToolkitConfig = Object.assign({}, window.GoToolkitConfig, JSON.parse(__cfg_xhr.responseText)); } catch (e) { }
            }
        } catch (e) { }
        document.addEventListener('DOMContentLoaded', function () {
            if (window.GoToolkitConfig && window.GoToolkitConfig.enableTours === false) {
                var btn = document.getElementById('tourReplayBtn');
                if (btn) btn.style.display = 'none';
                var overlay = document.getElementById('tourOverlay');
                if (overlay) {
                    overlay.setAttribute('aria-hidden', 'true');
                    overlay.style.display = 'none';
                }
            }
        });
    </script>
    <script>
        (() => {
            const DEFAULT_PROMPT_TEMPLATE =
                (window.GoPrompts && window.GoPrompts.drawDefaultPromptTemplate) || "";
            const DEFAULT_SYSTEM_PROMPT =
                (window.GoPrompts && window.GoPrompts.drawDefaultSystemPrompt) ||
                "Tu proposes des nouvelles id√©es en gardant le texte existant intact." +
                "Il doit poursuivre naturellement la phrase avec entre 4 √† 7 mots." +
                "Propose 3 alternatives (4 √† 7 mots). Pour chaque alternative, fournis un label (1-2 mots-cl√© du texte alternatif) et le texte complet. " +
                "R√©ponds STRICTEMENT au format JSON demand√©.";
            const DRAW_TYPES = [
                { id: "sequence", label: "√âchange", promptValue: "sequenceDiagram", emoji: "‚áÑ" },
                { id: "flow", label: "Processus", promptValue: "flowchart", emoji: "‚óá" },
                { id: "class", label: "Structure", promptValue: "classDiagram", emoji: "‚ÅÇ" }
            ];
            const DEFAULT_DRAW_TYPE = DRAW_TYPES[0].id;
            const MERMAID_STYLE_DEFAULTS = {
                strokeWidth: 2,
                strokeStyle: "solid",
                roughness: 0,
                roundness: null
            };
            const STORAGE_KEY = "connect-ai-state";
            const API_KEY_STORAGE_KEY = "go-toolkit-api-key";
            function getShareDraftKey(token) {
                return `${STORAGE_KEY}-share-${token}`;
            }

            function readShareDraft(token) {
                if (!token || typeof window === "undefined" || !window.localStorage) return null;
                try {
                    const raw = localStorage.getItem(getShareDraftKey(token));
                    if (!raw) return null;
                    const parsed = JSON.parse(raw);
                    if (!parsed || typeof parsed !== "object") return null;
                    return parsed;
                } catch (err) {
                    console.warn("Impossible de lire le cache local de la capsule", err);
                    return null;
                }
            }

            function writeShareDraft(token, payload, updatedAt) {
                if (!token || typeof window === "undefined" || !window.localStorage) return;
                try {
                    const value = {
                        payload,
                        updatedAt: updatedAt || new Date().toISOString()
                    };
                    localStorage.setItem(getShareDraftKey(token), JSON.stringify(value));
                } catch (err) {
                    console.warn("Impossible de sauvegarder le cache local de la capsule", err);
                }
            }
            const FIRESTORE_COLLECTION = "diagrams";
            const SHARE_QUERY_PARAM = "share";
            const EDIT_QUERY_PARAM = "edit";
            const SHARE_WORKER_UNAVAILABLE_MESSAGE =
                "Le partage priv√© n√©cessite le worker Cloudflare li√© √† Go-Toolkit.";
            const shareWorkerService = window.goToolkitShareWorker;
            const EXCALIDRAW_BUNDLE_SRC = "js/connect.bundle.js";
            const EXCALIDRAW_BRIDGE_MAX_WAIT_MS = 8000;
            const EXCALIDRAW_BRIDGE_POLL_INTERVAL_MS = 50;

            let state = {
                pages: [],
                activeIndex: 0,
                apiKey: "",
                promptTemplate: DEFAULT_PROMPT_TEMPLATE,
                systemPrompt: DEFAULT_SYSTEM_PROMPT,
                reasoningEffort: "low",
                templateId: null
            };
            let pendingSceneCode = "";
            let bridgeDetectionPromise = null;
            let sceneBuildRequestId = 0;
            let shareWorkerAvailable = Boolean(shareWorkerService?.isReady);
            let currentShareToken = null;
            let shareLoadedFromRemote = false;
            let shareStatusMessage = "";
            let shareStatusType = "";
            let shareRequestInProgress = false;
            let shareLastUpdatedAt = null;
            const capsuleDrafts = window.goToolkitCapsuleDrafts;
            let currentDraftId = null;
            let draftSaveTimer = null;
            let isDraftSaving = false;

            function getDrawSharePreview() {
                const firstPage = state.pages?.[0];
                const title = (firstPage?.title || firstPage?.label || "Page 1").trim();
                const desc = (firstPage?.input || "")
                    .split(/\r?\n/)
                    .map(line => line.trim())
                    .filter(Boolean)
                    .slice(0, 2)
                    .join(" ¬∑ ");
                return { title, description: desc || "Compl√®te le contexte pour l'afficher ici." };
            }

            async function persistDrawShareRecord(token, updatedAt) {
                if (!shareHistory || !token) {
                    return;
                }
                try {
                    const preview = getDrawSharePreview();
                    await shareHistory.upsertRecord("draw", {
                        token,
                        updatedAt: updatedAt || new Date().toISOString(),
                        title: preview.title,
                        description: preview.description
                    });
                } catch (err) {
                    console.warn("Impossible d'archiver le lien Le Cardinal", err);
                }
            }

            const promptInput = document.getElementById("promptInput");
            const promptOriginalPlaceholder = promptInput ? (promptInput.getAttribute('placeholder') || '') : '';
            const promptSuggestion = document.getElementById("promptSuggestion");
            const promptAltRow = document.getElementById("promptAltRow");
            const selectedTemplateLabel = document.getElementById("selectedTemplateLabel");
            const promptInputWrapper = document.querySelector(".prompt-input-wrapper");
            if (promptInput && promptInputWrapper && document.activeElement === promptInput) {
                promptInputWrapper.classList.add("is-focused");
            }
            if (promptAltRow) {
                promptAltRow.style.display = "none";
            }
            // Hide suggestions when the caret is moved by user action
            try {
                let lastCaretPos = promptInput ? (promptInput.selectionStart ?? 0) : 0;
                function hideBothSuggestionsOnCaretMove() {
                    try {
                        if (promptSuggestion) {
                            promptSuggestion.innerHTML = "";
                            promptSuggestion.style.opacity = "0";
                        }
                        if (promptInput) {
                            const ss = document.querySelector(`[data-speech-suggestion="${promptInput.id}"]`);
                            if (ss) {
                                ss.classList.remove("visible");
                                ss.innerHTML = "";
                            }
                            const saved = promptInput.getAttribute('data-original-placeholder');
                            if (saved !== null) {
                                promptInput.setAttribute('placeholder', saved || '');
                                promptInput.removeAttribute('data-original-placeholder');
                            } else if (promptOriginalPlaceholder) {
                                promptInput.setAttribute('placeholder', promptOriginalPlaceholder);
                            }
                        }
                    } catch (e) { /* noop */ }
                }
                if (promptInput) {
                    const checkCaret = () => {
                        try {
                            const pos = promptInput.selectionStart ?? 0;
                            if (pos !== lastCaretPos) {
                                lastCaretPos = pos;
                                hideBothSuggestionsOnCaretMove();
                            }
                        } catch (e) { /* noop */ }
                    };
                    promptInput.addEventListener('mouseup', () => setTimeout(checkCaret, 0));
                    promptInput.addEventListener('keyup', checkCaret);
                    promptInput.addEventListener('click', checkCaret);
                    promptInput.addEventListener('input', checkCaret);
                    promptInput.addEventListener('keydown', () => setTimeout(checkCaret, 0));
                }
            } catch (e) { /* noop */ }
            const diagramTitleInput = document.getElementById("diagramTitleInput");
            const mermaidOutput = document.getElementById("mermaidOutput");
            const drawTypeButtons = Array.from(document.querySelectorAll(".draw-type-btn[data-draw-type]"));
            const drawTypePlaceholders = {
                flow: "D√©cris le processus, les d√©cisions et les r√©sultats.",
                class: "D√©cris les √©l√©ments, leurs caract√©ristiques, leurs r√¥les et leurs relations.",
                sequence: "D√©cris les acteurs, les interactions et l'ordre."
            };
            const SpeechRecognitionCtor = window.SpeechRecognition || window.webkitSpeechRecognition;
            let activeSpeechRecognition = null;
            let activeSpeechButton = null;
            let activeSpeechWrapper = null;
            let activeSpeechField = null;
            let lastSpeechInterim = "";

            function appendSpeechText(field, transcript) {
                if (!field || !transcript) {
                    return;
                }
                const normalized = transcript.trim();
                if (!normalized) {
                    return;
                }
                // Smart separator: prefer a space between fragments, insert a newline
                // only if the existing text ends with sentence punctuation.
                const lastChar = field.value.slice(-1);
                const endsWithNewline = lastChar === "\n";
                const endsWithSentencePunct = /[.!?]\s*$/.test(field.value);
                const startsWithPunct = /^[,;:.!?)\]}]/.test(normalized);
                let separator = "";
                if (field.value && !endsWithNewline) {
                    if (startsWithPunct) separator = "";
                    else if (endsWithSentencePunct) separator = "\n";
                    else separator = " ";
                }
                field.value = field.value + (field.value ? separator : "") + normalized;
                field.dispatchEvent(new Event("input", { bubbles: true }));
                clearSpeechSuggestion(field);
            }

            function sanitizeScenarioText(raw) {
                if (!raw) return "";
                let text = String(raw);
                try {
                    const ps = document.getElementById('promptSuggestion');
                    if (ps) {
                        const overlay = ps.textContent || ps.innerText || '';
                        if (overlay) {
                            // remove overlay text if accidentally present in the value
                            const idx = text.indexOf(overlay);
                            if (idx !== -1) {
                                text = (text.slice(0, idx) + text.slice(idx + overlay.length)).trim();
                            }
                        }
                    }
                } catch (e) { /* noop */ }
                return text;
            }

            function getSpeechSuggestionElement(field) {
                if (!field) {
                    return null;
                }
                return document.querySelector(`[data-speech-suggestion="${field.id}"]`);
            }

            function updateSpeechSuggestion(field, partial) {
                const suggestionEl = getSpeechSuggestionElement(field);
                if (!suggestionEl) {
                    return;
                }
                if (!partial) {
                    suggestionEl.classList.remove("visible");
                    suggestionEl.innerHTML = "";
                    return;
                }
                const safeCurrent = escapeHtml(field.value);
                const safePartial = escapeHtml(partial);
                suggestionEl.innerHTML = `<span class="speech-suggestion-current">${safeCurrent}</span><span class="speech-suggestion-partial">${safePartial}</span>`;
                suggestionEl.classList.add("visible");
                if (field === activeSpeechField) {
                    lastSpeechInterim = partial || "";
                }
                // Hide prompt inline suggestion while speech interim is visible to avoid overlap.
                try {
                    const ps = document.getElementById("promptSuggestion");
                    if (ps) {
                        ps.setAttribute("data-hidden-by-speech", "true");
                        ps.style.opacity = "0";
                    }
                    // hide the textarea placeholder while speech interim is visible
                    try {
                        if (field && field.setAttribute) {
                            const existing = field.getAttribute('placeholder') || '';
                            if (existing) field.setAttribute('data-original-placeholder', existing);
                            field.setAttribute('placeholder', '');
                        }
                    } catch (e) { /* noop */ }
                } catch (e) { /* noop */ }
            }

            function clearSpeechSuggestion(field) {
                updateSpeechSuggestion(field, "");
                if (field === activeSpeechField) {
                    lastSpeechInterim = "";
                }
                // If the prompt inline suggestion was hidden while speech interim was visible,
                // restore it so the prompt assist can re-render.
                try {
                    const ps = document.getElementById("promptSuggestion");
                    if (ps && ps.getAttribute("data-hidden-by-speech") === "true") {
                        ps.removeAttribute("data-hidden-by-speech");
                        // allow renderPromptSuggestion to repopulate the UI
                        requestAnimationFrame(() => {
                            try {
                                refreshPromptSuggestion();
                            } catch (e) { /* noop */ }
                        });
                    }
                    // restore placeholder if it was hidden for speech
                    try {
                        if (promptInput) {
                            const saved = promptInput.getAttribute('data-original-placeholder');
                            if (saved !== null) {
                                promptInput.setAttribute('placeholder', saved || '');
                                promptInput.removeAttribute('data-original-placeholder');
                            } else if (promptOriginalPlaceholder) {
                                promptInput.setAttribute('placeholder', promptOriginalPlaceholder);
                            }
                        }
                    } catch (e) { /* noop */ }
                } catch (e) { /* noop */ }
            }

            function deactivateSpeechUiClasses() {
                if (activeSpeechButton) {
                    activeSpeechButton.classList.remove("speech-button--active");
                    activeSpeechButton = null;
                }
                if (activeSpeechWrapper) {
                    activeSpeechWrapper.classList.remove("speech-active");
                    activeSpeechWrapper = null;
                }
            }

            function stopActiveSpeechSession({ flushInterim = false, skipAbort = false } = {}) {
                const field = activeSpeechField;
                if (flushInterim && field && lastSpeechInterim) {
                    appendSpeechText(field, lastSpeechInterim);
                }
                lastSpeechInterim = "";
                if (activeSpeechRecognition) {
                    if (!skipAbort) {
                        activeSpeechRecognition.abort();
                    }
                    activeSpeechRecognition = null;
                }
                deactivateSpeechUiClasses();
                if (field) {
                    clearSpeechSuggestion(field);
                }
                if (promptInput) {
                    clearSpeechSuggestion(promptInput);
                }
                // Hide the template tooltip when speech recognition ends
                try {
                    const tt = document.getElementById("templateTooltip");
                    if (tt) tt.setAttribute("aria-hidden", "true");
                    if (typeof drawTemplateTooltipRaf !== "undefined" && drawTemplateTooltipRaf !== null) {
                        cancelAnimationFrame(drawTemplateTooltipRaf);
                        drawTemplateTooltipRaf = null;
                    }
                } catch (e) { /* noop */ }

                activeSpeechField = null;
            }

            function startSpeechRecognition(field, button) {
                if (!SpeechRecognitionCtor) {
                    alert("Reconnaissance vocale non disponible dans ce navigateur.");
                    return;
                }
                if (!field) {
                    return;
                }
                if (activeSpeechButton === button) {
                    stopActiveSpeechSession();
                    return;
                }
                stopActiveSpeechSession();
                const recognition = new SpeechRecognitionCtor();
                recognition.lang = "fr-FR";
                recognition.interimResults = true;
                recognition.maxAlternatives = 1;
                recognition.continuous = true;
                const wrapper = button?.closest ? button.closest(".speech-field-wrapper") : null;
                recognition.addEventListener("start", () => {
                    button?.classList.add("speech-button--active");
                    activeSpeechRecognition = recognition;
                    activeSpeechButton = button;
                    activeSpeechField = field;
                    lastSpeechInterim = "";
                    field.focus();
                    clearSpeechSuggestion(field);
                    if (wrapper) {
                        wrapper.classList.add("speech-active");
                        activeSpeechWrapper = wrapper;
                    }
                });
                recognition.addEventListener("result", event => {
                    let interimText = "";
                    for (let i = event.resultIndex; i < event.results.length; i++) {
                        const result = event.results[i];
                        const transcript = (result[0]?.transcript || "").trim();
                        if (!transcript) continue;
                        if (result.isFinal) {
                            appendSpeechText(field, transcript);
                        } else {
                            interimText += (interimText ? " " : "") + transcript;
                        }
                    }
                    if (interimText) {
                        updateSpeechSuggestion(field, interimText);
                    } else {
                        const lastResult = event.results[event.results.length - 1];
                        if (lastResult && !lastResult.isFinal) {
                            clearSpeechSuggestion(field);
                        }
                    }
                });
                recognition.addEventListener("error", () => {
                    console.warn("Speech recognition error");
                    setStatus("Reconnaissance vocale termin√©e");
                    clearSpeechSuggestion(field);
                    stopActiveSpeechSession();
                });
                recognition.addEventListener("end", () => {
                    if (activeSpeechRecognition === recognition) {
                        stopActiveSpeechSession({ skipAbort: true });
                    }
                });
                try {
                    recognition.start();
                } catch (err) {
                    console.error("Speech recognition start failed", err);
                    alert("Impossible de d√©marrer la dict√©e vocale.");
                }
            }

            document.addEventListener("click", event => {
                const targetButton =
                    event.target && typeof event.target.closest === "function" ? event.target.closest(".speech-button") : null;
                if (!targetButton) return;
                event.preventDefault();
                const targetId = targetButton.getAttribute("data-speech-target");
                const field = targetId ? document.getElementById(targetId) : null;
                if (field) {
                    startSpeechRecognition(field, targetButton);
                }
            });

            function autoStartSpeechForField(fieldId) {
                if (!SpeechRecognitionCtor) {
                    return;
                }
                const field = document.getElementById(fieldId);
                if (!field || field.value.trim()) {
                    return;
                }
                const button = document.querySelector(`[data-speech-target="${fieldId}"]`);
                if (!button) {
                    return;
                }
                startSpeechRecognition(field, button);
            }

            function initAutoSpeechOnDrawLoad() {
                if (!isSpeechAutoEnabled()) return;
                autoStartSpeechForField("promptInput");
            }

            if (document.readyState === "loading") {
                document.addEventListener("DOMContentLoaded", initAutoSpeechOnDrawLoad);
            } else {
                initAutoSpeechOnDrawLoad();
            }

            function isSpeechTypingKey(event) {
                if (!event?.key) return false;
                if (event.metaKey || event.ctrlKey || event.altKey) return false;
                const key = event.key;
                if (key.length === 1) return true;
                return key === "Backspace" || key === "Delete" || key === "Enter";
            }

            function handleSpeechKeydown(event) {
                if (!activeSpeechRecognition || !activeSpeechField) return;
                if (event.target !== activeSpeechField) {
                    return;
                }
                if (!isSpeechTypingKey(event)) return;
                stopActiveSpeechSession({ flushInterim: true });
            }
            document.addEventListener("keydown", handleSpeechKeydown, true);
            let currentPromptSuggestion = "";
            let currentPromptAiSuggestion = "";
            let promptSuggestDebounce = null;
            let promptSuggestAbortController = null;
            let promptSuggestRequestId = 0;
            let inlineSuggestion = "";
            let promptAltSuggestions = [];
            // When the user manually moves the caret, suppress following the textarea
            // scroll/selection so the suggestion overlay doesn't jump under the cursor.
            let suppressSuggestionFollow = false;
            let suppressSuggestionTimer = null;
            let templateCriteriaStatus = {};
            let lastAnalyzedSentenceCount = 0;
            let lastAnalyzedTemplateId = null;
            let criteriaAnalysisAbortController = null;

            const DIAGRAM_PROMPTS =
                (window.GoPrompts && Array.isArray(window.GoPrompts.drawPrompts) && window.GoPrompts.drawPrompts.length
                    ? window.GoPrompts.drawPrompts
                    : []);

            let selectedPromptId = null;

            function getSelectedPrompt() {
                if (!selectedPromptId) return null;
                return DIAGRAM_PROMPTS.find(b => b.id === selectedPromptId) || null;
            }

            function getTemplateCriteria(template) {
                return GoToolkitTemplateCriteria.getTemplateCriteria(template);
            }

            function getTemplateSummary(template) {
                return GoToolkitTemplateCriteria.getTemplateSummary(template);
            }

            let drawTemplateTooltipRaf = null;
            let promptTooltipRenderAllowed = false;
            const SPEECH_MODE_STORAGE_KEY = "go-toolkit-speech-mode";

            function getSpeechModePreference() {
                if (typeof window === "undefined" || typeof window.localStorage === "undefined") {
                    return "manual";
                }
                try {
                    const stored = window.localStorage.getItem(SPEECH_MODE_STORAGE_KEY);
                    return stored === "auto" ? "auto" : "manual";
                } catch (error) {
                    return "manual";
                }
            }

            function isSpeechAutoEnabled() {
                return getSpeechModePreference() === "auto";
            }

            function positionDrawTemplateTooltip() {
                const tooltip = document.getElementById("templateTooltip");
                const promptInput = document.getElementById("promptInput");
                if (!tooltip || !promptInput) return;
                if (tooltip.getAttribute("aria-hidden") === "true") return;
                const targetRect = promptInput.getBoundingClientRect();
                const tooltipRect = tooltip.getBoundingClientRect();
                if (!targetRect.width || !targetRect.height || !tooltipRect.width || !tooltipRect.height) {
                    return;
                }
                const gap = 6;
                const maxLeft = Math.max(gap, window.innerWidth - tooltipRect.width - gap);
                const left = Math.min(maxLeft, Math.max(gap, targetRect.left));
                let top = targetRect.bottom + gap;
                if (top + tooltipRect.height + gap > window.innerHeight) {
                    top = targetRect.top - tooltipRect.height - gap;
                }
                if (top < gap) {
                    top = gap;
                }
                tooltip.style.left = `${left}px`;
                tooltip.style.top = `${top}px`;
            }

            function scheduleDrawTemplateTooltipPosition() {
                const tooltip = document.getElementById("templateTooltip");
                if (!tooltip || tooltip.getAttribute("aria-hidden") === "true") return;
                if (drawTemplateTooltipRaf !== null) {
                    cancelAnimationFrame(drawTemplateTooltipRaf);
                }
                drawTemplateTooltipRaf = requestAnimationFrame(() => {
                    drawTemplateTooltipRaf = null;
                    positionDrawTemplateTooltip();
                });
            }

            function renderTemplateTooltip(template, statusMap = null) {
                const tooltip = document.getElementById("templateTooltip");
                if (!tooltip) return;
                const lines = GoToolkitTemplateCriteria.renderTooltipLines(template, statusMap);
                tooltip.innerHTML = lines.join("<br>");
                const shouldShow = promptTooltipRenderAllowed && Boolean(lines.length);
                tooltip.setAttribute("aria-hidden", shouldShow ? "false" : "true");
                if (shouldShow) {
                    scheduleDrawTemplateTooltipPosition();
                }
            }

            function updateSelectedTemplateLabelDisplay() {
                if (!selectedTemplateLabel) return;
                const sel = getSelectedPrompt();
                const labelText = sel?.label || "";
                selectedTemplateLabel.textContent = labelText ? `: ${labelText}` : "";
                // update template tooltip content if present
                try {
                    const templateStatus = sel?.id ? templateCriteriaStatus[sel.id] : null;
                    renderTemplateTooltip(sel, templateStatus);
                } catch (e) { /* noop */ }
            }

            function renderPromptList(selectedId) {
                const list = document.getElementById("gtTemplateModalList");
                if (!list) return;
                list.innerHTML = "";
                const sel = selectedId || selectedPromptId;
                DIAGRAM_PROMPTS.forEach(bp => {
                    const card = document.createElement("div");
                    card.className = "gt-template-card";
                    card.dataset.bpId = bp.id;
                    card.tabIndex = 0;
                    if (bp.id === sel) card.classList.add("gt-template-card--selected");
                    const drawTypeMeta = DRAW_TYPES.find(option => option.id === bp.drawType) || DRAW_TYPES[0];
                    const drawTypeIcon = drawTypeMeta?.icon || drawTypeMeta?.emoji || "";
                    const title = document.createElement("h4");
                    title.textContent = bp.label;
                    const subtitle = document.createElement("p");
                    subtitle.className = "template-desc-line";
                    subtitle.textContent = `${drawTypeIcon ? drawTypeIcon + " " : ""}${drawTypeMeta.label}`;
                    const desc = document.createElement("p");
                    desc.innerHTML = (bp.description || "")
                        .split(/\n/)
                        .map(line => escapeHtml(line))
                        .join("<br>");
                    card.appendChild(title);
                    card.appendChild(subtitle);
                    card.appendChild(desc);
                    card.addEventListener("click", () => {
                        // visual selection only; apply on explicit action
                        list.querySelectorAll(".gt-template-card").forEach(c => c.classList.remove("gt-template-card--selected"));
                        card.classList.add("gt-template-card--selected");
                        selectedPromptId = bp.id;
                    });
                    card.addEventListener("keydown", (ev) => {
                        if (ev.key === "Enter" || ev.key === " ") {
                            ev.preventDefault();
                            card.click();
                        }
                    });
                    list.appendChild(card);
                });
            }

            function openPromptModal() {
                const overlay = document.getElementById("gtTemplateModal");
                if (!overlay) return;
                renderPromptList(selectedPromptId);
                overlay.classList.add("open");
                overlay.setAttribute("aria-hidden", "false");
            }

            function closePromptModal() {
                const overlay = document.getElementById("gtTemplateModal");
                if (!overlay) return;
                overlay.classList.remove("open");
                overlay.setAttribute("aria-hidden", "true");
            }

            document.addEventListener("click", (ev) => {
                const target = ev.target;
                // open button
                if (target && target.id === "gtTemplateModalTrigger") {
                    openPromptModal();
                    return;
                }
                // overlay click -> close
                if (target && target.id === "gtTemplateModal") {
                    closePromptModal();
                    return;
                }
            });

            document.addEventListener("keydown", (ev) => {
                if (ev.key === "Escape") closePromptModal();
            });

            // close / apply buttons
            document.addEventListener("DOMContentLoaded", () => {
                const closeBtn = document.getElementById("gtTemplateModalClose");
                const applyBtn = document.getElementById("gtTemplateModalApply");
                if (closeBtn) closeBtn.addEventListener("click", closePromptModal);
                if (applyBtn) applyBtn.addEventListener("click", () => {
                    applyPromptSelection();
                });
            });

            function applyPromptSelection() {
                if (!selectedPromptId) {
                    closePromptModal();
                    return;
                }
                const bp = DIAGRAM_PROMPTS.find(b => b.id === selectedPromptId);
                if (!bp) {
                    closePromptModal();
                    return;
                }
                state.templateId = selectedPromptId;
                updateSelectedTemplateLabelDisplay();
                try { saveState(); } catch (e) { /* noop */ }
                const promptInputEl = document.getElementById("promptInput");
                try { updateActivePageDrawType(bp.drawType); } catch (err) { }
                closePromptModal();
                if (bp.defaultScript && mermaidOutput) {
                    mermaidOutput.value = bp.defaultScript;
                    mermaidOutput.dispatchEvent(new Event("input", { bubbles: true }));
                }
                if (promptInputEl) {
                    promptInputEl.focus();
                    refreshPromptSuggestion();
                    syncPromptSuggestionScroll();
                    schedulePromptAISuggestion();
                    triggerCriteriaAnalysis({ force: true });
                }
            }

            const generateBtn = document.getElementById("generateBtn");
            const statusToast = document.getElementById("statusToast");
            const pageTabs = document.getElementById("pageTabs");
            const addPageBtn = document.getElementById("addPageBtn");
            const deletePageBtn = document.getElementById("deletePageBtn");
            const clearMermaidBtn = document.getElementById("clearMermaidBtn");
            const refreshExcalidrawBtn = document.getElementById("refreshExcalidrawBtn");
            const infoButton = document.getElementById("infoButton");
            const infoPopup = document.getElementById("infoPopup");
            const updateAppBtn = document.getElementById("updateAppBtn");
            const tourReplayBtn = document.getElementById("tourReplayBtn");
            const tourOverlay = document.getElementById("tourOverlay");
            const tourHighlight = tourOverlay?.querySelector(".tour-highlight");
            const tourStepCounter = document.getElementById("tourStepCounter");
            const tourStepTitle = document.getElementById("tourStepTitle");
            const tourStepDescription = document.getElementById("tourStepDescription");
            const tourPrevBtn = document.getElementById("tourPrevBtn");
            const tourNextBtn = document.getElementById("tourNextBtn");
            const tourCloseBtn = document.getElementById("tourCloseBtn");
            const tourSkipBtn = document.getElementById("tourSkipBtn");
            const promptModal = document.getElementById("gtPromptModal");
            const aiSettingsBtn = document.getElementById("gtPromptModalTrigger");
            const closePromptModalBtn = document.getElementById("gtPromptModalClose");
            // API key and reasoning controls moved to global settings (index.html)
            const promptTemplateField = document.getElementById("promptTemplateField");
            const systemPromptField = document.getElementById("systemPromptField");
            const resetPromptBtn = document.getElementById("resetPromptBtn");
            const navSwitcherBtn = document.getElementById("navSwitcherBtn");
            const navSwitcherMenu = document.getElementById("navSwitcherMenu");
            const shareBtn = document.getElementById("shareBtn");
            const shareMenu = document.getElementById("shareMenu");
            const shareLinkField = document.getElementById("shareLinkField");
            const shareMenuStatus = document.getElementById("shareMenuStatus");
            const shareCreateBtn = document.getElementById("shareCreateBtn");
            const shareUpdateBtn = document.getElementById("shareUpdateBtn");
            const capsuleMenuBtn = document.getElementById("capsuleMenuBtn");
            const capsuleMenu = document.getElementById("capsuleMenu");
            const capsuleNewDocBtn = document.getElementById("capsuleNewDocBtn");
            const capsuleDraftSaveBtn = document.getElementById("capsuleDraftSaveBtn");
            // prompt input tooltip behavior
            (function setupPromptTooltip() {
                const promptEl = document.getElementById('promptInput');
                const wrapper = document.querySelector('.prompt-input-wrapper');
                const tooltip = document.getElementById('templateTooltip');
                if (!promptEl || !wrapper || !tooltip) return;
                let inactivityTimer = null;
                let focusClickPending = false;
                const INACTIVITY_MS = 5000;

                function clearInactivityTimer() {
                    if (inactivityTimer) {
                        clearTimeout(inactivityTimer);
                        inactivityTimer = null;
                    }
                }

                function startInactivityTimer() {
                    clearInactivityTimer();
                    inactivityTimer = setTimeout(() => {
                        inactivityTimer = null;
                        hidePromptTooltip({ removeFocus: true });
                    }, INACTIVITY_MS);
                }

                function showPromptTooltip() {
                    promptTooltipRenderAllowed = true;
                    focusClickPending = false;
                    wrapper.classList.add('is-focused');
                    const sel = getSelectedPrompt();
                    const status = sel?.id ? templateCriteriaStatus[sel.id] : null;
                    renderTemplateTooltip(sel, status);
                    startInactivityTimer();
                }

                function hidePromptTooltip({ removeFocus = false } = {}) {
                    promptTooltipRenderAllowed = false;
                    focusClickPending = false;
                    tooltip.setAttribute('aria-hidden', 'true');
                    clearInactivityTimer();
                    if (removeFocus) {
                        wrapper.classList.remove('is-focused');
                    }
                }

                promptEl.addEventListener('pointerdown', () => {
                    focusClickPending = true;
                });

                promptEl.addEventListener('focus', () => {
                    if (focusClickPending) {
                        showPromptTooltip();
                    }
                });

                promptEl.addEventListener('blur', () => {
                    hidePromptTooltip({ removeFocus: true });
                });

                promptEl.addEventListener('input', () => {
                    hidePromptTooltip();
                });
                promptEl.addEventListener('keydown', () => {
                    hidePromptTooltip();
                });

                // update tooltip when selection is applied
                const origApply = window.applyPromptSelection;
                if (typeof origApply === 'function') {
                    window.applyPromptSelection = function () {
                        try { origApply.apply(this, arguments); } catch (e) { }
                        try {
                            const sel = getSelectedPrompt();
                            const status = sel?.id ? templateCriteriaStatus[sel.id] : null;
                            renderTemplateTooltip(sel, status);
                            if (document.activeElement === promptEl && tooltip.getAttribute('aria-hidden') === 'false') {
                                scheduleDrawTemplateTooltipPosition();
                            }
                        } catch (e) { }
                    };
                }

                window.addEventListener('resize', function () {
                    if (tooltip.getAttribute('aria-hidden') === 'false') {
                        scheduleDrawTemplateTooltipPosition();
                    }
                });
                window.addEventListener(
                    'scroll',
                    function () {
                        if (tooltip.getAttribute('aria-hidden') === 'false') {
                            scheduleDrawTemplateTooltipPosition();
                        }
                    },
                    { passive: true }
                );
            })();
            const capsuleOpenBtn = document.getElementById("capsuleOpenBtn");
            const capsuleSaveBtn = document.getElementById("capsuleSaveBtn");
            const toggleDrawerBtn = document.getElementById("gtContextModalTrigger");
            const drawerOverlay = document.getElementById("gtContextModalBackdrop");
            const connectLeft = document.querySelector(".connect-left");
            const connectRight = document.querySelector(".connect-right");
            const drawerMediaQuery = window.matchMedia("(max-width: 1200px)");
            const shareHistory = window.goToolkitShareHistory;
            const generateDefaultLabel = generateBtn?.textContent || "‚åò R√©pondre";
            const drawerDefaultLabel = toggleDrawerBtn?.textContent || "‚∏ô Contexte";
            let generateCooldownTimer = null;
            let generateCooldownEndTime = 0;
            let activeIaAbortController = null;
            let currentTourIndex = 0;
            // Start open on desktop by default; auto logic can rehydrate stored state
            let isDrawerOpen = true;
            const DESKTOP_GUTENBERG_BREAKPOINT = 900;
            const GUTENBERG_SEEN_KEY = "robert-gutenberg-opened-draw";
            const GUTENBERG_OPEN_STATE_KEY = "robert-gutenberg-open-state-draw";
            const capsuleImportInput = document.createElement("input");
            capsuleImportInput.type = "file";
            capsuleImportInput.accept = "application/json";
            capsuleImportInput.style.display = "none";
            document.body.appendChild(capsuleImportInput);
            const tourSteps = [
                {
                    title: "Intention Le Cardinal",
                    description: "Le Cardinal aide les consultants √† illustrer rapidement des id√©es en diagrammes clairs.",
                    selector: null
                },
                {
                    title: "Choisir un cas m√©tier",
                    description: "Ouvre ‚äû Mod√®le pour s√©lectionner le mod√®le de diagramme le plus adapt√© √† ton contexte.",
                    selector: "#gtTemplateModalTrigger"
                },
                {
                    title: "D√©cris et choisis",
                    description: "D√©cris le contexte, choisis le type de diagramme puis clique sur G√©n√©rer.",
                    selector: "#prompt-input-card"
                },
                {
                    title: "√âdition visuelle",
                    description: "Tu peux ajouter, modifier et supprimer fl√®ches, texte, forme et stype √† ta convenance",
                    selector: ".connect-right"
                },
                {
                    title: "√âdition en texte",
                    description: "Tu peux √©galement √©diter le contenud dans le bloc Script et ajuste le texte si besoin.",
                    selector: ".mermaid-output-card"
                },

            ];

            function closeDrawer() {
                if (!connectLeft) return;
                isDrawerOpen = false;
                persistDrawerOpenState(false);
                syncDrawerToggleUi();
            }

            function openDrawer() {
                if (!connectLeft) return;
                isDrawerOpen = true;
                persistDrawerOpenState(true);
                syncDrawerToggleUi();
            }

            function toggleDrawer() {
                if (isDrawerOpen) {
                    closeDrawer();
                } else {
                    openDrawer();
                }
            }

            function handleDrawerBreakpointChange(event) {
                if (drawerMediaQuery.matches) {
                    isDrawerOpen = false;
                }
                syncDrawerToggleUi();
            }

            function syncDrawerToggleUi() {
                const isMobile = drawerMediaQuery.matches;
                const isOpen = isDrawerOpen;

                if (isMobile) {
                    connectLeft?.classList.toggle("open", isOpen);
                    connectLeft?.classList.remove("collapsed");
                    connectRight?.classList.remove("full-width");
                    if (isOpen) {
                        drawerOverlay?.classList.add("visible");
                        drawerOverlay?.setAttribute("aria-hidden", "false");
                        toggleDrawerBtn?.setAttribute("aria-expanded", "true");
                    } else {
                        drawerOverlay?.classList.remove("visible");
                        drawerOverlay?.setAttribute("aria-hidden", "true");
                        toggleDrawerBtn?.setAttribute("aria-expanded", "false");
                    }
                } else {
                    connectLeft?.classList.remove("open");
                    drawerOverlay?.classList.remove("visible");
                    drawerOverlay?.setAttribute("aria-hidden", "true");
                    toggleDrawerBtn?.setAttribute("aria-expanded", isOpen ? "true" : "false");
                    connectLeft?.classList.toggle("collapsed", !isOpen);
                    connectRight?.classList.toggle("full-width", !isOpen);
                }
            }

            function readDrawerOpenState() {
                try {
                    if (!window.localStorage) return null;
                    const value = localStorage.getItem(GUTENBERG_OPEN_STATE_KEY);
                    if (value === "open") return true;
                    if (value === "closed") return false;
                } catch (err) {
                    console.warn("Impossible de lire l'√©tat de Gutenberg", err);
                }
                return null;
            }

            function persistDrawerOpenState(isOpen) {
                try {
                    if (!window.localStorage) return;
                    localStorage.setItem(GUTENBERG_OPEN_STATE_KEY, isOpen ? "open" : "closed");
                } catch (err) {
                    console.warn("Impossible de sauvegarder l'√©tat de Gutenberg", err);
                }
            }

            syncDrawerToggleUi();

            function loadState() {
                try {
                    const raw = localStorage.getItem(STORAGE_KEY);
                    const storedApiKey = localStorage.getItem(API_KEY_STORAGE_KEY) || "";
                    if (!raw) {
                        state.pages = [createPage(1)];
                        state.apiKey = storedApiKey || "";
                        return;
                    }
                    const parsed = JSON.parse(raw);
                    const storedPages = Array.isArray(parsed.pages) && parsed.pages.length ? parsed.pages : [createPage(1)];
                    const normalizedPages = storedPages.map((page, index) => normalizePage(page, index));
                    state = {
                        pages: normalizedPages,
                        activeIndex: Math.max(0, Math.min(normalizedPages.length - 1, parsed.activeIndex || 0)),
                        apiKey: parsed.apiKey || storedApiKey || "",
                        promptTemplate: parsed.promptTemplate || DEFAULT_PROMPT_TEMPLATE,
                        systemPrompt: parsed.systemPrompt || DEFAULT_SYSTEM_PROMPT,
                        reasoningEffort: parsed.reasoningEffort || parsed.reasoning?.effort || "low",
                        templateId: parsed.templateId || null
                    };
                } catch (err) {
                    console.warn("Impossible de charger l'√©tat", err);
                    state.pages = [createPage(1)];
                }
            }

            function isDesktopGutenberg() {
                return window.innerWidth >= DESKTOP_GUTENBERG_BREAKPOINT;
            }

            function markDrawerSeen() {
                try {
                    localStorage.setItem(GUTENBERG_SEEN_KEY, "1");
                } catch (err) {
                    console.warn("Impossible de noter l'ouverture du drawer", err);
                }
            }

            function maybeAutoOpenDrawer() {
                try {
                    if (!isDesktopGutenberg()) return;
                    const storedState = readDrawerOpenState();
                    if (storedState === true) {
                        openDrawer();
                        return;
                    }
                    if (storedState === false) {
                        syncDrawerToggleUi();
                        return;
                    }
                    var seen = localStorage.getItem(GUTENBERG_SEEN_KEY);
                    if (!seen) {
                        openDrawer();
                        markDrawerSeen();
                        return;
                    }
                } catch (err) {
                    // ignore
                }
                syncDrawerToggleUi();
            }

            function saveState() {
                try {
                    const persistable = {
                        ...state,
                        templateId: selectedPromptId || state.templateId || null,
                        pages: state.pages.map((page, index) => normalizePage(page, index))
                    };
                    state.templateId = persistable.templateId;
                    state.pages = persistable.pages;
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(persistable));
                    if (state.apiKey) {
                        localStorage.setItem(API_KEY_STORAGE_KEY, state.apiKey);
                    }
                    if (currentShareToken) {
                        writeShareDraft(currentShareToken, persistable, new Date().toISOString());
                    }
                } catch (err) {
                    console.error("Impossible de sauvegarder l'√©tat", err);
                }
                scheduleDraftSave();
            }

            function scheduleDraftSave() {
                if (isDraftSaving || !capsuleDrafts || !currentDraftId) {
                    return;
                }
                if (draftSaveTimer) {
                    clearTimeout(draftSaveTimer);
                }
                draftSaveTimer = setTimeout(() => {
                    draftSaveTimer = null;
                    saveCapsuleDraft({ updateUrl: false, showToast: false });
                }, 600);
            }

            function cancelScheduledDraftSave() {
                if (draftSaveTimer) {
                    clearTimeout(draftSaveTimer);
                    draftSaveTimer = null;
                }
            }

            async function captureExcalidrawScene() {
                try {
                    const api = await getExcalidrawApi();
                    const elements = typeof api.getSceneElements === "function"
                        ? api.getSceneElements()
                        : typeof api.getElements === "function"
                            ? api.getElements()
                            : [];
                    const appState = typeof api.getAppState === "function" ? api.getAppState() : undefined;
                    const files = typeof api.getFiles === "function" ? api.getFiles() : undefined;
                    return normalizeScene({ elements: elements || [], appState, files });
                } catch (err) {
                    console.warn("Impossible de capturer la sc√®ne Excalidraw", err);
                    return null;
                }
            }

            async function buildSharePayload() {
                const scene = await captureExcalidrawScene();
                const selectedTemplate = getSelectedPrompt();
                return {
                    pages: state.pages.map((page, index) => normalizePage(page, index)),
                    activeIndex: state.activeIndex,
                    apiKey: state.apiKey || "",
                    promptTemplate: state.promptTemplate || DEFAULT_PROMPT_TEMPLATE,
                    systemPrompt: state.systemPrompt || DEFAULT_SYSTEM_PROMPT,
                    reasoningEffort: state.reasoningEffort || "low",
                    templateId: selectedPromptId || state.templateId || null,
                    templateName: selectedTemplate?.label || selectedTemplate?.title || null,
                    scene
                };
            }

            let sharedScenePayload = null;

            function applySharedState(payload) {
                if (!payload) return false;
                const incomingPages = Array.isArray(payload.pages) && payload.pages.length
                    ? payload.pages
                    : [createPage(1)];
                state.pages = incomingPages.map((page, index) => normalizePage(page, index));
                state.activeIndex = Math.max(0, Math.min(state.pages.length - 1, payload.activeIndex || 0));
                state.apiKey = payload.apiKey || "";
                state.promptTemplate = payload.promptTemplate || DEFAULT_PROMPT_TEMPLATE;
                state.systemPrompt = payload.systemPrompt || DEFAULT_SYSTEM_PROMPT;
                state.reasoningEffort = payload.reasoningEffort || payload.reasoning?.effort || "low";
                state.templateId = payload.templateId || null;
                selectedPromptId = state.templateId;
                if (payload.scene) {
                    sharedScenePayload = sanitizeScene(payload.scene);
                }
                updateSelectedTemplateLabelDisplay();
                return true;
            }

            function getExportFilename(ext) {
                try {
                    const rawTitle = (document.title || "export").toString().trim();
                    const safe = rawTitle.replace(/[^a-z0-9\-_.]/gi, "_").replace(/_+/g, "_");
                    const ts = new Date().toISOString().replace(/[:.]/g, "-");
                    return `${safe || "export"}_${ts}.${ext || "txt"}`;
                } catch (err) {
                    return `export_${Date.now()}.${ext || "txt"}`;
                }
            }

            async function buildSceneSnapshotForPage(page, isActive) {
                if (!page) return null;
                if (isActive) {
                    const liveScene = await captureExcalidrawScene();
                    if (liveScene) return liveScene;
                }
                const storedScene = normalizeScene(page.scene);
                if (storedScene) return storedScene;
                try {
                    const sceneData = await buildScenePayload(page.mermaid || "");
                    const api = await getExcalidrawApi();
                    const appState = buildExcalidrawAppState(api, sceneData.appState || {});
                    const payload = {
                        elements: sceneData.elements || [],
                        appState
                    };
                    if (sceneData.files) {
                        payload.files = sceneData.files;
                    }
                    return normalizeScene(payload);
                } catch (err) {
                    console.warn("Impossible de g√©n√©rer la sc√®ne Excalidraw pour l'export", err);
                    return null;
                }
            }

            async function buildPageScenesSnapshot() {
                const snapshots = [];
                for (let i = 0; i < state.pages.length; i++) {
                    const snapshot = await buildSceneSnapshotForPage(state.pages[i], i === state.activeIndex);
                    snapshots.push(snapshot);
                }
                return snapshots;
            }

            async function buildCapsulePayload() {
                const snapshots = await buildPageScenesSnapshot();
                const pages = state.pages.map((page, index) => {
                    const normalized = normalizePage(page, index);
                    const scene = snapshots[index] || normalized.scene || null;
                    if (scene) {
                        normalized.scene = scene;
                    } else {
                        delete normalized.scene;
                    }
                    return normalized;
                });
                return {
                    pages,
                    activeIndex: state.activeIndex,
                    apiKey: state.apiKey || "",
                    promptTemplate: state.promptTemplate || DEFAULT_PROMPT_TEMPLATE,
                    systemPrompt: state.systemPrompt || DEFAULT_SYSTEM_PROMPT,
                    reasoningEffort: state.reasoningEffort || "low",
                    templateId: selectedPromptId || state.templateId || null,
                    templateName: getSelectedPrompt()?.label || getSelectedPrompt()?.title || null
                };
            }

            function applyImportedCapsule(payload) {
                if (!payload || typeof payload !== "object") return false;
                const incomingPages = Array.isArray(payload.pages) && payload.pages.length
                    ? payload.pages
                    : Array.isArray(payload.tabs) && payload.tabs.length
                        ? payload.tabs
                        : null;
                const normalizedPages = (incomingPages && incomingPages.length)
                    ? incomingPages.map((page, index) => normalizePage(page, index))
                    : [createPage(1)];
                state.pages = normalizedPages;
                state.activeIndex = Math.max(0, Math.min(normalizedPages.length - 1, payload.activeIndex || 0));
                state.apiKey = payload.apiKey || state.apiKey || "";
                state.promptTemplate = payload.promptTemplate || DEFAULT_PROMPT_TEMPLATE;
                state.reasoningEffort = payload.reasoningEffort || payload.reasoning?.effort || "low";
                state.templateId = payload.templateId || null;
                selectedPromptId = state.templateId;
                sharedScenePayload = null;
                currentShareToken = null;
                shareLoadedFromRemote = false;
                shareLastUpdatedAt = null;
                updateUrlWithShareToken(null);
                renderTabs();
                syncFormWithPage();
                if (promptTemplateField) {
                    promptTemplateField.value = state.promptTemplate || DEFAULT_PROMPT_TEMPLATE;
                }
                if (systemPromptField) {
                    systemPromptField.value = state.systemPrompt || DEFAULT_SYSTEM_PROMPT;
                }
                updateSelectedTemplateLabelDisplay();
                updateShareMenuUI();
                saveState();
                return true;
            }

            async function tryLoadLocalDraftFromUrl() {
                if (!capsuleDrafts) return false;
                const editId = getEditIdFromUrl();
                if (!editId) return false;
                const record = await capsuleDrafts.getRecord(editId);
                if (!record || !record.payload) return false;
                applyImportedCapsule(record.payload);
                currentDraftId = record.id;
                updateUrlWithEditId(record.id);
                return true;
            }

            function initShareWorkerService() {
                shareWorkerAvailable = Boolean(window.goToolkitShareWorker?.isReady);
            }

            function setShareStatus(message, type = "") {
                shareStatusMessage = message;
                shareStatusType = type;
            }

            function formatRelativeTime(isoString) {
                if (!isoString) return "";
                const value = new Date(isoString).getTime();
                if (Number.isNaN(value)) return "";
                const deltaSeconds = Math.max(0, Math.floor((Date.now() - value) / 1000));
                if (deltaSeconds < 60) {
                    return "Mis √† jour √† l'instant";
                }
                const deltaMinutes = Math.floor(deltaSeconds / 60);
                if (deltaMinutes < 60) {
                    return `Mis √† jour il y a ${deltaMinutes} minute${deltaMinutes > 1 ? "s" : ""}`;
                }
                const deltaHours = Math.floor(deltaMinutes / 60);
                if (deltaHours < 24) {
                    return `Mis √† jour il y a ${deltaHours} heure${deltaHours > 1 ? "s" : ""}`;
                }
                const deltaDays = Math.floor(deltaHours / 24);
                return `Mis √† jour il y a ${deltaDays} jour${deltaDays > 1 ? "s" : ""}`;
            }

            function formatFullDate(isoString) {
                const value = new Date(isoString);
                if (Number.isNaN(value.getTime())) return "";
                const formatter = new Intl.DateTimeFormat("fr-FR", {
                    day: "2-digit",
                    month: "short",
                    year: "numeric",
                    hour: "2-digit",
                    minute: "2-digit"
                });
                return formatter.format(value);
            }

            function getShareTokenFromUrl() {
                const params = new URLSearchParams(window.location.search);
                const value = params.get(SHARE_QUERY_PARAM);
                return value ? value.trim() : null;
            }

            function buildShareUrl(token) {
                if (!token) {
                    return "";
                }
                const url = new URL(window.location.href);
                url.searchParams.set(SHARE_QUERY_PARAM, token);
                return url.toString();
            }

            function updateUrlWithShareToken(token) {
                const url = new URL(window.location.href);
                if (token) {
                    url.searchParams.set(SHARE_QUERY_PARAM, token);
                } else {
                    url.searchParams.delete(SHARE_QUERY_PARAM);
                }
                history.replaceState(null, "", url.toString());
            }

            function createShareToken() {
                if (typeof crypto !== "undefined" && typeof crypto.randomUUID === "function") {
                    return crypto.randomUUID();
                }
                const bytes = new Uint8Array(16);
                if (typeof crypto !== "undefined" && typeof crypto.getRandomValues === "function") {
                    crypto.getRandomValues(bytes);
                } else {
                    for (let i = 0; i < bytes.length; i++) {
                        bytes[i] = Math.floor(Math.random() * 256);
                    }
                }
                return Array.from(bytes)
                    .map(byte => byte.toString(16).padStart(2, "0"))
                    .join("");
            }

            function getEditIdFromUrl() {
                try {
                    const params = new URLSearchParams(window.location.search);
                    const value = params.get(EDIT_QUERY_PARAM);
                    return value ? value.trim() : null;
                } catch (err) {
                    return null;
                }
            }

            function updateUrlWithEditId(id) {
                const url = new URL(window.location.href);
                if (id) {
                    url.searchParams.set(EDIT_QUERY_PARAM, id);
                } else {
                    url.searchParams.delete(EDIT_QUERY_PARAM);
                }
                history.replaceState(null, "", url.toString());
            }

            function createDraftId() {
                if (capsuleDrafts && typeof capsuleDrafts.generateId === "function") {
                    return capsuleDrafts.generateId();
                }
                return createShareToken();
            }

            async function saveCapsuleDraft(options = {}) {
                if (!capsuleDrafts || isDraftSaving) {
                    return null;
                }
                isDraftSaving = true;
                try {
                    saveState();
                    const payload = await buildCapsulePayload();
                    const preview = getDrawSharePreview();
                    let id = currentDraftId || createDraftId();
                    if (!id) {
                        id = createShareToken();
                    }
                    const now = new Date().toISOString();
                    const record = await capsuleDrafts.upsertRecord({
                        id,
                        app: "draw",
                        payload,
                        title: preview.title,
                        description: preview.description,
                        updatedAt: now
                    });
                    if (record) {
                        currentDraftId = record.id;
                        if (options.updateUrl !== false) {
                            updateUrlWithEditId(record.id);
                        }
                        if (options.showToast) {
                            setStatus("Capsule enregistr√©e");
                        }
                    }
                    return record;
                } catch (err) {
                    console.error("Impossible de sauvegarder la capsule locale", err);
                    return null;
                } finally {
                    isDraftSaving = false;
                }
            }

            async function handleSaveDocumentClick() {
                closeCapsuleMenu();
                if (!capsuleDrafts) {
                    alert("Impossible de sauvegarder localement.");
                    return null;
                }
                if (capsuleDraftSaveBtn) {
                    capsuleDraftSaveBtn.disabled = true;
                }
                cancelScheduledDraftSave();
                try {
                    return await saveCapsuleDraft({ showToast: true });
                } catch (err) {
                    console.error("Erreur lors de l'enregistrement local", err);
                    return null;
                } finally {
                    if (capsuleDraftSaveBtn) {
                        capsuleDraftSaveBtn.disabled = false;
                    }
                }
            }

            async function handleNewDocumentClick() {
                closeCapsuleMenu();
                const hasPages = state.pages.length > 0 || Boolean(currentDraftId);
                if (hasPages) {
                    const confirmSave = window.confirm(
                        "Sauvegarder la capsule actuelle avant d'ouvrir un nouveau document ?"
                    );
                    if (confirmSave) {
                        await handleSaveDocumentClick();
                    }
                }
                openNewDrawDocument();
            }

            function openNewDrawDocument() {
                try {
                    if (window.localStorage) {
                        localStorage.removeItem(STORAGE_KEY);
                    }
                } catch (err) {
                    console.warn("Impossible de r√©initialiser l'√©tat local", err);
                }
                if (currentShareToken) {
                    updateUrlWithShareToken(null);
                    currentShareToken = null;
                }
                updateUrlWithEditId(null);
                const url = new URL(window.location.href);
                url.searchParams.delete(SHARE_QUERY_PARAM);
                url.searchParams.delete(EDIT_QUERY_PARAM);
                url.hash = "";
                window.location.href = url.toString();
            }

            async function fetchSharePayload(token) {
                if (!shareWorkerAvailable || !shareWorkerService) {
                    throw new Error(SHARE_WORKER_UNAVAILABLE_MESSAGE);
                }
                return shareWorkerService.fetchSharePayload(FIRESTORE_COLLECTION, token);
            }

            async function applySharedSceneIfPresent() {
                if (!sharedScenePayload) return;
                try {
                    await applySceneToExcalidraw(sharedScenePayload);
                } catch (err) {
                    console.warn("Impossible d'appliquer la sc√®ne partag√©e", err);
                }
            }

            async function tryLoadSharedStateFromUrl() {
                const token = getShareTokenFromUrl();
                if (!token) {
                    return false;
                }
                const localDraft = readShareDraft(token);
                let remoteResult = null;
                try {
                    remoteResult = await fetchSharePayload(token);
                } catch (err) {
                    console.error("Erreur de chargement du lien partag√© :", err);
                }

                const remotePayload = remoteResult?.payload;
                const remoteUpdatedAt = remoteResult?.meta?.updatedAt;
                const localPayload = localDraft?.payload;
                const localUpdatedAt = localDraft?.updatedAt;

                const remoteDate = remoteUpdatedAt ? new Date(remoteUpdatedAt).getTime() : 0;
                const localDate = localUpdatedAt ? new Date(localUpdatedAt).getTime() : 0;
                const payloadsMatch = remotePayload && localPayload
                    ? JSON.stringify(remotePayload) === JSON.stringify(localPayload)
                    : false;
                const timestampsEqual = remoteUpdatedAt && localUpdatedAt && remoteDate === localDate;

                let chosenPayload = null;
                let chosenUpdatedAt = null;

                if (remotePayload && localPayload && (payloadsMatch || timestampsEqual)) {
                    chosenPayload = localPayload;
                    chosenUpdatedAt = localUpdatedAt || remoteUpdatedAt;
                } else if (localPayload && localDate > remoteDate) {
                    chosenPayload = localPayload;
                    chosenUpdatedAt = localUpdatedAt;
                } else if (remotePayload && remoteDate > localDate && localPayload) {
                    const confirmed = window.confirm(
                        `Mettre √† jour avec les modifications du ${formatFullDate(remoteUpdatedAt)} ?`
                    );
                    if (confirmed) {
                        chosenPayload = remotePayload;
                        chosenUpdatedAt = remoteUpdatedAt;
                    } else {
                        chosenPayload = localPayload;
                        chosenUpdatedAt = localUpdatedAt || remoteUpdatedAt || new Date().toISOString();
                    }
                } else if (remotePayload && Array.isArray(remotePayload.pages)) {
                    chosenPayload = remotePayload;
                    chosenUpdatedAt = remoteUpdatedAt || new Date().toISOString();
                } else if (localPayload) {
                    chosenPayload = localPayload;
                    chosenUpdatedAt = localUpdatedAt || new Date().toISOString();
                }

                if (!chosenPayload || !Array.isArray(chosenPayload.pages)) {
                    setShareStatus("Lien de partage introuvable.", "error");
                    return false;
                }

                applySharedState(chosenPayload);
                currentShareToken = token;
                shareLoadedFromRemote = true;
                shareLastUpdatedAt = chosenUpdatedAt || new Date().toISOString();
                setShareStatus(formatRelativeTime(shareLastUpdatedAt));
                await persistDrawShareRecord(token, shareLastUpdatedAt);
                writeShareDraft(token, chosenPayload, shareLastUpdatedAt);
                await applySharedSceneIfPresent();
                return true;
            }

            async function saveSharePayload(token, payload) {
                if (!shareWorkerAvailable || !shareWorkerService) {
                    throw new Error(SHARE_WORKER_UNAVAILABLE_MESSAGE);
                }
                const meta = await shareWorkerService.saveSharePayload(FIRESTORE_COLLECTION, token, payload);
                return meta?.updatedAt || new Date().toISOString();
            }

            function getShareDefaultStatusText() {
                if (!shareWorkerAvailable) {
                    return SHARE_WORKER_UNAVAILABLE_MESSAGE;
                }
                if (shareLastUpdatedAt) {
                    return formatRelativeTime(shareLastUpdatedAt);
                }
                if (shareLoadedFromRemote && currentShareToken) {
                    return "Ce lien charge une session partag√©e.";
                }
                if (currentShareToken) {
                    return "Un lien priv√© existe d√©j√† pour cette session.";
                }
                return "Seules les personnes disposant du lien peuvent y acc√©der.";
            }

            function updateShareMenuUI() {
                if (shareLinkField) {
                    const hasToken = Boolean(currentShareToken);
                    shareLinkField.value = hasToken ? buildShareUrl(currentShareToken) : "";
                    shareLinkField.placeholder = hasToken ? "" : "Cr√©er un lien priv√©";
                }
                if (shareCreateBtn) {
                    shareCreateBtn.disabled = shareRequestInProgress || !shareWorkerAvailable;
                    shareCreateBtn.classList.toggle("primary", !currentShareToken);
                }
                if (shareUpdateBtn) {
                    const hasToken = Boolean(currentShareToken);
                    shareUpdateBtn.hidden = !hasToken;
                    shareUpdateBtn.disabled = shareRequestInProgress || !hasToken || !shareWorkerAvailable;
                }
                if (shareMenuStatus) {
                    const text = shareStatusMessage || getShareDefaultStatusText();
                    shareMenuStatus.textContent = text;
                    const isError = (shareStatusType === "error" && Boolean(text)) || (!shareWorkerAvailable && !shareStatusMessage);
                    shareMenuStatus.classList.toggle("error", isError);
                }
            }

            function closeShareMenu() {
                shareMenu?.classList.remove("open");
            }

            function closeCapsuleMenu() {
                capsuleMenu?.classList.remove("open");
            }

            function closeInfoPopup() {
                infoPopup?.classList.remove("open");
            }

            function clearAppCacheAndReload() {
                // Preserve the OpenAI key and admin token across reset
                var _preservedOpenAiKey = null;
                var _preservedAdminToken = null;
                try {
                    _preservedOpenAiKey = localStorage.getItem('go-toolkit-api-key');
                } catch (err) { /* noop */ }
                try {
                    _preservedAdminToken = localStorage.getItem('feedback-admin-token');
                } catch (err) { /* noop */ }
                try {
                    localStorage.clear();
                    if (_preservedOpenAiKey) {
                        try { localStorage.setItem('go-toolkit-api-key', _preservedOpenAiKey); } catch (e) { }
                    }
                    if (_preservedAdminToken) {
                        try { localStorage.setItem('feedback-admin-token', _preservedAdminToken); } catch (e) { }
                    }
                } catch (err) {
                    console.warn("Impossible de vider localStorage", err);
                }
                try {
                    sessionStorage.clear();
                } catch (err) {
                    console.warn("Impossible de vider sessionStorage", err);
                }
                (document.cookie || "")
                    .split(";")
                    .forEach(function (cookie) {
                        const eqPos = cookie.indexOf("=");
                        let name = eqPos > -1 ? cookie.substr(0, eqPos) : cookie;
                        name = name.trim();
                        if (!name) return;
                        document.cookie = name + "=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/";
                    });
                const reload = function () {
                    window.location.reload();
                };
                if (window.caches && typeof window.caches.keys === "function") {
                    window.caches
                        .keys()
                        .then(function (keys) {
                            return Promise.all(keys.map(function (key) {
                                return window.caches.delete(key);
                            }));
                        })
                        .catch(function () { })
                        .finally(reload);
                } else {
                    reload();
                }
            }

            function promptManualUpdate() {
                const warning = "La mise √† jour effacera les donn√©es locales (cache, cookies, pr√©f√©rences). Continuer ?";
                if (!confirm(warning)) return;
                closeInfoPopup();
                clearAppCacheAndReload();
            }

            function focusHighlight(selector) {
                if (!tourHighlight || !tourOverlay || !selector) {
                    tourHighlight?.style.setProperty("display", "none");
                    tourOverlay?.classList.remove("has-highlight");
                    return;
                }
                const target = document.querySelector(selector);
                if (!target) {
                    tourHighlight.style.display = "none";
                    tourOverlay.classList.remove("has-highlight");
                    return;
                }
                const rect = target.getBoundingClientRect();
                tourHighlight.style.display = "block";
                tourHighlight.style.top = `${rect.top - 8 + window.scrollY}px`;
                tourHighlight.style.left = `${rect.left - 8 + window.scrollX}px`;
                tourHighlight.style.width = `${rect.width + 16}px`;
                tourHighlight.style.height = `${rect.height + 16}px`;
                tourOverlay.classList.add("has-highlight");
            }

            function renderTourStep(index) {
                if (!tourOverlay) return;
                const step = tourSteps[index];
                if (!step) return;
                currentTourIndex = index;
                tourOverlay.classList.add("open");
                tourStepCounter.textContent = `${index + 1}/${tourSteps.length}`;
                tourStepTitle.textContent = step.title;
                tourStepDescription.textContent = step.description;
                focusHighlight(step.selector);
                tourPrevBtn.disabled = index === 0;
                tourNextBtn.textContent = index === tourSteps.length - 1 ? "Terminer" : "Suivant";
            }

            function closeTour() {
                if (!tourOverlay) return;
                tourOverlay.classList.remove("open");
                focusHighlight(null);
            }

            function startTour() {
                renderTourStep(0);
            }

            async function copyCurrentShareLinkToClipboard() {
                if (!currentShareToken) return false;
                const link = buildShareUrl(currentShareToken);
                if (!link) return false;
                try {
                    await copyTextToClipboard(link);
                    setStatus("Lien priv√© copi√© ‚úîÔ∏è");
                    return true;
                } catch (err) {
                    console.error("Copie du lien priv√© impossible", err);
                    setStatus("Impossible de copier le lien priv√©");
                    return false;
                }
            }

            async function handleShareCreateClick() {
                if (!shareWorkerAvailable) {
                    setShareStatus(SHARE_WORKER_UNAVAILABLE_MESSAGE, "error");
                    updateShareMenuUI();
                    return;
                }
                if (shareRequestInProgress) return;
                shareRequestInProgress = true;
                updateShareMenuUI();
                try {
                    const token = createShareToken();
                    const payload = await buildSharePayload();
                    const updatedAt = await saveSharePayload(token, payload);
                    currentShareToken = token;
                    shareLoadedFromRemote = true;
                    shareLastUpdatedAt = updatedAt;
                    updateUrlWithShareToken(token);
                    setShareStatus(formatRelativeTime(updatedAt));
                    updateShareMenuUI();
                    await persistDrawShareRecord(token, updatedAt);
                    writeShareDraft(token, payload, updatedAt);
                    await copyCurrentShareLinkToClipboard();
                } catch (err) {
                    console.error("Erreur lors de la cr√©ation du lien partag√© :", err);
                    setShareStatus("Impossible de cr√©er le lien partag√©.", "error");
                } finally {
                    shareRequestInProgress = false;
                    updateShareMenuUI();
                }
            }

            async function handleShareUpdateClick() {
                if (!shareWorkerAvailable) {
                    setShareStatus(SHARE_WORKER_UNAVAILABLE_MESSAGE, "error");
                    updateShareMenuUI();
                    return;
                }
                if (!currentShareToken) {
                    setShareStatus("Pas de lien priv√© √† mettre √† jour.", "error");
                    updateShareMenuUI();
                    return;
                }
                if (shareRequestInProgress) return;
                shareRequestInProgress = true;
                updateShareMenuUI();
                try {
                    const payload = await buildSharePayload();
                    const updatedAt = await saveSharePayload(currentShareToken, payload);
                    shareLoadedFromRemote = true;
                    shareLastUpdatedAt = updatedAt;
                    setShareStatus(formatRelativeTime(updatedAt));
                    updateShareMenuUI();
                    await persistDrawShareRecord(currentShareToken, updatedAt);
                    writeShareDraft(currentShareToken, payload, updatedAt);
                    await copyCurrentShareLinkToClipboard();
                } catch (err) {
                    console.error("Erreur lors de la mise √† jour du lien partag√© :", err);
                    setShareStatus("Impossible de mettre √† jour le lien partag√©.", "error");
                } finally {
                    shareRequestInProgress = false;
                    updateShareMenuUI();
                }
            }

            function copyTextToClipboard(text) {
                if (navigator.clipboard && typeof navigator.clipboard.writeText === "function") {
                    return navigator.clipboard.writeText(text);
                }
                return new Promise((resolve, reject) => {
                    const textarea = document.createElement("textarea");
                    textarea.value = text;
                    textarea.setAttribute("readonly", "");
                    textarea.style.position = "absolute";
                    textarea.style.left = "-9999px";
                    document.body.appendChild(textarea);
                    textarea.select();
                    textarea.setSelectionRange(0, textarea.value.length);
                    const success = document.execCommand("copy");
                    document.body.removeChild(textarea);
                    if (success) {
                        resolve();
                    } else {
                        reject(new Error("Fallback copy failed"));
                    }
                });
            }

            function normalizeScene(scene) {
                if (!scene || typeof scene !== "object") {
                    return null;
                }
                const elements = Array.isArray(scene.elements) ? scene.elements : [];
                const appState = scene.appState && typeof scene.appState === "object" ? { ...scene.appState } : undefined;
                if (appState && appState.collaborators) {
                    delete appState.collaborators;
                }
                const files = toBinaryFilesObject(scene.files);
                if (!elements.length && !appState && !files) {
                    return null;
                }
                return { elements, appState, files };
            }

            function sanitizeScene(scene) {
                const normalized = normalizeScene(scene);
                if (!normalized) return null;
                if (!Array.isArray(normalized.elements)) {
                    return null;
                }
                const filesObj = toBinaryFilesObject(normalized.files);
                return {
                    elements: normalized.elements,
                    appState: normalized.appState,
                    files: filesObj
                };
            }

            function toBinaryFilesObject(files) {
                if (!files) return null;
                if (files instanceof Map) {
                    return Object.fromEntries(files.entries());
                }
                if (typeof files === "object") {
                    const result = {};
                    Object.entries(files).forEach(([key, value]) => {
                        if (value) result[key] = value;
                    });
                    return result;
                }
                return null;
            }

            function createPage(position) {
                return {
                    id: crypto.randomUUID ? crypto.randomUUID() : `${Date.now()}-${Math.random()}`,
                    label: `Page ${position}`,
                    title: `Page ${position}`,
                    input: "",
                    mermaid: "",
                    lastAiMermaid: "",
                    drawType: DEFAULT_DRAW_TYPE,
                    scene: null
                };
            }

            function normalizePage(page, index) {
                const fallback = createPage(index + 1);
                const incomingType = page?.drawType;
                const drawType = DRAW_TYPES.some(option => option.id === incomingType)
                    ? incomingType
                    : DEFAULT_DRAW_TYPE;
                const mermaid = page?.mermaid || "";
                const lastAiMermaid = page?.lastAiMermaid || mermaid || "";
                const titleFromScript = extractDiagramTitle(mermaid);
                const label = page?.label || titleFromScript || fallback.label;
                const scene = sanitizeScene(page?.scene);
                return {
                    id: page?.id || fallback.id,
                    label,
                    title: titleFromScript || page?.title || page?.label || fallback.title,
                    input: sanitizeScenarioText(page?.input || ""),
                    mermaid,
                    lastAiMermaid,
                    drawType,
                    scene
                };
            }

            function getDrawTypeOptionById(typeId) {
                return DRAW_TYPES.find(option => option.id === typeId) || DRAW_TYPES[0];
            }

            function getDrawTypePromptValue(typeId) {
                return getDrawTypeOptionById(typeId).promptValue;
            }

            function getActivePage() {
                return state.pages[state.activeIndex];
            }

            function renderTabs() {
                pageTabs.innerHTML = "";
                const activeLabel = state.activeIndex >= 0 ? state.pages[state.activeIndex]?.label || `Page ${state.activeIndex + 1}` : "";
                pageTabs.dataset.activePageLabel = activeLabel || "";
                state.pages.forEach((page, index) => {
                    const btn = document.createElement("button");
                    btn.className = `tab${index === state.activeIndex ? " active" : ""}`;
                    btn.textContent = page.label || `Page ${index + 1}`;
                    btn.title = "Double-clique pour renommer";
                    btn.addEventListener("click", () => {
                        setActivePage(index);
                    });
                    btn.addEventListener("dblclick", () => {
                        const name = prompt("Renommer le bloc", page.label || "Page");
                        if (name) {
                            page.label = name.trim();
                            renderTabs();
                            saveState();
                        }
                    });
                    pageTabs.appendChild(btn);
                });
            }

            function updateDrawTypeSelector(selectedType) {
                const normalizedType = DRAW_TYPES.some(option => option.id === selectedType)
                    ? selectedType
                    : DEFAULT_DRAW_TYPE;
                if (!drawTypeButtons.length) {
                    return;
                }
                drawTypeButtons.forEach(button => {
                    const isActive = button.dataset.drawType === normalizedType;
                    button.classList.toggle("active", isActive);
                    button.setAttribute("aria-pressed", isActive ? "true" : "false");
                });
                updatePromptPlaceholder(normalizedType);
                updateMermaidPlaceholder(normalizedType);
            }

            function updatePromptPlaceholder(drawType) {
                if (!promptInput) return;
                const normalized = DRAW_TYPES.some(option => option.id === drawType) ? drawType : DEFAULT_DRAW_TYPE;
                promptInput.placeholder = drawTypePlaceholders[normalized] || "D√©cris ton contexte produit, tes utilisateurs, ta probl√©matique...";
                refreshPromptSuggestion();
                schedulePromptAISuggestion();
            }

            function updateMermaidPlaceholder() {
                if (!mermaidOutput) return;
                mermaidOutput.placeholder = "";
            }

            function escapeHtml(str) {
                return (str || "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
            }

            function countCompletedSentences(text) {
                return GoToolkitTemplateCriteria.countCompletedSentences(text);
            }

            async function analyzePromptCriteria(text, template) {
                if (!template || !template.id) return;
                const criteria = getTemplateCriteria(template);
                if (!criteria.length) return;
                if (criteriaAnalysisAbortController) {
                    try { criteriaAnalysisAbortController.abort(); } catch (e) { /* noop */ }
                }
                const controller = new AbortController();
                criteriaAnalysisAbortController = controller;
                const apiKey = (state.apiKey || "").trim();
                const useProxy = !apiKey;
                const endpoint = useProxy
                    ? GoToolkitTemplateCriteria.DEFAULT_PROXY_ENDPOINT
                    : GoToolkitTemplateCriteria.DEFAULT_DIRECT_ENDPOINT;
                try {
                    const normalized = await GoToolkitTemplateCriteria.analyzeCriteria({
                        text,
                        template,
                        apiKey: useProxy ? "" : apiKey,
                        endpoint,
                        signal: controller.signal,
                        model: "gpt-5-nano"
                    });
                    templateCriteriaStatus[template.id] = normalized;
                    renderTemplateTooltip(template, normalized);
                } catch (err) {
                    if (err?.name === "AbortError") return;
                    console.warn("Analyse des crit√®res impossible", err);
                } finally {
                    if (criteriaAnalysisAbortController === controller) {
                        criteriaAnalysisAbortController = null;
                    }
                }
            }

            function triggerCriteriaAnalysis(options = {}) {
                const force = options.force || false;
                const template = getSelectedPrompt();
                const templateId = template?.id || null;
                if (templateId && !templateCriteriaStatus[templateId]) {
                    templateCriteriaStatus[templateId] = {};
                }
                if (templateId !== lastAnalyzedTemplateId) {
                    lastAnalyzedSentenceCount = 0;
                    lastAnalyzedTemplateId = templateId;
                }
                const status = templateId ? templateCriteriaStatus[templateId] : null;
                renderTemplateTooltip(template, status);
                if (!promptInput) return;
                const text = promptInput.value || "";
                const trimmed = text.trim();
                const criteria = getTemplateCriteria(template);
                if (!trimmed || !criteria.length) {
                    lastAnalyzedSentenceCount = countCompletedSentences(text);
                    if (templateId) {
                        templateCriteriaStatus[templateId] = {};
                        renderTemplateTooltip(template, templateCriteriaStatus[templateId]);
                    }
                    if (criteriaAnalysisAbortController) {
                        try { criteriaAnalysisAbortController.abort(); } catch (e) { /* noop */ }
                        criteriaAnalysisAbortController = null;
                    }
                    return;
                }
                const sentenceCount = countCompletedSentences(text);
                if (!force && sentenceCount === lastAnalyzedSentenceCount) {
                    return;
                }
                lastAnalyzedSentenceCount = sentenceCount;
                analyzePromptCriteria(trimmed, template);
            }

            function formatInlineSuggestion(textBeforeCursor, suggestion) {
                const trimmed = (suggestion || "").trim();
                if (!trimmed) return "";
                const lastChar = (textBeforeCursor || "").slice(-1);
                const startsWithPunctuation = /^[,.;:!?)/\]]/.test(trimmed);
                const needsLeadingSpace = lastChar && !/\s/.test(lastChar) && !startsWithPunctuation;
                return `${needsLeadingSpace ? " " : ""}${trimmed}`;
            }

            function setInlineSuggestion(text) {
                inlineSuggestion = (text || "").trim();
                currentPromptAiSuggestion = inlineSuggestion;
                renderPromptSuggestion();
            }

            function clearPromptAlternatives() {
                promptAltSuggestions = [];
                if (promptAltRow) {
                    promptAltRow.innerHTML = "";
                    promptAltRow.style.display = "none";
                }
            }

            function renderPromptAlternatives(alts) {
                if (!promptAltRow) return;
                const items = Array.isArray(alts)
                    ? alts
                        .map(item => {
                            if (typeof item === "string") {
                                return { label: item.trim(), text: item.trim() };
                            }
                            if (item && typeof item === "object") {
                                const label = (item.label || item.title || item.text || item.value || "").trim();
                                const text = (item.text || item.value || item.label || item.title || "").trim();
                                return { label, text };
                            }
                            return null;
                        })
                        .filter(item => item && item.text)
                        .slice(0, 3)
                    : [];
                promptAltSuggestions = items;
                promptAltRow.innerHTML = "";
                if (!items.length) {
                    promptAltRow.style.display = "none";
                    try {
                        const tooltip = document.getElementById("templateTooltip");
                        if (tooltip) tooltip.setAttribute('aria-hidden', tooltip.textContent ? 'false' : 'true');
                    } catch (e) { }
                    return;
                }
                // show alternatives and hide template tooltip while alternatives are visible
                promptAltRow.style.display = "flex";
                try {
                    const tooltip = document.getElementById("templateTooltip");
                    if (tooltip) tooltip.setAttribute('aria-hidden', 'true');
                } catch (e) { }
                items.forEach(alt => {
                    const displayLabel = alt.label || alt.text.split(" ")[0] || alt.text;
                    const badge = document.createElement("button");
                    badge.type = "button";
                    badge.className = "prompt-alt-badge";
                    badge.textContent = displayLabel;
                    badge.title = alt.text;
                    badge.addEventListener("click", () => insertTextAtCursor(alt.text));
                    promptAltRow.appendChild(badge);
                });
            }

            function insertTextAtCursor(insertText) {
                if (!promptInput || typeof insertText !== "string") return;
                const value = promptInput.value || "";
                const start = promptInput.selectionStart ?? value.length;
                const end = promptInput.selectionEnd ?? start;
                const before = value.slice(0, start);
                const after = value.slice(end);
                const formattedInsert = formatInlineSuggestion(before, insertText);
                if (!formattedInsert) return;
                const nextValue = before + formattedInsert + after;
                const caret = before.length + formattedInsert.length;
                promptInput.value = nextValue;
                promptInput.setSelectionRange(caret, caret);
                promptInput.dispatchEvent(new Event("input", { bubbles: true }));
                refreshPromptSuggestion();
            }

            function extractJsonFromMarkdown(value) {
                if (!value) return value;
                const fenceRe = /```(?:json)?\s*([\s\S]*?)\s*```/gi;
                let match;
                while ((match = fenceRe.exec(value)) !== null) {
                    const candidate = (match[1] || "").trim();
                    if (candidate) {
                        return candidate;
                    }
                }
                return value.trim();
            }

            async function fetchPromptAssist(/* params omitted - API disabled */) {
                // Prompt-assist API disabled: return no suggestion to avoid external calls.
                try {
                    return { main: "", alts: [] };
                } catch (e) {
                    return null;
                }
            }

            function renderPromptSuggestion() {
                if (!promptInput || !promptSuggestion) return;
                const value = promptInput.value || "";
                const hasSelection = promptInput.selectionStart !== promptInput.selectionEnd;
                const caret = promptInput.selectionStart ?? value.length;
                const hint = !hasSelection && inlineSuggestion
                    ? formatInlineSuggestion(value.slice(0, caret), inlineSuggestion)
                    : "";
                currentPromptSuggestion = hint;
                if (!hint) {
                    promptSuggestion.innerHTML = "";
                    promptSuggestion.style.opacity = "0";
                    try {
                        if (promptInput) {
                            const saved = promptInput.getAttribute('data-original-placeholder');
                            if (saved !== null) {
                                promptInput.setAttribute('placeholder', saved || '');
                                promptInput.removeAttribute('data-original-placeholder');
                            } else if (promptOriginalPlaceholder) {
                                promptInput.setAttribute('placeholder', promptOriginalPlaceholder);
                            }
                        }
                    } catch (e) { /* noop */ }
                    return;
                }
                // Hide textarea placeholder while prompt inline suggestion is visible
                try {
                    if (promptInput) {
                        const existing = promptInput.getAttribute('placeholder') || '';
                        if (existing) promptInput.setAttribute('data-original-placeholder', existing);
                        promptInput.setAttribute('placeholder', '');
                    }
                } catch (e) { /* noop */ }
                const before = escapeHtml(value.slice(0, caret));
                const after = escapeHtml(value.slice(caret));
                const hintHtml = escapeHtml(hint);
                // Wrap mask and hint inside a container that mimics textarea content.
                promptSuggestion.innerHTML =
                    `<div class="prompt-suggestion-content">` +
                    `<span class="prompt-suggestion-mask">${before}</span>` +
                    `<span class="prompt-suggestion-hint">${hintHtml}</span>` +
                    `<span class="prompt-suggestion-mask">${after}</span>` +
                    `</div>`;
                const suggestionContent = promptSuggestion.querySelector(".prompt-suggestion-content");
                if (suggestionContent && promptInput) {
                    const inputStyles = getComputedStyle(promptInput);
                    suggestionContent.style.padding = inputStyles.padding;
                    suggestionContent.style.lineHeight = inputStyles.lineHeight;
                    suggestionContent.style.fontFamily = inputStyles.fontFamily;
                    suggestionContent.style.fontSize = inputStyles.fontSize;
                    suggestionContent.style.letterSpacing = inputStyles.letterSpacing;
                    suggestionContent.style.whiteSpace = "pre-wrap";
                    suggestionContent.style.wordBreak = "break-word";
                }
                promptSuggestion.style.opacity = "1";
                promptSuggestion.scrollTop = promptInput.scrollTop;
                promptSuggestion.scrollLeft = promptInput.scrollLeft;
            }

            function refreshPromptSuggestion() {
                requestAnimationFrame(renderPromptSuggestion);
            }

            function acceptPromptSuggestion() {
                if (!promptInput || !currentPromptSuggestion) return false;
                const value = promptInput.value || "";
                const start = promptInput.selectionStart ?? value.length;
                const end = promptInput.selectionEnd ?? start;
                const before = value.slice(0, start);
                const after = value.slice(end);
                const formatted = formatInlineSuggestion(before, inlineSuggestion || currentPromptSuggestion);
                if (!formatted) return false;
                const nextValue = before + formatted + after;
                const caret = before.length + formatted.length;
                promptInput.value = nextValue;
                promptInput.setSelectionRange(caret, caret);
                renderPromptSuggestion();
                promptInput.dispatchEvent(new Event("input", { bubbles: true }));
                currentPromptAiSuggestion = "";
                return true;
            }

            function syncPromptSuggestionScroll() {
                if (!promptInput || !promptSuggestion) return;
                if (suppressSuggestionFollow) return;
                promptSuggestion.scrollTop = promptInput.scrollTop;
                promptSuggestion.scrollLeft = promptInput.scrollLeft;
            }

            function clearPromptAiSuggestion() {
                inlineSuggestion = "";
                currentPromptAiSuggestion = "";
                renderPromptSuggestion();
            }

            function stopPromptSuggestionRequest() {
                if (promptSuggestAbortController) {
                    promptSuggestAbortController.abort();
                    promptSuggestAbortController = null;
                }
            }

            function schedulePromptAISuggestion() {
                if (promptSuggestDebounce) {
                    clearTimeout(promptSuggestDebounce);
                }
                promptSuggestDebounce = setTimeout(startPromptAISuggestion, 250);
            }

            async function startPromptAISuggestion() {
                console.debug("[prompt-assist] start request");
                if (!promptInput) {
                    console.debug("[prompt-assist] skip: input unavailable");
                    return;
                }
                const apiKey = (state.apiKey || "").trim();
                const rawValue = promptInput.value || "";
                const valueLength = rawValue.trim().length;
                if (!valueLength || valueLength < 6) {
                    console.debug("[prompt-assist] skip: text too short", { length: valueLength });
                    clearPromptAiSuggestion();
                    clearPromptAlternatives();
                    return;
                }
                const cursor = promptInput.selectionStart ?? rawValue.length;
                const selectionEnd = promptInput.selectionEnd ?? cursor;
                const page = getActivePage();
                const drawType = page?.drawType || DEFAULT_DRAW_TYPE;
                const placeholder = drawTypePlaceholders[drawType] || promptInput.placeholder || "";
                const templateMeta = getSelectedPrompt();
                const templateDescription = templateMeta?.description || "";
                const requestId = ++promptSuggestRequestId;
                stopPromptSuggestionRequest();
                const abortController = new AbortController();
                promptSuggestAbortController = abortController;
                const startedAt = performance.now();
                console.debug("[prompt-assist] sending", { requestId, valueLength });
                clearPromptAlternatives();
                try {
                    const result = await fetchPromptAssist({
                        apiKey,
                        text: rawValue,
                        cursor,
                        placeholder,
                        templateDescription,
                        signal: abortController.signal
                    });
                    if (requestId !== promptSuggestRequestId) return;
                    const enforceWordLimit = (textValue, maxWords = 5) => {
                        if (!textValue) return "";
                        const words = textValue.trim().split(/\s+/).slice(0, maxWords);
                        return words.join(" ").trim();
                    };
                    const mainSuggestion = enforceWordLimit(result?.main || "", 6);
                    const alts = Array.isArray(result?.alts)
                        ? result.alts.map(entry => {
                            if (entry && typeof entry === "object") {
                                return {
                                    label: (entry.label || entry.title || entry.text || "").trim(),
                                    text: enforceWordLimit(entry.text || entry.value || entry.label || "", 6)
                                };
                            }
                            const textVal = enforceWordLimit(entry || "", 6);
                            return { label: textVal.split(" ")[0] || textVal, text: textVal };
                        })
                        : [];
                    setInlineSuggestion(mainSuggestion);
                    renderPromptAlternatives(alts);
                    refreshPromptSuggestion();
                    syncPromptSuggestionScroll();
                    const elapsedMs = Math.round(performance.now() - startedAt);
                    console.log("[prompt-assist] completed in", elapsedMs, "ms", {
                        mainLength: (mainSuggestion || "").length,
                        altCount: alts.length
                    });
                } catch (err) {
                    if (err?.name !== "AbortError") {
                        const elapsedMs = Math.round(performance.now() - startedAt);
                        console.log("[prompt-assist] failed after", elapsedMs, "ms", err);
                        console.warn("Prompt assist failed", err);
                        clearPromptAiSuggestion();
                        clearPromptAlternatives();
                    }
                } finally {
                    if (promptSuggestAbortController === abortController) {
                        promptSuggestAbortController = null;
                    }
                }
            }

            function updateActivePageDrawType(typeId) {
                const page = getActivePage();
                if (!page) return;
                const normalizedType = DRAW_TYPES.some(option => option.id === typeId)
                    ? typeId
                    : DEFAULT_DRAW_TYPE;
                if (page.drawType === normalizedType) {
                    updateDrawTypeSelector(normalizedType);
                    return;
                }
                page.drawType = normalizedType;
                updateDrawTypeSelector(normalizedType);
                saveState();
            }

            async function persistActivePageScene(page = getActivePage()) {
                if (!page) return null;
                try {
                    const scene = await captureExcalidrawScene();
                    if (scene) {
                        page.scene = scene;
                        return scene;
                    }
                } catch (err) {
                    console.warn("Impossible de sauvegarder la sc√®ne active", err);
                }
                return null;
            }

            function setActivePage(index) {
                const targetIndex = Math.max(0, Math.min(state.pages.length - 1, index));
                const previousPage = getActivePage();
                const capturePromise = persistActivePageScene(previousPage);
                state.activeIndex = targetIndex;
                renderTabs();
                const applySwitch = () => {
                    syncFormWithPage();
                    saveState();
                };
                if (capturePromise && typeof capturePromise.finally === "function") {
                    capturePromise.finally(applySwitch);
                } else {
                    applySwitch();
                }
            }

            async function renderPageScene(page) {
                if (!page) return;
                const storedScene = sanitizeScene(page.scene);
                if (storedScene) {
                    try {
                        const applied = await applySceneToExcalidraw(storedScene);
                        if (applied) {
                            return;
                        }
                    } catch (err) {
                        console.warn("Impossible d'appliquer la sc√®ne sauvegard√©e", err);
                    }
                    // If the stored scene is invalid, drop it to avoid repeated crashes
                    page.scene = null;
                    try {
                        saveState();
                    } catch (e) {
                        /* noop */
                    }
                }
                await updateExcalidrawScene(page?.mermaid || "");
            }

            function syncFormWithPage() {
                const page = getActivePage();
                promptInput.value = page?.input || "";
                mermaidOutput.value = page?.mermaid || "";
                if (diagramTitleInput) {
                    diagramTitleInput.value = page?.title || page?.label || `Page ${state.activeIndex + 1}`;
                    diagramTitleInput.readOnly = true;
                }
                updateDrawTypeSelector(page?.drawType || DEFAULT_DRAW_TYPE);
                updatePromptPlaceholder(page?.drawType || DEFAULT_DRAW_TYPE);
                updateMermaidPlaceholder(page?.drawType || DEFAULT_DRAW_TYPE);
                refreshPromptSuggestion();
                syncPromptSuggestionScroll();
                renderPageScene(page);
                triggerCriteriaAnalysis({ force: Boolean(promptInput.value.trim()) });
            }

            function clearGenerateCooldown() {
                if (generateCooldownTimer) {
                    clearInterval(generateCooldownTimer);
                    generateCooldownTimer = null;
                }
                generateCooldownEndTime = 0;
                if (generateBtn) {
                    generateBtn.disabled = false;
                    generateBtn.textContent = generateDefaultLabel;
                }
                if (toggleDrawerBtn) {
                    toggleDrawerBtn.disabled = false;
                    toggleDrawerBtn.textContent = drawerDefaultLabel;
                }
            }

            function startGenerateCooldown(seconds = 30) {
                if (!generateBtn) return;
                clearGenerateCooldown();
                const duration = Math.max(1, seconds);
                generateCooldownEndTime = Date.now() + duration * 1000;

                const updateLabel = () => {
                    if (!generateBtn) {
                        clearGenerateCooldown();
                        return;
                    }
                    const remainingMs = generateCooldownEndTime - Date.now();
                    const remainingSeconds = Math.max(0, Math.ceil(remainingMs / 1000));
                    if (remainingSeconds === 0 && activeIaAbortController) {
                        generateBtn.textContent = "‚åõ en cours";
                        if (toggleDrawerBtn) {
                            toggleDrawerBtn.textContent = "‚åõ en cours";
                        }
                        return;
                    }
                    const frames = ["‚ó¥", "‚ó∑", "‚ó∂", "‚óµ"];
                    const frame = frames[remainingSeconds % frames.length];
                    const label = `${frame} ${remainingSeconds}s`;
                    generateBtn.textContent = label;
                    if (toggleDrawerBtn) {
                        toggleDrawerBtn.textContent = label;
                    }
                    if (remainingSeconds <= 0) {
                        clearGenerateCooldown();
                        generateBtn.disabled = false;
                        generateBtn.textContent = generateDefaultLabel;
                        if (toggleDrawerBtn) {
                            toggleDrawerBtn.disabled = false;
                            toggleDrawerBtn.textContent = drawerDefaultLabel;
                        }
                    }
                };

                updateLabel();
                generateCooldownTimer = setInterval(updateLabel, 1000);
            }

            async function handleGenerate() {
                if (activeIaAbortController) {
                    try {
                        activeIaAbortController.abort();
                    } catch (e) { }
                    clearGenerateCooldown();
                    setStatus("Requ√™te annul√©e.");
                    return;
                }
                const controller = new AbortController();
                activeIaAbortController = controller;
                stopActiveSpeechSession({ flushInterim: true });
                const page = getActivePage();
                if (!page) {
                    activeIaAbortController = null;
                    return;
                }
                const inputText = promptInput.value.trim();
                if (!inputText) {
                    setStatus("Ajoute du contexte pour g√©n√©rer ‚úçÔ∏è");
                    promptInput.focus();
                    activeIaAbortController = null;
                    return;
                }
                startGenerateCooldown(30);
                const existingScript = mermaidOutput.value.trim();
                const drawType = page.drawType || DEFAULT_DRAW_TYPE;
                const drawTypePrompt = getDrawTypePromptValue(drawType);
                const templateBase = state.promptTemplate || DEFAULT_PROMPT_TEMPLATE;
                let template = templateBase
                    .replace(/{{field_input}}/gi, inputText)
                    .replace(/{{draw_type}}/gi, drawTypePrompt);
                if (existingScript) {
                    template +=
                        "\n\nScript Mermaid actuel :\n```mermaid\n" +
                        existingScript +
                        "\n```\nTiens compte du script existant s'il existe et ne fais que les modifications demand√©es.";
                } else {
                    template +=
                        "\n\nTiens compte du script existant s'il existe et ne fais que les modifications demand√©es.";
                }
                const messages = [
                    { role: "system", content: "Tu es un assistant produit." },
                    { role: "user", content: template }
                ];
                setStatus("G√©n√©ration en cours...");
                try {
                    const aiText = await callOpenAI(messages, controller);
                    if (!aiText) {
                        setStatus("R√©ponse vide de l'IA ‚Äî r√©essaie ou v√©rifie le backend.");
                        return;
                    }
                    const mermaidCode = extractMermaidCode(aiText);
                    const extractedTitle = extractDiagramTitle(mermaidCode || aiText);
                    page.input = inputText;
                    page.mermaid = mermaidCode;
                    page.lastAiMermaid = mermaidCode;
                    if (extractedTitle) {
                        page.title = extractedTitle;
                        if (diagramTitleInput) {
                            diagramTitleInput.value = extractedTitle;
                        }
                    }
                    mermaidOutput.value = mermaidCode;
                    updateExcalidrawScene(mermaidCode);
                    saveState();
                    setStatus("Diagramme g√©n√©r√© ‚úîÔ∏è");
                } catch (err) {
                    console.error(err);
                    setStatus(`Erreur: ${err.message || "impr√©vue"}`);
                } finally {
                    activeIaAbortController = null;
                    clearGenerateCooldown();
                }
            }

            function extractMermaidCode(text) {
                if (!text) return "";
                const fenced = text.match(/```(?:mermaid)?([\s\S]*?)```/i);
                if (fenced && fenced[1]) {
                    return fenced[1].trim();
                }
                return text.trim();
            }

            function extractDiagramTitle(text) {
                if (!text) return "";
                const match = text.match(/^%%\s*Title\s*[:\-]?\s*(.+)$/im);
                return match && match[1] ? match[1].trim() : "";
            }

            function hasCompleteMermaidBlock(text) {
                if (!text) return false;
                return /```(?:mermaid)?[\s\S]*?```/i.test(text);
            }

            let statusTimeoutId = null;

            function setStatus(message) {
                if (!statusToast) return;
                const text = message?.trim() || "";
                if (!text) {
                    statusToast.classList.remove("visible");
                    statusToast.textContent = "";
                    return;
                }
                statusToast.textContent = text;
                statusToast.classList.add("visible");
                if (statusTimeoutId) {
                    clearTimeout(statusTimeoutId);
                }
                statusTimeoutId = setTimeout(() => {
                    statusToast.classList.remove("visible");
                }, 3500);
            }

            function zoomExcalidrawByFactor(factor) {
                try {
                    const api = getExcalidrawBridge()?.getApi();
                    if (!api) return;
                    const appState = api.getAppState();
                    const currentZoom = appState?.zoom?.value || 1;
                    const nextZoom = Math.min(4, Math.max(0.1, currentZoom * factor));
                    api.setAppState({ zoom: { value: nextZoom } });
                } catch (err) {
                    console.warn("Zoom Excalidraw impossible", err);
                }
            }

            async function callOpenAI(messages, controller) {
                try {
                    if (!window.GoToolkitIA || typeof window.GoToolkitIA.chatCompletion !== "function") {
                        throw new Error("Client IA indisponible");
                    }
                    var reasoningEffort = state.reasoningEffort || "low";
                    var payload = {
                        model:
                            window.GoToolkitIAConfig && typeof window.GoToolkitIAConfig.getOpenAiModel === "function"
                                ? window.GoToolkitIAConfig.getOpenAiModel()
                                : "gpt-5-nano",
                        messages: messages,
                        reasoning: { effort: reasoningEffort },
                        temperature: 1,
                        stream: true
                    };
                    return await window.GoToolkitIA.chatCompletion({
                        payload: payload,
                        stopCondition: hasCompleteMermaidBlock,
                        signal: controller?.signal
                    });
                } catch (err) {
                    console.error("Erreur OpenAI", err);
                    if (err && err.name === "AbortError") {
                        setStatus("Requ√™te annul√©e.");
                        return null;
                    }
                    if (err && (err.message === "OllamaUnavailable" || (err.backendInfo && err.backendInfo.type === "ollama-unavailable"))) {
                        setStatus("Ollama indisponible ‚Äî v√©rifie l'URL ou la connexion au serveur Ollama.");
                    } else {
                        setStatus("Impossible de contacter le service IA ‚Äî v√©rifie tes r√©glages.");
                    }
                    return null;
                }
            }

            function openModal() {
                promptModal?.classList.add("open");
                promptTemplateField.value = state.promptTemplate || DEFAULT_PROMPT_TEMPLATE;
                if (systemPromptField) systemPromptField.value = state.systemPrompt || DEFAULT_SYSTEM_PROMPT;
                // API key and reasoning settings are now managed globally in the Settings modal
            }

            function closeModal() {
                promptModal?.classList.remove("open");
            }

            function resetPrompt() {
                promptTemplateField.value = DEFAULT_PROMPT_TEMPLATE;
                if (systemPromptField) systemPromptField.value = DEFAULT_SYSTEM_PROMPT;
            }

            const EXCALIDRAW_STYLESHEET_URL = "https://unpkg.com/@excalidraw/excalidraw@0.17.6/dist/excalidraw-assets/index.css";

            function ensureExcalidrawStyles() {
                if (document.querySelector('[data-excalidraw-css="main"]')) {
                    return;
                }
                const link = document.createElement("link");
                link.rel = "stylesheet";
                link.href = EXCALIDRAW_STYLESHEET_URL;
                link.dataset.excalidrawCss = "main";
                document.head.appendChild(link);
            }

            function ensureExcalidrawBundleScript() {
                if (window.GoToolkitExcalidraw) {
                    return;
                }
                let script = document.querySelector('script[data-excalidraw-bundle]');
                if (!script) {
                    script = document.createElement("script");
                    script.src = EXCALIDRAW_BUNDLE_SRC;
                    script.dataset.excalidrawBundle = "true";
                    document.body.appendChild(script);
                }
            }

            function waitForBridgeBundle() {
                if (window.GoToolkitExcalidraw) {
                    return Promise.resolve(window.GoToolkitExcalidraw);
                }
                ensureExcalidrawBundleScript();
                if (!bridgeDetectionPromise) {
                    bridgeDetectionPromise = new Promise((resolve, reject) => {
                        const deadline = Date.now() + EXCALIDRAW_BRIDGE_MAX_WAIT_MS;
                        const poll = () => {
                            const bridge = window.GoToolkitExcalidraw;
                            if (bridge) {
                                resolve(bridge);
                                return;
                            }
                            if (Date.now() > deadline) {
                                bridgeDetectionPromise = null;
                                reject(new Error("Bundle Excalidraw non charg√©"));
                                return;
                            }
                            setTimeout(poll, EXCALIDRAW_BRIDGE_POLL_INTERVAL_MS);
                        };
                        poll();
                    });
                }
                return bridgeDetectionPromise;
            }

            let excalidrawReadyPromise = null;

            function getExcalidrawBridge() {
                return window.GoToolkitExcalidraw || null;
            }

            function ensureExcalidrawReady() {
                ensureExcalidrawStyles();
                if (excalidrawReadyPromise) {
                    return excalidrawReadyPromise;
                }
                const hostEl = document.getElementById("excalidrawHost");
                if (!hostEl) {
                    return Promise.reject(new Error("H√¥te Excalidraw introuvable"));
                }
                excalidrawReadyPromise = waitForBridgeBundle()
                    .then(bridge => bridge.initialize(hostEl).then(() => bridge))
                    .catch(error => {
                        excalidrawReadyPromise = null;
                        throw error;
                    });
                return excalidrawReadyPromise;
            }

            function initializeExcalidraw() {
                ensureExcalidrawReady()
                    .then(() => {
                        console.info("Excalidraw initialis√© via bundle");
                    })
                    .catch(err => {
                        console.error("Impossible d'initialiser Excalidraw", err);
                        setStatus("Erreur Excalidraw : consulte la console");
                    });
            }

            async function getExcalidrawApi() {
                const bridge = await ensureExcalidrawReady();
                const api = bridge?.getApi();
                if (!api) {
                    throw new Error("API Excalidraw indisponible");
                }
                return api;
            }

            async function tryMermaidConversion(code) {
                const trimmed = (code || "").trim();
                if (!trimmed) {
                    return null;
                }
                try {
                    const bridge = await ensureExcalidrawReady();
                    const conversion = await bridge.convertMermaid(trimmed);
                    if (conversion?.elements?.length) {
                        return conversion;
                    }
                    return null;
                } catch (error) {
                    console.warn("Conversion Mermaid -> Excalidraw impossible", error);
                    return null;
                }
            }
            function applyMermaidStyleDefaults(elements) {
                if (!Array.isArray(elements)) return [];
                return elements.map(element => {
                    if (!element || typeof element !== "object") return element;
                    return {
                        ...element,
                        strokeWidth: element.strokeWidth ?? MERMAID_STYLE_DEFAULTS.strokeWidth,
                        strokeStyle: element.strokeStyle || MERMAID_STYLE_DEFAULTS.strokeStyle,
                        roughness: MERMAID_STYLE_DEFAULTS.roughness,
                        roundness: MERMAID_STYLE_DEFAULTS.roundness
                    };
                });
            }
            async function buildScenePayload(code) {
                const trimmed = (code || "").trim();
                if (!trimmed) {
                    return { elements: [] };
                }
                const converted = await tryMermaidConversion(trimmed);
                if (converted?.elements?.length) {
                    const hasImage = converted.elements.some(element => element?.type === "image");
                    const imageOnlyScene = converted.elements.every(element => element?.type === "image");
                    // If mermaid conversion produced any image, skip it and fallback to legacy vectorization for editability.
                    if (!hasImage && !imageOnlyScene) {
                        return {
                            ...converted,
                            elements: applyMermaidStyleDefaults(converted.elements || [])
                        };
                    }
                }
                return {
                    elements: applyMermaidStyleDefaults(buildLegacyExcalidrawElements(trimmed)),
                    files: null
                };
            }

            function createBaseElement(type, overrides = {}) {
                const timestamp = Date.now();
                return {
                    id: `${type}-${timestamp}-${Math.floor(Math.random() * 1000000)}`,
                    type,
                    x: 0,
                    y: 0,
                    width: overrides.width ?? 0,
                    height: overrides.height ?? 0,
                    angle: 0,
                    strokeColor: "#1c2a55",
                    backgroundColor: overrides.backgroundColor ?? "#ffffff",
                    fillStyle: overrides.fillStyle ?? "solid",
                    strokeWidth: overrides.strokeWidth ?? MERMAID_STYLE_DEFAULTS.strokeWidth,
                    strokeStyle: overrides.strokeStyle || MERMAID_STYLE_DEFAULTS.strokeStyle,
                    roundness: overrides.roundness ?? MERMAID_STYLE_DEFAULTS.roundness,
                    roughness: MERMAID_STYLE_DEFAULTS.roughness,
                    opacity: 100,
                    groupIds: [],
                    boundElements: [],
                    updated: timestamp,
                    seed: Math.floor(Math.random() * 1000000),
                    version: 1,
                    versionNonce: Math.floor(Math.random() * 1000000),
                    isDeleted: false,
                    locked: false,
                    ...overrides
                };
            }

            function wrapTextContent(value, maxCharsPerLine = 24) {
                const text = (value ?? "").toString().trim();
                if (!text) return "";
                const segments = text.split(/\n+/);
                const lines = [];
                segments.forEach((segment, segmentIndex) => {
                    const words = segment.trim().split(/\s+/).filter(Boolean);
                    if (!words.length) {
                        if (segmentIndex < segments.length - 1) {
                            lines.push("");
                        }
                        return;
                    }
                    let currentLine = "";
                    words.forEach(word => {
                        const candidate = currentLine ? `${currentLine} ${word}` : word;
                        if (candidate.length > maxCharsPerLine && currentLine) {
                            lines.push(currentLine);
                            currentLine = word;
                        } else {
                            currentLine = candidate;
                        }
                    });
                    if (currentLine) {
                        lines.push(currentLine);
                    }
                    if (segmentIndex < segments.length - 1) {
                        lines.push("");
                    }
                });
                const joined = lines.join("\n").replace(/^(\n+)/, "").replace(/(\n+)$/, "");
                return joined || text;
            }

            function countTextLines(text) {
                if (!text) {
                    return 1;
                }
                const segments = text.split(/\n/);
                return segments.length || 1;
            }

            function createTextElement(text, x, y, options = {}) {
                const fontSize = options.fontSize || 18;
                const width = options.width || Math.max(100, (text?.length || 0) * (fontSize * 0.6));
                const lineHeight = options.lineHeight || 1.2;
                const textLines = options.textLines || countTextLines(text);
                const height = options.height || fontSize * lineHeight * textLines;
                const cleanOptions = { ...options };
                delete cleanOptions.textLines;
                delete cleanOptions.lineHeight;
                return createBaseElement("text", {
                    x,
                    y,
                    width,
                    height,
                    strokeColor: options.strokeColor || "#1c2a55",
                    backgroundColor: "transparent",
                    text,
                    originalText: text,
                    fontSize,
                    fontFamily: 1,
                    textAlign: options.textAlign || "left",
                    verticalAlign: options.verticalAlign || "top",
                    baseline: fontSize,
                    lineHeight,
                    containerId: null,
                    ...cleanOptions
                });
            }

            function createRectangleElement(x, y, width, height, options = {}) {
                return createBaseElement("rectangle", {
                    x,
                    y,
                    width,
                    height,
                    backgroundColor: options.backgroundColor || "#ffffff",
                    strokeColor: options.strokeColor || "#1c2a55",
                    ...options
                });
            }

            function createLineElement(x, y, dx, dy, options = {}) {
                return createBaseElement("line", {
                    x,
                    y,
                    width: dx,
                    height: dy,
                    points: [
                        [0, 0],
                        [dx, dy]
                    ],
                    backgroundColor: "transparent",
                    strokeColor: options.strokeColor || "#1c2a55",
                    strokeStyle: options.strokeStyle || "dashed",
                    ...options
                });
            }

            function createArrowElement(startX, startY, endX, endY, options = {}) {
                const cleanOptions = { ...options };
                delete cleanOptions.startArrowhead;
                delete cleanOptions.endArrowhead;
                delete cleanOptions.strokeStyle;
                return createBaseElement("arrow", {
                    x: startX,
                    y: startY,
                    width: endX - startX,
                    height: endY - startY,
                    points: [
                        [0, 0],
                        [endX - startX, endY - startY]
                    ],
                    backgroundColor: "transparent",
                    strokeColor: options.strokeColor || "#1c2a55",
                    strokeStyle: "solid",
                    startArrowhead: options.startArrowhead ?? null,
                    endArrowhead: options.endArrowhead ?? "arrow",
                    ...cleanOptions
                });
            }

            function resolveArrowDirection(arrowString, startCoords, endCoords) {
                const normalized = (arrowString || "").replace(/\s+/g, "");
                const hasLeftHead = normalized.includes("<");
                const hasRightHead = normalized.includes(">");
                const shouldSwap = hasLeftHead && !hasRightHead;
                const start = shouldSwap ? endCoords : startCoords;
                const end = shouldSwap ? startCoords : endCoords;
                const startArrowhead = hasLeftHead && hasRightHead ? "arrow" : null;
                const endArrowhead =
                    hasRightHead || (!hasLeftHead && !hasRightHead) || (hasLeftHead && !hasRightHead)
                        ? "arrow"
                        : null;
                return {
                    startX: start.x,
                    startY: start.y,
                    endX: end.x,
                    endY: end.y,
                    startArrowhead,
                    endArrowhead
                };
            }

            function computeCompactionFactor(count, start = 4, end = 16) {
                if (count <= start) {
                    return 0;
                }
                if (count >= end) {
                    return 1;
                }
                return (count - start) / (end - start);
            }

            function compactValue(count, minValue, maxValue, options = {}) {
                if (maxValue <= minValue) {
                    return minValue;
                }
                const factor = computeCompactionFactor(count, options.start ?? 4, options.end ?? 16);
                return maxValue - (maxValue - minValue) * factor;
            }

            function translateMermaidToElements(code) {
                const trimmed = (code || "").trim();
                if (!trimmed) {
                    return null;
                }
                const lines = trimmed.split(/\n+/).map(line => line.trim()).filter(Boolean);
                if (!lines.length) {
                    return null;
                }
                const header = lines[0].toLowerCase();
                if (header.startsWith("flowchart") || header.startsWith("graph")) {
                    return buildFlowchartElements(lines);
                }
                if (header.startsWith("sequencediagram")) {
                    return buildSequenceDiagramElements(lines);
                }
                if (header.startsWith("classdiagram")) {
                    return buildClassDiagramElements(lines);
                }
                return null;
            }

            function buildFlowchartElements(lines) {
                const elements = [];
                const header = lines.shift();
                const orientationMatch = header.match(/(LR|RL|TD|BT)/i);
                const orientation = orientationMatch ? orientationMatch[1].toUpperCase() : "TD";
                const horizontal = orientation === "LR" || orientation === "RL";
                const nodeMap = new Map();
                const edges = [];

                const registerNode = (id, label) => {
                    if (!nodeMap.has(id)) {
                        nodeMap.set(id, {
                            id,
                            label: label || id
                        });
                    } else if (label) {
                        nodeMap.get(id).label = label;
                    }
                };

                lines.forEach(line => {
                    if (!line) return;
                    const nodeMatch = line.match(/^([A-Za-z0-9_]+)\s*(?:\(|\[|\{)\s*(.+?)\s*(?:\)|\]|\})/);
                    if (nodeMatch) {
                        registerNode(nodeMatch[1], nodeMatch[2]);
                    }
                    const edgeMatch = line.match(
                        /^([A-Za-z0-9_]+)\s*([-.=|<>o*]+)\s*([A-Za-z0-9_]+)(?:\s*:?\s*(.+))?/
                    );
                    if (edgeMatch) {
                        registerNode(edgeMatch[1]);
                        registerNode(edgeMatch[3]);
                        edges.push({
                            from: edgeMatch[1],
                            to: edgeMatch[3],
                            label: edgeMatch[4]?.trim(),
                            arrow: edgeMatch[2]
                        });
                    }
                });

                if (!nodeMap.size) {
                    return null;
                }

                const nodeIds = Array.from(nodeMap.keys());
                const nodeCount = nodeIds.length;
                const nodeWidth = compactValue(nodeCount, 120, 170);
                const spacingX = nodeWidth + compactValue(nodeCount, 30, 80);
                const spacingY = compactValue(nodeCount, 100, 150);
                const baseX = 40;
                const baseY = 40;
                const minBoxHeight = compactValue(nodeCount, 60, 80);
                const columns = (() => {
                    if (!nodeCount) {
                        return 1;
                    }
                    if (horizontal) {
                        return Math.max(2, Math.min(nodeCount, Math.ceil(Math.sqrt(nodeCount * 1.4))));
                    }
                    if (nodeCount <= 4) {
                        return nodeCount;
                    }
                    if (nodeCount <= 9) {
                        return 3;
                    }
                    return Math.min(nodeCount, 4);
                })();

                nodeIds.forEach((id, idx) => {
                    const col = idx % columns;
                    const row = Math.floor(idx / columns);
                    const x = baseX + col * spacingX;
                    const y = baseY + row * spacingY;
                    const rawLabel = (nodeMap.get(id)?.label || id).trim() || id;
                    const wrappedLabel = wrapTextContent(rawLabel, 24) || rawLabel;
                    const lineCount = countTextLines(wrappedLabel);
                    const fontSize = 16;
                    const textHeight = lineCount * fontSize * 1.3;
                    const nodeHeight = Math.max(minBoxHeight, textHeight + 24);
                    const rect = createRectangleElement(x, y, nodeWidth, nodeHeight);
                    const textY = y + (nodeHeight - textHeight) / 2;
                    const text = createTextElement(wrappedLabel, x + 10, textY, {
                        width: nodeWidth - 20,
                        fontSize,
                        textAlign: "center",
                        lineHeight: 1.3,
                        textLines: lineCount,
                        height: textHeight
                    });
                    nodeMap.get(id).x = x;
                    nodeMap.get(id).y = y;
                    nodeMap.get(id).width = nodeWidth;
                    nodeMap.get(id).height = nodeHeight;
                    elements.push(rect, text);
                });

                edges.forEach(edge => {
                    const source = nodeMap.get(edge.from);
                    const target = nodeMap.get(edge.to);
                    if (!source || !target) return;
                    const startX = source.x + source.width / 2;
                    const startY = source.y + source.height / 2;
                    const endX = target.x + target.width / 2;
                    const endY = target.y + target.height / 2;
                    const arrowSpec = resolveArrowDirection(
                        edge.arrow,
                        { x: startX, y: startY },
                        { x: endX, y: endY }
                    );
                    const arrow = createArrowElement(arrowSpec.startX, arrowSpec.startY, arrowSpec.endX, arrowSpec.endY, {
                        startArrowhead: arrowSpec.startArrowhead,
                        endArrowhead: arrowSpec.endArrowhead
                    });
                    elements.push(arrow);
                    if (edge.label) {
                        const labelX = (arrowSpec.startX + arrowSpec.endX) / 2 - 40;
                        const labelY = (arrowSpec.startY + arrowSpec.endY) / 2 - 20;
                        elements.push(createTextElement(edge.label, labelX, labelY, {
                            fontSize: 14,
                            width: 80,
                            textAlign: "center"
                        }));
                    }
                });

                return elements;
            }

            function buildSequenceDiagramElements(lines) {
                const elements = [];
                lines.shift();
                const participants = [];
                const participantLabels = new Map();
                const messages = [];

                const registerParticipant = (id, label) => {
                    if (!participantLabels.has(id)) {
                        participantLabels.set(id, label || id);
                        participants.push(id);
                    }
                };

                lines.forEach(line => {
                    if (!line) return;
                    const participantMatch = line.match(/^participant\s+([A-Za-z0-9_]+)(?:\s+as\s+(.+))?/i);
                    if (participantMatch) {
                        registerParticipant(participantMatch[1], participantMatch[2]?.trim());
                        return;
                    }
                    const messageMatch = line.match(
                        /^([A-Za-z0-9_]+)\s*([-.=|<>]+)\s*([A-Za-z0-9_]+)\s*:?\s*(.*)?/
                    );
                    if (messageMatch) {
                        registerParticipant(messageMatch[1]);
                        registerParticipant(messageMatch[3]);
                        messages.push({
                            from: messageMatch[1],
                            to: messageMatch[3],
                            text: messageMatch[4]?.trim() || "",
                            arrow: messageMatch[2]
                        });
                    }
                });

                if (!participants.length) {
                    return null;
                }

                const participantCount = participants.length;
                const messageCount = Math.max(1, messages.length);
                const spacingX = compactValue(participantCount, 120, 190, { start: 3, end: 12 });
                const baseX = 60;
                const topY = 40;
                const messageSpacing = compactValue(messageCount, 55, 80, { start: 2, end: 12 });
                const lifelineHeight = 100 + messageCount * messageSpacing;
                const boxWidth = compactValue(participantCount, 110, 150, { start: 3, end: 12 });
                const headerBaseHeight = compactValue(participantCount, 36, 48, { start: 3, end: 12 });
                const positions = new Map();

                participants.forEach((id, idx) => {
                    const x = baseX + idx * spacingX;
                    positions.set(id, x);
                    const boxX = x - boxWidth / 2;
                    const label = participantLabels.get(id) || id;
                    const wrappedLabel = wrapTextContent(label, 18) || label;
                    const lineCount = countTextLines(wrappedLabel);
                    const fontSize = 15;
                    const textHeight = lineCount * fontSize * 1.3;
                    const headerHeight = Math.max(headerBaseHeight, textHeight + 16);
                    const rect = createRectangleElement(boxX, topY, boxWidth, headerHeight, {
                        backgroundColor: "#ffffff"
                    });
                    const textY = topY + (headerHeight - textHeight) / 2;
                    const text = createTextElement(wrappedLabel, boxX + 10, textY, {
                        width: boxWidth - 20,
                        fontSize,
                        textAlign: "center",
                        lineHeight: 1.3,
                        textLines: lineCount,
                        height: textHeight
                    });
                    elements.push(rect, text);
                    const adjustedLifelineHeight = Math.max(110, lifelineHeight - Math.max(0, headerHeight - headerBaseHeight));
                    const lifeline = createLineElement(x, topY + headerHeight, 0, adjustedLifelineHeight, {
                        strokeWidth: 1.5,
                        strokeStyle: "dotted"
                    });
                    elements.push(lifeline);
                });

                messages.forEach((message, idx) => {
                    const startX = positions.get(message.from);
                    const endX = positions.get(message.to);
                    if (startX == null || endX == null) return;
                    const y = topY + headerBaseHeight + 20 + idx * messageSpacing;
                    const arrowSpec = resolveArrowDirection(
                        message.arrow,
                        { x: startX, y },
                        { x: endX, y }
                    );
                    const arrow = createArrowElement(arrowSpec.startX, arrowSpec.startY, arrowSpec.endX, arrowSpec.endY, {
                        strokeWidth: 1.5,
                        startArrowhead: arrowSpec.startArrowhead,
                        endArrowhead: arrowSpec.endArrowhead
                    });
                    elements.push(arrow);
                    if (message.text) {
                        const horizontalGap = Math.abs(arrowSpec.endX - arrowSpec.startX);
                        const labelWidth = Math.max(90, horizontalGap - 40);
                        const labelX = Math.min(arrowSpec.startX, arrowSpec.endX) + (horizontalGap - labelWidth) / 2;
                        elements.push(createTextElement(message.text, labelX, y - 22, {
                            width: labelWidth,
                            fontSize: 13,
                            textAlign: "center"
                        }));
                    }
                });

                return elements;
            }

            function buildClassDiagramElements(lines) {
                const elements = [];
                lines.shift();
                const classes = [];
                const relations = [];

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    if (!line) continue;
                    if (/^class\s+/i.test(line)) {
                        const match = line.match(/^class\s+([A-Za-z0-9_]+)(?:\s+as\s+(.+?))?(?:\s*\{)?/i);
                        if (!match) continue;
                        const id = match[1];
                        const label = match[2]?.trim() || id;
                        const members = [];
                        if (line.includes("{") && !line.includes("}")) {
                            i++;
                            while (i < lines.length && !lines[i].includes("}")) {
                                const member = lines[i].replace(/[{}]/g, "").trim();
                                if (member) members.push(member);
                                i++;
                            }
                        } else if (line.includes("{") && line.includes("}")) {
                            const inside = line.split("{")[1].split("}")[0];
                            inside.split(/;|\n/).forEach(entry => {
                                const trimmed = entry.trim();
                                if (trimmed) members.push(trimmed);
                            });
                        }
                        classes.push({ id, label, members });
                        continue;
                    }
                    const relationMatch = line.match(/^([A-Za-z0-9_]+)\s+([<:\.o*\-|>=]+)\s+([A-Za-z0-9_]+)/);
                    if (relationMatch) {
                        relations.push({
                            from: relationMatch[1],
                            to: relationMatch[3],
                            marker: relationMatch[2]
                        });
                    }
                }

                if (!classes.length) {
                    return null;
                }

                const classCount = classes.length;
                const columns = Math.max(1, Math.min(classCount, Math.round(Math.sqrt(classCount * 1.3)) || 1));
                const spacingX = compactValue(classCount, 150, 240, { start: 3, end: 12 });
                const spacingY = compactValue(classCount, 140, 220, { start: 3, end: 12 });
                const baseX = 40;
                const baseY = 40;
                const boxWidth = compactValue(classCount, 160, 210, { start: 3, end: 12 });
                const memberLineHeight = 18;
                const classPositions = new Map();

                classes.forEach((klass, idx) => {
                    const col = idx % columns;
                    const row = Math.floor(idx / columns);
                    const width = boxWidth;
                    const memberLines = Math.max(0, klass.members.length);
                    const wrappedLabel = wrapTextContent(klass.label, 20) || klass.label;
                    const titleLineCount = countTextLines(wrappedLabel);
                    const titleFontSize = 18;
                    const titleTextHeight = titleLineCount * titleFontSize * 1.3;
                    const titleHeight = Math.max(compactValue(classCount, 36, 52, { start: 3, end: 12 }), titleTextHeight + 12);
                    const bodyHeight = memberLines ? memberLines * memberLineHeight + 16 : 20;
                    const height = titleHeight + bodyHeight;
                    const x = baseX + col * spacingX;
                    const y = baseY + row * spacingY;
                    const rect = createRectangleElement(x, y, width, height, {
                        backgroundColor: "#fafbff"
                    });
                    const titleY = y + (titleHeight - titleTextHeight) / 2;
                    const title = createTextElement(wrappedLabel, x + 10, titleY, {
                        width: width - 20,
                        fontSize: titleFontSize,
                        textAlign: "center",
                        lineHeight: 1.3,
                        textLines: titleLineCount,
                        height: titleTextHeight
                    });
                    const memberText = klass.members.join("\n");
                    if (memberText) {
                        elements.push(
                            rect,
                            title,
                            createTextElement(memberText, x + 10, y + titleHeight + 10, {
                                width: width - 20,
                                fontSize: 13,
                                lineHeight: 1.2,
                                textLines: Math.max(1, memberLines)
                            })
                        );
                    } else {
                        elements.push(rect, title);
                    }
                    const position = {
                        x: x + width / 2,
                        y: y + height / 2,
                        boxX: x,
                        boxY: y,
                        width,
                        height
                    };
                    classPositions.set(klass.id, position);
                    classPositions.set(klass.label, position);
                });

                relations.forEach(rel => {
                    const from = classPositions.get(rel.from);
                    const to = classPositions.get(rel.to);
                    if (!from || !to) return;
                    const arrowSpec = resolveArrowDirection(
                        rel.marker,
                        { x: from.x, y: from.y },
                        { x: to.x, y: to.y }
                    );
                    const arrow = createArrowElement(arrowSpec.startX, arrowSpec.startY, arrowSpec.endX, arrowSpec.endY, {
                        strokeWidth: rel.marker.includes("..") ? 1 : 2,
                        startArrowhead: arrowSpec.startArrowhead,
                        endArrowhead: arrowSpec.endArrowhead
                    });
                    elements.push(arrow);
                });

                return elements;
            }

            function buildFallbackTextElements(code) {
                const lines = code
                    .split("\n")
                    .map(line => line.trim())
                    .filter(Boolean);
                if (!lines.length) {
                    lines.push("Diagramme vide");
                }
                const baseY = 40;
                const gap = 70;
                return lines.map((line, idx) => createTextElement(line, 40, baseY + idx * gap, {
                    fontSize: 24
                }));
            }

            function buildLegacyExcalidrawElements(code) {
                const translated = translateMermaidToElements(code);
                if (translated && translated.length) {
                    return translated;
                }
                return buildFallbackTextElements(code);
            }

            function applySceneUpdate(api, scenePayload) {
                if (api && typeof api.updateScene === "function") {
                    api.updateScene(scenePayload);
                    return true;
                }
                if (api && typeof api.resetScene === "function") {
                    api.resetScene({ ...scenePayload, commitToHistory: false });
                    return true;
                }
                if (api && typeof api.replaceAllElements === "function") {
                    api.replaceAllElements(scenePayload.elements);
                    if (typeof api.setAppState === "function") {
                        api.setAppState(scenePayload.appState);
                    }
                    return true;
                }
                return false;
            }

            function buildExcalidrawAppState(api, overrides = {}) {
                const base = (api && typeof api.getAppState === "function") ? api.getAppState() : {};
                const sanitized = { ...overrides };
                if (!(sanitized.collaborators instanceof Map)) {
                    delete sanitized.collaborators;
                }
                return {
                    ...base,
                    ...sanitized,
                    viewBackgroundColor: "#fdfdfd",
                    gridModeEnabled: false,
                    isLoading: false,
                    currentItemRoundness: "sharp"
                };
            }

            async function applySceneToExcalidraw(scene, options = {}) {
                const normalized = sanitizeScene(scene);
                if (!normalized) return false;
                const api = await getExcalidrawApi();
                const appState = buildExcalidrawAppState(api, normalized.appState || {});
                const filesObj = toBinaryFilesObject(normalized.files);
                // Prepare files for the Excalidraw API: prefer a Map; if conversion fails, omit files.
                let filesForApi = null;
                if (filesObj) {
                    if (filesObj instanceof Map) {
                        filesForApi = filesObj;
                    } else if (typeof filesObj === "object") {
                        try {
                            filesForApi = new Map(Object.entries(filesObj));
                        } catch (e) {
                            filesForApi = null;
                        }
                    }
                }

                const scenePayload = {
                    elements: Array.isArray(normalized.elements) ? normalized.elements : [],
                    appState
                };
                if (filesForApi) {
                    scenePayload.files = filesForApi;
                }

                let applied = false;
                try {
                    applied = applySceneUpdate(api, scenePayload);
                } catch (err) {
                    console.warn("Excalidraw updateScene failed, will fallback to mermaid", err);
                    applied = false;
                }
                if (filesForApi && typeof api.addFiles === "function") {
                    api.addFiles(Array.from(filesForApi.values()));
                }
                if (applied && !options.skipStore) {
                    const activePage = getActivePage();
                    if (activePage) {
                        activePage.scene = sanitizeScene({
                            elements: scenePayload.elements,
                            appState,
                            files: scenePayload.files || null
                        });
                    }
                }
                return applied;
            }

            async function updateExcalidrawScene(code) {
                pendingSceneCode = code || "";
                sceneBuildRequestId += 1;
                const requestId = sceneBuildRequestId;
                try {
                    const api = await getExcalidrawApi();
                    const sceneData = await buildScenePayload(pendingSceneCode);
                    if (requestId !== sceneBuildRequestId) {
                        return;
                    }
                    const appState = buildExcalidrawAppState(api, sceneData.appState || {});
                    const filesObj = toBinaryFilesObject(sceneData.files);
                    // Convert stored files object to Map for the Excalidraw API when possible.
                    let filesForApi = null;
                    if (filesObj) {
                        if (filesObj instanceof Map) {
                            filesForApi = filesObj;
                        } else if (typeof filesObj === "object") {
                            try {
                                filesForApi = new Map(Object.entries(filesObj));
                            } catch (e) {
                                filesForApi = null;
                            }
                        }
                    }
                    const scenePayload = {
                        elements: sceneData.elements || [],
                        appState
                    };
                    if (filesForApi) {
                        scenePayload.files = filesForApi;
                    }
                    if (!applySceneUpdate(api, scenePayload)) {
                        console.warn("Aucune m√©thode disponible pour mettre √† jour Excalidraw", {
                            hasUpdateScene: typeof api?.updateScene === "function",
                            hasResetScene: typeof api?.resetScene === "function",
                            hasReplaceAll: typeof api?.replaceAllElements === "function"
                        });
                    }
                    if (filesForApi && typeof api.addFiles === "function") {
                        api.addFiles(Array.from(filesForApi.values()));
                    }
                    if (requestId === sceneBuildRequestId) {
                        const activePage = getActivePage();
                        if (activePage) {
                            activePage.scene = normalizeScene({
                                elements: scenePayload.elements,
                                appState,
                                files: scenePayload.files || null
                            });
                        }
                    }
                } catch (error) {
                    console.error("Impossible de mettre √† jour Excalidraw", error);
                    if (requestId !== sceneBuildRequestId) {
                        return;
                    }
                    const api = getExcalidrawBridge()?.getApi();
                    if (!api) {
                        return;
                    }
                    const fallbackElements = buildFallbackTextElements(pendingSceneCode || "Diagramme indisponible");
                    const appState = buildExcalidrawAppState(api);
                    const scenePayload = { elements: fallbackElements, appState };
                    applySceneUpdate(api, scenePayload);
                    const activePage = getActivePage();
                    if (activePage) {
                        activePage.scene = normalizeScene(scenePayload);
                    }
                }
            }

            function bindEvents() {
                generateBtn.addEventListener("click", handleGenerate);
                promptInput.addEventListener("input", () => {
                    const page = getActivePage();
                    clearSpeechSuggestion(promptInput);
                    if (page) {
                        page.input = sanitizeScenarioText(promptInput.value);
                        saveState();
                    }
                    setInlineSuggestion("");
                    clearPromptAlternatives();
                    refreshPromptSuggestion();
                    schedulePromptAISuggestion();
                    triggerCriteriaAnalysis();
                });
                promptInput.addEventListener("focus", () => {
                    promptInputWrapper?.classList.add("is-focused");
                    refreshPromptSuggestion();
                });
                promptInput.addEventListener("blur", () => {
                    promptInputWrapper?.classList.remove("is-focused");
                    refreshPromptSuggestion();
                });
                // mark that the user moved the cursor (mouse or navigation keys)
                function markUserMovedCursor() {
                    try {
                        suppressSuggestionFollow = true;
                        if (suppressSuggestionTimer) clearTimeout(suppressSuggestionTimer);
                        suppressSuggestionTimer = setTimeout(() => {
                            suppressSuggestionFollow = false;
                            suppressSuggestionTimer = null;
                        }, 1000);
                    } catch (e) { /* noop */ }
                }
                promptInput.addEventListener("keydown", event => {
                    if (!currentPromptSuggestion) return;
                    const collapsed =
                        promptInput.selectionStart === promptInput.selectionEnd;
                    const shouldAccept =
                        collapsed &&
                        (event.key === "Tab" ||
                            (event.key === "ArrowRight" && !event.metaKey && !event.ctrlKey && !event.shiftKey));
                    if (shouldAccept) {
                        event.preventDefault();
                        acceptPromptSuggestion();
                    }
                });
                // detect user navigation keys to suppress suggestion-following
                promptInput.addEventListener("keydown", (e) => {
                    const navKeys = ['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Home', 'End', 'PageUp', 'PageDown'];
                    if (navKeys.includes(e.key)) markUserMovedCursor();
                });
                promptInput.addEventListener("keyup", refreshPromptSuggestion);
                promptInput.addEventListener("mouseup", () => { markUserMovedCursor(); setTimeout(refreshPromptSuggestion, 0); });
                // clear suppression when the user types (we should follow again)
                promptInput.addEventListener("input", () => {
                    try { if (suppressSuggestionTimer) { clearTimeout(suppressSuggestionTimer); suppressSuggestionTimer = null; } suppressSuggestionFollow = false; } catch (e) { }
                }, { passive: true });
                promptInput.addEventListener("scroll", syncPromptSuggestionScroll);
                diagramTitleInput?.addEventListener("dblclick", () => {
                    diagramTitleInput.readOnly = false;
                    diagramTitleInput.focus();
                    diagramTitleInput.select();
                });
                diagramTitleInput?.addEventListener("blur", () => {
                    diagramTitleInput.readOnly = true;
                });
                diagramTitleInput?.addEventListener("input", () => {
                    const page = getActivePage();
                    if (!page) return;
                    page.title = diagramTitleInput.value;
                    saveState();
                });
                mermaidOutput.addEventListener("input", () => {
                    const page = getActivePage();
                    const value = mermaidOutput.value;
                    if (page) {
                        page.mermaid = value;
                        page.scene = null;
                        const titleFromScript = extractDiagramTitle(value);
                        if (titleFromScript) {
                            page.title = titleFromScript;
                            if (diagramTitleInput) {
                                diagramTitleInput.value = titleFromScript;
                            }
                        }
                        saveState();
                    }
                    updateExcalidrawScene(value);
                });
                drawTypeButtons.forEach(button => {
                    button.addEventListener("click", () => {
                        const selectedType = button.dataset.drawType;
                        if (!selectedType) {
                            return;
                        }
                        updateActivePageDrawType(selectedType);
                    });
                });
                addPageBtn.addEventListener("click", () => {
                    const newPage = createPage(state.pages.length + 1);
                    state.pages.push(newPage);
                    setActivePage(state.pages.length - 1);
                    saveState();
                    try {
                        if (isDesktopGutenberg()) openDrawer();
                    } catch (err) {
                        /* noop */
                    }
                });
                function clearActivePage(options = {}) {
                    const clearRecit = !!options.clearRecit;
                    const page = getActivePage();
                    if (!page) return;
                    if (!clearRecit) {
                        promptInput.value = page.input || promptInput.value;
                    } else {
                        promptInput.value = "";
                        page.input = "";
                    }
                    page.mermaid = "";
                    page.title = page.label;
                    page.drawType = DEFAULT_DRAW_TYPE;
                    page.scene = null;
                    mermaidOutput.value = "";
                    diagramTitleInput.value = page.title;
                    updateActivePageDrawType(DEFAULT_DRAW_TYPE);
                    refreshPromptSuggestion();
                    syncPromptSuggestionScroll();
                    clearPromptAiSuggestion();
                    clearPromptAlternatives();
                    updateExcalidrawScene("");
                }
                deletePageBtn.addEventListener("click", () => {
                    const page = getActivePage();
                    if (!page || state.pages.length <= 1) return;
                    const name = page.title || page.label || `Page ${state.activeIndex + 1}`;
                    if (!confirm(`Supprimer la vue '${name}' ? Cette action est irr√©versible.`)) {
                        return;
                    }
                    const targetIndex = Math.max(0, state.activeIndex - 1);
                    state.pages.splice(state.activeIndex, 1);
                    setActivePage(targetIndex);
                });
                clearMermaidBtn?.addEventListener("click", () => {
                    const page = getActivePage();
                    if (page) {
                        page.mermaid = "";
                        page.scene = null;
                        page.title = page.label || page.title;
                    }
                    mermaidOutput.value = "";
                    updateExcalidrawScene("");
                    saveState();
                    setStatus("Script vid√©.");
                });
                refreshExcalidrawBtn?.addEventListener("click", () => {
                    const page = getActivePage();
                    const restoreCode = page?.lastAiMermaid || "";
                    if (!restoreCode) {
                        setStatus("Aucun script IA pr√©c√©dent √† restaurer.");
                        return;
                    }
                    page.mermaid = restoreCode;
                    page.scene = null;
                    const titleFromScript = extractDiagramTitle(restoreCode);
                    if (titleFromScript) {
                        page.title = titleFromScript;
                        if (diagramTitleInput) {
                            diagramTitleInput.value = titleFromScript;
                        }
                    }
                    mermaidOutput.value = restoreCode;
                    updateExcalidrawScene(restoreCode);
                    saveState();
                    setStatus("Script restaur√© depuis la derni√®re r√©ponse IA ‚úîÔ∏è");
                });
                infoButton?.addEventListener("click", event => {
                    event.stopPropagation();
                    closeShareMenu();
                    closeCapsuleMenu();
                    infoPopup?.classList.toggle("open");
                });
                updateAppBtn?.addEventListener("click", event => {
                    event.stopPropagation();
                    promptManualUpdate();
                });
                tourReplayBtn?.addEventListener("click", event => {
                    event.stopPropagation();
                    infoPopup?.classList.remove("open");
                    if (window.GoToolkitConfig && window.GoToolkitConfig.enableTours === false) {
                        setStatus("Tours guid√©s d√©sactiv√©s");
                        return;
                    }
                    startTour();
                });
                document.addEventListener("click", event => {
                    if (!infoPopup?.contains(event.target) && event.target !== infoButton) {
                        closeInfoPopup();
                    }
                });
                tourPrevBtn?.addEventListener("click", () => {
                    const prev = Math.max(0, currentTourIndex - 1);
                    renderTourStep(prev);
                });
                tourNextBtn?.addEventListener("click", () => {
                    if (currentTourIndex >= tourSteps.length - 1) {
                        closeTour();
                        return;
                    }
                    renderTourStep(currentTourIndex + 1);
                });
                tourCloseBtn?.addEventListener("click", closeTour);
                tourSkipBtn?.addEventListener("click", closeTour);
                aiSettingsBtn.addEventListener("click", openModal);
                closePromptModalBtn.addEventListener("click", closeModal);
                const applyAiSettingsBtn = document.getElementById("applyAiSettingsBtn");
                applyAiSettingsBtn?.addEventListener("click", () => {
                    state.promptTemplate = promptTemplateField?.value.trim() || DEFAULT_PROMPT_TEMPLATE;
                    state.systemPrompt = systemPromptField?.value.trim() || DEFAULT_SYSTEM_PROMPT;
                    saveState();
                    setStatus("Param√®tres enregistr√©s ‚úîÔ∏è");
                    closeModal();
                });
                resetPromptBtn.addEventListener("click", resetPrompt);
                window.addEventListener("keydown", event => {
                    const isEscape = event.key === "Escape";
                    if (isEscape && promptModal?.classList.contains("open")) {
                        closeModal();
                    }
                    if (isEscape && isDrawerOpen && drawerMediaQuery.matches) {
                        closeDrawer();
                    }
                });

                toggleDrawerBtn?.addEventListener("click", () => {
                    toggleDrawer();
                });

                drawerOverlay?.addEventListener("click", () => {
                    closeDrawer();
                });

                drawerMediaQuery.addEventListener("change", handleDrawerBreakpointChange);

                capsuleMenuBtn?.addEventListener("click", event => {
                    event.stopPropagation();
                    closeShareMenu();
                    closeInfoPopup();
                    capsuleMenu?.classList.toggle("open");
                });
                capsuleNewDocBtn?.addEventListener("click", event => {
                    event.preventDefault();
                    event.stopPropagation();
                    handleNewDocumentClick();
                });
                capsuleDraftSaveBtn?.addEventListener("click", event => {
                    event.preventDefault();
                    event.stopPropagation();
                    handleSaveDocumentClick();
                });
                capsuleMenu?.addEventListener("click", event => {
                    event.stopPropagation();
                });
                capsuleOpenBtn?.addEventListener("click", () => {
                    capsuleImportInput.value = "";
                    capsuleImportInput.click();
                    closeCapsuleMenu();
                });
                capsuleSaveBtn?.addEventListener("click", async () => {
                    closeCapsuleMenu();
                    try {
                        const payload = await buildCapsulePayload();
                        const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
                        const link = document.createElement("a");
                        link.href = URL.createObjectURL(blob);
                        link.download = getExportFilename("json");
                        link.click();
                        URL.revokeObjectURL(link.href);
                        setStatus("Capsule enregistr√©e en JSON.");
                    } catch (err) {
                        console.error("Impossible de sauvegarder la capsule", err);
                        setStatus("Erreur pendant l'enregistrement de la capsule.");
                    }
                });
                capsuleImportInput.addEventListener("change", event => {
                    const file = event.target.files?.[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = () => {
                        try {
                            const parsed = JSON.parse(reader.result);
                            const applied = applyImportedCapsule(parsed);
                            if (applied) {
                                setStatus("Capsule charg√©e ‚úîÔ∏è");
                            } else {
                                throw new Error("Format invalide");
                            }
                        } catch (err) {
                            console.error("Import JSON invalide", err);
                            alert("Import JSON invalide.");
                        }
                    };
                    reader.readAsText(file);
                });

                if (shareBtn && shareMenu) {
                    shareBtn.addEventListener("click", event => {
                        event.stopPropagation();
                        // If info popup is open, close it when opening the share menu
                        closeInfoPopup();
                        shareMenu.classList.toggle("open");
                        updateShareMenuUI();
                    });
                    shareMenu.addEventListener("click", event => {
                        event.stopPropagation();
                    });
                }
                shareLinkField?.addEventListener("focus", () => {
                    shareLinkField.select();
                });
                shareLinkField?.addEventListener("click", () => {
                    shareLinkField.select();
                });
                shareCreateBtn?.addEventListener("click", handleShareCreateClick);
                shareUpdateBtn?.addEventListener("click", handleShareUpdateClick);
                document.addEventListener("click", event => {
                    if (!shareMenu?.contains(event.target) && event.target !== shareBtn) {
                        closeShareMenu();
                    }
                });
                document.addEventListener("click", event => {
                    if (!capsuleMenu?.contains(event.target) && event.target !== capsuleMenuBtn) {
                        closeCapsuleMenu();
                    }
                });

                if (navSwitcherBtn && navSwitcherMenu) {
                    navSwitcherBtn.addEventListener("click", event => {
                        event.stopPropagation();
                        navSwitcherMenu.classList.toggle("open");
                    });
                    navSwitcherMenu.addEventListener("click", event => {
                        event.stopPropagation();
                    });
                    document.addEventListener("click", event => {
                        if (!navSwitcherMenu.contains(event.target) && event.target !== navSwitcherBtn) {
                            navSwitcherMenu.classList.remove("open");
                        }
                    });
                }

                updateShareMenuUI();
            }

            async function initializeAppState() {
                initShareWorkerService();
                const sharedLoaded = await tryLoadSharedStateFromUrl();
                const localLoaded = !sharedLoaded && await tryLoadLocalDraftFromUrl();
                if (!sharedLoaded && !localLoaded) {
                    loadState();
                }
                // Load global Settings (shared across pages) if present in localStorage.
                // This allows a central "R√©glages" modal (index.html) to control API key
                // and reasoning effort for all pages.
                try {
                    if (window.localStorage) {
                        // API key (shared)
                        const sharedApiKey = localStorage.getItem(API_KEY_STORAGE_KEY) || "";
                        if (sharedApiKey && !state.apiKey) {
                            state.apiKey = sharedApiKey;
                        }
                        // Reasoning effort (shared key used by timeline page)
                        const SHARED_REASONING_KEY = "plan-reasoning-effort";
                        const sharedReasoning = localStorage.getItem(SHARED_REASONING_KEY) || "";
                        if (sharedReasoning) {
                            state.reasoningEffort = sharedReasoning;
                        }
                    }
                } catch (e) {
                    /* noop */
                }
                if (state.templateId && !selectedPromptId) {
                    selectedPromptId = state.templateId;
                }
                renderTabs();
                syncFormWithPage();
                updateSelectedTemplateLabelDisplay();
                bindEvents();
                handleDrawerBreakpointChange(drawerMediaQuery);
                initializeExcalidraw();
                try {
                    maybeAutoOpenDrawer();
                } catch (err) {
                    /* noop */
                }
                if (sharedLoaded) {
                    saveState();
                }
            }

            initializeAppState();
            // React to global Settings changes saved in other tabs/windows
            window.addEventListener("storage", function (ev) {
                if (!ev || !ev.key) return;
                try {
                    if (ev.key === API_KEY_STORAGE_KEY) {
                        state.apiKey = ev.newValue || "";
                    }
                    if (ev.key === "plan-reasoning-effort" || ev.key === "robert-reasoning-effort") {
                        state.reasoningEffort = ev.newValue || "low";
                        const sel = document.getElementById("reasoningEffortSelect");
                        if (sel) sel.value = state.reasoningEffort;
                    }
                } catch (err) {
                    /* noop */
                }
            });
        })();
    </script>
    <script>
        (function removeVersionQueryParam() {
            try {
                const url = new URL(window.location.href);
                if (!url.searchParams.has("v")) return;
                url.searchParams.delete("v");
                const search = url.searchParams.toString();
                const newUrl = url.pathname + (search ? `?${search}` : "") + url.hash;
                window.history.replaceState({}, "", newUrl);
            } catch (err) {
                /* noop */
            }
        })();
    </script>
    <script>
        window.GoToolkitAppFeedbackConfig = {
            appId: "draw",
            appName: "Draw",
            defaultType: "bug-draw",
            shareCollection: "diagrams",
            buildSharePayload: async () => ({
                app: "draw",
                url: window.location.href,
                payload: typeof buildCapsulePayload === "function" ? await buildCapsulePayload() : {}
            })
        };
    </script>
    <script src="js/feedback-app.js"></script>
</body>

</html>
