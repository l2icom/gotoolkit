<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Go-Draw</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap">
    <link rel="stylesheet" href="https://unpkg.com/@excalidraw/excalidraw@0.17.6/dist/excalidraw.min.css">
    <style>
        :root {
            font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            font-size: 12px;
            color: #101428;
            background-color: #eef0f6;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            min-height: 100vh;
            background: #eef0f6;
        }

        .app {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 10px 0px;
        }

        .app-header {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 2px;
            flex-wrap: wrap;
            width: 100%;
            margin: 4px 0 auto;
            padding: 0 20px;
            border-radius: 0;
            border: none;
            box-shadow: none;
            background: transparent;
        }

        .app-home-link {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
            border-radius: 8px;
            border: 1px solid #cdd4ed;
            background: #ffffff;
            font-size: 16px;
            color: #1f2a56;
            text-decoration: none;
            transition: box-shadow 0.2s ease, border-color 0.2s ease;
        }

        .app-home-link:hover,
        .app-home-link:focus-visible {
            border-color: #2a7a57;
            box-shadow: 0 8px 20px rgba(42, 122, 87, 0.3);
            outline: none;
        }

        .tabs-actions {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
            flex-wrap: wrap;
        }

        .tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .tab-btn {
            border: 1px solid #cdd4ed;
            background: #f7f8ff;
            color: #1f2a56;
            padding: 4px 10px;
            border-radius: 9999px;
            font-weight: 500;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.2s ease, color 0.2s ease;
        }

        .tab-btn.active {
            background: #2a7a57;
            border-color: #2a7a57;
            color: #ffffff;
        }

        .tab-btn-add,
        .tab-btn-remove {
            border: 1px solid #ebe0d1;
            background: #ffffff;
            color: #1f2a56;
            font-size: 12px;
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.2s ease;
            padding: 4px 8px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 32px;
        }

        .tab-btn-add:hover,
        .tab-btn-remove:hover {
            background: #dbe2ff;
        }

        .global-actions {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
            margin-left: auto;
        }

        .global-actions button,
        .global-actions .info-button,
        .reset-prompts-btn,
        .nav-switch-btn {
            border-radius: 999px;
            border: 1px solid #ebe0d1;
            background: #ffffff;
            padding: 0 6px;
            min-height: 24px;
            font-size: 12px;
            line-height: 24px;
            cursor: pointer;
            box-shadow: none;
        }

        .drawer-toggle-btn {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            border-radius: 8px;
            border: 1px solid #dfe3f5;
            background: #ffffff;
            padding: 4px 8px;
            font-size: 12px;
            line-height: 18px;
            cursor: pointer;
        }

        .global-actions button.primary {
            border: none;
            background: #2a7a57;
            color: #ffffff;
        }

        .global-actions button:hover,
        .global-actions button:focus-visible,
        .global-actions .info-button:hover,
        .global-actions .info-button:focus-visible,
        .reset-prompts-btn:hover,
        .reset-prompts-btn:focus-visible,
        .nav-switch-btn:hover,
        .nav-switch-btn:focus-visible {
            box-shadow: 0 6px 18px rgba(42, 122, 87, 0.32);
        }

        .share-menu-wrapper {
            position: relative;
        }

        .share-menu {
            position: absolute;
            top: calc(100% + 8px);
            right: 0;
            min-width: 240px;
            padding: 14px;
            border-radius: 12px;
            border: 1px solid #dfe3f5;
            background: #ffffff;
            box-shadow: 0 18px 32px rgba(16, 20, 40, 0.18);
            display: none;
            z-index: 20;
        }

        .share-menu.open {
            display: block;
        }

        .share-menu-header {
            font-size: 12px;
            font-weight: 600;
            color: #1f2a56;
            margin-bottom: 8px;
        }

        .share-link-line {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }

        .share-link-field {
            flex: 1;
            border-radius: 6px;
            border: 1px solid #d6dbf2;
            padding: 8px 10px;
            font-size: 12px;
            background: #fbfbff;
            color: #101428;
        }

        .share-actions {
            display: flex;
            gap: 8px;
            margin-bottom: 6px;
        }

        .share-action-btn {
            flex: 1;
            border-radius: 10px;
            border: 1px solid #ebe0d1;
            background: #ffffff;
            font-size: 12px;
            padding: 6px 10px;
            cursor: pointer;
        }

        .share-action-btn.primary {
            border: 1px solid #2a7a57;
            background: #2a7a57;
            color: #ffffff;
        }

        .share-action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .share-menu-status {
            font-size: 11px;
            color: #566188;
            min-height: 16px;
            margin: 0;
        }

        .share-menu-status.error {
            color: #b42318;
        }

        .nav-switch {
            position: relative;
            display: inline-flex;
            align-items: center;
        }

        .nav-switch-menu {
            position: absolute;
            top: calc(100% + 6px);
            left: 0;
            min-width: 180px;
            background: #ffffff;
            border-radius: 14px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            padding: 6px;
            display: none;
            z-index: 50;
        }

        .nav-switch-menu.open {
            display: block;
        }

        .nav-switch-link {
            display: flex;
            align-items: center;
            gap: 6px;
            width: 100%;
            border: none;
            background: transparent;
            border-radius: 10px;
            padding: 8px 12px;
            font-size: 12px;
            cursor: pointer;
            text-decoration: none;
            color: #1f2a56;
        }

        .nav-switch-link:hover,
        .nav-switch-link:focus-visible {
            background: rgba(42, 122, 87, 0.08);
        }

        .ai-button,
        .generate-btn,
        .refresh-btn {
            border: 1px solid #cec9c9;
            background: white;
            color: #1f2a56;
            font-size: 13px;
            padding: 6px 10px;
            border-radius: 8px;
            cursor: pointer;
        }

        .connect-layout {
            flex: 1;
            padding: 5px 10px;
            display: flex;
            gap: 10px;
        }

        .connect-left {
            background: #ffffff;
            border-radius: 4px;
            padding: 10px;
            border: 1px solid #dfe3f5;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .connect-left.collapsed {
            display: none;
        }

        .connect-right.full-width {
            flex: 1 1 100%;
            width: 100%;
        }


        .connect-right {
            background: #ffffff;
            border-radius: 4px;
            padding: 0px;
            border: 1px solid #dfe3f5;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .connect-left,
        .connect-right {
            flex: 1;
        }

        .connect-left {
            flex: 0 0 350px;
            max-width: 350px;
            width: 100%;
        }

        .drawer-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.25);
            backdrop-filter: blur(2px);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 60;
        }

        .card-title {
            font-size: 13px;
            font-weight: 600;
        }

        .card-title-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0px;
            margin-bottom: 0px;
        }

        textarea {
            width: 100%;
            border-radius: 4px;
            border: 1px solid #d6dbf2;
            padding: 12px;
            resize: none;
            font-family: inherit;
            font-size: 12px;
            line-height: 1.5;
            background: #fbfbff;
            color: #101428;
        }

        textarea:focus {
            outline: 2px solid #6776ff;
            background: #ffffff;
        }

        .prompt-input-card {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .prompt-input-card textarea {
            height: 130px;
            margin-bottom: 10px;
        }

        .draw-type-control {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .draw-type-control-label {
            font-size: 11px;
            font-weight: 600;
            color: #566188;
        }

        .draw-type-selector {
            display: flex;
            gap: 6px;
        }

        .draw-type-btn {
            flex: 1;
            border-radius: 20px;
            border: 1px solid #d6dbf2;
            background: #ffffff;
            padding: 6px 10px;
            font-size: 12px;
            font-weight: 600;
            color: #1f2a56;
            cursor: pointer;
            transition: background 0.2s ease, border-color 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
        }

        .draw-type-btn.active {
            background: #2a7a57;
            border-color: #2a7a57;
            color: #ffffff;
        }

        .draw-type-btn:focus-visible {
            outline: 2px solid #2a7a57;
        }

        .mermaid-output-card {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-height: 0;
        }

        .mermaid-output-card textarea {
            flex: 1;
            min-height: 0;
        }

        .generate-btn,
        .refresh-btn {
            align-self: flex-start;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .status-label {
            font-size: 12px;
            color: #566188;
            min-height: 18px;
        }

        .status-toast {
            position: fixed;
            left: 24px;
            bottom: 24px;
            max-width: 280px;
            background: rgba(16, 20, 40, 0.92);
            color: #ffffff;
            padding: 12px 16px;
            border-radius: 8px;
            box-shadow: 0 12px 24px rgba(16, 20, 40, 0.35);
            font-size: 13px;
            line-height: 1.4;
            opacity: 0;
            transform: translateY(8px);
            transition: opacity 0.2s ease, transform 0.2s ease;
            pointer-events: none;
            z-index: 100;
        }

        .status-toast.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .excalidraw-card {
            flex: 1;
            border-radius: 4px;
            border: 1px dashed #cfd5ef;
            background: #fdfdff;
            padding: 12px;
            display: flex;
            flex-direction: column;
            min-height: 320px;
            overflow: hidden;
        }

        .diagram-title-row {
            margin: 0 10px 2px 0;
        }

        .diagram-title-input {
            width: 100%;
            padding: 6px 6px;
            font-size: 14px;
            font-weight: 700;
            border: 1px solid transparent;
            border-radius: 8px;
            background: #ffffff;
            color: #0f172a;
        }

        #excalidrawHost {
            flex: 1;
            border-radius: 4px;
            background: #ffffff;
            min-height: 360px;
            height: 100%;
            width: 100%;
            position: relative;
            overflow: hidden;
            --bar-padding: 5px;
        }

        #excalidrawHost .App-bottom-bar {
            margin: 5px !important;
        }

        #excalidrawHost .layer-ui__wrapper__top-left {
            left: auto;
            right: 12px;
            flex-direction: row-reverse;
        }

        #excalidrawHost .layer-ui__wrapper__bottom-left {
            left: auto;
            right: 12px;
        }

        #excalidrawHost .layer-ui__wrapper__top-right,
        #excalidrawHost .layer-ui__wrapper__bottom-right {
            right: 12px;
        }

        #excalidrawHost a[href*="excalidraw"],
        #excalidrawHost button[title*="Excalidraw" i],
        #excalidrawHost [aria-label*="Excalidraw" i],
        #excalidrawHost a[href*="discord" i],
        #excalidrawHost button[title*="Discord" i],
        #excalidrawHost [aria-label*="Discord" i] {
            display: none !important;
        }

        .placeholder {
            color: #9ca3c7;
            font-size: 14px;
            margin: 0;
        }

        .ai-modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.4);
            display: none;
            align-items: center;
            justify-content: center;
            padding: 24px;
            z-index: 40;
        }

        .ai-modal-overlay.open {
            display: flex;
        }

        .ai-modal {
            width: min(520px, 92vw);
            background: #ffffff;
            border-radius: 14px;
            padding: 18px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .ai-modal header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 4px;
        }

        .ai-modal header h3 {
            margin: 0;
            font-size: 18px;
        }

        .ai-modal header button {
            border: none;
            background: transparent;
            font-size: 18px;
            cursor: pointer;
            color: #6b7280;
        }

        .ai-modal input,
        .ai-modal textarea {
            width: 100%;
            border-radius: 8px;
            border: 1px solid #d0c3ad;
            padding: 10px 12px;
            background: #ffffff;
            font-size: 13px;
            font-family: inherit;
        }

        .ai-modal textarea {
            min-height: 110px;
        }

        .ai-modal-actions {
            display: flex;
            justify-content: flex-start;
            gap: 10px;
        }

        .ai-modal-actions button {
            border-radius: 8px;
            border: 1px solid #ebe0d1;
            background: #ffffff;
            color: #0f172a;
            padding: 6px 12px;
            font-size: 12px;
            cursor: pointer;
        }

        .ai-modal-actions .btn-primary {
            border: none;
            background: #2a7a57;
            color: #ffffff;
        }

        .info-popup {
            position: absolute;
            top: 56px;
            right: 12px;
            width: 280px;
            background: #fff;
            border-radius: 14px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            padding: 15px;
            display: none;
            flex-direction: column;
            gap: 6px;
            font-size: 12px;
            z-index: 60;
        }

        .info-popup.open {
            display: flex;
        }

        .info-popup img {
            width: 48px;
            height: 48px;
            object-fit: contain;
            align-self: center;
        }

        .info-popup a {
            color: #2a7a57;
            text-decoration: none;
            font-weight: 600;
        }

        .info-popup button {
            border-radius: 8px;
            border: 1px solid rgba(15, 23, 42, 0.15);
            background: #fff;
            color: #0f172a;
            padding: 6px 10px;
            font-size: 12px;
            cursor: pointer;
            min-width: 110px;
        }

        .info-popup button.update-btn {
            background: #2a7a57;
            border-color: #2a7a57;
            color: #fff;
        }

        .info-popup button.secondary {
            background: #fff;
            border-color: rgba(15, 23, 42, 0.15);
            color: #0f172a;
        }

        .info-actions {
            display: flex;
            justify-content: space-between;
            gap: 8px;
            flex-wrap: wrap;
        }

        .tour-overlay {
            position: fixed;
            inset: 0;
            background: rgba(15, 23, 42, 0.55);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 80;
        }

        .tour-overlay.open {
            display: flex;
        }

        .tour-overlay.has-highlight {
            background: transparent;
        }

        .tour-highlight {
            position: absolute;
            border: 2px solid #2a7a57;
            border-radius: 12px;
            background: transparent;
            box-shadow: 0 0 0 9999px rgba(15, 23, 42, 0.55);
            pointer-events: none;
            transition: all 0.2s ease;
        }

        .tour-panel {
            position: relative;
            z-index: 2;
            background: #fff;
            border-radius: 14px;
            padding: 16px;
            width: min(480px, 92vw);
            box-shadow: 0 18px 40px rgba(0, 0, 0, 0.35);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .tour-step-counter {
            font-size: 12px;
            color: #6b7280;
        }

        .tour-panel h4 {
            margin: 0;
            font-size: 16px;
        }

        .tour-panel p {
            margin: 0;
            font-size: 13px;
            color: #374151;
        }

        .tour-step-footer {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            flex-wrap: wrap;
        }

        .tour-step-footer button {
            border-radius: 8px;
            border: 1px solid rgba(15, 23, 42, 0.15);
            background: #fff;
            color: #0f172a;
            padding: 6px 10px;
            font-size: 12px;
            cursor: pointer;
        }

        .tour-step-footer button.primary {
            background: #2a7a57;
            color: #fff;
            border-color: #2a7a57;
        }

        .tour-skip {
            position: absolute;
            top: 12px;
            right: 12px;
            border: none;
            background: transparent;
            color: #fff;
            font-size: 18px;
            cursor: pointer;
        }

        .btn-secondary,
        .btn-primary {
            border: none;
            border-radius: 4px;
            padding: 6px 12px;

            font-size: 12px;
            cursor: pointer;
        }

        .btn-secondary {
            background: #eef0ff;
            color: #2a7a57;
            font-weight: 300;
        }

        .btn-primary {
            background: #2a7a57;
            color: #ffffff;
            font-weight: 600;
        }

        /* Ajuste le menu lat√©ral Excalidraw (selected-shape-actions) */
        .excalidraw-card .Island.App-menu__left {
            --padding: 2px;
            max-height: 200px;
            max-width: 100px;
        }

        @media (max-width: 1200px) {
            .connect-layout {
                position: relative;
                gap: 6px;
            }

            .connect-right {
                width: 100%;
            }

            .connect-left {
                position: fixed;
                top: 0;
                right: 0;
                height: 100vh;
                max-width: min(420px, 90vw);
                width: 90vw;
                box-shadow: -12px 0 30px rgba(16, 20, 40, 0.25);
                transform: translateX(110%);
                transition: transform 0.22s ease;
                z-index: 70;
                overflow-y: auto;
            }

            .connect-left.open {
                transform: translateX(0);
            }

            .drawer-overlay.visible {
                opacity: 1;
                pointer-events: all;
            }

            .excalidraw-card,
            #excalidrawHost {
                min-height: 70vh;
                height: 70vh;
            }
        }
    </style>
</head>

<body>
    <div class="app">
        <header class="app-header">
            <a class="app-home-link" href="index.html" title="Revenir √† l'accueil">‚åò</a>
            <div class="nav-switch">
                <button id="navSwitcherBtn" class="nav-switch-btn" type="button">‚óá Go-Draw ‚ñæ</button>
                <div id="navSwitcherMenu" class="nav-switch-menu">
                    <a class="nav-switch-link" href="think.html">‚ó´ Go-Think</a>
                    <a class="nav-switch-link" href="plan.html">‚ñ∑ Go-Plan</a>
                </div>
            </div>
            <div class="tabs-actions">
                <div id="pageTabs" class="tabs"></div>
                <button id="addPageBtn" class="tab-btn-add" title="Ajouter une page">‚ûï</button>
                <button id="deletePageBtn" class="tab-btn-remove" title="Supprimer la page">üóëÔ∏è</button>
            </div>
            <div class="global-actions">
                <button id="toggleDrawerBtn" class="drawer-toggle-btn" type="button">üìÑ Contexte</button>
                <button id="aiSettingsBtn" class="ai-button" type="button">ü§ñ Assistant AI</button>
                <div class="share-menu-wrapper">
                    <button id="shareBtn" class="info-button" type="button" title="Lien de partage">üîó Partage</button>
                    <div id="shareMenu" class="share-menu" role="dialog" aria-live="polite">
                        <div class="share-menu-header">Lien de partage</div>
                        <div class="share-link-line">
                            <input id="shareLinkField" class="share-link-field" type="text" readonly
                                placeholder="Cr√©er un lien priv√©">
                        </div>
                        <div class="share-actions">
                            <button id="shareUpdateBtn" type="button" class="share-action-btn primary">üîÑ
                                Actualiser</button>
                            <button id="shareCreateBtn" type="button" class="share-action-btn primary">üîó
                                Cr√©er</button>
                        </div>
                        <p class="share-menu-status" id="shareMenuStatus"></p>
                    </div>
                </div>
                <button id="infoButton" class="info-button" type="button" title="√Ä propos">‚ÑπÔ∏è √Ä propos</button>

            </div>
        </header>

        <div id="drawerOverlay" class="drawer-overlay" aria-hidden="true"></div>

        <div id="infoPopup" class="info-popup" role="dialog" aria-live="polite">
            <img src="logo.gif" alt="Logo Go-Toolkit">
            <strong>Go-Draw</strong>
            <span>Version 2025.12.05</span>
            <span>D√©velopp√© par Quang TRAN.</span>
            <span>Usage r√©serv√© √† Savane Consulting.</span>
            <div class="info-actions">
                <button id="updateAppBtn" type="button" class="update-btn">Mettre √† jour</button>
                <button id="tourReplayBtn" type="button" class="secondary">Tour guid√©</button>
            </div>
        </div>

        <main class="connect-layout">
            <section class="connect-right">
                <div class="diagram-title-row">
                    <input id="diagramTitleInput" class="diagram-title-input" type="text" readonly
                        placeholder="Titre de la page">
                </div>
                <div class="excalidraw-card">
                    <div id="excalidrawHost"></div>
                </div>
            </section>

            <section class="connect-left">
                <div class="prompt-input-card" id="prompt-input-card">
                    <div class="card-title-row">
                        <div class="card-title">Contexte</div>
                        <button id="generateBtn" class="generate-btn" type="button">‚ú® G√©n√©rer</button>
                    </div>
                    <div class="draw-type-control">
                        <span class="draw-type-control-label">Type de diagramme</span>
                        <div class="draw-type-selector" role="group" aria-label="Type de diagramme">
                            <button class="draw-type-btn active" type="button" data-draw-type="sequence"
                                aria-pressed="true">‚Ü¶ S√©quence</button>
                            <button class="draw-type-btn" type="button" data-draw-type="flow" aria-pressed="false">‚ñ≥
                                Flux</button>
                            <button class="draw-type-btn" type="button" data-draw-type="class" aria-pressed="false">‚å¨
                                Classe</button>
                        </div>
                    </div>
                    <textarea id="promptInput" rows="5"
                        placeholder="D√©cris ton contexte produit, tes utilisateurs, ta probl√©matique..."></textarea>
                </div>
                <div class="mermaid-output-card">
                    <div class="card-title-row">
                        <div class="card-title">Code Mermaid re√ßu</div>
                        <button id="refreshExcalidrawBtn" class="refresh-btn" type="button">‚Üª Rafra√Æchir</button>
                    </div>
                    <textarea id="mermaidOutput" placeholder="Le code g√©n√©r√© apparaitra ici"></textarea>
                </div>
            </section>
        </main>
    </div>

    <div id="statusToast" class="status-toast" role="status"></div>

    <div id="tourOverlay" class="tour-overlay" aria-hidden="true">
        <div class="tour-highlight" aria-hidden="true"></div>
        <div class="tour-panel">
            <span class="tour-step-counter" id="tourStepCounter"></span>
            <h4 id="tourStepTitle"></h4>
            <p id="tourStepDescription"></p>
            <div class="tour-step-footer">
                <button id="tourPrevBtn" type="button">Pr√©c√©dent</button>
                <button id="tourNextBtn" type="button" class="primary">Suivant</button>
                <button id="tourCloseBtn" type="button">Fermer</button>
            </div>
        </div>
        <button id="tourSkipBtn" class="tour-skip" type="button" aria-label="Fermer">√ó</button>
    </div>

    <div class="ai-modal-overlay" id="aiModal">
        <div class="ai-modal">
            <header>
                <h3>Assistant IA</h3>
                <button id="closeAiModal" class="btn-secondary" type="button">‚úï</button>
            </header>
            <label>
                <a href="https://platform.openai.com/settings/organization/api-keys" target="_blank"
                    rel="noreferrer">OpenAI API key</a>
                <input type="password" id="apiKeyField" placeholder="sk-...">
            </label>
            <label>
                <span>Effort de raisonnement</span>
                <select id="reasoningEffortSelect"
                    style="border: 1px solid #d0c3ad; font-size: 13px; font-family: inherit; color: inherit;">
                    <option value="minimal">minimal</option>
                    <option value="low" selected>low</option>
                    <option value="medium">medium</option>
                </select>
            </label>
            <label>
                <span>Prompt personnalis√©</span>
                <textarea id="promptTemplateField" rows="6"></textarea>
            </label>
            <div class="ai-modal-actions">
                <button id="resetPromptBtn" class="btn-secondary" type="button">‚Ü∫ R√©initialiser</button>
            </div>
        </div>
    </div>

    <script>
        window.GO_TOOLKIT_SHARE_API_URL =
            window.GO_TOOLKIT_SHARE_API_URL || "https://share.gotoolkit.workers.dev/";
    </script>
    <script src="js/share-worker-client.js"></script>
    <script src="js/share-history.js"></script>
    <script src="js/openai-client.js"></script>
    <script>
        var process = window.process || {};
        (function () {
            process.env = process.env || {};
            if (!process.env.NODE_ENV) {
                process.env.NODE_ENV = "production";
            }
            process.browser = true;
            window.process = process;
        })();
    </script>
    <script src="js/connect.bundle.js" data-excalidraw-bundle="true"></script>
    <script>
        (() => {
            const DEFAULT_PROMPT_TEMPLATE =
                "Tu es un product owner exp√©riment√©, sur la base de {{field_input}}, produis un code mermaid sous forme d'un diagramme de {{draw_type}}. Les intitul√©s font moins de 4 mots. Ajoute un titre en commentaire %% Title dans la r√©ponse. Ne fais pas d'introduction ou de conclusion, donne uniquement le bloc de code.";
            const DRAW_TYPES = [
                { id: "sequence", label: "‚Ü¶ S√©quence", promptValue: "sequenceDiagram" },
                { id: "flow", label: "‚ñ≥ Flux", promptValue: "flowchart" },
                { id: "class", label: "‚å¨ Classe", promptValue: "classDiagram" }
            ];
            const DEFAULT_DRAW_TYPE = DRAW_TYPES[0].id;
            const STORAGE_KEY = "connect-ai-state";
            const FIRESTORE_COLLECTION = "diagrams";
            const SHARE_QUERY_PARAM = "share";
            const SHARE_WORKER_UNAVAILABLE_MESSAGE =
                "Le partage priv√© n√©cessite le worker Cloudflare li√© √† Go-Toolkit.";
            const shareWorkerService = window.goToolkitShareWorker;
            const EXCALIDRAW_BUNDLE_SRC = "js/connect.bundle.js";
            const EXCALIDRAW_BRIDGE_MAX_WAIT_MS = 8000;
            const EXCALIDRAW_BRIDGE_POLL_INTERVAL_MS = 50;

            let state = {
                pages: [],
                activeIndex: 0,
                apiKey: "",
                promptTemplate: DEFAULT_PROMPT_TEMPLATE,
                reasoningEffort: "low"
            };
            let pendingSceneCode = "";
            let bridgeDetectionPromise = null;
            let sceneBuildRequestId = 0;
            let shareWorkerAvailable = Boolean(shareWorkerService?.isReady);
            let currentShareToken = null;
            let shareLoadedFromRemote = false;
            let shareStatusMessage = "";
            let shareStatusType = "";
            let shareRequestInProgress = false;
            let shareLastUpdatedAt = null;

            function getDrawSharePreview() {
                const firstPage = state.pages?.[0];
                const title = (firstPage?.title || firstPage?.label || "Page 1").trim();
                const desc = (firstPage?.input || "")
                    .split(/\r?\n/)
                    .map(line => line.trim())
                    .filter(Boolean)
                    .slice(0, 2)
                    .join(" ¬∑ ");
                return { title, description: desc || "Compl√®te le contexte pour l'afficher ici." };
            }

            function persistDrawShareRecord(token, updatedAt) {
                if (!shareHistory || !token) {
                    return;
                }
                try {
                    const preview = getDrawSharePreview();
                    shareHistory.upsertRecord("draw", {
                        token,
                        updatedAt: updatedAt || new Date().toISOString(),
                        title: preview.title,
                        description: preview.description
                    });
                } catch (err) {
                    console.warn("Impossible d'archiver le lien Go-Draw", err);
                }
            }

            const promptInput = document.getElementById("promptInput");
            const diagramTitleInput = document.getElementById("diagramTitleInput");
            const mermaidOutput = document.getElementById("mermaidOutput");
            const drawTypeButtons = Array.from(document.querySelectorAll(".draw-type-btn[data-draw-type]"));
            const drawTypePlaceholders = {
                flow: "D√©cris les √©tapes du processus, ce qui se passe √† chaque moment, les d√©cisions possibles et comment on arrive au r√©sultat final.",
                class: "D√©cris les √©l√©ments importants, leurs caract√©ristiques, leurs r√¥les et la mani√®re dont ils sont reli√©s entre eux.",
                sequence: "D√©cris qui interagit avec qui, dans quel ordre, ce que chaque √©change signifie et comment la situation √©volue du d√©but √† la fin."
            };
            const mermaidPlaceholders = {
                flow: `%% FLOW DIAGRAM PLACEHOLDER
flowchart TD
    A[D√©cris ici la premi√®re √©tape du flux] --> B[Explique l'√©tape suivante]
    B --> C{D√©cris la d√©cision ou le choix possible}
    C -->|Option 1| D[D√©cris ce qui arrive si on choisit cette option]
    C -->|Option 2| E[D√©cris l‚Äôautre chemin]
    E --> F[D√©cris l‚Äô√©tape finale du processus]`,
                class: `%% CLASS DIAGRAM PLACEHOLDER
classDiagram
    class Item {
        +D√©crisIciLesAttributs
        +D√©crisIciLesActions
    }
    class User {
        +D√©crisCeQuiCaract√©riseCet√âl√©ment
    }
    User --> Item : "D√©cris le lien entre eux"`,
                sequence: `%% SEQUENCE DIAGRAM PLACEHOLDER
sequenceDiagram
    participant A as D√©crisIciLePremierActeur
    participant B as D√©crisLeDeuxi√®meActeur
    A->>B: D√©cris la premi√®re interaction
    B->>A: D√©cris la r√©ponse
    A->>B: D√©cris l‚Äô√©tape suivante
    Note over A,B: Ajoute ici une explication ou un contexte`
            };
            const generateBtn = document.getElementById("generateBtn");
            const statusToast = document.getElementById("statusToast");
            const pageTabs = document.getElementById("pageTabs");
            const addPageBtn = document.getElementById("addPageBtn");
            const deletePageBtn = document.getElementById("deletePageBtn");
            const refreshExcalidrawBtn = document.getElementById("refreshExcalidrawBtn");
            const infoButton = document.getElementById("infoButton");
            const infoPopup = document.getElementById("infoPopup");
            const updateAppBtn = document.getElementById("updateAppBtn");
            const tourReplayBtn = document.getElementById("tourReplayBtn");
            const tourOverlay = document.getElementById("tourOverlay");
            const tourHighlight = tourOverlay?.querySelector(".tour-highlight");
            const tourStepCounter = document.getElementById("tourStepCounter");
            const tourStepTitle = document.getElementById("tourStepTitle");
            const tourStepDescription = document.getElementById("tourStepDescription");
            const tourPrevBtn = document.getElementById("tourPrevBtn");
            const tourNextBtn = document.getElementById("tourNextBtn");
            const tourCloseBtn = document.getElementById("tourCloseBtn");
            const tourSkipBtn = document.getElementById("tourSkipBtn");
            const aiModal = document.getElementById("aiModal");
            const aiSettingsBtn = document.getElementById("aiSettingsBtn");
            const closeAiModalBtn = document.getElementById("closeAiModal");
            const apiKeyField = document.getElementById("apiKeyField");
            const reasoningEffortSelect = document.getElementById("reasoningEffortSelect");
            const promptTemplateField = document.getElementById("promptTemplateField");
            const resetPromptBtn = document.getElementById("resetPromptBtn");
            const navSwitcherBtn = document.getElementById("navSwitcherBtn");
            const navSwitcherMenu = document.getElementById("navSwitcherMenu");
            const shareBtn = document.getElementById("shareBtn");
            const shareMenu = document.getElementById("shareMenu");
            const shareLinkField = document.getElementById("shareLinkField");
            const shareMenuStatus = document.getElementById("shareMenuStatus");
            const shareCreateBtn = document.getElementById("shareCreateBtn");
            const shareUpdateBtn = document.getElementById("shareUpdateBtn");
            const toggleDrawerBtn = document.getElementById("toggleDrawerBtn");
            const drawerOverlay = document.getElementById("drawerOverlay");
            const connectLeft = document.querySelector(".connect-left");
            const connectRight = document.querySelector(".connect-right");
            const drawerMediaQuery = window.matchMedia("(max-width: 1200px)");
            const shareHistory = window.goToolkitShareHistory;
            const generateDefaultLabel = generateBtn?.textContent || "‚ú® G√©n√©rer";
            const drawerDefaultLabel = toggleDrawerBtn?.textContent || "üìÑ Contexte";
            let generateCooldownTimer = null;
            let generateCooldownEndTime = 0;
            let currentTourIndex = 0;
            let isDrawerOpen = !drawerMediaQuery.matches;
            const tourSteps = [
                {
                    title: "Intention Go-Draw",
                    description: "Go-Draw aide les consultants √† illustrer rapidement des id√©es en diagrammes clairs.",
                    selector: null
                },
                {
                    title: "D√©cris et choisis",
                    description: "D√©cris le contexte, choisis le type de diagramme puis clique sur G√©n√©rer.",
                    selector: "#prompt-input-card"
                },
                {
                    title: "Code g√©n√©r√©",
                    description: "Attends la r√©ponse dans le bloc Mermaid et ajuste le texte si besoin.",
                    selector: "#mermaidOutput"
                },
                {
                    title: "Visualisation en direct",
                    description: "Observe les changements dans la zone de droite et affine visuellement fl√®ches et formes.",
                    selector: ".connect-right"
                },
                {
                    title: "Actions globales",
                    description: "Utilise les actions d'en-t√™te pour partager, g√©rer les pages ou acc√©der √† l'IA.",
                    selector: ".app-header"
                }
            ];

            function syncDrawerToggleUi() {
                const isOpen = isDrawerOpen || !drawerMediaQuery.matches;
                toggleDrawerBtn?.classList.toggle("is-open", isOpen);
                connectLeft?.classList.toggle("is-open", isOpen);
            }

            function closeDrawer() {
                if (!connectLeft) return;
                isDrawerOpen = false;
                syncDrawerToggleUi();
            }

            function openDrawer() {
                if (!connectLeft) return;
                isDrawerOpen = true;
                syncDrawerToggleUi();
            }

            function toggleDrawer() {
                if (isDrawerOpen) {
                    closeDrawer();
                } else {
                    openDrawer();
                }
            }

            function handleDrawerBreakpointChange(event) {
                if (event.matches) {
                    isDrawerOpen = false; // mobile starts closed
                } else {
                    isDrawerOpen = true; // desktop defaults open
                }
                syncDrawerToggleUi();
            }

            function syncDrawerToggleUi() {
                const isMobile = drawerMediaQuery.matches;
                const isOpen = isDrawerOpen;

                if (isMobile) {
                    connectLeft?.classList.toggle("open", isOpen);
                    connectLeft?.classList.remove("collapsed");
                    connectRight?.classList.remove("full-width");
                    if (isOpen) {
                        drawerOverlay?.classList.add("visible");
                        drawerOverlay?.setAttribute("aria-hidden", "false");
                        toggleDrawerBtn?.setAttribute("aria-expanded", "true");
                    } else {
                        drawerOverlay?.classList.remove("visible");
                        drawerOverlay?.setAttribute("aria-hidden", "true");
                        toggleDrawerBtn?.setAttribute("aria-expanded", "false");
                    }
                } else {
                    connectLeft?.classList.remove("open");
                    drawerOverlay?.classList.remove("visible");
                    drawerOverlay?.setAttribute("aria-hidden", "true");
                    toggleDrawerBtn?.setAttribute("aria-expanded", isOpen ? "true" : "false");
                    connectLeft?.classList.toggle("collapsed", !isOpen);
                    connectRight?.classList.toggle("full-width", !isOpen);
                }
            }

            syncDrawerToggleUi();

            function loadState() {
                try {
                    const raw = localStorage.getItem(STORAGE_KEY);
                    if (!raw) {
                        state.pages = [createPage(1)];
                        return;
                    }
                    const parsed = JSON.parse(raw);
                    const storedPages = Array.isArray(parsed.pages) && parsed.pages.length ? parsed.pages : [createPage(1)];
                    state = {
                        pages: storedPages.map((page, index) => normalizePage(page, index)),
                        activeIndex: parsed.activeIndex || 0,
                        apiKey: parsed.apiKey || "",
                        promptTemplate: parsed.promptTemplate || DEFAULT_PROMPT_TEMPLATE,
                        reasoningEffort: parsed.reasoningEffort || parsed.reasoning?.effort || "low"
                    };
                } catch (err) {
                    console.warn("Impossible de charger l'√©tat", err);
                    state.pages = [createPage(1)];
                }
            }

            function saveState() {
                try {
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
                } catch (err) {
                    console.error("Impossible de sauvegarder l'√©tat", err);
                }
            }

            async function captureExcalidrawScene() {
                try {
                    const api = await getExcalidrawApi();
                    const elements = typeof api.getSceneElements === "function"
                        ? api.getSceneElements()
                        : typeof api.getElements === "function"
                            ? api.getElements()
                            : [];
                    const appState = typeof api.getAppState === "function" ? api.getAppState() : undefined;
                    const files = typeof api.getFiles === "function" ? api.getFiles() : undefined;
                    return { elements: elements || [], appState, files };
                } catch (err) {
                    console.warn("Impossible de capturer la sc√®ne Excalidraw", err);
                    return null;
                }
            }

            async function buildSharePayload() {
                const scene = await captureExcalidrawScene();
                return {
                    pages: state.pages.map((page, index) => normalizePage(page, index)),
                    activeIndex: state.activeIndex,
                    apiKey: state.apiKey || "",
                    promptTemplate: state.promptTemplate || DEFAULT_PROMPT_TEMPLATE,
                    reasoningEffort: state.reasoningEffort || "low",
                    scene
                };
            }

            let sharedScenePayload = null;

            function applySharedState(payload) {
                if (!payload) return false;
                const incomingPages = Array.isArray(payload.pages) && payload.pages.length
                    ? payload.pages
                    : [createPage(1)];
                state.pages = incomingPages.map((page, index) => normalizePage(page, index));
                state.activeIndex = Math.max(0, Math.min(state.pages.length - 1, payload.activeIndex || 0));
                state.apiKey = payload.apiKey || "";
                state.promptTemplate = payload.promptTemplate || DEFAULT_PROMPT_TEMPLATE;
                state.reasoningEffort = payload.reasoningEffort || payload.reasoning?.effort || "low";
                if (payload.scene && payload.scene.elements) {
                    sharedScenePayload = payload.scene;
                }
                return true;
            }

            function initShareWorkerService() {
                shareWorkerAvailable = Boolean(window.goToolkitShareWorker?.isReady);
            }

            function setShareStatus(message, type = "") {
                shareStatusMessage = message;
                shareStatusType = type;
            }

            function formatRelativeTime(isoString) {
                if (!isoString) return "";
                const value = new Date(isoString).getTime();
                if (Number.isNaN(value)) return "";
                const deltaSeconds = Math.max(0, Math.floor((Date.now() - value) / 1000));
                if (deltaSeconds < 60) {
                    return "Mis √† jour √† l'instant";
                }
                const deltaMinutes = Math.floor(deltaSeconds / 60);
                if (deltaMinutes < 60) {
                    return `Mis √† jour il y a ${deltaMinutes} minute${deltaMinutes > 1 ? "s" : ""}`;
                }
                const deltaHours = Math.floor(deltaMinutes / 60);
                if (deltaHours < 24) {
                    return `Mis √† jour il y a ${deltaHours} heure${deltaHours > 1 ? "s" : ""}`;
                }
                const deltaDays = Math.floor(deltaHours / 24);
                return `Mis √† jour il y a ${deltaDays} jour${deltaDays > 1 ? "s" : ""}`;
            }

            function getShareTokenFromUrl() {
                const params = new URLSearchParams(window.location.search);
                const value = params.get(SHARE_QUERY_PARAM);
                return value ? value.trim() : null;
            }

            function buildShareUrl(token) {
                if (!token) {
                    return "";
                }
                const url = new URL(window.location.href);
                url.searchParams.set(SHARE_QUERY_PARAM, token);
                return url.toString();
            }

            function updateUrlWithShareToken(token) {
                const url = new URL(window.location.href);
                if (token) {
                    url.searchParams.set(SHARE_QUERY_PARAM, token);
                } else {
                    url.searchParams.delete(SHARE_QUERY_PARAM);
                }
                history.replaceState(null, "", url.toString());
            }

            function createShareToken() {
                if (typeof crypto !== "undefined" && typeof crypto.randomUUID === "function") {
                    return crypto.randomUUID();
                }
                const bytes = new Uint8Array(16);
                if (typeof crypto !== "undefined" && typeof crypto.getRandomValues === "function") {
                    crypto.getRandomValues(bytes);
                } else {
                    for (let i = 0; i < bytes.length; i++) {
                        bytes[i] = Math.floor(Math.random() * 256);
                    }
                }
                return Array.from(bytes)
                    .map(byte => byte.toString(16).padStart(2, "0"))
                    .join("");
            }

            async function fetchSharePayload(token) {
                if (!shareWorkerAvailable || !shareWorkerService) {
                    throw new Error(SHARE_WORKER_UNAVAILABLE_MESSAGE);
                }
                return shareWorkerService.fetchSharePayload(FIRESTORE_COLLECTION, token);
            }

            async function applySharedSceneIfPresent() {
                if (!sharedScenePayload) return;
                try {
                    const api = await getExcalidrawApi();
                    const appState = {
                        ...api.getAppState?.(),
                        ...(sharedScenePayload.appState || {})
                    };
                    const scenePayload = {
                        elements: sharedScenePayload.elements || [],
                        appState
                    };
                    if (sharedScenePayload.files) {
                        scenePayload.files = sharedScenePayload.files;
                    }
                    applySceneUpdate(api, scenePayload);
                    if (sharedScenePayload.files && typeof api.addFiles === "function") {
                        api.addFiles(sharedScenePayload.files);
                    }
                } catch (err) {
                    console.warn("Impossible d'appliquer la sc√®ne partag√©e", err);
                }
            }

            async function tryLoadSharedStateFromUrl() {
                const token = getShareTokenFromUrl();
                if (!token) {
                    return false;
                }
                try {
                    const result = await fetchSharePayload(token);
                    const payload = result?.payload;
                    if (!payload || !Array.isArray(payload.pages)) {
                        setShareStatus("Lien de partage introuvable.", "error");
                        return false;
                    }
                    applySharedState(payload);
                    currentShareToken = token;
                    shareLoadedFromRemote = true;
                    shareLastUpdatedAt = result?.meta?.updatedAt || new Date().toISOString();
                    setShareStatus(formatRelativeTime(shareLastUpdatedAt));
                    persistDrawShareRecord(token, shareLastUpdatedAt);
                    await applySharedSceneIfPresent();
                    return true;
                } catch (err) {
                    console.error("Erreur de chargement du lien partag√© :", err);
                    setShareStatus("Impossible de charger le lien partag√©.", "error");
                    return false;
                }
            }

            async function saveSharePayload(token, payload) {
                if (!shareWorkerAvailable || !shareWorkerService) {
                    throw new Error(SHARE_WORKER_UNAVAILABLE_MESSAGE);
                }
                const meta = await shareWorkerService.saveSharePayload(FIRESTORE_COLLECTION, token, payload);
                return meta?.updatedAt || new Date().toISOString();
            }

            function getShareDefaultStatusText() {
                if (!shareWorkerAvailable) {
                    return SHARE_WORKER_UNAVAILABLE_MESSAGE;
                }
                if (shareLastUpdatedAt) {
                    return formatRelativeTime(shareLastUpdatedAt);
                }
                if (shareLoadedFromRemote && currentShareToken) {
                    return "Ce lien charge une session partag√©e.";
                }
                if (currentShareToken) {
                    return "Un lien priv√© existe d√©j√† pour cette session.";
                }
                return "Seules les personnes disposant du lien peuvent y acc√©der.";
            }

            function updateShareMenuUI() {
                if (shareLinkField) {
                    const hasToken = Boolean(currentShareToken);
                    shareLinkField.value = hasToken ? buildShareUrl(currentShareToken) : "";
                    shareLinkField.placeholder = hasToken ? "" : "Cr√©er un lien priv√©";
                }
                if (shareCreateBtn) {
                    shareCreateBtn.disabled = shareRequestInProgress || !shareWorkerAvailable;
                    shareCreateBtn.classList.toggle("primary", !currentShareToken);
                }
                if (shareUpdateBtn) {
                    const hasToken = Boolean(currentShareToken);
                    shareUpdateBtn.hidden = !hasToken;
                    shareUpdateBtn.disabled = shareRequestInProgress || !hasToken || !shareWorkerAvailable;
                }
                if (shareMenuStatus) {
                    const text = shareStatusMessage || getShareDefaultStatusText();
                    shareMenuStatus.textContent = text;
                    const isError = (shareStatusType === "error" && Boolean(text)) || (!shareWorkerAvailable && !shareStatusMessage);
                    shareMenuStatus.classList.toggle("error", isError);
                }
            }

            function closeShareMenu() {
                shareMenu?.classList.remove("open");
            }

            function closeInfoPopup() {
                infoPopup?.classList.remove("open");
            }

            function clearAppCacheAndReload() {
                try {
                    localStorage.clear();
                } catch (err) {
                    console.warn("Impossible de vider localStorage", err);
                }
                try {
                    sessionStorage.clear();
                } catch (err) {
                    console.warn("Impossible de vider sessionStorage", err);
                }
                (document.cookie || "")
                    .split(";")
                    .forEach(function (cookie) {
                        const eqPos = cookie.indexOf("=");
                        let name = eqPos > -1 ? cookie.substr(0, eqPos) : cookie;
                        name = name.trim();
                        if (!name) return;
                        document.cookie = name + "=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/";
                    });
                const reload = function () {
                    window.location.reload();
                };
                if (window.caches && typeof window.caches.keys === "function") {
                    window.caches
                        .keys()
                        .then(function (keys) {
                            return Promise.all(keys.map(function (key) {
                                return window.caches.delete(key);
                            }));
                        })
                        .catch(function () { })
                        .finally(reload);
                } else {
                    reload();
                }
            }

            function promptManualUpdate() {
                const warning = "La mise √† jour effacera les donn√©es locales (cache, cookies, pr√©f√©rences). Continuer ?";
                if (!confirm(warning)) return;
                closeInfoPopup();
                clearAppCacheAndReload();
            }

            function focusHighlight(selector) {
                if (!tourHighlight || !tourOverlay || !selector) {
                    tourHighlight?.style.setProperty("display", "none");
                    tourOverlay?.classList.remove("has-highlight");
                    return;
                }
                const target = document.querySelector(selector);
                if (!target) {
                    tourHighlight.style.display = "none";
                    tourOverlay.classList.remove("has-highlight");
                    return;
                }
                const rect = target.getBoundingClientRect();
                tourHighlight.style.display = "block";
                tourHighlight.style.top = `${rect.top - 8 + window.scrollY}px`;
                tourHighlight.style.left = `${rect.left - 8 + window.scrollX}px`;
                tourHighlight.style.width = `${rect.width + 16}px`;
                tourHighlight.style.height = `${rect.height + 16}px`;
                tourOverlay.classList.add("has-highlight");
            }

            function renderTourStep(index) {
                if (!tourOverlay) return;
                const step = tourSteps[index];
                if (!step) return;
                currentTourIndex = index;
                tourOverlay.classList.add("open");
                tourStepCounter.textContent = `${index + 1}/${tourSteps.length}`;
                tourStepTitle.textContent = step.title;
                tourStepDescription.textContent = step.description;
                focusHighlight(step.selector);
                tourPrevBtn.disabled = index === 0;
                tourNextBtn.textContent = index === tourSteps.length - 1 ? "Terminer" : "Suivant";
            }

            function closeTour() {
                if (!tourOverlay) return;
                tourOverlay.classList.remove("open");
                focusHighlight(null);
            }

            function startTour() {
                renderTourStep(0);
            }

            async function copyCurrentShareLinkToClipboard() {
                if (!currentShareToken) return false;
                const link = buildShareUrl(currentShareToken);
                if (!link) return false;
                try {
                    await copyTextToClipboard(link);
                    setStatus("Lien priv√© copi√© ‚úîÔ∏è");
                    return true;
                } catch (err) {
                    console.error("Copie du lien priv√© impossible", err);
                    setStatus("Impossible de copier le lien priv√©");
                    return false;
                }
            }

            async function handleShareCreateClick() {
                if (!shareWorkerAvailable) {
                    setShareStatus(SHARE_WORKER_UNAVAILABLE_MESSAGE, "error");
                    updateShareMenuUI();
                    return;
                }
                if (shareRequestInProgress) return;
                shareRequestInProgress = true;
                updateShareMenuUI();
                try {
                    const token = createShareToken();
                    const payload = await buildSharePayload();
                    const updatedAt = await saveSharePayload(token, payload);
                    currentShareToken = token;
                    shareLoadedFromRemote = true;
                    shareLastUpdatedAt = updatedAt;
                    updateUrlWithShareToken(token);
                    setShareStatus(formatRelativeTime(updatedAt));
                    updateShareMenuUI();
                    persistDrawShareRecord(token, updatedAt);
                    await copyCurrentShareLinkToClipboard();
                } catch (err) {
                    console.error("Erreur lors de la cr√©ation du lien partag√© :", err);
                    setShareStatus("Impossible de cr√©er le lien partag√©.", "error");
                } finally {
                    shareRequestInProgress = false;
                    updateShareMenuUI();
                }
            }

            async function handleShareUpdateClick() {
                if (!shareWorkerAvailable) {
                    setShareStatus(SHARE_WORKER_UNAVAILABLE_MESSAGE, "error");
                    updateShareMenuUI();
                    return;
                }
                if (!currentShareToken) {
                    setShareStatus("Pas de lien priv√© √† mettre √† jour.", "error");
                    updateShareMenuUI();
                    return;
                }
                if (shareRequestInProgress) return;
                shareRequestInProgress = true;
                updateShareMenuUI();
                try {
                    const payload = await buildSharePayload();
                    const updatedAt = await saveSharePayload(currentShareToken, payload);
                    shareLoadedFromRemote = true;
                    shareLastUpdatedAt = updatedAt;
                    setShareStatus(formatRelativeTime(updatedAt));
                    updateShareMenuUI();
                    persistDrawShareRecord(currentShareToken, updatedAt);
                    await copyCurrentShareLinkToClipboard();
                } catch (err) {
                    console.error("Erreur lors de la mise √† jour du lien partag√© :", err);
                    setShareStatus("Impossible de mettre √† jour le lien partag√©.", "error");
                } finally {
                    shareRequestInProgress = false;
                    updateShareMenuUI();
                }
            }

            function copyTextToClipboard(text) {
                if (navigator.clipboard && typeof navigator.clipboard.writeText === "function") {
                    return navigator.clipboard.writeText(text);
                }
                return new Promise((resolve, reject) => {
                    const textarea = document.createElement("textarea");
                    textarea.value = text;
                    textarea.setAttribute("readonly", "");
                    textarea.style.position = "absolute";
                    textarea.style.left = "-9999px";
                    document.body.appendChild(textarea);
                    textarea.select();
                    textarea.setSelectionRange(0, textarea.value.length);
                    const success = document.execCommand("copy");
                    document.body.removeChild(textarea);
                    if (success) {
                        resolve();
                    } else {
                        reject(new Error("Fallback copy failed"));
                    }
                });
            }

            function createPage(position) {
                return {
                    id: crypto.randomUUID ? crypto.randomUUID() : `${Date.now()}-${Math.random()}`,
                    label: `Page ${position}`,
                    title: `Page ${position}`,
                    input: "",
                    mermaid: "",
                    drawType: DEFAULT_DRAW_TYPE
                };
            }

            function normalizePage(page, index) {
                const fallback = createPage(index + 1);
                const incomingType = page?.drawType;
                const drawType = DRAW_TYPES.some(option => option.id === incomingType)
                    ? incomingType
                    : DEFAULT_DRAW_TYPE;
                return {
                    id: page?.id || fallback.id,
                    label: page?.label || fallback.label,
                    title: page?.title || page?.label || fallback.title,
                    input: page?.input || "",
                    mermaid: page?.mermaid || "",
                    drawType
                };
            }

            function getDrawTypeOptionById(typeId) {
                return DRAW_TYPES.find(option => option.id === typeId) || DRAW_TYPES[0];
            }

            function getDrawTypePromptValue(typeId) {
                return getDrawTypeOptionById(typeId).promptValue;
            }

            function getActivePage() {
                return state.pages[state.activeIndex];
            }

            function renderTabs() {
                pageTabs.innerHTML = "";
                state.pages.forEach((page, index) => {
                    const btn = document.createElement("button");
                    btn.className = `tab-btn${index === state.activeIndex ? " active" : ""}`;
                    btn.textContent = page.label || `Page ${index + 1}`;
                    btn.title = "Double-clique pour renommer";
                    btn.addEventListener("click", () => {
                        setActivePage(index);
                    });
                    btn.addEventListener("dblclick", () => {
                        const name = prompt("Renommer la page", page.label || "Page");
                        if (name) {
                            page.label = name.trim();
                            renderTabs();
                            saveState();
                        }
                    });
                    pageTabs.appendChild(btn);
                });
            }

            function updateDrawTypeSelector(selectedType) {
                const normalizedType = DRAW_TYPES.some(option => option.id === selectedType)
                    ? selectedType
                    : DEFAULT_DRAW_TYPE;
                if (!drawTypeButtons.length) {
                    return;
                }
                drawTypeButtons.forEach(button => {
                    const isActive = button.dataset.drawType === normalizedType;
                    button.classList.toggle("active", isActive);
                    button.setAttribute("aria-pressed", isActive ? "true" : "false");
                });
                updatePromptPlaceholder(normalizedType);
                updateMermaidPlaceholder(normalizedType);
            }

            function updatePromptPlaceholder(drawType) {
                if (!promptInput) return;
                const normalized = DRAW_TYPES.some(option => option.id === drawType) ? drawType : DEFAULT_DRAW_TYPE;
                promptInput.placeholder = drawTypePlaceholders[normalized] || "D√©cris ton contexte produit, tes utilisateurs, ta probl√©matique...";
            }

            function updateMermaidPlaceholder(drawType) {
                if (!mermaidOutput) return;
                const normalized = DRAW_TYPES.some(option => option.id === drawType) ? drawType : DEFAULT_DRAW_TYPE;
                mermaidOutput.placeholder = mermaidPlaceholders[normalized] || "Le code g√©n√©r√© apparaitra ici";
            }

            function updateActivePageDrawType(typeId) {
                const page = getActivePage();
                if (!page) return;
                const normalizedType = DRAW_TYPES.some(option => option.id === typeId)
                    ? typeId
                    : DEFAULT_DRAW_TYPE;
                if (page.drawType === normalizedType) {
                    updateDrawTypeSelector(normalizedType);
                    return;
                }
                page.drawType = normalizedType;
                updateDrawTypeSelector(normalizedType);
                saveState();
            }

            function setActivePage(index) {
                state.activeIndex = Math.max(0, Math.min(state.pages.length - 1, index));
                renderTabs();
                syncFormWithPage();
                saveState();
            }

            function syncFormWithPage() {
                const page = getActivePage();
                promptInput.value = page?.input || "";
                mermaidOutput.value = page?.mermaid || "";
                if (diagramTitleInput) {
                    diagramTitleInput.value = page?.title || page?.label || `Page ${state.activeIndex + 1}`;
                    diagramTitleInput.readOnly = true;
                }
                updateDrawTypeSelector(page?.drawType || DEFAULT_DRAW_TYPE);
                updatePromptPlaceholder(page?.drawType || DEFAULT_DRAW_TYPE);
                updateMermaidPlaceholder(page?.drawType || DEFAULT_DRAW_TYPE);
                updateExcalidrawScene(page?.mermaid || "");
            }

            function clearGenerateCooldown() {
                if (generateCooldownTimer) {
                    clearInterval(generateCooldownTimer);
                    generateCooldownTimer = null;
                }
                generateCooldownEndTime = 0;
                if (generateBtn) {
                    generateBtn.disabled = false;
                    generateBtn.textContent = generateDefaultLabel;
                }
                if (toggleDrawerBtn) {
                    toggleDrawerBtn.disabled = false;
                    toggleDrawerBtn.textContent = drawerDefaultLabel;
                }
            }

            function startGenerateCooldown(seconds = 30) {
                if (!generateBtn) return;
                clearGenerateCooldown();
                const duration = Math.max(1, seconds);
                generateCooldownEndTime = Date.now() + duration * 1000;
                generateBtn.disabled = true;
                if (toggleDrawerBtn) {
                    toggleDrawerBtn.disabled = true;
                }

                const updateLabel = () => {
                    if (!generateBtn) {
                        clearGenerateCooldown();
                        return;
                    }
                    const remainingMs = generateCooldownEndTime - Date.now();
                    const remainingSeconds = Math.max(0, Math.ceil(remainingMs / 1000));
                    const label = `‚è≥ ${remainingSeconds}s`;
                    generateBtn.textContent = label;
                    if (toggleDrawerBtn) {
                        toggleDrawerBtn.textContent = label;
                    }
                    if (remainingSeconds <= 0) {
                        clearGenerateCooldown();
                        generateBtn.disabled = false;
                        generateBtn.textContent = generateDefaultLabel;
                        if (toggleDrawerBtn) {
                            toggleDrawerBtn.disabled = false;
                            toggleDrawerBtn.textContent = drawerDefaultLabel;
                        }
                    }
                };

                updateLabel();
                generateCooldownTimer = setInterval(updateLabel, 1000);
            }

            async function handleGenerate() {
                const page = getActivePage();
                if (!page) return;
                const inputText = promptInput.value.trim();
                if (!inputText) {
                    setStatus("Ajoute du contexte pour g√©n√©rer ‚úçÔ∏è");
                    promptInput.focus();
                    return;
                }
                startGenerateCooldown(30);
                const drawType = page.drawType || DEFAULT_DRAW_TYPE;
                const drawTypePrompt = getDrawTypePromptValue(drawType);
                const templateBase = state.promptTemplate || DEFAULT_PROMPT_TEMPLATE;
                const template = templateBase
                    .replace(/{{field_input}}/gi, inputText)
                    .replace(/{{draw_type}}/gi, drawTypePrompt);
                const messages = [
                    { role: "system", content: "Tu es un assistant produit." },
                    { role: "user", content: template }
                ];
                setStatus("G√©n√©ration en cours...");
                try {
                    const aiText = await callOpenAI(messages);
                    if (!aiText) {
                        throw new Error("R√©ponse vide");
                    }
                    const mermaidCode = extractMermaidCode(aiText);
                    const extractedTitle = extractDiagramTitle(mermaidCode || aiText);
                    page.input = inputText;
                    page.mermaid = mermaidCode;
                    if (extractedTitle) {
                        page.title = extractedTitle;
                        if (diagramTitleInput) {
                            diagramTitleInput.value = extractedTitle;
                        }
                    }
                    mermaidOutput.value = mermaidCode;
                    updateExcalidrawScene(mermaidCode);
                    saveState();
                    setStatus("Diagramme g√©n√©r√© ‚úîÔ∏è");
                } catch (err) {
                    console.error(err);
                    setStatus(`Erreur: ${err.message || "impr√©vue"}`);
                } finally {
                    clearGenerateCooldown();
                }
            }

            function extractMermaidCode(text) {
                if (!text) return "";
                const fenced = text.match(/```(?:mermaid)?([\s\S]*?)```/i);
                if (fenced && fenced[1]) {
                    return fenced[1].trim();
                }
                return text.trim();
            }

            function extractDiagramTitle(text) {
                if (!text) return "";
                const match = text.match(/^%%\s*Title\s*[:\-]?\s*(.+)$/im);
                return match && match[1] ? match[1].trim() : "";
            }

            function hasCompleteMermaidBlock(text) {
                if (!text) return false;
                return /```(?:mermaid)?[\s\S]*?```/i.test(text);
            }

            let statusTimeoutId = null;

            function setStatus(message) {
                if (!statusToast) return;
                const text = message?.trim() || "";
                if (!text) {
                    statusToast.classList.remove("visible");
                    statusToast.textContent = "";
                    return;
                }
                statusToast.textContent = text;
                statusToast.classList.add("visible");
                if (statusTimeoutId) {
                    clearTimeout(statusTimeoutId);
                }
                statusTimeoutId = setTimeout(() => {
                    statusToast.classList.remove("visible");
                }, 3500);
            }

            function zoomExcalidrawByFactor(factor) {
                try {
                    const api = getExcalidrawBridge()?.getApi();
                    if (!api) return;
                    const appState = api.getAppState();
                    const currentZoom = appState?.zoom?.value || 1;
                    const nextZoom = Math.min(4, Math.max(0.1, currentZoom * factor));
                    api.setAppState({ zoom: { value: nextZoom } });
                } catch (err) {
                    console.warn("Zoom Excalidraw impossible", err);
                }
            }

            async function callOpenAI(messages) {
                if (!window.GoToolkitOpenAI) {
                    throw new Error("Client OpenAI indisponible");
                }
                const apiKey = (state.apiKey || "").trim();
                const proxyEndpoint = "https://openai.gotoolkit.workers.dev/v1/responses";
                const directEndpoint = "https://api.openai.com/v1/responses";
                const payload = {
                    model: "gpt-5-nano",
                    messages,
                    reasoning: { effort: state.reasoningEffort || "low" },
                    temperature: 1,
                    stream: true
                };
                const useProxy = !apiKey;
                try {
                    return await GoToolkitOpenAI.chatCompletion({
                        endpoint: useProxy ? proxyEndpoint : directEndpoint,
                        apiKey: useProxy ? "" : apiKey,
                        payload,
                        stopCondition: hasCompleteMermaidBlock
                    });
                } catch (err) {
                    if (!useProxy) {
                        console.warn("Direct OpenAI call failed, retrying via proxy", err);
                        return GoToolkitOpenAI.chatCompletion({
                            endpoint: proxyEndpoint,
                            apiKey: "",
                            payload,
                            stopCondition: hasCompleteMermaidBlock
                        });
                    }
                    throw err;
                }
            }

            function openModal() {
                aiModal.classList.add("open");
                apiKeyField.value = state.apiKey || "";
                promptTemplateField.value = state.promptTemplate || DEFAULT_PROMPT_TEMPLATE;
                if (reasoningEffortSelect) {
                    reasoningEffortSelect.value = state.reasoningEffort || "low";
                }
            }

            function closeModal() {
                aiModal.classList.remove("open");
            }

            function resetPrompt() {
                promptTemplateField.value = DEFAULT_PROMPT_TEMPLATE;
                state.promptTemplate = DEFAULT_PROMPT_TEMPLATE;
                saveState();
            }

            const EXCALIDRAW_STYLESHEET_URL = "https://unpkg.com/@excalidraw/excalidraw@0.17.6/dist/excalidraw-assets/index.css";

            function ensureExcalidrawStyles() {
                if (document.querySelector('[data-excalidraw-css="main"]')) {
                    return;
                }
                const link = document.createElement("link");
                link.rel = "stylesheet";
                link.href = EXCALIDRAW_STYLESHEET_URL;
                link.dataset.excalidrawCss = "main";
                document.head.appendChild(link);
            }

            function ensureExcalidrawBundleScript() {
                if (window.GoToolkitExcalidraw) {
                    return;
                }
                let script = document.querySelector('script[data-excalidraw-bundle]');
                if (!script) {
                    script = document.createElement("script");
                    script.src = EXCALIDRAW_BUNDLE_SRC;
                    script.dataset.excalidrawBundle = "true";
                    document.body.appendChild(script);
                }
            }

            function waitForBridgeBundle() {
                if (window.GoToolkitExcalidraw) {
                    return Promise.resolve(window.GoToolkitExcalidraw);
                }
                ensureExcalidrawBundleScript();
                if (!bridgeDetectionPromise) {
                    bridgeDetectionPromise = new Promise((resolve, reject) => {
                        const deadline = Date.now() + EXCALIDRAW_BRIDGE_MAX_WAIT_MS;
                        const poll = () => {
                            const bridge = window.GoToolkitExcalidraw;
                            if (bridge) {
                                resolve(bridge);
                                return;
                            }
                            if (Date.now() > deadline) {
                                bridgeDetectionPromise = null;
                                reject(new Error("Bundle Excalidraw non charg√©"));
                                return;
                            }
                            setTimeout(poll, EXCALIDRAW_BRIDGE_POLL_INTERVAL_MS);
                        };
                        poll();
                    });
                }
                return bridgeDetectionPromise;
            }

            let excalidrawReadyPromise = null;

            function getExcalidrawBridge() {
                return window.GoToolkitExcalidraw || null;
            }

            function ensureExcalidrawReady() {
                ensureExcalidrawStyles();
                if (excalidrawReadyPromise) {
                    return excalidrawReadyPromise;
                }
                const hostEl = document.getElementById("excalidrawHost");
                if (!hostEl) {
                    return Promise.reject(new Error("H√¥te Excalidraw introuvable"));
                }
                excalidrawReadyPromise = waitForBridgeBundle()
                    .then(bridge => bridge.initialize(hostEl).then(() => bridge))
                    .catch(error => {
                        excalidrawReadyPromise = null;
                        throw error;
                    });
                return excalidrawReadyPromise;
            }

            function initializeExcalidraw() {
                ensureExcalidrawReady()
                    .then(() => {
                        console.info("Excalidraw initialis√© via bundle");
                    })
                    .catch(err => {
                        console.error("Impossible d'initialiser Excalidraw", err);
                        setStatus("Erreur Excalidraw : consulte la console");
                    });
            }

            async function getExcalidrawApi() {
                const bridge = await ensureExcalidrawReady();
                const api = bridge?.getApi();
                if (!api) {
                    throw new Error("API Excalidraw indisponible");
                }
                return api;
            }

            async function tryMermaidConversion(code) {
                const trimmed = (code || "").trim();
                if (!trimmed) {
                    return null;
                }
                try {
                    const bridge = await ensureExcalidrawReady();
                    const conversion = await bridge.convertMermaid(trimmed);
                    if (conversion?.elements?.length) {
                        return conversion;
                    }
                    return null;
                } catch (error) {
                    console.warn("Conversion Mermaid -> Excalidraw impossible", error);
                    return null;
                }
            }
            async function buildScenePayload(code) {
                const trimmed = (code || "").trim();
                if (!trimmed) {
                    return { elements: [] };
                }
                const converted = await tryMermaidConversion(trimmed);
                if (converted?.elements?.length) {
                    const hasImage = converted.elements.some(element => element?.type === "image");
                    const imageOnlyScene = converted.elements.every(element => element?.type === "image");
                    // If mermaid conversion produced any image, skip it and fallback to legacy vectorization for editability.
                    if (!hasImage && !imageOnlyScene) {
                        return converted;
                    }
                }
                return { elements: buildLegacyExcalidrawElements(trimmed), files: null };
            }

            function createBaseElement(type, overrides = {}) {
                const timestamp = Date.now();
                return {
                    id: `${type}-${timestamp}-${Math.floor(Math.random() * 1000000)}`,
                    type,
                    x: 0,
                    y: 0,
                    width: overrides.width ?? 0,
                    height: overrides.height ?? 0,
                    angle: 0,
                    strokeColor: "#1c2a55",
                    backgroundColor: overrides.backgroundColor ?? "#ffffff",
                    fillStyle: overrides.fillStyle ?? "solid",
                    strokeWidth: overrides.strokeWidth ?? 2,
                    strokeStyle: "solid",
                    roundness: overrides.roundness ?? null,
                    roughness: 0,
                    opacity: 100,
                    groupIds: [],
                    boundElements: [],
                    updated: timestamp,
                    seed: Math.floor(Math.random() * 1000000),
                    version: 1,
                    versionNonce: Math.floor(Math.random() * 1000000),
                    isDeleted: false,
                    locked: false,
                    ...overrides
                };
            }

            function wrapTextContent(value, maxCharsPerLine = 24) {
                const text = (value ?? "").toString().trim();
                if (!text) return "";
                const segments = text.split(/\n+/);
                const lines = [];
                segments.forEach((segment, segmentIndex) => {
                    const words = segment.trim().split(/\s+/).filter(Boolean);
                    if (!words.length) {
                        if (segmentIndex < segments.length - 1) {
                            lines.push("");
                        }
                        return;
                    }
                    let currentLine = "";
                    words.forEach(word => {
                        const candidate = currentLine ? `${currentLine} ${word}` : word;
                        if (candidate.length > maxCharsPerLine && currentLine) {
                            lines.push(currentLine);
                            currentLine = word;
                        } else {
                            currentLine = candidate;
                        }
                    });
                    if (currentLine) {
                        lines.push(currentLine);
                    }
                    if (segmentIndex < segments.length - 1) {
                        lines.push("");
                    }
                });
                const joined = lines.join("\n").replace(/^(\n+)/, "").replace(/(\n+)$/, "");
                return joined || text;
            }

            function countTextLines(text) {
                if (!text) {
                    return 1;
                }
                const segments = text.split(/\n/);
                return segments.length || 1;
            }

            function createTextElement(text, x, y, options = {}) {
                const fontSize = options.fontSize || 18;
                const width = options.width || Math.max(100, (text?.length || 0) * (fontSize * 0.6));
                const lineHeight = options.lineHeight || 1.2;
                const textLines = options.textLines || countTextLines(text);
                const height = options.height || fontSize * lineHeight * textLines;
                const cleanOptions = { ...options };
                delete cleanOptions.textLines;
                delete cleanOptions.lineHeight;
                return createBaseElement("text", {
                    x,
                    y,
                    width,
                    height,
                    strokeColor: options.strokeColor || "#1c2a55",
                    backgroundColor: "transparent",
                    text,
                    originalText: text,
                    fontSize,
                    fontFamily: 1,
                    textAlign: options.textAlign || "left",
                    verticalAlign: options.verticalAlign || "top",
                    baseline: fontSize,
                    lineHeight,
                    containerId: null,
                    ...cleanOptions
                });
            }

            function createRectangleElement(x, y, width, height, options = {}) {
                return createBaseElement("rectangle", {
                    x,
                    y,
                    width,
                    height,
                    backgroundColor: options.backgroundColor || "#ffffff",
                    strokeColor: options.strokeColor || "#1c2a55",
                    ...options
                });
            }

            function createLineElement(x, y, dx, dy, options = {}) {
                return createBaseElement("line", {
                    x,
                    y,
                    width: dx,
                    height: dy,
                    points: [
                        [0, 0],
                        [dx, dy]
                    ],
                    backgroundColor: "transparent",
                    strokeColor: options.strokeColor || "#1c2a55",
                    strokeStyle: options.strokeStyle || "dashed",
                    ...options
                });
            }

            function createArrowElement(startX, startY, endX, endY, options = {}) {
                return createBaseElement("arrow", {
                    x: startX,
                    y: startY,
                    width: endX - startX,
                    height: endY - startY,
                    points: [
                        [0, 0],
                        [endX - startX, endY - startY]
                    ],
                    backgroundColor: "transparent",
                    strokeColor: options.strokeColor || "#1c2a55",
                    startArrowhead: null,
                    endArrowhead: "arrow",
                    ...options
                });
            }

            function computeCompactionFactor(count, start = 4, end = 16) {
                if (count <= start) {
                    return 0;
                }
                if (count >= end) {
                    return 1;
                }
                return (count - start) / (end - start);
            }

            function compactValue(count, minValue, maxValue, options = {}) {
                if (maxValue <= minValue) {
                    return minValue;
                }
                const factor = computeCompactionFactor(count, options.start ?? 4, options.end ?? 16);
                return maxValue - (maxValue - minValue) * factor;
            }

            function translateMermaidToElements(code) {
                const trimmed = (code || "").trim();
                if (!trimmed) {
                    return null;
                }
                const lines = trimmed.split(/\n+/).map(line => line.trim()).filter(Boolean);
                if (!lines.length) {
                    return null;
                }
                const header = lines[0].toLowerCase();
                if (header.startsWith("flowchart") || header.startsWith("graph")) {
                    return buildFlowchartElements(lines);
                }
                if (header.startsWith("sequencediagram")) {
                    return buildSequenceDiagramElements(lines);
                }
                if (header.startsWith("classdiagram")) {
                    return buildClassDiagramElements(lines);
                }
                return null;
            }

            function buildFlowchartElements(lines) {
                const elements = [];
                const header = lines.shift();
                const orientationMatch = header.match(/(LR|RL|TD|BT)/i);
                const orientation = orientationMatch ? orientationMatch[1].toUpperCase() : "TD";
                const horizontal = orientation === "LR" || orientation === "RL";
                const nodeMap = new Map();
                const edges = [];

                const registerNode = (id, label) => {
                    if (!nodeMap.has(id)) {
                        nodeMap.set(id, {
                            id,
                            label: label || id
                        });
                    } else if (label) {
                        nodeMap.get(id).label = label;
                    }
                };

                lines.forEach(line => {
                    if (!line) return;
                    const nodeMatch = line.match(/^([A-Za-z0-9_]+)\s*(?:\(|\[|\{)\s*(.+?)\s*(?:\)|\]|\})/);
                    if (nodeMatch) {
                        registerNode(nodeMatch[1], nodeMatch[2]);
                    }
                    const edgeMatch = line.match(/^([A-Za-z0-9_]+)\s*[-.]{1,4}[>]{1,2}\s*([A-Za-z0-9_]+)(?:\s*:?\s*(.+))?/);
                    if (edgeMatch) {
                        registerNode(edgeMatch[1]);
                        registerNode(edgeMatch[2]);
                        edges.push({
                            from: edgeMatch[1],
                            to: edgeMatch[2],
                            label: edgeMatch[3]?.trim()
                        });
                    }
                });

                if (!nodeMap.size) {
                    return null;
                }

                const nodeIds = Array.from(nodeMap.keys());
                const nodeCount = nodeIds.length;
                const nodeWidth = compactValue(nodeCount, 120, 170);
                const spacingX = nodeWidth + compactValue(nodeCount, 30, 80);
                const spacingY = compactValue(nodeCount, 100, 150);
                const baseX = 40;
                const baseY = 40;
                const minBoxHeight = compactValue(nodeCount, 60, 80);
                const columns = (() => {
                    if (!nodeCount) {
                        return 1;
                    }
                    if (horizontal) {
                        return Math.max(2, Math.min(nodeCount, Math.ceil(Math.sqrt(nodeCount * 1.4))));
                    }
                    if (nodeCount <= 4) {
                        return nodeCount;
                    }
                    if (nodeCount <= 9) {
                        return 3;
                    }
                    return Math.min(nodeCount, 4);
                })();

                nodeIds.forEach((id, idx) => {
                    const col = idx % columns;
                    const row = Math.floor(idx / columns);
                    const x = baseX + col * spacingX;
                    const y = baseY + row * spacingY;
                    const rawLabel = (nodeMap.get(id)?.label || id).trim() || id;
                    const wrappedLabel = wrapTextContent(rawLabel, 24) || rawLabel;
                    const lineCount = countTextLines(wrappedLabel);
                    const fontSize = 16;
                    const textHeight = lineCount * fontSize * 1.3;
                    const nodeHeight = Math.max(minBoxHeight, textHeight + 24);
                    const rect = createRectangleElement(x, y, nodeWidth, nodeHeight);
                    const textY = y + (nodeHeight - textHeight) / 2;
                    const text = createTextElement(wrappedLabel, x + 10, textY, {
                        width: nodeWidth - 20,
                        fontSize,
                        textAlign: "center",
                        lineHeight: 1.3,
                        textLines: lineCount,
                        height: textHeight
                    });
                    nodeMap.get(id).x = x;
                    nodeMap.get(id).y = y;
                    nodeMap.get(id).width = nodeWidth;
                    nodeMap.get(id).height = nodeHeight;
                    elements.push(rect, text);
                });

                edges.forEach(edge => {
                    const source = nodeMap.get(edge.from);
                    const target = nodeMap.get(edge.to);
                    if (!source || !target) return;
                    const startX = source.x + source.width / 2;
                    const startY = source.y + source.height / 2;
                    const endX = target.x + target.width / 2;
                    const endY = target.y + target.height / 2;
                    const arrow = createArrowElement(startX, startY, endX, endY);
                    elements.push(arrow);
                    if (edge.label) {
                        const labelX = (startX + endX) / 2 - 40;
                        const labelY = (startY + endY) / 2 - 20;
                        elements.push(createTextElement(edge.label, labelX, labelY, {
                            fontSize: 14,
                            width: 80,
                            textAlign: "center"
                        }));
                    }
                });

                return elements;
            }

            function buildSequenceDiagramElements(lines) {
                const elements = [];
                lines.shift();
                const participants = [];
                const participantLabels = new Map();
                const messages = [];

                const registerParticipant = (id, label) => {
                    if (!participantLabels.has(id)) {
                        participantLabels.set(id, label || id);
                        participants.push(id);
                    }
                };

                lines.forEach(line => {
                    if (!line) return;
                    const participantMatch = line.match(/^participant\s+([A-Za-z0-9_]+)(?:\s+as\s+(.+))?/i);
                    if (participantMatch) {
                        registerParticipant(participantMatch[1], participantMatch[2]?.trim());
                        return;
                    }
                    const messageMatch = line.match(/^([A-Za-z0-9_]+)\s*([-.]+[>]{1,2})\s*([A-Za-z0-9_]+)\s*:?\s*(.*)?/);
                    if (messageMatch) {
                        registerParticipant(messageMatch[1]);
                        registerParticipant(messageMatch[3]);
                        messages.push({
                            from: messageMatch[1],
                            to: messageMatch[3],
                            text: messageMatch[4]?.trim() || ""
                        });
                    }
                });

                if (!participants.length) {
                    return null;
                }

                const participantCount = participants.length;
                const messageCount = Math.max(1, messages.length);
                const spacingX = compactValue(participantCount, 120, 190, { start: 3, end: 12 });
                const baseX = 60;
                const topY = 40;
                const messageSpacing = compactValue(messageCount, 55, 80, { start: 2, end: 12 });
                const lifelineHeight = 100 + messageCount * messageSpacing;
                const boxWidth = compactValue(participantCount, 110, 150, { start: 3, end: 12 });
                const headerBaseHeight = compactValue(participantCount, 36, 48, { start: 3, end: 12 });
                const positions = new Map();

                participants.forEach((id, idx) => {
                    const x = baseX + idx * spacingX;
                    positions.set(id, x);
                    const boxX = x - boxWidth / 2;
                    const label = participantLabels.get(id) || id;
                    const wrappedLabel = wrapTextContent(label, 18) || label;
                    const lineCount = countTextLines(wrappedLabel);
                    const fontSize = 15;
                    const textHeight = lineCount * fontSize * 1.3;
                    const headerHeight = Math.max(headerBaseHeight, textHeight + 16);
                    const rect = createRectangleElement(boxX, topY, boxWidth, headerHeight, {
                        backgroundColor: "#ffffff"
                    });
                    const textY = topY + (headerHeight - textHeight) / 2;
                    const text = createTextElement(wrappedLabel, boxX + 10, textY, {
                        width: boxWidth - 20,
                        fontSize,
                        textAlign: "center",
                        lineHeight: 1.3,
                        textLines: lineCount,
                        height: textHeight
                    });
                    elements.push(rect, text);
                    const adjustedLifelineHeight = Math.max(110, lifelineHeight - Math.max(0, headerHeight - headerBaseHeight));
                    const lifeline = createLineElement(x, topY + headerHeight, 0, adjustedLifelineHeight, {
                        strokeWidth: 1.5,
                        strokeStyle: "dashed"
                    });
                    elements.push(lifeline);
                });

                messages.forEach((message, idx) => {
                    const startX = positions.get(message.from);
                    const endX = positions.get(message.to);
                    if (startX == null || endX == null) return;
                    const y = topY + headerBaseHeight + 20 + idx * messageSpacing;
                    const arrow = createArrowElement(startX, y, endX, y, {
                        strokeWidth: 1.5
                    });
                    elements.push(arrow);
                    if (message.text) {
                        const horizontalGap = Math.abs(endX - startX);
                        const labelWidth = Math.max(90, horizontalGap - 40);
                        const labelX = Math.min(startX, endX) + (horizontalGap - labelWidth) / 2;
                        elements.push(createTextElement(message.text, labelX, y - 22, {
                            width: labelWidth,
                            fontSize: 13,
                            textAlign: "center"
                        }));
                    }
                });

                return elements;
            }

            function buildClassDiagramElements(lines) {
                const elements = [];
                lines.shift();
                const classes = [];
                const relations = [];

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    if (!line) continue;
                    if (/^class\s+/i.test(line)) {
                        const match = line.match(/^class\s+([A-Za-z0-9_]+)(?:\s+as\s+(.+?))?(?:\s*\{)?/i);
                        if (!match) continue;
                        const id = match[1];
                        const label = match[2]?.trim() || id;
                        const members = [];
                        if (line.includes("{") && !line.includes("}")) {
                            i++;
                            while (i < lines.length && !lines[i].includes("}")) {
                                const member = lines[i].replace(/[{}]/g, "").trim();
                                if (member) members.push(member);
                                i++;
                            }
                        } else if (line.includes("{") && line.includes("}")) {
                            const inside = line.split("{")[1].split("}")[0];
                            inside.split(/;|\n/).forEach(entry => {
                                const trimmed = entry.trim();
                                if (trimmed) members.push(trimmed);
                            });
                        }
                        classes.push({ id, label, members });
                        continue;
                    }
                    const relationMatch = line.match(/^([A-Za-z0-9_]+)\s+([<:\.o*\-|]+)\s+([A-Za-z0-9_]+)/);
                    if (relationMatch) {
                        relations.push({
                            from: relationMatch[1],
                            to: relationMatch[3],
                            marker: relationMatch[2]
                        });
                    }
                }

                if (!classes.length) {
                    return null;
                }

                const classCount = classes.length;
                const columns = Math.max(1, Math.min(classCount, Math.round(Math.sqrt(classCount * 1.3)) || 1));
                const spacingX = compactValue(classCount, 150, 240, { start: 3, end: 12 });
                const spacingY = compactValue(classCount, 140, 220, { start: 3, end: 12 });
                const baseX = 40;
                const baseY = 40;
                const boxWidth = compactValue(classCount, 160, 210, { start: 3, end: 12 });
                const memberLineHeight = 18;
                const classPositions = new Map();

                classes.forEach((klass, idx) => {
                    const col = idx % columns;
                    const row = Math.floor(idx / columns);
                    const width = boxWidth;
                    const memberLines = Math.max(0, klass.members.length);
                    const wrappedLabel = wrapTextContent(klass.label, 20) || klass.label;
                    const titleLineCount = countTextLines(wrappedLabel);
                    const titleFontSize = 18;
                    const titleTextHeight = titleLineCount * titleFontSize * 1.3;
                    const titleHeight = Math.max(compactValue(classCount, 36, 52, { start: 3, end: 12 }), titleTextHeight + 12);
                    const bodyHeight = memberLines ? memberLines * memberLineHeight + 16 : 20;
                    const height = titleHeight + bodyHeight;
                    const x = baseX + col * spacingX;
                    const y = baseY + row * spacingY;
                    const rect = createRectangleElement(x, y, width, height, {
                        backgroundColor: "#fafbff"
                    });
                    const titleY = y + (titleHeight - titleTextHeight) / 2;
                    const title = createTextElement(wrappedLabel, x + 10, titleY, {
                        width: width - 20,
                        fontSize: titleFontSize,
                        textAlign: "center",
                        lineHeight: 1.3,
                        textLines: titleLineCount,
                        height: titleTextHeight
                    });
                    const memberText = klass.members.join("\n");
                    if (memberText) {
                        elements.push(
                            rect,
                            title,
                            createTextElement(memberText, x + 10, y + titleHeight + 10, {
                                width: width - 20,
                                fontSize: 13,
                                lineHeight: 1.2,
                                textLines: Math.max(1, memberLines)
                            })
                        );
                    } else {
                        elements.push(rect, title);
                    }
                    const position = {
                        x: x + width / 2,
                        y: y + height / 2,
                        boxX: x,
                        boxY: y,
                        width,
                        height
                    };
                    classPositions.set(klass.id, position);
                    classPositions.set(klass.label, position);
                });

                relations.forEach(rel => {
                    const from = classPositions.get(rel.from);
                    const to = classPositions.get(rel.to);
                    if (!from || !to) return;
                    const arrow = createArrowElement(from.x, from.y, to.x, to.y, {
                        strokeWidth: rel.marker.includes("..") ? 1 : 2,
                        strokeStyle: rel.marker.includes("..") ? "dashed" : "solid"
                    });
                    elements.push(arrow);
                });

                return elements;
            }

            function buildFallbackTextElements(code) {
                const lines = code
                    .split("\n")
                    .map(line => line.trim())
                    .filter(Boolean);
                if (!lines.length) {
                    lines.push("Diagramme vide");
                }
                const baseY = 40;
                const gap = 70;
                return lines.map((line, idx) => createTextElement(line, 40, baseY + idx * gap, {
                    fontSize: 24
                }));
            }

            function buildLegacyExcalidrawElements(code) {
                const translated = translateMermaidToElements(code);
                if (translated && translated.length) {
                    return translated;
                }
                return buildFallbackTextElements(code);
            }

            function applySceneUpdate(api, scenePayload) {
                if (api && typeof api.updateScene === "function") {
                    api.updateScene(scenePayload);
                    return true;
                }
                if (api && typeof api.resetScene === "function") {
                    api.resetScene({ ...scenePayload, commitToHistory: false });
                    return true;
                }
                if (api && typeof api.replaceAllElements === "function") {
                    api.replaceAllElements(scenePayload.elements);
                    if (typeof api.setAppState === "function") {
                        api.setAppState(scenePayload.appState);
                    }
                    return true;
                }
                return false;
            }

            async function updateExcalidrawScene(code) {
                pendingSceneCode = code || "";
                sceneBuildRequestId += 1;
                const requestId = sceneBuildRequestId;
                try {
                    const api = await getExcalidrawApi();
                    const sceneData = await buildScenePayload(pendingSceneCode);
                    if (requestId !== sceneBuildRequestId) {
                        return;
                    }
                    const appState = {
                        ...api.getAppState(),
                        viewBackgroundColor: "#fdfdfd",
                        gridModeEnabled: false,
                        isLoading: false
                    };
                    const scenePayload = {
                        elements: sceneData.elements || [],
                        appState
                    };
                    if (sceneData.files) {
                        scenePayload.files = sceneData.files;
                    }
                    if (!applySceneUpdate(api, scenePayload)) {
                        console.warn("Aucune m√©thode disponible pour mettre √† jour Excalidraw", {
                            hasUpdateScene: typeof api?.updateScene === "function",
                            hasResetScene: typeof api?.resetScene === "function",
                            hasReplaceAll: typeof api?.replaceAllElements === "function"
                        });
                    }
                    if (sceneData.files && typeof api.addFiles === "function") {
                        api.addFiles(sceneData.files);
                    }
                } catch (error) {
                    console.error("Impossible de mettre √† jour Excalidraw", error);
                    if (requestId !== sceneBuildRequestId) {
                        return;
                    }
                    const api = getExcalidrawBridge()?.getApi();
                    if (!api) {
                        return;
                    }
                    const fallbackElements = buildFallbackTextElements(pendingSceneCode || "Diagramme indisponible");
                    const appState = {
                        ...api.getAppState(),
                        viewBackgroundColor: "#fdfdfd",
                        gridModeEnabled: false,
                        isLoading: false
                    };
                    applySceneUpdate(api, { elements: fallbackElements, appState });
                }
            }

            function bindEvents() {
                generateBtn.addEventListener("click", handleGenerate);
                promptInput.addEventListener("input", () => {
                    const page = getActivePage();
                    if (page) {
                        page.input = promptInput.value;
                        saveState();
                    }
                });
                diagramTitleInput?.addEventListener("dblclick", () => {
                    diagramTitleInput.readOnly = false;
                    diagramTitleInput.focus();
                    diagramTitleInput.select();
                });
                diagramTitleInput?.addEventListener("blur", () => {
                    diagramTitleInput.readOnly = true;
                });
                diagramTitleInput?.addEventListener("input", () => {
                    const page = getActivePage();
                    if (!page) return;
                    page.title = diagramTitleInput.value;
                    saveState();
                });
                mermaidOutput.addEventListener("input", () => {
                    const page = getActivePage();
                    const value = mermaidOutput.value;
                    if (page) {
                        page.mermaid = value;
                        saveState();
                    }
                    updateExcalidrawScene(value);
                });
                document.addEventListener("wheel", (event) => {
                    if (!event.ctrlKey) return;
                    event.preventDefault();
                    const factor = event.deltaY < 0 ? 0.85 : 1.2;
                    zoomExcalidrawByFactor(factor);
                }, { passive: false });
                drawTypeButtons.forEach(button => {
                    button.addEventListener("click", () => {
                        const selectedType = button.dataset.drawType;
                        if (!selectedType) {
                            return;
                        }
                        updateActivePageDrawType(selectedType);
                    });
                });
                addPageBtn.addEventListener("click", () => {
                    const newPage = createPage(state.pages.length + 1);
                    state.pages.push(newPage);
                    setActivePage(state.pages.length - 1);
                    saveState();
                });
                deletePageBtn.addEventListener("click", () => {
                    if (state.pages.length <= 1) {
                        setStatus("Au moins une page est requise");
                        return;
                    }
                    state.pages.splice(state.activeIndex, 1);
                    setActivePage(Math.max(0, state.activeIndex - 1));
                    saveState();
                });
                refreshExcalidrawBtn.addEventListener("click", () => {
                    updateExcalidrawScene(mermaidOutput.value);
                    setStatus("Projection mise √† jour ‚úîÔ∏è");
                });
                infoButton?.addEventListener("click", event => {
                    event.stopPropagation();
                    closeShareMenu();
                    infoPopup?.classList.toggle("open");
                });
                updateAppBtn?.addEventListener("click", event => {
                    event.stopPropagation();
                    promptManualUpdate();
                });
                tourReplayBtn?.addEventListener("click", event => {
                    event.stopPropagation();
                    infoPopup?.classList.remove("open");
                    startTour();
                });
                document.addEventListener("click", event => {
                    if (!infoPopup?.contains(event.target) && event.target !== infoButton) {
                        closeInfoPopup();
                    }
                });
                tourPrevBtn?.addEventListener("click", () => {
                    const prev = Math.max(0, currentTourIndex - 1);
                    renderTourStep(prev);
                });
                tourNextBtn?.addEventListener("click", () => {
                    if (currentTourIndex >= tourSteps.length - 1) {
                        closeTour();
                        return;
                    }
                    renderTourStep(currentTourIndex + 1);
                });
                tourCloseBtn?.addEventListener("click", closeTour);
                tourSkipBtn?.addEventListener("click", closeTour);
                aiSettingsBtn.addEventListener("click", openModal);
                closeAiModalBtn.addEventListener("click", closeModal);
                aiModal.addEventListener("click", event => {
                    if (event.target === aiModal) {
                        closeModal();
                    }
                });
                resetPromptBtn.addEventListener("click", resetPrompt);
                apiKeyField?.addEventListener("input", () => {
                    state.apiKey = apiKeyField.value.trim();
                    saveState();
                });
                promptTemplateField?.addEventListener("input", () => {
                    state.promptTemplate = promptTemplateField.value.trim() || DEFAULT_PROMPT_TEMPLATE;
                    saveState();
                });
                reasoningEffortSelect?.addEventListener("change", () => {
                    state.reasoningEffort = reasoningEffortSelect.value || "low";
                    saveState();
                });
                window.addEventListener("keydown", event => {
                    const isEscape = event.key === "Escape";
                    if (isEscape && aiModal.classList.contains("open")) {
                        closeModal();
                    }
                    if (isEscape && isDrawerOpen && drawerMediaQuery.matches) {
                        closeDrawer();
                    }
                });

                toggleDrawerBtn?.addEventListener("click", () => {
                    toggleDrawer();
                });

                drawerOverlay?.addEventListener("click", () => {
                    closeDrawer();
                });

                drawerMediaQuery.addEventListener("change", handleDrawerBreakpointChange);

                if (shareBtn && shareMenu) {
                    shareBtn.addEventListener("click", event => {
                        event.stopPropagation();
                        shareMenu.classList.toggle("open");
                        updateShareMenuUI();
                    });
                    shareMenu.addEventListener("click", event => {
                        event.stopPropagation();
                    });
                }
                shareLinkField?.addEventListener("focus", () => {
                    shareLinkField.select();
                });
                shareLinkField?.addEventListener("click", () => {
                    shareLinkField.select();
                });
                shareCreateBtn?.addEventListener("click", handleShareCreateClick);
                shareUpdateBtn?.addEventListener("click", handleShareUpdateClick);
                document.addEventListener("click", event => {
                    if (!shareMenu?.contains(event.target) && event.target !== shareBtn) {
                        closeShareMenu();
                    }
                });

                if (navSwitcherBtn && navSwitcherMenu) {
                    navSwitcherBtn.addEventListener("click", event => {
                        event.stopPropagation();
                        navSwitcherMenu.classList.toggle("open");
                    });
                    navSwitcherMenu.addEventListener("click", event => {
                        event.stopPropagation();
                    });
                    document.addEventListener("click", event => {
                        if (!navSwitcherMenu.contains(event.target) && event.target !== navSwitcherBtn) {
                            navSwitcherMenu.classList.remove("open");
                        }
                    });
                }

                updateShareMenuUI();
            }

            async function initializeAppState() {
                initShareWorkerService();
                const sharedLoaded = await tryLoadSharedStateFromUrl();
                if (!sharedLoaded) {
                    loadState();
                }
                renderTabs();
                syncFormWithPage();
                bindEvents();
                handleDrawerBreakpointChange(drawerMediaQuery);
                initializeExcalidraw();
                if (sharedLoaded) {
                    saveState();
                }
            }

            initializeAppState();
        })();
    </script>
</body>

</html>