<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8" />
    <title>Petit Robert Downrey Jr | Go-Toolkit</title>
    <link rel="stylesheet" href="styles/app-shell.css">
    <style>
        :root {
            --app-bg: #f3f4f6;
            --app-border: #cdd4ed;
            --app-border-strong: #cdd4ed;
            --app-primary-strong: #1f2a56;
            --app-text: #101428;
            --slide-bg: #ffffff;
        }

        * {
            box-sizing: border-box;
        }

        .template-actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            flex-wrap: wrap;
        }

        .menu-trigger {
            position: relative;
            display: inline-flex;
            align-items: stretch;
            gap: 4px;
        }

        .context-menu {
            position: absolute;
            top: calc(100% + 6px);
            right: 0;
            background: #fff;
            border-radius: 14px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            padding: 0;
            min-width: 150px;
            max-width: 320px;
            display: none;
            z-index: 40;
        }

        .context-menu.open {
            display: block;
        }

        .context-menu.share-menu {
            right: 0;
            left: auto;
            min-width: 260px;
        }

        .context-menu.share-menu .menu-panel {
            padding: 12px;
            gap: 8px;
        }

        .context-menu.share-menu button {
            border-radius: 10px;
        }

        .context-menu.share-menu button:hover,
        .context-menu.share-menu button:focus {
            border-radius: 10px;
        }

        .menu-panel {
            display: flex;
            max-width: 300px;
            flex-direction: column;
            gap: 5px;
            padding: 0px;
        }

        .menu-header {
            font-size: 14px;
            font-weight: 700;
        }

        .context-menu label {
            margin: 0;
            font-size: 13px;
            padding: 12px;
        }

        .context-menu select {
            width: 100%;
            border: 1px solid #dcd0c1;
            border-radius: 6px;
            padding: 6px 8px;
            font-size: 13px;
            background: #fff;
        }

        .context-menu button {
            border-radius: 4px;
            text-align: left;
            width: 100%;
            font-size: 14px;
            cursor: pointer;
        }

        .menu-panel-btn {
            border-radius: 0;
            border: 1px solid #fff;
            background: transparent;
            text-align: left;
            padding: 8px 12px;
            width: 100%;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .menu-panel-btn:hover {
            background: rgba(42, 122, 87, 0.08);
            border-radius: 0px;
        }

        .menu-panel .menu-panel-btn {
            border: none;
        }

        .toast {
            position: fixed;
            bottom: 18px;
            right: 18px;
            background: rgba(15, 23, 42, 0.92);
            color: #fff;
            padding: 8px 16px;
            border-radius: 999px;
            font-size: 13px;
            box-shadow: 0 8px 18px rgba(15, 23, 42, 0.3);
            pointer-events: none;
            opacity: 0;
            transform: translateY(12px);
            transition: opacity 0.25s ease, transform 0.25s ease;
            z-index: 90;
        }

        .toast.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .error-toast {
            position: fixed;
            top: 18px;
            right: 18px;
            background: #b00020;
            color: #fff;
            padding: 10px 16px;
            border-radius: 12px;
            font-size: 13px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
            pointer-events: none;
            opacity: 0;
            transform: translateY(-12px);
            transition: opacity 0.25s ease, transform 0.25s ease;
            z-index: 95;
        }

        .error-toast.visible {
            opacity: 1;
            transform: translateY(0);
        }


        .share-link-field {
            width: 100%;
            border-radius: 8px;
            border: 1px solid #d0c3ad;
            padding: 8px;
            font-size: 13px;
            font-family: inherit;
            background: #fbf8f2;
        }

        .share-link-line {
            display: flex;
        }

        .share-menu-status {
            font-size: 12px;
            color: var(--muted);
            margin: 0;
        }

        .share-menu-status.error {
            color: #b00020;
        }

        .share-actions {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(0, 1fr));
            gap: 6px;
        }

        .share-actions .menu-panel-btn {
            width: 100%;
        }

        .prompt-mode-line {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
        }

        .prompt-mode-label {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            color: var(--muted);
            font-weight: 600;
        }

        .prompt-editor {
            width: 100%;
            border-radius: 8px;
            border: 1px solid #d0c3ad;
            padding: 10px 12px;
            font-size: 13px;
            font-family: inherit;
            resize: vertical;
            min-height: 80px;
            background: #fff;
        }

        .prompt-editor:focus-visible {
            outline: none;
            border-color: #2a7a57;
            box-shadow: 0 0 0 2px rgba(42, 122, 87, 0.3);
        }

        .prompt-editor-context {
            font-size: 13px;
            color: var(--muted);
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-bottom: 8px;
        }

        .prompt-editor-context.hidden {
            display: none;
        }

        .prompt-editor-context-row {
            display: flex;
            gap: 4px;
        }

        .prompt-editor-context-label {
            font-weight: 600;
        }

        .prompt-editor-context-row strong {
            font-weight: 600;
            color: #111;
        }

        .prompt-editor-preview {
            font-size: 14px;
            color: #111;
            background: #fefdf8;
            border: 1px solid #ded5c8;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            white-space: pre-wrap;
            min-height: 95px;
            cursor: text;
            outline: none;
        }

        .prompt-editor-preview.hidden {
            display: none;
        }

        .prompt-editor-placeholder {
            font-weight: 600;
            color: #111;
        }

        .prompt-editor-placeholder-empty {
            font-style: italic;
            color: var(--muted);
        }

        .prompt-editor-placeholder strong {
            font-weight: 600;
            color: #111;
        }


        .prompt-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 10px;
            flex-direction: row-reverse;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }

        .modal-footer button {
            border-radius: 8px;
            padding: 6px 12px;
            border: 1px solid #dcd0c1;
            background: #fff;
            cursor: pointer;
            font-size: 13px;
        }

        .modal-footer button.primary {
            border: none;
            background: #2a7a57;
            color: #fff;
        }

        .ia-mode-toggle {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            flex-wrap: wrap;
            padding-top: 12px;
        }

        .ia-mode-toggle button {
            border-radius: 999px;
            border: 1px solid #ebe0d1;
            background: #fff;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 13px;
        }

        .ia-mode-label {
            width: 100%;
            font-size: 13px;
            font-weight: 600;
            letter-spacing: 0.08em;
            color: var(--muted);
        }

        .ia-mode-toggle button.active {
            background: #2a7a57;
            color: #fff;
            border-color: #2a7a57;
        }

        #promptCustomizationArea.hidden {
            display: none;
        }


        :root {
            --bg: #f5f2eb;
            --card-bg: #ffffff;
            --border-soft: #dfd5c7;
            --text-main: #2f2922;
            --muted: #8b8173;
            --border-display: #d0c3ad;
            --radius-large: 16px;
            --radius: 10px;
            --shadow-soft: 0 10px 25px rgba(0, 0, 0, 0.05);
            --slide-aspect-ratio: 16 / 9;
            --slide-width: min(1400px, 100%);
            --slide-available-height: calc(100vh - 190px);
            --slide-aspect-value: calc(16 / 9);
        }

        html,
        body {
            min-height: 100vh;
            height: 100vh;
            overflow: hidden;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: var(--app-font, "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif);
            background: #f3f4f6;
            color: var(--text-main);
            display: flex;
            justify-content: center;
            align-items: flex-start;
            overflow: hidden;
        }

        .app {
            width: 100%;
            max-width: none;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 0px;
            align-items: stretch;
            min-height: 100vh;
            height: 100vh;
            padding: 12px;
            overflow: hidden;
        }

        .app-main {
            flex: 1;
            display: grid;
            grid-template-columns: minmax(0, 1fr);
            gap: 12px;
            min-height: 0;
            align-items: stretch;
            position: relative;
        }

        .app-main.gutenberg-open {
            /* make the right-hand card responsive: at most 350px, at least 200px */
            grid-template-columns: minmax(0, 1fr) minmax(200px, 350px);
        }

        .gutenberg-card {
            background: #fff;
            border: 1px solid #ebe0d1;
            border-radius: 8px;
            box-shadow: var(--shadow-soft);
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            height: calc(100%-10px);
            min-height: 0;
            max-height: 100%;
            overflow: auto;
            transition: transform 0.25s ease, opacity 0.25s ease;
            z-index: 25;
            font-size: 13px;
            margin: 10px 0px 10px 0px;
            padding-top: 0px;
        }

        .gutenberg-card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0px;
        }

        .gutenberg-card-title {
            font-size: 14px;
            font-weight: 700;
            letter-spacing: 0.02em;
        }

        .gutenberg-card-actions {
            display: flex;
            align-items: center;
            gap: 6px;
            flex-wrap: wrap;
            justify-content: flex-end;
        }

        .gutenberg-card-actions-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            width: 100%;
            margin-bottom: 4px;
            flex-direction: row;
        }

        .gutenberg-card-actions-row-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .scenario-section {
            display: flex;
            flex-direction: column;
            gap: 6px;
            height: 100%;
        }

        .scenario-header-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .scenario-header-row span {
            font-weight: 600;
            font-size: 13px;
            line-height: 1.2;
        }

        .scenario-input-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
            height: 100%;
        }

        /* Make the full generate button primary green */


        .right {
            margin-left: auto;
        }





        .gutenberg-card-body {
            display: flex;
            flex-direction: column;
            gap: 2px;
            min-height: 0;
            height: 100%;
            font-size: 13px
        }

        .gutenberg-card label {
            font-size: 13px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .gutenberg-card textarea {
            border-radius: 8px;
            border: 1px solid #d0c3ad;
            padding: 8px;
            font-size: 13px;
            font-family: var(--app-font, "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif);
            min-height: 120px;
            resize: none;
            overflow: auto;
            scrollbar-width: none;
            line-height: 1.4;
            /* Firefox: hide by default */
        }

        /* Layout: make the global context smaller and let the page context fill the card
           so the `#pageContextField` occupies the remaining space instead of roughly half. */
        .gutenberg-card-body>label:first-child textarea,
        #globalContextField {
            height: 250px;
            flex: none;
            min-height: 0;
        }

        .gutenberg-card-body>label:last-child {
            display: flex;
            flex-direction: column;
            flex: 1 1 auto;
            min-height: 0;
        }

        .gutenberg-card-body>label:last-child textarea,
        #pageContextField {
            flex: 1 1 0;
            min-height: 0;
            overflow: auto;
            height: 100%;
        }

        /* Thin scrollbar only visible on focus */
        .gutenberg-card textarea::-webkit-scrollbar {
            width: 6px;
            height: 0px;
            /* hide horizontal by default */
        }

        .gutenberg-card textarea:focus::-webkit-scrollbar {
            height: 6px;
            width: 6px;
        }

        .gutenberg-card textarea::-webkit-scrollbar-thumb {
            background: rgba(15, 23, 42, 0.10);
            border-radius: 999px;
        }

        .gutenberg-card textarea:focus::-webkit-scrollbar-thumb {
            background: rgba(15, 23, 42, 0.22);
        }

        /* Firefox: show thin scrollbar only on focus */
        .gutenberg-card textarea {
            scrollbar-width: none;
        }

        .gutenberg-card textarea:focus {
            scrollbar-width: thin;
        }

        .prompt-input-wrapper {
            position: relative;
            width: 100%;
            display: flex;
            height: 100%;
            flex-direction: column;
        }

        .template-tooltip {
            display: none;
            position: absolute;
            left: 0;
            bottom: -8px;
            transform: translateY(100%);
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.08);
            padding: 8px 10px;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            z-index: 10;
            max-width: 360px;
            font-size: 12px;
            color: #ffffff;
            line-height: 1.3;
            backdrop-filter: blur(2px);
        }

        .prompt-input-wrapper.is-focused .template-tooltip {
            display: block;
        }

        /* Canvas-specific: show the template tooltip above the Scénario textarea
           when the prompt-input-wrapper is focused (float at top of textarea). */
        #canvasTemplateTooltip {
            bottom: auto;
            top: -8px;
            transform: translateY(-100%);
            left: 0;
            z-index: 60;
            max-width: 360px;
        }

        .template-label {
            font-size: 12px;
            color: var(--muted);
        }

        .gutenberg-status {
            font-size: 11px;
            color: var(--muted);
        }

        .gutenberg-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.28);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.25s ease;
            z-index: 24;
        }

        .gutenberg-backdrop.visible {
            opacity: 1;
            pointer-events: auto;
        }

        @media (min-width: 900px) {
            .gutenberg-card {
                /* responsive: fill the column but never exceed 350px */
                width: 100%;
                width: 350px;
                flex: 0 0 auto;
                display: none;
                transform: none;
                opacity: 1;
                position: relative;
            }

            .gutenberg-card-actions-row {
                display: flex;
                gap: 8px;
                justify-content: space-between;
                align-items: center;
                width: 100%;
                flex-direction: row;
                flex-wrap: wrap;
            }

            .gutenberg-card.open {
                display: flex;
            }

            .gutenberg-backdrop {
                display: none;
            }
        }

        @media (max-width: 899px) {
            .app-main {
                grid-template-columns: minmax(0, 1fr);
            }

            .gutenberg-card {
                position: fixed;
                top: 12px;
                right: 12px;
                bottom: 12px;
                width: min(320px, 88vw);
                max-height: calc(100vh - 24px);
                transform: translateX(110%);
                opacity: 0;
                pointer-events: none;
                visibility: hidden;
            }

            .gutenberg-card.open {
                transform: translateX(0);
                opacity: 1;
                pointer-events: auto;
                visibility: visible;
            }

            /* ensure actions row stacks nicely on small screens */
            .gutenberg-card-actions-row {
                justify-content: flex-start;
                flex-wrap: wrap;
                gap: 8px;
            }
        }


        .app::after {
            content: "";
            position: absolute;
            bottom: 16px;
            right: 16px;
            width: 120px;
            height: 120px;
            background: url("logo.gif") no-repeat center/contain;
            opacity: 0.25;
            pointer-events: none;
            z-index: -1;
        }

        .tabs-actions {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
            flex-wrap: wrap;
        }

        .reset-prompts-btn {
            border-radius: 999px;
            border: 1px solid #ebe0d1;
            background: #fff;
            padding: 0 6px;
            min-height: 24px;
            font-size: 12px;
            line-height: 24px;
            cursor: pointer;
            box-shadow: none;
        }

        .info-popup {
            position: absolute;
            top: 56px;
            right: 12px;
            width: 280px;
            background: #fff;
            border-radius: 14px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            padding: 15px;
            display: none;
            flex-direction: column;
            gap: 6px;
            font-size: 12px;
            z-index: 60;
        }

        .info-popup.open {
            display: flex;
        }

        .info-popup img {
            width: 48px;
            height: 48px;
            object-fit: contain;
            align-self: center;
        }

        .info-popup a {
            color: #2a7a57;
            text-decoration: none;
            font-weight: 600;
        }

        .info-popup button {
            border-radius: 8px;
            border: 1px solid rgba(15, 23, 42, 0.15);
            background: #fff;
            color: #0f172a;
            padding: 6px 10px;
            font-size: 12px;
            cursor: pointer;
            min-width: 110px;
        }

        .info-popup button.update-btn {
            background: #2a7a57;
            border-color: #2a7a57;
            color: #fff;
        }

        .info-popup button.secondary {
            background: #fff;
            border-color: rgba(15, 23, 42, 0.15);
            color: #0f172a;
        }

        .info-actions {
            display: flex;
            justify-content: space-between;
            gap: 8px;
            flex-wrap: wrap;
        }

        .tour-overlay {
            position: fixed;
            inset: 0;
            background: transparent;
            display: none;
            z-index: 120;
            pointer-events: auto;
        }

        .tour-overlay.dimmed {
            background: rgba(15, 15, 15, 0.65);
        }

        .tour-overlay.visible {
            display: block;
        }

        .tour-highlight {
            position: absolute;
            border: 2px solid #2a7a57;
            border-radius: 12px;
            background: transparent;
            box-shadow: 0 0 0 9999px rgba(15, 15, 15, 0.65);
            transition: all 0.25s ease;
            pointer-events: none;
        }

        .tour-highlight.hidden {
            opacity: 0;
        }

        .tour-panel {
            position: absolute;
            bottom: 28px;
            left: 50%;
            transform: translateX(-50%);
            max-width: 460px;
            width: calc(100% - 40px);
            background: #fff;
            border-radius: 14px;
            padding: 18px;
            box-shadow: 0 16px 32px rgba(0, 0, 0, 0.28);
            color: #1f1f1f;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .tour-panel h4 {
            margin: 0;
            font-size: 18px;
        }

        .tour-panel p {
            margin: 0;
            line-height: 1.4;
        }

        .tour-step-counter {
            font-size: 11px;
            color: #918b7f;
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        .tour-step-footer {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            flex-wrap: wrap;
            margin-top: 8px;
        }

        .tour-panel button {
            border-radius: 10px;
            border: 1px solid #ebe0d1;
            background: #fff;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 13px;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        .tour-panel button.primary {
            border: none;
            background: #2a7a57;
            color: #fff;
        }

        .tour-panel button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .tour-panel button:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 6px 18px rgba(15, 23, 42, 0.12);
        }

        .tour-skip {
            position: absolute;
            top: 12px;
            right: 12px;
            border: none;
            background: rgba(255, 255, 255, 0.12);
            color: #fff;
            border-radius: 999px;
            padding: 6px 12px;
            font-size: 12px;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        .tour-skip:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
        }

        #tabs {
            display: flex;
            align-items: center;
            gap: 6px;
            flex-wrap: no-wrap;
        }




        .nav-switch {
            position: relative;
            display: inline-flex;
            align-items: center;
        }

        .nav-switch-menu {
            position: absolute;
            top: calc(100% + 6px);
            left: 0;
            min-width: 180px;
            background: #ffffff;
            border-radius: 14px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            padding: 6px;
            display: none;
            z-index: 60;
        }

        .nav-switch-menu.open {
            display: block;
        }

        .nav-switch-link {
            display: flex;
            align-items: center;
            gap: 6px;
            width: 100%;
            border: none;
            background: transparent;
            border-radius: 10px;
            padding: 8px 12px;
            font-size: 12px;
            cursor: pointer;
            text-decoration: none;
            color: #1f2a56;
        }

        .nav-switch-link:hover,
        .nav-switch-link:focus-visible {
            background: rgba(42, 122, 87, 0.08);
        }



        .slides-container {
            position: relative;
            flex: 1;
            min-height: 0;
            max-height: 100%;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            overflow-y: auto;
            width: 100%;
            -ms-overflow-style: none;
            /* IE and Edge */
            scrollbar-width: none;
            /* Firefox */
        }

        .slides-container::-webkit-scrollbar {
            display: none;
            /* Safari and Chrome */
            width: 0px;
            height: 0px;
        }

        .slide-empty-state {
            position: absolute;
            inset: 40px 40px 20px;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            background: rgba(255, 255, 255, 0.92);
            border-radius: 24px;
            border: 1px dashed rgba(15, 23, 42, 0.25);
            color: var(--text-main);
            padding: 24px;
            gap: 12px;
            z-index: 2;
        }

        .slide-empty-state.visible {
            display: flex;
        }

        .slide-empty-state p {
            margin: 0;
            font-size: 14px;
            color: var(--text-main);
        }

        .slide-empty-state button {
            border-radius: 14px;
            border: 1px solid rgba(15, 23, 42, 0.2);
            background: #fff;
            color: #2a7a57;
            padding: 8px 16px;
            cursor: pointer;
            font-size: 13px;
        }

        .slide-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
            padding: 12px 0px;
        }

        .slide {
            background: var(--slide-bg, #ffffff);
            border-radius: var(--radius);
            padding: 8px 8px 8px;
            box-shadow: var(--shadow-soft);
            display: flex;
            flex-direction: column;
            aspect-ratio: var(--slide-aspect-ratio, 16 / 9);
            width: min(var(--slide-width, min(1680px, 100%)),
                    var(--slide-height-width-limit,
                        calc(var(--slide-available-height, calc(100vh - 190px)) * var(--slide-aspect-value, calc(16 / 9)))));
            height: 100%;
        }

        .slide-bottom-section {
            width: 100%;
            display: flex;
            flex-direction: column;
            padding: 0px 4px;
        }

        .bottom-section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 2px;
        }

        .bottom-section-title {
            font-size: 12px;
            font-weight: 600;
            color: var(--muted);
        }

        .slide-bottom-section .bottom-section-delete {
            opacity: 0;
            pointer-events: none;
        }

        .slide-bottom-section.bottom-section-focused .bottom-section-delete {
            opacity: 1;
            pointer-events: auto;
            color: #918b7f;
        }

        .bottom-section-text {
            width: 100%;
            min-height: 60px;
            border-radius: 8px;
            border: 1px solid #dcd0c1;
            background: var(--slide-bg, #ffffff);
            color: var(--slide-text-color, var(--text-main));
            font-family: var(--slide-font-family, var(--app-font, "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif));
            font-size: var(--slide-font-size, 16px);
            margin: 4px 0px 4px 0px;
            line-height: 1.5;
            overflow: auto;
            padding: 0px 6px;
        }

        .slide-bottom-section .textarea-wrapper textarea {
            padding-top: 10px;
        }

        .slide,
        .slide-body,
        .column-body {
            color: var(--slide-text-color, var(--text-main));
        }

        .slide.hidden {
            display: none;
        }

        .slide-header {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .slide-title-row,
        .slide-subtitle-row {
            display: flex;
            align-items: center;
            gap: 2px;
            justify-content: space-between;
        }

        .slide-title-row input,
        .slide-subtitle-row input {
            flex: 1;
        }

        .slide-title-input {
            border: 1px solid transparent;
            background: transparent;
            font-size: 20px;
            font-weight: 650;
            margin: 4px 6px;
            color: var(--slide-text-color, var(--text-main));
            line-height: 1.2;
            border-radius: 4px;
            transition: background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
            padding: 2px 4px;
        }

        .slide-subtitle-input {
            border: none;
            background: transparent;
            font-size: 13px;
            color: var(--slide-text-color, var(--muted));
            padding: 0;
            margin: 0;
            line-height: 1.2;
        }

        .slide-header-main {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .slide-body {
            display: flex;
            gap: 18px;
            align-items: stretch;
            flex: 1;
            position: relative;
        }

        .columns {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(0, 1fr));
            gap: 0px;
            flex: 1;
        }

        .column {
            border-radius: 4px;
            background: var(--slide-bg, #ffffff);
            border: 1px solid transparent;
            display: flex;
            flex-direction: column;
            min-height: 420px;
            --stage-color: #f0ede7;
            transition: box-shadow 0.2s ease;
        }

        .column.palette-active {
            box-shadow: none;
            border-color: transparent;
        }

        :root {
            --global-background: transparent;
        }

        .column-header {
            background: var(--slide-bg, #ffffff);
            border-bottom: 1px solid rgba(0, 0, 0, 0.02);
            border-radius: 4px 4px 0 0;
            padding: 4px 4px 4px;
            min-height: 20px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            font-size: 11px;
            overflow: visible;
        }

        .column-header-main {
            display: flex;
            width: 100%;
        }

        .column-title-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 2px;
            width: 100%;
        }

        .column-title {
            font-size: calc(var(--slide-font-size) + 3px);
            font-weight: 500;
            font-family: var(--slide-font-family, var(--app-font, "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif));
            padding: 0px 4px;
            border-radius: 4px;
            border: 1px solid transparent;
            background: transparent;
            cursor: text;
            width: 100%;
            text-align: left;
            transition: background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
        }

        .column-body {
            padding: 0px 4px 0px;
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
            gap: 2px;
            font-size: 10px;
            background: var(--slide-bg, #ffffff);
            border-radius: 0 0 4px 4px;
        }

        .section {
            display: flex;
            flex-direction: column;
            gap: 0px;
            flex: 1;
            min-height: 0;
        }

        .section-label {
            font-size: calc(var(--slide-font-size, 12px));
            font-weight: 500;
            color: var(--slide-text-color, var(--muted));
            display: flex;
            align-items: center;
            gap: 0px;
            min-height: 22px;
            font-family: var(--slide-font-family, var(--app-font, "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif));
            border-radius: 8px;
            border: 1px solid transparent;
            padding: 2px 4px;
            transition: background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
        }

        .section-label[data-suggestions] {
            position: relative;
        }

        .section-label[data-suggestions]::after {
            content: attr(data-suggestions);
            position: absolute;
            left: 0;
            bottom: calc(100% + 6px);
            background: rgba(31, 41, 55, 0.92);
            color: #fff;
            padding: 6px 10px;
            border-radius: 8px;
            font-size: 11px;
            white-space: pre-line;
            width: 300px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.35);
            opacity: 0;
            visibility: hidden;
            transform: translateY(6px);
            transition: opacity 0.2s ease, transform 0.2s ease, max-width 0.2s ease;
            pointer-events: none;
            z-index: 60;
        }

        .section-label[data-suggestions]:hover::after,
        .section-label[data-suggestions]:focus-visible::after {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .textarea-wrapper[data-suggestions] {
            position: relative;
        }

        .textarea-wrapper[data-suggestions]::after {
            content: attr(data-suggestions);
            position: absolute;
            left: 0;
            bottom: calc(100% + 6px);
            background: rgba(31, 41, 55, 0.92);
            color: #fff;
            padding: 6px 10px;
            border-radius: 8px;
            font-size: 11px;
            white-space: pre-line;
            width: 300px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.35);
            opacity: 0;
            visibility: hidden;
            transform: translateY(6px);
            transition: opacity 0.2s ease, transform 0.2s ease, max-width 0.2s ease;
            pointer-events: none;
            z-index: 60;
        }

        .textarea-wrapper[data-suggestions]:focus-within::after {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .column-copy-btn {
            border: none;
            background: transparent;
            font-size: 13px;
            border-radius: 999px;
            cursor: pointer;
            color: #918b7f;
            padding: 0px;
            opacity: 0;
            pointer-events: none;
        }



        .column-delete-btn,

        .section-delete-btn,
        .bottom-section-delete {
            border: none;
            background: transparent;
            font-size: 20px;
            border-radius: 999px;
            cursor: pointer;
            color: #918b7f;
            padding: 0px;
            opacity: 0;
            pointer-events: none;
        }

        .column-title-row:hover .column-delete-btn,
        .column-title-row:hover .column-copy-btn,
        .section-label-row:hover .section-delete-btn,
        .section:hover .section-delete-btn,
        .section:focus-within .section-delete-btn {
            opacity: 1;
            pointer-events: auto;
        }

        .column-title:focus-visible~.column-delete-btn,
        .column-title:focus-visible~.column-copy-btn,
        .section-label:focus-visible+.section-delete-btn,
        .slide-title-input:focus-visible {
            outline: none;
            border-color: #2a7a57;
            box-shadow: 0 0 0 3px rgba(42, 122, 87, 0.2);
            background: rgba(42, 122, 87, 0.05);
        }

        .section-text-row {
            position: relative;
            display: flex;
            align-items: stretch;
            gap: 2px;
            justify-content: space-between;
            flex: 1;
            min-height: 0;
        }

        .textarea-wrapper {
            position: relative;
            width: 100%;
            flex: 1;
            display: flex;
            min-height: 0;
        }

        .textarea-wrapper textarea {
            padding-top: 26px;
        }

        .field-ai-btn.inside {
            position: absolute;
            bottom: 6px;
            right: 6px;
            border-radius: 999px;
            border: 1px solid #dcd0c1;
            background: rgba(255, 255, 255, 0.9);
            font-size: 11px;
            padding: 2px 6px;
            cursor: pointer;
        }

        .section-label-row,
        .section-text-row {
            display: flex;
            gap: 2px;
            justify-content: space-between;
        }

        .field-ai-btn {
            border: none;
            background: transparent;
            font-size: 16px;
            color: #918b7f;
            cursor: pointer;
            padding: 0;
            line-height: 1;
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }

        .textarea-wrapper:hover .field-ai-btn,
        .textarea-wrapper textarea:focus-visible+.field-ai-btn,
        .field-ai-btn:focus-visible {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
        }

        .field-ai-btn:hover {
            color: #2a7a57;
        }

        .section textarea {
            width: 100%;
            border-radius: 4px;
            font-size: var(--slide-font-size, 16px);
            padding: 6px 8px;
            line-height: 1.3;
            min-height: 0;
            height: 100%;
            resize: none;
            border: none;
            background: var(--slide-bg, #ffffff);
            color: var(--slide-text-color, #2f2922);
            font-family: var(--slide-font-family, var(--app-font, "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif));
            overflow: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
            flex: 1;
        }

        .column-focused textarea {
            border: 1px solid #cfcfcf;
        }

        .section textarea::-webkit-scrollbar {
            width: 0;
            height: 0;
        }

        .section textarea:focus-visible {
            outline: 1px solid rgba(42, 122, 87, 0.8);
            box-shadow: none;
            scrollbar-width: thin;
        }

        /* Keep section textareas using the slide background on hover/focus
           to avoid an unwanted white flash when interacting with them. */
        .section textarea:hover,
        .section textarea:focus,
        .textarea-wrapper:hover textarea,
        .textarea-wrapper:focus-within textarea {
            background: var(--slide-bg, #ffffff) !important;
            color: var(--slide-text-color, #2f2922) !important;
        }

        .section textarea.textarea-overflow {
            border: 2px solid #f7c63a;
            box-shadow: 0 0 0 1px rgba(247, 198, 58, 0.35);
        }

        .section textarea:focus-visible::-webkit-scrollbar {
            width: 8px;
        }

        .section textarea::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }

        .section textarea::-webkit-resizer,
        .section textarea::-moz-resizer {
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .section textarea:focus-visible::-webkit-resizer,
        .section textarea:focus-visible::-moz-resizer {
            opacity: 1;
        }

        .column-color-grid,
        .slide-bg-grid {
            display: grid;
            grid-template-columns: repeat(5, minmax(0, 1fr));
            gap: 6px;
        }

        .settings-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #e0d7c8;
        }

        .section-heading {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--muted);
        }

        .column-palettes {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .palette-block {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .palette-label {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-main);
        }

        .ratio-wrapper {
            display: flex;
            flex-direction: column;
            gap: 6px;
            padding: 10px;
        }

        .ratio-grid {
            display: flex;
            gap: 6px;
        }

        .ratio-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--muted);
        }

        .ratio-option {
            flex: 1;
            border-radius: 8px;
            border: 1px solid #e0d7c1;
            background: #fff;
            padding: 8px;
            font-size: 12px;
            cursor: pointer;
        }

        .ratio-option.active {
            border-color: #2a7a57;
        }

        .font-size-control {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .font-size-control button {
            border-radius: 999px;
            border: 1px solid #dcd0c1;
            background: #f7f5f1;
            width: 28px;
            height: 28px;
            font-size: 18px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .font-size-control input {
            flex: 1;
            text-align: center;
        }

        .color-swatch {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            border: 1px solid #cfc6b8;
            cursor: pointer;
            padding: 0;
            background: #fff;
        }

        .color-swatch.transparent {
            background-image: repeating-conic-gradient(#cfc6b8 0% 25%, #fff 0% 50%);
            background-size: 6px 6px;
        }

        .color-swatch:focus-visible {
            outline: 2px solid #2a7a57;
            outline-offset: 2px;
        }

        .text-style-option {
            border-radius: 10px;
            border: 1px solid #e0d7c8;
            padding: 8px;
            background: #fff;
            text-align: left;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-height: 64px;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.08);
        }

        .text-style-option.active {
            border-color: #2a7a57;
        }

        /* états d’édition : bordures seulement au survol / focus */
        .editable {
            border: 1px solid var(--border-display) !important;
            background: transparent;
            transition: border-color 0.12s ease, background-color 0.12s ease, box-shadow 0.12s ease;
        }

        .editable:hover {
            border-color: var(--border-display);
            background: #fffdf8;
        }

        .editable:focus-visible {
            outline: none;
            border-color: #c0a97f;
            background: #ffffff;
            box-shadow: 0 0 0 1px rgba(192, 169, 127, 0.35);
        }

        /* textareas utilisent editable + fond léger */
        .section textarea.editable {
            background: var(--slide-bg, #ffffff);
        }

        body.exporting .editable {
            border: none;
            box-shadow: none;
            background: var(--slide-bg, #ffffff);
        }

        body.exporting .section textarea {
            border: none;
        }

        @media print {
            body {
                background: #ffffff;
            }

            .app-header {
                display: none;
            }

            .gutenberg-card,
            .gutenberg-backdrop {
                display: none !important;
            }

            .slide {
                box-shadow: none;
                border-radius: 0;
            }
        }
    </style>
</head>

<body class="app-body">
    <div class="app">
        <div class="app-header">
            <div class="tabs-actions">
                <a class="app-home-link" href="index.html" title="Revenir à l'accueil">☍</a>
                <div class="nav-switch">
                    <button id="navSwitcherBtn" class="nav-switch-btn" type="button" aria-haspopup="true"
                        aria-expanded="false">⊞ Petit Robert ▾</button>
                    <div id="navSwitcherMenu" class="nav-switch-menu" role="menu">
                        <a class="nav-switch-link" href="timeline.html" role="menuitem">⇥ Goal Digger</a>
                        <a class="nav-switch-link" href="draw.html" role="menuitem">◇ Le Cardinal</a>
                    </div>
                </div>

                <div id="tabs"></div>
                <button class="tab-action" id="addTabBtn" type="button" aria-label="Ajouter un onglet">+</button>
                <button class="tab-action" id="restoreStructureBtn" type="button"
                    aria-label="Restaurer les colonnes et sections">↺</button>
                <button class="tab-action" id="deleteTabBtn" type="button" aria-label="Supprimer l'onglet">×</button>
            </div>
            <div class="global-actions">


                <div class="menu-trigger" id="settingsMenuTrigger">
                    <button id="templateBtn" class="btn" type="button" aria-label="Choisir un Promptzilla">⛶
                        Promptzilla</button>
                    <button id="contextEditorBtn" class="btn" type="button" aria-label="Ouvrir Gutenberg">⸙
                        Gutenberg</button>
                    <button id="contextBtn" class="btn" type="button" aria-label="Soulgorithm">⌘ Soulgorithm</button>

                    <button id="textStyleBtn" class="btn" type="button" aria-label="Hublot">◯ Hublot</button>
                    <div class="context-menu" id="settingsMenu">
                        <div class="menu-panel">
                            <label>
                                Police
                                <select id="fontSelect"></select>
                            </label>
                            <label>
                                Taille (px)
                                <select id="fontSizeInput">
                                    <option value="9">9</option>
                                    <option value="10">10</option>
                                    <option value="11">11</option>
                                    <option value="12">12</option>
                                    <option value="13">13</option>
                                    <option value="14">14</option>
                                    <option value="15">15</option>
                                    <option value="16">16</option>
                                </select>
                            </label>
                            <label>
                                Fond global
                                <select id="backgroundSelector">
                                    <option value="transparent">Transparent</option>
                                    <option value="#ffffff" selected>Blanc</option>
                                </select>
                            </label>
                            <div class="ratio-wrapper">
                                <div class="ratio-label">Aspect ratio</div>
                                <div class="ratio-grid" id="ratioGrid"></div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="menu-trigger" id="fileMenuTrigger">
                    <button id="fileMenuBtn" class="btn" type="button" aria-label="Capsule">⬠ Capsule</button>
                    <div class="context-menu" id="fileMenu">
                        <div class="menu-panel">
                            <button id="importJsonBtn" type="button" class="menu-panel-btn">⤷ Ouvrir</button>
                            <button id="exportJsonBtn" type="button" class="menu-panel-btn">⭳ Télécharger</button>
                            <button id="exportPptxBtn" type="button" class="menu-panel-btn">▭ Powerpoint</button>
                            <button id="exportTextBtn" type="button" class="menu-panel-btn">¶ Texte</button>
                            <button id="exportPngBtn" type="button" class="menu-panel-btn">◩ Image</button>
                            <button id="infoButton" type="button" class="menu-panel-btn">⎉ Vaisseau</button>
                        </div>
                    </div>
                </div>
                <div class="menu-trigger" id="shareMenuTrigger">
                    <button id="shareBtn" class="btn btn-secondary" type="button" aria-label="Partager"
                        title="Lien de partage">☍ Nexus</button>
                    <div class="context-menu share-menu" id="shareMenu">
                        <div class="menu-panel">
                            <div class="menu-header">Lien de la capsule</div>
                            <div class="share-link-line">
                                <input id="shareLinkField" class="share-link-field" type="text" readonly
                                    placeholder="Créer un lien ">
                            </div>
                            <div class="share-actions">
                                <button id="shareUpdateBtn" type="button" class="btn-primary">⟳ Actualiser</button>
                                <button id="shareCreateBtn" type="button" class="btn">☍
                                    Créer</button>
                            </div>
                            <p class="share-menu-status" id="shareMenuStatus"></p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="infoPopup" class="info-popup" role="dialog" aria-live="polite">
            <img src="logo.gif" alt="Logo Go-Toolkit">
            <strong>Module Petit Robert Downey Jr</strong>
            <span>Version 2025.12.07</span>
            <span>Développé par Quang TRAN.</span>
            <span>Usage réservé à Savane Consulting.</span>
            <div class="info-actions">
                <button id="updateAppBtn" type="button" class="update-btn">Réinitialiser</button>
                <button id="tourReplayBtn" type="button" class="secondary">Tour guidé</button>
            </div>
        </div>

        <div class="app-main">
            <div class="slides-container">
                <div class="slide-empty-state" id="slideEmptyState">
                    <p>
                        Cette page est vide.
                    </p>
                    <button id="slideContextLink" type="button">⌘ Ouvrir l’IA contexte</button>
                </div>
                <div id="slides" class="slide-wrapper"></div>
            </div>
            <aside class="gutenberg-card" id="gutenbergCard" aria-label="Gutenberg" aria-hidden="true">
                <div class="gutenberg-card-header">
                    <div class="gutenberg-card-actions">
                        <!-- header left intentionally minimal; status and actions placed below -->
                    </div>
                </div>
                <div class="gutenberg-card-body">
                    <div class="gutenberg-card-actions-row">
                        <label>Histoire</label>
                        <div class="gutenberg-card-actions-row-right">

                            <button class="btn-primary" id="generateFullSlideBtn" type="button"
                                aria-label="Générer toutes les sections et la synthèse">⌘ Répondre</button>

                            <span class="gutenberg-status" id="suggestionStatusLabel" aria-live="polite"></span>
                        </div>
                    </div>
                    <label>
                        <textarea id="globalContextField" rows="10"
                            placeholder="Décris le domaine, les utilisateurs, la problématique et l'intention"></textarea>
                    </label>
                    <div class="scenario-section">
                        <div class="scenario-header-row">
                            <label>Scénario</label>
                            <button class="btn" id="clearSectionsBtn" type="button" aria-label="Vider les sections">⊘
                                Vider</button>
                        </div>
                        <label class="scenario-input-group">
                            <div id="canvasSelectedTemplateLabel" class="template-label"></div>
                            <div class="prompt-input-wrapper">
                                <textarea id="pageContextField" rows="10"
                                    placeholder="Décrire la situation de manière quantitative et qualitative"></textarea>
                                <div id="canvasTemplateTooltip" class="template-tooltip" aria-hidden="true"></div>
                            </div>
                        </label>
                    </div>
                </div>
            </aside>
        </div>

        <div id="gutenbergBackdrop" class="gutenberg-backdrop"></div>

        <div id="tourOverlay" class="tour-overlay" aria-hidden="true">
            <div class="tour-highlight hidden" aria-hidden="true"></div>
            <div class="tour-panel">
                <span class="tour-step-counter" id="tourStepCounter"></span>
                <h4 id="tourStepTitle"></h4>
                <p id="tourStepDescription"></p>
                <div class="tour-step-footer">
                    <button id="tourPrevBtn" type="button">Précédent</button>
                    <button id="tourNextBtn" type="button" class="primary">Suivant</button>
                    <button id="tourCloseBtn" type="button">Fermer</button>
                </div>
            </div>
            <button id="tourSkipBtn" class="tour-skip" type="button">×</button>
        </div>
        <div id="copyToast" class="toast" aria-live="polite" aria-atomic="true"></div>
        <div id="errorToast" class="error-toast" role="status" aria-live="polite" aria-atomic="true"></div>
    </div>

    <div class="modal-overlay" id="contextModal">
        <div class="modal promptzilla-modal">
            <div class="modal-header">
                <h3>⌘ Soulgorithm</h3>
                <button class="modal-close" data-close="contextModal">×</button>
            </div>
            <div class="modal-panel hide" data-panel="settings">
                <!-- API key and reasoning settings moved to global Settings (index.html) -->
                <div class="ia-mode-toggle" id="iaModeToggle">
                    <div class="ia-mode-label">Prompt</div>
                    <button type="button" data-ia-mode="express">🛫︎ Auto</button>
                    <button type="button" data-ia-mode="experimental">⌬ Avancé</button>
                </div>
                <div id="promptCustomizationArea">
                    <label>
                        <span class="prompt-label-text">Prompt - Sections</span>
                        <textarea id="mainPromptField" rows="5" class="prompt-editor"
                            style="font-family: Menlo, Consolas, 'Courier New', monospace;"></textarea>
                    </label>
                    <label>
                        <span class="prompt-label-text">Prompt - Synthèse</span>
                        <textarea id="bottomPromptField" rows="4" class="prompt-editor"
                            style="font-family: Menlo, Consolas, 'Courier New', monospace;"></textarea>
                    </label>
                    <label>
                        <span class="prompt-label-text">Prompt - Suggestions</span>
                        <textarea id="suggestionPromptField" rows="5" class="prompt-editor"
                            style="font-family: Menlo, Consolas, 'Courier New', monospace;"></textarea>
                    </label>
                    <div class="prompt-actions">
                        <button id="contextApplyBtn" type="button" class="btn-primary">Appliquer</button>
                        <button id="resetPromptsBtn" type="button" class="btn">↺ Réinitialiser</button>

                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="templateModal">
        <div class="modal">
            <div class="modal-header">
                <h3>⛶ Promptzilla</h3>
                <button class="modal-close" data-close="templateModal">×</button>
            </div>
            <div class="modal-panel">
                <div id="templateList" class="promptzilla-grid" role="radiogroup" aria-label="Modèles disponibles">
                </div>
            </div>
            <div class="modal-footer">
                <button id="templateApplyBtn" type="button" class="btn primary">Appliquer</button>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="promptEditorModal">
        <div class="modal">
            <div class="modal-header">
                <h3>Modifier le prompt</h3>
                <button class="modal-close" data-close="promptEditorModal">×</button>
            </div>
            <div class="prompt-editor-context hidden" id="promptEditorContextPreview" aria-live="polite"></div>
            <div class="prompt-editor-preview-wrapper">
                <div class="prompt-label-text">Prompt personalisé</div>
                <div id="promptEditorPreview" class="prompt-editor-preview hidden" aria-live="polite"
                    contenteditable="true" spellcheck="false" role="textbox" aria-multiline="true"
                    aria-label="Modifier le prompt expérimental"></div>
            </div>
            <textarea id="promptEditorTextarea" rows="5" class="prompt-editor prompt-editor-textarea" hidden
                style="font-family: Menlo, Consolas, 'Courier New', monospace;"></textarea>
            <div class="modal-footer">
                <button type="button" class="secondary" id="promptEditorCancelBtn">Annuler</button>
                <button type="button" class="primary" id="promptEditorSendBtn">Envoyer</button>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pptxgenjs@3.9.0/dist/pptxgen.bundle.js"></script>
    <script>
        window.GO_TOOLKIT_SHARE_API_URL =
            window.GO_TOOLKIT_SHARE_API_URL || "https://share.gotoolkit.workers.dev/";
    </script>

    <script>
        (function () {
            var STORAGE_KEY = "robert-gutenberg-open-state-canvas";
            function readAutoOpenState() {
                try {
                    if (!window.localStorage) return null;
                    return localStorage.getItem(STORAGE_KEY);
                } catch (err) {
                    return null;
                }
            }

            function updateGutenbergVisibility() {
                var card = document.getElementById("gutenbergCard");
                var appMain = document.querySelector(".app-main");
                if (!card || !appMain) return;
                var stored = readAutoOpenState();
                var shouldOpen = stored === "open" && (window.innerWidth || 0) >= 900;
                card.classList.toggle("open", shouldOpen);
                appMain.classList.toggle("gutenberg-open", shouldOpen);
                card.setAttribute("aria-hidden", shouldOpen ? "false" : "true");
            }

            window.addEventListener("resize", updateGutenbergVisibility);
            if (document.readyState === "loading") {
                document.addEventListener("DOMContentLoaded", updateGutenbergVisibility);
            } else {
                updateGutenbergVisibility();
            }
        })();
    </script>
    <script src="js/prompt.js"></script>
    <script src="js/share-worker-client.js"></script>
    <script src="js/share-history.js"></script>
    <script src="js/openai-client.js"></script>
    <script src="js/template-criteria.js"></script>
    <script>
        const stageColors = {
            "first-col": getComputedStyle(document.documentElement).getPropertyValue("--now-color").trim(),
            "second-col": getComputedStyle(document.documentElement).getPropertyValue("--next-color").trim(),
            "third-col": getComputedStyle(document.documentElement).getPropertyValue("--later-color").trim()
        };
        document.documentElement.style.setProperty("--global-background", "#ffffff");

        const textStyles = [
            { name: "Inter", font: "Inter, system-ui, sans-serif", size: 14 },
            { name: "Arial", font: "Arial, Helvetica, sans-serif", size: 14 },
            { name: "Tahoma", font: "Tahoma, Geneva, sans-serif", size: 14 },
            { name: "Trebuchet MS", font: "'Trebuchet MS', Helvetica, sans-serif", size: 14 },
            { name: "Georgia", font: "Georgia, 'Times New Roman', serif", size: 16 },
            { name: "Times New Roman", font: "'Times New Roman', Times, serif", size: 16 },
            { name: "Lucida Console", font: "'Lucida Console', Monaco, monospace", size: 13 },
            { name: "Rounded", font: "'Segoe UI', 'Fredoka One', sans-serif", size: 14 },
            { name: "Serif", font: "Georgia, 'Times New Roman', serif", size: 16 },
            { name: "Mono", font: "'JetBrains Mono', 'Menlo', monospace", size: 13 }
        ];

        const ratioOptions = [
            {
                name: "100%",
                css: "16 / 9",
                width: "100%",
                ignoreHeightLimit: true,
                pptx: { width: 10, height: 5.625 }
            },
            {
                name: "16:9",
                css: "16 / 9",
                width: "min(1400px, 100%)",
                pptx: { width: 10, height: 5.625 }
            },
            {
                name: "4:3",
                css: "4 / 3",
                width: "min(960px, 100%)",
                pptx: { width: 10, height: 7.5 }
            },
            {
                name: "A4",
                css: "297 / 210",
                width: "min(820px, 100%)",
                pptx: { width: 11.69, height: 8.27 }
            }
        ];

        const fallbackTemplates = [
            {
                id: "default",
                name: "🕊️ Libre",
                defaultTitle: "Libre",
                description: "Grille ouverte à trois colonnes et trois sections pour noter, esquisser ou brainstormer sans cadre imposé.",
                columns: [
                    { stage: "first-col", label: "Colonne 1" },
                    { stage: "second-col", label: "Colonne 2" },
                    { stage: "third-col", label: "Colonne 3" }
                ],
                sections: [
                    { key: "first-section", label: "Section 1", examples: "" },
                    { key: "second-section", label: "Section 2", examples: "" },
                    { key: "third-section", label: "Section 3", examples: "" }
                ]
            }
        ];
        const defaultTemplateId = "default";
        const rawTemplates =
            (window.GoPrompts && Array.isArray(window.GoPrompts.canvasTemplates) && window.GoPrompts.canvasTemplates.length
                ? window.GoPrompts.canvasTemplates
                : fallbackTemplates);
        const templates = Array.isArray(rawTemplates) && rawTemplates.length
            ? rawTemplates.slice()
            : fallbackTemplates.slice();
        const defaultTemplateIndex = templates.findIndex(template => template?.id === defaultTemplateId);
        if (defaultTemplateIndex > 0) {
            templates.unshift(templates.splice(defaultTemplateIndex, 1)[0]);
        }
        const templateExamples =
            (window.GoPrompts && window.GoPrompts.canvasExamples) || {};
        const promptVariableDefinitions = {
            globalContext: "Contexte global saisi dans la modalité Contexte",
            pageContext: "Contexte spécifique à la page active",
            contextField: "Alias historique de {{globalContext}} pour la compatibilité",
            columnTitle: "Titre de la colonne concernée",
            columnId: "Identifiant de la colonne (stage du template)",
            fieldValue: "Valeur actuelle du champ",
            sectionTitle: "Intitulé de la section ciblée",
            sectionLabel: "Label actuel de la section",
            sectionGuidance: "Consignes issues de canvasExamples pour cette colonne/section",
            slideTitle: "Titre de la slide",
            columnSections: "Résumé des 9 éléments de toutes les sections"
        };
        const promptPreviewMaskedKeys = new Set(["fieldValue", "globalContext", "pageContext"]);
        const sectionPromptTail =
            ', et en tant que product owner expérimenté, en tenant compte du {{globalContext}} et du {{pageContext}}, formule en 3 éléments ( de moins de 15 mots chacun et en commençant par •). Mettre uniquement la liste à puce des 3 éléments. N\'introduis ou ne conclut pas ton propos et ne mets pas d\'emojis.';
        const defaultPromptTemplate =
            "{{sectionGuidance}}\n" + ' à partir du contenu actuel éventuel "{{fieldValue}}"' + sectionPromptTail;
        const IA_MODE_EXPRESS = "express";
        const IA_MODE_EXPERIMENTAL = "experimental";
        const promptModeMap = {
            [IA_MODE_EXPRESS]: "express",
            [IA_MODE_EXPERIMENTAL]: "lab"
        };
        const bottomSectionPlaceholderText = "Synthèse, décisions clés ou résumé rapide";
        const bottomSectionDefaultPrompt =
            (window.GoPrompts && window.GoPrompts.canvasBottomPromptTemplate) || "";
        const defaultSuggestionsPrompt =
            (window.GoPrompts && window.GoPrompts.canvasSuggestionsPromptTemplate) || "";

        function getTemplateById(id) {
            return templates.find(template => template.id === id) || templates[0];
        }

        function getDefaultTitle(templateId) {
            const template = getTemplateById(templateId);
            return template?.defaultTitle || template?.name || fallbackTitle;
        }

        function getSectionExample(templateId, stage, sectionKey) {
            const examplesByTemplate = templateExamples[templateId] || templateExamples.default || {};
            const byStage = examplesByTemplate[stage] || {};
            return byStage[sectionKey] || "";
        }

        function getTemplateSections(templateId) {
            return getTemplateById(templateId).sections;
        }

        function getTemplateSection(templateId, sectionKey) {
            return getTemplateSections(templateId).find(section => section.key === sectionKey);
        }

        function getSectionGuidance(templateId, columnId, sectionKey, sectionLabel, columnTitle) {
            const exampleText = getSectionExample(templateId, columnId, sectionKey) || "";
            if (exampleText) {
                return exampleText;
            }
            const readableColumn = columnTitle || columnId || "cette colonne";
            const readableSection = sectionLabel || sectionKey || "cette section";
            return `aucune consigne spécifique trouvée pour ${readableColumn} / ${readableSection}`;
        }

        function getDefaultSectionLabel(templateId, sectionKey) {
            const section = getTemplateSection(templateId, sectionKey);
            return section ? section.label : sectionKey;
        }

        function getTemplateColumns(templateId) {
            return getTemplateById(templateId).columns;
        }

        function getTemplateColumn(templateId, index) {
            return getTemplateColumns(templateId)[index] || { stage: "first-col", label: `Colonne ${index + 1}` };
        }

        function getActiveTemplateId() {
            const activeSlide = getActiveSlideElement?.();
            return activeSlide?.dataset.templateId || currentTemplateId || templates[0].id;
        }

        function getActiveTemplate() {
            return getTemplateById(getActiveTemplateId());
        }

        function getTemplateCriteria(template) {
            return GoToolkitTemplateCriteria.getTemplateCriteria(template);
        }

        function getTemplateSummary(template) {
            return GoToolkitTemplateCriteria.getTemplateSummary(template);
        }

        let templateSlides = {};

        function initializeTemplateSlides(slideList = []) {
            templateSlides = templates.reduce((acc, template) => {
                acc[template.id] = [];
                return acc;
            }, {});
            slideList.forEach(slide => {
                const incomingId = slide.templateId || "";
                const templateId = templates.some(t => t.id === incomingId) ? incomingId : templates[0].id;
                slide.templateId = templateId;
                slide.pageContext = slide.pageContext ?? slide.context ?? "";
                templateSlides[templateId].push(slide);
            });
            const fallbackId = templates.find(template => template?.id === defaultTemplateId)?.id || templates[0].id;
            if (!templateSlides[fallbackId] || !templateSlides[fallbackId].length) {
                templateSlides[fallbackId] = [{
                    templateId: fallbackId,
                    bgColor: "#ffffff"
                }];
            }
        }


        const slidesContainer = document.getElementById("slides");
        const tabsContainer = document.getElementById("tabs");
        const slideEmptyState = document.getElementById("slideEmptyState");
        const slideContextLink = document.getElementById("slideContextLink");
        const navSwitcherBtn = document.getElementById("navSwitcherBtn");
        const navSwitcherMenu = document.getElementById("navSwitcherMenu");
        const addTabBtn = document.getElementById("addTabBtn");
        const deleteTabBtn = document.getElementById("deleteTabBtn");
        const restoreStructureBtn = document.getElementById("restoreStructureBtn");
        const generateFullSlideBtn = document.getElementById("generateFullSlideBtn");
        const suggestionStatusLabel = document.getElementById("suggestionStatusLabel");
        const clearSectionsBtn = document.getElementById("clearSectionsBtn");
        const exportBtn = document.getElementById("exportPngBtn");
        const exportPptxBtn = document.getElementById("exportPptxBtn");
        const exportTextBtn = document.getElementById("exportTextBtn");
        const textStyleBtn = document.getElementById("textStyleBtn");
        const fileMenuBtn = document.getElementById("fileMenuBtn");
        const templateBtn = document.getElementById("templateBtn");
        const importJsonBtn = document.getElementById("importJsonBtn");
        const exportJsonBtn = document.getElementById("exportJsonBtn");
        const contextBtn = document.getElementById("contextBtn");
        const contextEditorBtn = document.getElementById("contextEditorBtn");
        const selectedTemplateLabelEl = document.getElementById("canvasSelectedTemplateLabel");
        const canvasTemplateTooltip = document.getElementById("canvasTemplateTooltip");
        const contextModal = document.getElementById("contextModal");
        const appMain = document.querySelector(".app-main");
        const gutenbergCard = document.getElementById("gutenbergCard");
        const gutenbergBackdrop = document.getElementById("gutenbergBackdrop");
        const templateModal = document.getElementById("templateModal");
        const templateList = document.getElementById("templateList");
        const templateApplyBtn = document.getElementById("templateApplyBtn");
        let selectedTemplateId = null;
        let hasPromptzillaOpenedForNewSlide = false;
        const globalContextField = document.getElementById("globalContextField");
        const pageContextField = document.getElementById("pageContextField");
        const contextModalTabs = contextModal?.querySelectorAll(".modal-tab") ?? [];
        const contextModalPanels = contextModal?.querySelectorAll(".modal-panel") ?? [];
        const settingsMenu = document.getElementById("settingsMenu");
        const fileMenu = document.getElementById("fileMenu");
        const shareMenu = document.getElementById("shareMenu");
        // per-modal API key input removed; use shared localStorage key `go-toolkit-api-key` instead
        const reasoningEffortSelect = document.getElementById("reasoningEffortSelect");
        const reasoningEffortKey = "robert-reasoning-effort";
        const reasoningEfforts = ["minimal", "low", "medium", "high"];
        const fontSelect = document.getElementById("fontSelect");
        const fontSizeInput = document.getElementById("fontSizeInput");
        const ratioGrid = document.getElementById("ratioGrid");
        const backgroundSelector = document.getElementById("backgroundSelector");
        const resetPromptsBtn = document.getElementById("resetPromptsBtn");
        const iaModeToggle = document.getElementById("iaModeToggle");
        const iaModeButtons = Array.from(iaModeToggle?.querySelectorAll("[data-ia-mode]") ?? []);
        const promptCustomizationArea = document.getElementById("promptCustomizationArea");
        const applyPromptToAllBtn = document.getElementById("applyPromptToAllBtn");
        const copyToast = document.getElementById("copyToast");
        const errorToast = document.getElementById("errorToast");
        const mainPromptField = document.getElementById("mainPromptField");
        const bottomPromptField = document.getElementById("bottomPromptField");
        const suggestionPromptField = document.getElementById("suggestionPromptField");
        const promptModeLabel = document.getElementById("promptModeLabel");
        const promptEditorModal = document.getElementById("promptEditorModal");
        const promptEditorTextarea = document.getElementById("promptEditorTextarea");
        const promptEditorSendBtn = document.getElementById("promptEditorSendBtn");
        const promptEditorCancelBtn = document.getElementById("promptEditorCancelBtn");
        const promptEditorContextPreview = document.getElementById("promptEditorContextPreview");
        const promptEditorPreview = document.getElementById("promptEditorPreview");
        let promptEditorCurrentContext = null;
        const scenarioContextWrapper = document.getElementById("pageContextField")?.closest(".prompt-input-wrapper");
        let templateCriteriaStatus = {};
        let lastAnalyzedSentenceCount = 0;
        let lastAnalyzedTemplateId = null;
        let criteriaAnalysisAbortController = null;
        let scenarioTooltipTimer = null;
        const SCENARIO_TOOLTIP_INACTIVITY_MS = 5000;
        const sectionCriteriaSentenceCount = new WeakMap();
        const sectionCriteriaControllers = new WeakMap();
        const sectionCriteriaLastText = new WeakMap();
        const contextApplyBtn = document.getElementById("contextApplyBtn");
        promptEditorPreview?.addEventListener("input", () => {
            if (!promptEditorTextarea) return;
            promptEditorTextarea.value = collectTemplateFromPreview();
        });
        let copyToastTimer = null;
        let errorToastTimer = null;
        const slidesViewport = document.querySelector(".slides-container");

        let slideClampRaf = null;
        const DESKTOP_GUTENBERG_BREAKPOINT = 900;
        const GUTENBERG_SEEN_KEY = "robert-gutenberg-opened-canvas";
        const GUTENBERG_OPEN_STATE_KEY = "robert-gutenberg-open-state-canvas";

        function updateSlideClamp() {
            if (!slidesViewport) return;
            const height = slidesViewport.clientHeight;
            const safeHeight = Math.max(height - 12, 0);
            document.documentElement.style.setProperty("--slide-available-height", `${safeHeight}px`);
        }

        function scheduleSlideClampUpdate() {
            if (slideClampRaf !== null) return;
            slideClampRaf = requestAnimationFrame(() => {
                slideClampRaf = null;
                updateSlideClamp();
            });
        }

        function isDesktopGutenberg() {
            return window.innerWidth >= DESKTOP_GUTENBERG_BREAKPOINT;
        }

        function isGutenbergOpen() {
            return Boolean(gutenbergCard?.classList.contains("open"));
        }

        function markGutenbergSeen() {
            try {
                localStorage.setItem(GUTENBERG_SEEN_KEY, "1");
            } catch (err) {
                console.warn("Impossible de noter l'ouverture de Gutenberg", err);
            }
        }

        function readGutenbergOpenState() {
            try {
                if (!window.localStorage) return null;
                const value = localStorage.getItem(GUTENBERG_OPEN_STATE_KEY);
                if (value === "open") return true;
                if (value === "closed") return false;
            } catch (err) {
                console.warn("Impossible de lire l'état de Gutenberg", err);
            }
            return null;
        }

        function persistGutenbergOpenState(isOpen) {
            try {
                if (!window.localStorage) return;
                localStorage.setItem(GUTENBERG_OPEN_STATE_KEY, isOpen ? "open" : "closed");
            } catch (err) {
                console.warn("Impossible de sauvegarder l'état de Gutenberg", err);
            }
        }

        function syncGutenbergLayoutState() {
            const open = isGutenbergOpen();
            const desktop = isDesktopGutenberg();
            appMain?.classList.toggle("gutenberg-open", open && desktop);
            gutenbergBackdrop?.classList.toggle("visible", open && !desktop);
        }

        function setGutenbergOpen(open, { auto = false } = {}) {
            if (!gutenbergCard || !appMain) return;
            const shouldOpen = Boolean(open);
            gutenbergCard.classList.toggle("open", shouldOpen);
            gutenbergCard.setAttribute("aria-hidden", shouldOpen ? "false" : "true");
            persistGutenbergOpenState(shouldOpen);
            syncGutenbergLayoutState();
            contextEditorBtn?.setAttribute("aria-expanded", shouldOpen ? "true" : "false");
            contextEditorBtn?.setAttribute("aria-label", shouldOpen ? "Masquer Gutenberg" : "Ouvrir Gutenberg");
            if (shouldOpen && !auto) {
                markGutenbergSeen();
            }
        }

        function toggleGutenberg(openValue = null) {
            const shouldOpen = openValue === null ? !isGutenbergOpen() : Boolean(openValue);
            if (shouldOpen) {
                syncPageContextFieldWithActiveSlide();
            }
            setGutenbergOpen(shouldOpen);
            if (shouldOpen) {
                globalContextField?.focus();
            }
        }

        function maybeAutoOpenGutenberg() {
            // Auto-open Gutenberg on desktop the first time the user opens this view.
            if (!gutenbergCard || !appMain) return;
            if (!isDesktopGutenberg()) return;
            try {
                const storedState = readGutenbergOpenState();
                if (storedState === true) {
                    setGutenbergOpen(true, { auto: true });
                    return;
                }
                if (storedState === false) {
                    syncGutenbergLayoutState();
                    return;
                }
                var seen = localStorage.getItem(GUTENBERG_SEEN_KEY);
                if (!seen) {
                    setGutenbergOpen(true, { auto: true });
                    // mark as seen so we don't auto-open on every load
                    markGutenbergSeen();
                    return;
                }
            } catch (err) {
                // ignore storage errors
            }
            syncGutenbergLayoutState();
        }

        function handleResize() {
            scheduleSlideClampUpdate();
            syncGutenbergLayoutState();
        }

        window.addEventListener("resize", handleResize);

        // API key input moved to global Settings (index.html). Use readSharedApiKey()/writeSharedApiKey() helpers.

        const STORAGE_KEY = "go-roadmap-state";
        const API_KEY_STORAGE_KEY = "go-toolkit-api-key";
        // user preference: default background for new slides (can be 'transparent' or a color)
        let userDefaultBackground = "#ffffff";

        function getShareDraftKey(token) {
            return `${STORAGE_KEY}-share-${token}`;
        }

        function readShareDraft(token) {
            if (!token || typeof window === "undefined" || !window.localStorage) {
                return null;
            }
            try {
                const raw = localStorage.getItem(getShareDraftKey(token));
                if (!raw) return null;
                const parsed = JSON.parse(raw);
                if (!parsed || typeof parsed !== "object") return null;
                return parsed;
            } catch (err) {
                console.warn("Impossible de lire le cache local de la capsule", err);
                return null;
            }
        }

        function writeShareDraft(token, payload, updatedAt) {
            if (!token || typeof window === "undefined" || !window.localStorage) {
                return;
            }
            try {
                const value = {
                    payload,
                    updatedAt: updatedAt || new Date().toISOString()
                };
                localStorage.setItem(getShareDraftKey(token), JSON.stringify(value));
            } catch (err) {
                console.warn("Impossible de sauvegarder le cache local de la capsule", err);
            }
        }

        function readSharedApiKey() {
            if (typeof window === "undefined" || !window.localStorage) {
                return "";
            }
            try {
                return localStorage.getItem(API_KEY_STORAGE_KEY) || "";
            } catch (err) {
                console.warn("Impossible de lire la clé OpenAI stockée localement", err);
                return "";
            }
        }

        function writeSharedApiKey(value) {
            if (typeof window === "undefined" || !window.localStorage) {
                return;
            }
            try {
                if (value) {
                    localStorage.setItem(API_KEY_STORAGE_KEY, value);
                } else {
                    localStorage.removeItem(API_KEY_STORAGE_KEY);
                }
            } catch (err) {
                console.warn("Impossible de sauvegarder la clé OpenAI localement", err);
            }
        }

        let persistTimer = null;

        function schedulePersist() {
            clearTimeout(persistTimer);
            persistTimer = setTimeout(persistState, 500);
        }

        function collectAllSlides() {
            return collectSlidesFromDOM();
        }

        function buildStatePayload() {
            storeCurrentSlides();
            const globalContextValue = globalContextField?.value || "";
            return {
                slides: collectAllSlides(),
                settings: {
                    ratioIndex: currentRatioIndex,
                    textStyleIndex: currentTextStyleIndex,
                    fontSize: currentFontSize,
                    apiKey: readSharedApiKey(),
                    globalContext: globalContextValue,
                    context: globalContextValue,
                    prompts: promptLibrary,
                    promptTemplateId: activePromptTemplateId,
                    iaMode: activeIaMode,
                    defaultTemplateId: currentTemplateId
                    ,
                    backgroundDefault: (backgroundSelector && backgroundSelector.value) || userDefaultBackground
                }
            };
        }

        function persistState() {
            const payload = buildStatePayload();
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
            } catch (err) {
                console.error("Impossible de sauvegarder l'état :", err);
            }
            if (currentShareToken) {
                writeShareDraft(currentShareToken, payload, new Date().toISOString());
            }
        }

        function loadSavedState() {
            const stored = localStorage.getItem(STORAGE_KEY);
            if (!stored) {
                initializeTemplateSlides();
                return false;
            }
            try {
                const parsed = JSON.parse(stored);
                const settings = parsed.settings || {};
                initializeTemplateSlides(Array.isArray(parsed.slides) ? parsed.slides : []);
                applySettingsFromPayload(settings);
                return Array.isArray(parsed.slides) && parsed.slides.length;
            } catch (err) {
                console.error("Impossible de charger l'état :", err);
                initializeTemplateSlides();
                setPromptFieldsForTemplate(activePromptTemplateId);
                return false;
            }
        }

        const FIRESTORE_COLLECTION = "slides";
        const SHARE_QUERY_PARAM = "share";
        const SHARE_WORKER_UNAVAILABLE_MESSAGE =
            "Le partage privé nécessite le worker Cloudflare lié à Go-Toolkit (go-toolkit-share).";
        const shareWorkerService = window.goToolkitShareWorker;
        let shareWorkerAvailable = Boolean(shareWorkerService?.isReady);
        let currentShareToken = null;
        let shareLoadedFromRemote = false;
        let shareStatusMessage = "";
        let shareStatusType = "";
        let shareRequestInProgress = false;
        let shareLastUpdatedAt = null;

        function initShareWorkerService() {
            shareWorkerAvailable = Boolean(window.goToolkitShareWorker?.isReady);
        }

        function setShareStatus(message, type = "") {
            shareStatusMessage = message;
            shareStatusType = type;
        }

        function formatRelativeTime(isoString) {
            if (!isoString) return "";
            const value = new Date(isoString).getTime();
            if (Number.isNaN(value)) return "";
            const deltaSeconds = Math.max(0, Math.floor((Date.now() - value) / 1000));
            if (deltaSeconds < 60) {
                return "Mis à jour à l'instant";
            }
            const deltaMinutes = Math.floor(deltaSeconds / 60);
            if (deltaMinutes < 60) {
                return `Mis à jour il y a ${deltaMinutes} minute${deltaMinutes > 1 ? "s" : ""}`;
            }
            const deltaHours = Math.floor(deltaMinutes / 60);
            if (deltaHours < 24) {
                return `Mis à jour il y a ${deltaHours} heure${deltaHours > 1 ? "s" : ""}`;
            }
            const deltaDays = Math.floor(deltaHours / 24);
            return `Mis à jour il y a ${deltaDays} jour${deltaDays > 1 ? "s" : ""}`;
        }

        function getShareTokenFromUrl() {
            const params = new URLSearchParams(window.location.search);
            const value = params.get(SHARE_QUERY_PARAM);
            return value ? value.trim() : null;
        }

        function buildShareUrl(token) {
            if (!token) {
                return "";
            }
            const url = new URL(window.location.href);
            url.searchParams.set(SHARE_QUERY_PARAM, token);
            return url.toString();
        }

        function updateUrlWithShareToken(token) {
            const url = new URL(window.location.href);
            if (token) {
                url.searchParams.set(SHARE_QUERY_PARAM, token);
            } else {
                url.searchParams.delete(SHARE_QUERY_PARAM);
            }
            history.replaceState(null, "", url.toString());
        }

        function createShareToken() {
            if (typeof crypto !== "undefined" && typeof crypto.randomUUID === "function") {
                return crypto.randomUUID();
            }
            const bytes = new Uint8Array(16);
            if (typeof crypto !== "undefined" && typeof crypto.getRandomValues === "function") {
                crypto.getRandomValues(bytes);
            } else {
                for (let i = 0; i < bytes.length; i++) {
                    bytes[i] = Math.floor(Math.random() * 256);
                }
            }
            return Array.from(bytes)
                .map(byte => byte.toString(16).padStart(2, "0"))
                .join("");
        }

        async function fetchSharePayload(token) {
            if (!shareWorkerAvailable || !shareWorkerService) {
                throw new Error(SHARE_WORKER_UNAVAILABLE_MESSAGE);
            }
            return shareWorkerService.fetchSharePayload(FIRESTORE_COLLECTION, token);
        }

        function formatFullDate(isoString) {
            const value = new Date(isoString);
            if (Number.isNaN(value.getTime())) return "";
            const formatter = new Intl.DateTimeFormat("fr-FR", {
                day: "2-digit",
                month: "short",
                year: "numeric",
                hour: "2-digit",
                minute: "2-digit"
            });
            return formatter.format(value);
        }

        async function tryLoadSharedStateFromUrl() {
            const token = getShareTokenFromUrl();
            if (!token) {
                return false;
            }
            const localDraft = readShareDraft(token);
            let remoteResult = null;
            try {
                remoteResult = await fetchSharePayload(token);
            } catch (err) {
                console.error("Erreur de chargement distant du lien partagé :", err);
            }

            const remotePayload = remoteResult?.payload;
            const remoteUpdatedAt = remoteResult?.meta?.updatedAt;
            const localPayload = localDraft?.payload;
            const localUpdatedAt = localDraft?.updatedAt;

            const remoteDate = remoteUpdatedAt ? new Date(remoteUpdatedAt).getTime() : 0;
            const localDate = localUpdatedAt ? new Date(localUpdatedAt).getTime() : 0;
            const payloadsMatch = remotePayload && localPayload
                ? JSON.stringify(remotePayload) === JSON.stringify(localPayload)
                : false;
            const timestampsEqual = remoteUpdatedAt && localUpdatedAt && remoteDate === localDate;

            let chosenPayload = null;
            let chosenUpdatedAt = null;

            if (remotePayload && localPayload && (payloadsMatch || timestampsEqual)) {
                chosenPayload = localPayload;
                chosenUpdatedAt = localUpdatedAt || remoteUpdatedAt;
            } else if (localPayload && localDate > remoteDate) {
                chosenPayload = localPayload;
                chosenUpdatedAt = localUpdatedAt;
            } else if (remotePayload && remoteDate > localDate && localPayload) {
                const confirmed = window.confirm(
                    `Mettre à jour avec les modifications du ${formatFullDate(remoteUpdatedAt)} ?`
                );
                if (confirmed) {
                    chosenPayload = remotePayload;
                    chosenUpdatedAt = remoteUpdatedAt;
                } else {
                    chosenPayload = localPayload;
                    chosenUpdatedAt = localUpdatedAt || remoteUpdatedAt || new Date().toISOString();
                }
            } else if (remotePayload && Array.isArray(remotePayload.slides)) {
                chosenPayload = remotePayload;
                chosenUpdatedAt = remoteUpdatedAt || new Date().toISOString();
            } else if (localPayload) {
                chosenPayload = localPayload;
                chosenUpdatedAt = localUpdatedAt || new Date().toISOString();
            }

            if (!chosenPayload || !Array.isArray(chosenPayload.slides)) {
                setShareStatus("Lien de la capsule introuvable.", "error");
                return false;
            }

            initializeTemplateSlides(chosenPayload.slides);
            applySettingsFromPayload(chosenPayload.settings || {});
            currentShareToken = token;
            shareLoadedFromRemote = true;
            shareLastUpdatedAt = chosenUpdatedAt || new Date().toISOString();
            setShareStatus(formatRelativeTime(shareLastUpdatedAt));
            persistShareHistoryRecord(token, shareLastUpdatedAt);
            writeShareDraft(token, chosenPayload, shareLastUpdatedAt);
            return true;
        }

        async function saveSharePayload(token, payload) {
            if (!shareWorkerAvailable || !shareWorkerService) {
                throw new Error(SHARE_WORKER_UNAVAILABLE_MESSAGE);
            }
            const meta = await shareWorkerService.saveSharePayload(FIRESTORE_COLLECTION, token, payload);
            return meta?.updatedAt || new Date().toISOString();
        }

        const importInput = document.createElement("input");
        importInput.type = "file";
        importInput.accept = "application/json";
        importInput.style.display = "none";
        document.body.appendChild(importInput);

        let slideCount = 0;
        let activeIndex = 0;
        let activePaletteColumn = null;
        let currentTextStyleIndex = 0;
        let currentFontSize = 12;
        let currentRatioIndex = 0;
        let currentTemplateId = templates[0].id;
        let lastAppliedTemplateId = templates[0].id;
        let activePromptTemplateId = templates[0].id;
        let activeIaMode = IA_MODE_EXPRESS;
        let lastFocusedPromptTextarea = null;
        const promptLibrary = templates.reduce((acc, template) => {
            acc[template.id] = {
                express: defaultPromptTemplate,
                lab: defaultPromptTemplate,
                bottom: bottomSectionDefaultPrompt,
                suggestions: defaultSuggestionsPrompt
            };
            return acc;
        }, {});
        const PLACEHOLDER_COOLDOWN_DURATION = 30;
        let suggestionCooldownTimer = null;
        let isGeneratingSuggestions = false;

        setPromptFieldsForTemplate(activePromptTemplateId);
        setActiveIaMode(activeIaMode);

        function applySettingsFromPayload(settings = {}) {
            const payload = settings || {};
            if (payload.prompts) {
                Object.entries(payload.prompts).forEach(([templateId, prompts]) => {
                    if (!promptLibrary[templateId]) return;
                    const target = promptLibrary[templateId];
                    target.express = prompts.express || prompts.apprenti || defaultPromptTemplate;
                    target.lab = prompts.lab || prompts.experimental || defaultPromptTemplate;
                    target.bottom = prompts.bottom || bottomSectionDefaultPrompt;
                    target.suggestions = prompts.suggestions || defaultSuggestionsPrompt;
                });
            }
            activePromptTemplateId = payload.promptTemplateId || activePromptTemplateId;
            currentTemplateId = payload.defaultTemplateId || currentTemplateId;
            lastAppliedTemplateId = currentTemplateId;
            if (true) {
                const hasSavedApiKey = Object.prototype.hasOwnProperty.call(payload, "apiKey");
                const apiKeyValue = hasSavedApiKey ? payload.apiKey || "" : readSharedApiKey();
                // Persist to shared storage so other pages read the same API key
                writeSharedApiKey(apiKeyValue || "");
            }
            const storedReasoning = localStorage.getItem(reasoningEffortKey) || "low";
            // reasoning effort is managed globally in Settings (index.html); stored value is read from localStorage
            const globalContextValue = payload.globalContext ?? payload.context ?? "";
            if (globalContextField) {
                globalContextField.value = globalContextValue;
            }
            if (globalContextValue) {
                Object.values(templateSlides).forEach(slides => {
                    slides.forEach(slide => {
                        if (!slide.pageContext) {
                            slide.pageContext = globalContextValue;
                        }
                    });
                });
            }
            if (typeof payload.ratioIndex === "number") {
                currentRatioIndex = Math.max(0, Math.min(ratioOptions.length - 1, payload.ratioIndex));
                applyRatio(currentRatioIndex);
            }
            if (typeof payload.textStyleIndex === "number") {
                currentTextStyleIndex = payload.textStyleIndex;
            }
            if (typeof payload.fontSize === "number") {
                currentFontSize = normalizeFontSize(payload.fontSize);
            }
            // load user display preference for default background
            if (payload.backgroundDefault) {
                try { userDefaultBackground = String(payload.backgroundDefault); } catch (e) { /* noop */ }
            }
            // reflect the global background preference in CSS var
            try { document.documentElement.style.setProperty("--global-background", userDefaultBackground || "#ffffff"); } catch (e) { /* noop */ }
            setPromptFieldsForTemplate(activePromptTemplateId);
            setActiveIaMode(payload.iaMode || activeIaMode);
        }

        const fallbackTitle = "GO-Roadmap";
        const defaultSubtitle = "Produit / équipe / scope";
        const ratioButtons = [];

        function parseStyleIndex(value) {
            const parsed = parseInt(value, 10);
            return Number.isNaN(parsed) ? currentTextStyleIndex : parsed;
        }

        function selectColumnForPalette(column) {
            if (!column) {
                activePaletteColumn = null;
                document.querySelectorAll(".column.palette-active").forEach(el => el.classList.remove("palette-active"));
                return;
            }
            document.querySelectorAll(".column.palette-active").forEach(el => el.classList.remove("palette-active"));
            activePaletteColumn = column;
            column.classList.add("palette-active");
        }

        function clearSectionSuggestionsForLabel(label, { skipPersist = false } = {}) {
            if (!label) {
                return false;
            }
            const hasHeaderSuggestion = Boolean(label.dataset.suggestions);
            const sectionEl = label.closest(".section");
            const textarea = sectionEl?.querySelector("textarea");
            const hasTextareaSuggestion = Boolean(textarea?.dataset.suggestionPlaceholder);
            if (!hasHeaderSuggestion && !hasTextareaSuggestion) {
                return false;
            }
            if (hasHeaderSuggestion) {
                label.classList.remove("has-suggestion");
                label.removeAttribute("title");
                delete label.dataset.suggestions;
            }
            if (textarea && hasTextareaSuggestion) {
                delete textarea.dataset.suggestionPlaceholder;
                textarea.placeholder = "";
            }
            if (!skipPersist) {
                schedulePersist();
            }
            return true;
        }

        function bindSectionLabel(label) {
            const sectionKey = label.dataset.section;
            label.addEventListener("input", () => {
                clearSectionSuggestionsForLabel(label);
            });
            label.addEventListener("blur", () => {
                const slide = label.closest(".slide");
                const templateId = slide?.dataset.templateId || templates[0].id;
                const fallback = getDefaultSectionLabel(templateId, sectionKey);
                const normalized = label.textContent.trim() || fallback;
                if (label.textContent !== normalized) {
                    label.textContent = normalized;
                }
            });
        }

        function bindTextareaPlaceholder(textarea) {
            // Keep `placeholder` empty; example text stays in `data-placeholder` only.
            textarea.placeholder = "";
        }

        function parseSuggestionCriteria(text) {
            const lines = (text || "").split(/\n/).map(line => line.trim()).filter(Boolean);
            if (!lines.length) return { instruction: "", criteria: [] };
            const startsWithCheckbox = lines[0].match(/^[☐☑]/);
            const instruction = startsWithCheckbox ? "" : lines[0];
            const criteriaLines = startsWithCheckbox ? lines : lines.slice(1);
            const criteria = criteriaLines
                .map(line => line.replace(/^[☐☑]\s*/, "").trim())
                .filter(Boolean);
            return { instruction, criteria };
        }

        function renderSuggestionWithStatus(parsed, statusMap = {}) {
            const lines = [];
            if (parsed.instruction) {
                lines.push(parsed.instruction);
            }
            parsed.criteria.forEach(item => {
                const matched = statusMap[item.toLowerCase()] || false;
                const marker = matched ? "☑" : "☐";
                lines.push(`${marker} ${item}`);
            });
            return lines.join("\n");
        }

        function promptKeyFromMode(mode) {
            return promptModeMap[mode] || "express";
        }

        function getPromptLibraryForTemplate(templateId) {
            return promptLibrary[templateId] || promptLibrary[templates[0].id];
        }

        function updatePromptFields() {
            const library = getPromptLibraryForTemplate(activePromptTemplateId);
            const modeKey = promptKeyFromMode(activeIaMode);
            const fallbackTemplate = defaultPromptTemplate;
            if (mainPromptField) {
                mainPromptField.value = library[modeKey] || fallbackTemplate;
            }
            if (bottomPromptField) {
                bottomPromptField.value = library.bottom || bottomSectionDefaultPrompt;
            }
            if (suggestionPromptField) {
                suggestionPromptField.value = library.suggestions || defaultSuggestionsPrompt;
            }
            if (promptModeLabel) {
                const modeName = activeIaMode === IA_MODE_EXPRESS ? "Express" : "Personalisé";
                promptModeLabel.textContent = `Mode ${modeName}`;
            }
        }

        function setPromptFieldsForTemplate(templateId) {
            if (!templateId) return;
            activePromptTemplateId = templateId;
            updatePromptFields();
        }

        function updateIaModeUI() {
            iaModeButtons.forEach(button => {
                button.classList.toggle("active", button.dataset.iaMode === activeIaMode);
            });
            updatePromptFields();
        }

        function setActiveIaMode(mode) {
            if (![IA_MODE_EXPRESS, IA_MODE_EXPERIMENTAL].includes(mode)) {
                return;
            }
            activeIaMode = mode;
            updateIaModeUI();
        }
        if (mainPromptField) {
            mainPromptField.addEventListener("focus", () => {
                lastFocusedPromptTextarea = mainPromptField;
            });
            mainPromptField.addEventListener("input", () => {
                const library = getPromptLibraryForTemplate(activePromptTemplateId);
                const modeKey = promptKeyFromMode(activeIaMode);
                library[modeKey] = mainPromptField.value || defaultPromptTemplate;
            });
        }
        if (bottomPromptField) {
            bottomPromptField.addEventListener("focus", () => {
                lastFocusedPromptTextarea = bottomPromptField;
            });
            bottomPromptField.addEventListener("input", () => {
                const library = getPromptLibraryForTemplate(activePromptTemplateId);
                library.bottom = bottomPromptField.value || bottomSectionDefaultPrompt;
            });
        }
        if (suggestionPromptField) {
            suggestionPromptField.addEventListener("focus", () => {
                lastFocusedPromptTextarea = suggestionPromptField;
            });
            suggestionPromptField.addEventListener("input", () => {
                const library = getPromptLibraryForTemplate(activePromptTemplateId);
                library.suggestions = suggestionPromptField.value || defaultSuggestionsPrompt;
            });
        }
        pageContextField?.addEventListener("focus", () => {
            // On focus, afficher dans `canvasTemplateTooltip` la description complète
            // du template actif (escaped + sauts de ligne conservés) puis démarrer
            // la minuterie d'inactivité.
            try {
                const tpl = getActiveTemplate();
                const desc = tpl && tpl.description ? String(tpl.description) : "";
                if (canvasTemplateTooltip) {
                    canvasTemplateTooltip.innerHTML = escapeHtml(desc).replace(/\n/g, "<br>");
                    canvasTemplateTooltip.setAttribute("aria-hidden", desc ? "false" : "true");
                }
            } catch (e) {
                /* noop */
            }
            updateSelectedTemplateLabelDisplay();
            resetScenarioTooltipTimer();
        });
        pageContextField?.addEventListener("blur", () => {
            if (scenarioContextWrapper) scenarioContextWrapper.classList.remove("is-focused");
            if (canvasTemplateTooltip) {
                canvasTemplateTooltip.setAttribute("aria-hidden", "true");
            }
            clearScenarioTooltipTimer();
        });
        pageContextField?.addEventListener("input", () => {
            setActivePageContext(pageContextField.value);
            schedulePersist();
            triggerCriteriaAnalysis();
            resetScenarioTooltipTimer();
        });
        pageContextField?.addEventListener("keydown", () => {
            resetScenarioTooltipTimer();
        });
        globalContextField?.addEventListener("blur", () => {
            // no-op: suggestion generation removed
        });
        document.addEventListener("input", event => {
            const target = event.target;
            if (target instanceof Element && target.matches(".column-title, .section-label, .section-text-row textarea")) {
                updateSlideEmptyState();
            }
        });

        iaModeButtons.forEach(button => {
            button.addEventListener("click", () => {
                setActiveIaMode(button.dataset.iaMode);
                schedulePersist();
            });
        });

        // reasoning select moved to global Settings (index.html)

        function showColumnPlaceholders(column) {
            column.querySelectorAll("textarea").forEach(textarea => {
                // Do not expose placeholders in the `placeholder` attribute.
                // Keep example text only in `data-placeholder` for internal use.
                textarea.placeholder = "";
            });
        }

        function clearColumnPlaceholders(column) {
            column.querySelectorAll("textarea").forEach(textarea => {
                // Ensure `placeholder` is always empty; we keep examples in data-* only.
                textarea.placeholder = "";
            });
        }

        function clearScenarioTooltipTimer() {
            if (scenarioTooltipTimer) {
                clearTimeout(scenarioTooltipTimer);
                scenarioTooltipTimer = null;
            }
        }

        function startScenarioTooltipTimer() {
            clearScenarioTooltipTimer();
            scenarioTooltipTimer = setTimeout(() => {
                scenarioContextWrapper?.classList.remove("is-focused");
                canvasTemplateTooltip?.setAttribute("aria-hidden", "true");
                scenarioTooltipTimer = null;
            }, SCENARIO_TOOLTIP_INACTIVITY_MS);
        }

        function resetScenarioTooltipTimer() {
            if (scenarioContextWrapper) {
                scenarioContextWrapper.classList.add("is-focused");
            }
            if (canvasTemplateTooltip) {
                const hasText = Boolean(canvasTemplateTooltip.textContent);
                canvasTemplateTooltip.setAttribute("aria-hidden", hasText ? "false" : "true");
            }
            startScenarioTooltipTimer();
        }

        function normalizeBullets(textarea) {
            const lines = textarea.value.split("\n");
            const normalized = lines.map(line => {
                const trimmed = line.trim();
                if (!trimmed) return "";
                return trimmed.startsWith("•") ? trimmed : `• ${trimmed}`;
            });
            textarea.value = normalized.join("\n");
        }

        function updateTextareaOverflowState(textarea) {
            if (!textarea) return;
            textarea.classList.toggle("textarea-overflow", textarea.scrollHeight > textarea.clientHeight);
        }

        function redistributeSectionHeights(column) {
            if (!column || !column.isConnected) return;
            const body = column.querySelector(".column-body");
            if (!body) return;
            const sections = Array.from(body.querySelectorAll(".section"));
            if (!sections.length) return;
            const bodyStyles = getComputedStyle(body);
            const gap = parseFloat(bodyStyles.gap || "0") || 0;
            let available = body.getBoundingClientRect().height - gap * Math.max(0, sections.length - 1);
            const textareas = [];
            sections.forEach(section => {
                const labelRow = section.querySelector(".section-label-row");
                const textRow = section.querySelector(".section-text-row");
                const textarea = textRow?.querySelector("textarea");
                if (!textarea) return;
                const labelHeight = labelRow?.getBoundingClientRect().height || 0;
                const textRowGap = textRow ? (parseFloat(getComputedStyle(textRow).gap || "0") || 0) : 0;
                available -= labelHeight + textRowGap;
                textareas.push(textarea);
            });
            if (!textareas.length) return;
            const perHeight = Math.max(80, available / textareas.length);
            textareas.forEach(textarea => {
                textarea.style.height = `${perHeight}px`;
            });
        }

        function resizeAllColumnSections(targetSlide) {
            const slide = targetSlide || getActiveSlideElement();
            if (!slide) return;
            slide.querySelectorAll(".column").forEach(column => redistributeSectionHeights(column));
        }

        function handleSectionCriteriaTrigger(textarea, options = {}) {
            const force = Boolean(options.force);
            const text = textarea.value || "";
            const sentenceCount = countCompletedSentences(text);
            const prev = sectionCriteriaSentenceCount.get(textarea) || 0;
            const prevText = sectionCriteriaLastText.get(textarea) || "";
            const hasTextChanged = text !== prevText;
            const sentenceChanged = sentenceCount !== prev;
            const endsWithSentence = /[.!?]\s*$/.test(text);
            const shouldAnalyzeOnInput = sentenceCount > prev || (hasTextChanged && endsWithSentence);
            if (!force && !shouldAnalyzeOnInput) return;
            if (force && !hasTextChanged) return;
            sectionCriteriaSentenceCount.set(textarea, sentenceCount);
            sectionCriteriaLastText.set(textarea, text);
            evaluateSectionCriteria(textarea);
        }

        function updateTextareaTooltip(textarea) {
            if (!textarea) return;
            const wrapper = textarea.closest(".textarea-wrapper");
            if (!wrapper) return;
            const tooltipText =
                textarea.dataset.suggestionPlaceholder ||
                textarea.dataset.placeholder ||
                "";
            if (tooltipText) {
                wrapper.dataset.suggestions = tooltipText;
            } else {
                delete wrapper.dataset.suggestions;
            }
        }

        async function evaluateSectionCriteria(textarea) {
            if (!textarea) return;
            const placeholderText = textarea.dataset.suggestionPlaceholder || textarea.dataset.placeholder || "";
            const parsed = parseSuggestionCriteria(placeholderText);
            if (!parsed.criteria.length) return;
            const text = textarea.value || "";
            const criteria = parsed.criteria;
            const apiKey = (readSharedApiKey() || "").trim();
            const prevController = sectionCriteriaControllers.get(textarea);
            if (prevController) {
                try { prevController.abort(); } catch (e) { /* noop */ }
            }
            const controller = new AbortController();
            sectionCriteriaControllers.set(textarea, controller);

            // simple fallback if no API key: check keyword presence
            if (!apiKey) {
                const lower = text.toLowerCase();
                const normalized = {};
                criteria.forEach(item => {
                    const keyLc = item.toLowerCase();
                    normalized[keyLc] = lower.includes(keyLc);
                });
                const updated = renderSuggestionWithStatus(parsed, normalized);
                textarea.dataset.suggestionPlaceholder = updated;
                // Do not set `placeholder` attribute; keep suggestion text in data-attr.
                updateTextareaTooltip(textarea);
                sectionCriteriaControllers.delete(textarea);
                return;
            }

            const endpoint = "https://api.openai.com/v1/chat/completions";
            const body = {
                model: "gpt-4o-mini",
                messages: [
                    {
                        role: "system",
                        content:
                            "Tu vérifies si un texte respecte des critères donnés. " +
                            "Réponds uniquement avec un JSON {\"matches\":{\"critère\":true/false}}. " +
                            "Un critère est rempli si l'idée ou un synonyme est présent."
                    },
                    {
                        role: "user",
                        content:
                            `Texte : """${text}"""` +
                            `\nCritères (${criteria.length}) : ${criteria.join(", ")}` +
                            `\nRéponds STRICTEMENT au format {"matches":{"Critère":true/false}} avec les mêmes libellés.`
                    }
                ],
                response_format: { type: "json_object" },
                temperature: 0
            };

            try {
                const res = await fetch(endpoint, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        Authorization: `Bearer ${apiKey}`
                    },
                    body: JSON.stringify(body),
                    signal: controller.signal
                });
                const rawText = await res.text();
                if (sectionCriteriaControllers.get(textarea) !== controller) return;
                if (!res.ok) throw new Error(rawText || "Analyse critères indisponible");
                let content = rawText;
                try {
                    const parsedOuter = JSON.parse(rawText);
                    content = parsedOuter?.choices?.[0]?.message?.content || rawText;
                } catch (e) { /* noop */ }
                let parsedJson = null;
                try { parsedJson = JSON.parse(content || "{}"); } catch (e) { }
                const matches = parsedJson?.matches || parsedJson?.result || {};
                const normalized = {};
                criteria.forEach(item => {
                    const keyLc = item.toLowerCase();
                    const candidates = [
                        matches[item],
                        matches[keyLc],
                        matches[item.replace(/\s+/g, "_")],
                        matches[item.replace(/\s+/g, "_").toLowerCase()],
                        matches[item.replace(/\s+/g, "").toLowerCase()]
                    ];
                    const val = candidates.find(v => typeof v !== "undefined");
                    normalized[keyLc] = val === true || val === "true" || val === 1;
                });
                const updated = renderSuggestionWithStatus(parsed, normalized);
                textarea.dataset.suggestionPlaceholder = updated;
                // Do not set `placeholder` attribute; tooltip updated via data attrs.
                updateTextareaTooltip(textarea);
            } catch (err) {
                if (err?.name === "AbortError") return;
                console.warn("Analyse critères section impossible", err);
            } finally {
                if (sectionCriteriaControllers.get(textarea) === controller) {
                    sectionCriteriaControllers.delete(textarea);
                }
            }
        }

        function monitorTextareaOverflow(textarea) {
            updateTextareaOverflowState(textarea);
            updateTextareaTooltip(textarea);
            textarea.addEventListener("input", () => {
                updateTextareaOverflowState(textarea);
                updateTextareaTooltip(textarea);
                if (textarea.dataset.section) {
                    handleSectionCriteriaTrigger(textarea);
                }
            });
            textarea.addEventListener("keydown", event => {
                if (event.key === "Enter" && !event.shiftKey) {
                    event.preventDefault();
                    const start = textarea.selectionStart;
                    const end = textarea.selectionEnd;
                    const insert = "\n• ";
                    textarea.setRangeText(insert, start, end, "end");
                    const newPos = start + insert.length;
                    textarea.setSelectionRange(newPos, newPos);
                    updateTextareaOverflowState(textarea);
                }
            });
            textarea.addEventListener("blur", () => {
                normalizeBullets(textarea);
                if (textarea.dataset.section) {
                    handleSectionCriteriaTrigger(textarea, { force: true });
                }
            });
            if (textarea.dataset.section) {
                sectionCriteriaSentenceCount.set(textarea, countCompletedSentences(textarea.value || ""));
            }
        }

        function updateGeneratePlaceholdersButton(remaining = 0) {
            const onCooldown = remaining > 0;
            const disableButtons = onCooldown || isGeneratingSuggestions;
            if (generateFullSlideBtn) {
                generateFullSlideBtn.disabled = disableButtons;
                generateFullSlideBtn.textContent = "⌘ Répondre";
            }
            if (suggestionStatusLabel) {
                const frames = ["◴", "◷", "◶", "◵"];
                const frame = frames[remaining % frames.length];
                suggestionStatusLabel.textContent = onCooldown ? `${frame} ${remaining}s` : "";
            }
        }

        function startGeneratePlaceholdersCooldown(duration = PLACEHOLDER_COOLDOWN_DURATION) {
            if (!generateFullSlideBtn && !suggestionStatusLabel) {
                return;
            }
            if (suggestionCooldownTimer) {
                clearInterval(suggestionCooldownTimer);
            }
            let remaining = Math.max(0, duration);
            updateGeneratePlaceholdersButton(remaining);
            if (remaining === 0) {
                return;
            }
            suggestionCooldownTimer = setInterval(() => {
                remaining -= 1;
                if (remaining <= 0) {
                    clearInterval(suggestionCooldownTimer);
                    suggestionCooldownTimer = null;
                    updateGeneratePlaceholdersButton(0);
                } else {
                    updateGeneratePlaceholdersButton(remaining);
                }
            }, 1000);
        }

        function stopGeneratePlaceholdersCooldown() {
            if (suggestionCooldownTimer) {
                clearInterval(suggestionCooldownTimer);
                suggestionCooldownTimer = null;
            }
            updateGeneratePlaceholdersButton(0);
        }

        async function generateSectionPlaceholders() {
            return;
        }

        async function generateFullSlideContent() {
            if (!generateFullSlideBtn || isGeneratingSuggestions || suggestionCooldownTimer) {
                return;
            }
            const slide = getActiveSlideElement();
            if (!slide) {
                return;
            }
            const templateId = slide.dataset.templateId || templates[0].id;
            const sectionTasks = [];
            Array.from(slide.querySelectorAll(".section")).forEach(sectionEl => {
                const sectionKey = sectionEl.dataset.section;
                const textarea = sectionEl.querySelector("textarea");
                if (!sectionKey || !textarea) {
                    return;
                }
                const column = sectionEl.closest(".column");
                const promptContext = buildSectionPromptContext(slide, column, sectionKey, textarea, templateId);
                const promptText = buildFieldPrompt(sectionKey, templateId, promptContext);
                sectionTasks.push({ textarea, messages: buildAssistantMessages(promptText) });
            });

            const bottomTextarea = slide.querySelector(".bottom-section-text");
            if (!sectionTasks.length && !bottomTextarea) {
                showCopyToast("Aucune zone à générer.");
                return;
            }

            const generateForTextarea = async (textarea, messages) => {
                const aiText = await callOpenAI(messages);
                if (!aiText) {
                    return false;
                }
                const trimmed = aiText.trim();
                if (!trimmed) {
                    return false;
                }
                textarea.value = trimmed;
                updateTextareaOverflowState(textarea);
                return true;
            };

            isGeneratingSuggestions = true;
            startGeneratePlaceholdersCooldown(PLACEHOLDER_COOLDOWN_DURATION);

            try {
                const sectionResults = await Promise.allSettled(
                    sectionTasks.map(({ textarea, messages }) => generateForTextarea(textarea, messages))
                );
                const sectionsHaveResponse = sectionResults.length === 0
                    ? true
                    : sectionResults.every(result => result.status === "fulfilled" && result.value);
                const sectionSucceeded = sectionResults.some(result => result.status === "fulfilled" && result.value);

                let bottomSuccess = false;
                if (bottomTextarea && sectionsHaveResponse) {
                    const bottomPromptContext = buildBottomPromptContext(slide);
                    const bottomPrompt = buildFieldPrompt("bottom-section", templateId, bottomPromptContext);
                    bottomSuccess = await generateForTextarea(bottomTextarea, buildAssistantMessages(bottomPrompt));
                }

                const hasSuccess = sectionSucceeded || bottomSuccess;
                if (hasSuccess) {
                    schedulePersist();
                    updateSlideEmptyState();
                    showCopyToast("Contenu IA généré pour cette page.");
                } else {
                    showCopyToast("Impossible de générer le contenu.");
                }
            } finally {
                isGeneratingSuggestions = false;
                stopGeneratePlaceholdersCooldown();
            }
        }


        function getActiveSlideElement() {
            return slidesContainer.querySelector(`.slide[data-index="${activeIndex}"]`);
        }

        function clearSectionsInActiveSlide(confirmBefore = true) {
            const slide = getActiveSlideElement();
            if (!slide) return;
            const sections = Array.from(slide.querySelectorAll('.section textarea.editable'));
            if (!sections.length) return;
            if (confirmBefore) {
                const ok = confirm('Vider toutes les sections de ce bloc ? Cette action est irréversible.');
                if (!ok) return;
            }
            sections.forEach(el => {
                try {
                    el.value = '';
                    // also clear any bound placeholder UI if present
                    if (typeof el.dataset !== 'undefined' && el.dataset.placeholder) {
                        // leave data-placeholder intact but remove visual content already cleared
                    }
                    el.dispatchEvent(new Event('input', { bubbles: true }));
                } catch (e) { /* noop */ }
            });
            // trigger layout and persistence
            try { resizeAllColumnSections(slide); } catch (e) { /* noop */ }
            try { schedulePersist(); } catch (e) { /* noop */ }
        }

        function applyColumnStageColor(stage, color) {
            const column = getActiveSlideElement()?.querySelector(`.column[data-stage="${stage}"]`);
            if (!column) return;
            column.style.setProperty("--stage-color", color);
            schedulePersist();
        }

        function applyBackgroundToActiveSlide(color) {
            const slide = getActiveSlideElement();
            if (!slide) return;
            applyBackgroundToSlide(slide, color);
            syncBackgroundSelector();
            document.documentElement.style.setProperty("--global-background", color);
        }

        function syncBackgroundSelector() {
            if (!backgroundSelector) return;
            const slide = getActiveSlideElement();
            if (!slide) return;
            const value = slide.dataset.bgColor ?? userDefaultBackground ?? "#ffffff";
            backgroundSelector.value = value === "transparent" ? "transparent" : "#ffffff";
        }

        function normalizeFontSize(value) {
            const parsed = Number(value);
            if (Number.isNaN(parsed)) {
                return currentFontSize;
            }
            return Math.max(8, Math.min(72, parsed));
        }

        function syncFontControls() {
            if (fontSelect) {
                fontSelect.value = currentTextStyleIndex;
            }
            if (fontSizeInput) {
                fontSizeInput.value = currentFontSize;
            }
        }

        function handleFontSizeChange(value) {
            const normalized = normalizeFontSize(value);
            if (normalized === currentFontSize && Number(value) === normalized) {
                return;
            }
            currentFontSize = normalized;
            if (fontSizeInput) {
                fontSizeInput.value = normalized;
            }
            const activeSlide = getActiveSlideElement();
            if (activeSlide) {
                applyTextStyleToSlide(activeSlide, currentTextStyleIndex, currentFontSize);
            }
        }

        function initSettingsMenu() {
            fontSelect.innerHTML = "";
            textStyles.forEach((style, index) => {
                const option = document.createElement("option");
                option.value = index;
                option.textContent = style.name;
                option.style.fontFamily = style.font;
                option.style.fontSize = `${style.size}px`;
                fontSelect.appendChild(option);
            });

            ratioGrid.innerHTML = "";
            ratioButtons.length = 0;
            ratioOptions.forEach((ratio, index) => {
                const btn = document.createElement("button");
                btn.type = "button";
                btn.className = "ratio-option btn";
                btn.dataset.index = index;
                btn.textContent = ratio.name;
                btn.addEventListener("click", () => {
                    applyRatio(index);
                });
                ratioButtons.push(btn);
                ratioGrid.appendChild(btn);
            });

            fontSelect.addEventListener("change", () => {
                currentTextStyleIndex = parseInt(fontSelect.value, 10);
                const activeSlide = getActiveSlideElement();
                if (activeSlide) {
                    applyTextStyleToSlide(activeSlide, currentTextStyleIndex, currentFontSize);
                }
            });
            fontSizeInput.addEventListener("change", () => handleFontSizeChange(fontSizeInput.value));
            Array.from(fontSizeInput.options).forEach(opt => {
                opt.style.fontSize = `${opt.value}px`;
            });
            backgroundSelector.addEventListener("change", () => {
                applyBackgroundToActiveSlide(backgroundSelector.value);
            });

            syncFontControls();
            syncBackgroundSelector();
            updateRatioButtons();
        }

        function toggleSettingsMenu() {
            syncFontControls();
            syncBackgroundSelector();
            toggleMenu(settingsMenu);
        }

        initSettingsMenu();

        function updateRatioButtons() {
            ratioButtons.forEach((button, index) => {
                button.classList.toggle("active", index === currentRatioIndex);
            });
        }

        function parseHexColor(value) {
            const hex = value.replace(/^#/, "");
            if (hex.length !== 6) return null;
            return {
                r: parseInt(hex.slice(0, 2), 16),
                g: parseInt(hex.slice(2, 4), 16),
                b: parseInt(hex.slice(4, 6), 16)
            };
        }

        function getBrightnessFromColor(value) {
            const parsed = parseHexColor(value);
            if (!parsed) return 1;
            return (parsed.r * 299 + parsed.g * 587 + parsed.b * 114) / 1000 / 255;
        }

        function getTextColorForBackground(value) {
            if (!value || value === "transparent") {
                return "#2f2922";
            }
            if (value.startsWith("linear-gradient")) {
                const match = value.match(/#([0-9a-fA-F]{6})/);
                if (match) {
                    value = `#${match[1]}`;
                }
            }
            const brightness = getBrightnessFromColor(value);
            return brightness < 0.6 ? "#ffffff" : "#2f2922";
        }

        function setSlideTextColor(slide, color) {
            const textColor = getTextColorForBackground(color);
            slide.style.setProperty("--slide-text-color", textColor);
        }

        function applyBackgroundToSlide(slide, color) {
            const normalized = color || userDefaultBackground || "#ffffff";
            slide.dataset.bgColor = normalized;
            slide.style.setProperty("--slide-bg", normalized);
            setSlideTextColor(slide, normalized);
            schedulePersist();
        }

        function applyTextStyleToSlide(slide, styleIndex, size = currentFontSize) {
            const style = textStyles[styleIndex] || textStyles[0];
            const fontSize = typeof size === "number" ? size : currentFontSize;
            slide.dataset.textStyleIndex = styleIndex;
            slide.dataset.fontSize = fontSize;
            slide.style.setProperty("--slide-font-family", style.font);
            slide.style.setProperty("--slide-font-size", `${fontSize}px`);
            const labelSize = Math.max(fontSize - 2, 12);
            slide.style.setProperty("--slide-label-size", `${labelSize}px`);
            schedulePersist();
        }

        function applyRatio(index) {
            const ratio = ratioOptions[index] || ratioOptions[0];
            currentRatioIndex = index;
            document.documentElement.style.setProperty("--slide-aspect-ratio", ratio.css);
            document.documentElement.style.setProperty("--slide-width", ratio.width || "min(1180px, 100%)");
            if (ratio.ignoreHeightLimit) {
                document.documentElement.style.setProperty("--slide-height-width-limit", "10000px");
            } else {
                document.documentElement.style.removeProperty("--slide-height-width-limit");
            }
            updateRatioButtons();
            schedulePersist();
        }

        function collectSlidesFromDOM() {
            const slides = Array.from(slidesContainer.querySelectorAll(".slide"));
            return slides.map(slide => {
                const templateId = slide.dataset.templateId || templates[0].id;
                const columns = Array.from(slide.querySelectorAll(".column")).map(column => {
                    const columnTitleEl = column.querySelector(".column-title");
                    const columnTitle = columnTitleEl ? columnTitleEl.textContent.trim() : "";
                    const stageLabel = columnTitleEl ? columnTitleEl.textContent.trim() : column.dataset.stage || "";
                    const stageColor = column.style.getPropertyValue("--stage-color").trim();
                    const columnData = {
                        stage: column.dataset.stage,
                        stageLabel,
                        stageColor,
                        title: columnTitle,
                        sections: {}
                    };
                    column.querySelectorAll(".section").forEach(sectionEl => {
                        const sectionKey = sectionEl.dataset.section;
                        if (!sectionKey) {
                            return;
                        }
                        const label = sectionEl.querySelector(".section-label");
                        const textarea = sectionEl.querySelector("textarea");
                        const fallbackLabel = getDefaultSectionLabel(templateId, sectionKey);
                        const suggestionHint =
                            (label && (label.dataset.suggestions || label.title)) ||
                            (textarea && textarea.dataset.suggestionPlaceholder) ||
                            "";
                        columnData.sections[sectionKey] = {
                            label: label ? label.textContent.trim() : fallbackLabel,
                            text: textarea ? textarea.value : "",
                            suggestions: suggestionHint,
                            placeholder: textarea
                                ? textarea.dataset.suggestionPlaceholder ||
                                textarea.dataset.placeholder ||
                                ""
                                : ""
                        };
                    });
                    return columnData;
                });
                const bottomSectionEl = slide.querySelector(".slide-bottom-section");
                const bottomTextarea = bottomSectionEl?.querySelector(".bottom-section-text");
                const bottomSectionData = bottomSectionEl
                    ? { text: bottomTextarea?.value || "", deleted: false }
                    : { text: "", deleted: true };
                const titleEl = slide.querySelector(".slide-title-input");
                const fontSizeValue = parseInt(slide.dataset.fontSize, 10);
                return {
                    title: titleEl ? titleEl.value : getDefaultTitle(templateId),
                    templateId,
                    bgColor: slide.dataset.bgColor || "transparent",
                    textStyleIndex: parseStyleIndex(slide.dataset.textStyleIndex),
                    fontSize: Number.isNaN(fontSizeValue) ? currentFontSize : fontSizeValue,
                    columns,
                    pageContext: slide.dataset.pageContext || "",
                    bottomSection: bottomSectionData
                };
            });
        }

        function createColumn(templateId, columnIndex, seed = {}) {
            const column = document.createElement("div");
            column.className = "column";
            const columnConfig = getTemplateColumn(templateId, columnIndex);
            const stage = seed.stage || columnConfig.stage;
            column.dataset.stage = stage;
            const baseStageLabel = columnConfig.label;
            const fallbackStage = seed.stageLabel || baseStageLabel;
            const stageColor = seed.stageColor || stageColors[stage] || stageColors[columnConfig.stage] || "#ffffff";
            column.style.setProperty("--stage-color", stageColor);

            const sectionSeeds = seed.sections || null;
            const sectionKeys = sectionSeeds
                ? Object.keys(sectionSeeds)
                : getTemplateSections(templateId).map(section => section.key);
            const sectionsHtml = sectionKeys
                .map(sectionKey => {
                    const sectionMeta = getTemplateSection(templateId, sectionKey) || { label: sectionKey, examples: "" };
                    const exampleText = getSectionExample(templateId, stage, sectionKey) || sectionMeta.examples || "";
                    const placeholder = exampleText.replace(/"/g, '&quot;');
                    const labelText = sectionMeta.label || sectionKey;
                    return `
        <div class="section" data-section="${sectionKey}">
          <div class="section-label-row">
            <span class="section-label" data-section="${sectionKey}" contenteditable="true">${labelText}</span>
            <button type="button" class="section-delete-btn" aria-label="Supprimer la section">×</button>
          </div>
                    <div class="section-text-row">
                        <div class="textarea-wrapper">
                            <textarea class="editable" data-section="${sectionKey}" data-placeholder="${placeholder}"></textarea>
              <button class="field-ai-btn inside" type="button" data-field="section-text" data-section="${sectionKey}" title="Générer le contenu" aria-label="Générer le contenu">⌘</button>
            </div>
          </div>
        </div>
      `;
                })
                .join("");

            column.innerHTML = `
            <div class="column-header">
                <div class="column-header-main">
                    <div class="column-title-row">
                        <span class="column-title" contenteditable="true">${fallbackStage}</span>
                                                <button type="button" class="column-copy-btn" aria-label="Copier la colonne à droite">⧉</button>
                        <button type="button" class="column-delete-btn" aria-label="Supprimer la colonne">×</button>
                    </div>
                </div>
            </div>
            <div class="column-body">
                ${sectionsHtml}
            </div>
        `;

            const columnTitleEl = column.querySelector(".column-title");
            columnTitleEl.addEventListener("focus", () => {
                selectColumnForPalette(column);
                const selection = window.getSelection();
                if (selection) {
                    const range = document.createRange();
                    range.selectNodeContents(columnTitleEl);
                    selection.removeAllRanges();
                    selection.addRange(range);
                }
            });
            columnTitleEl.addEventListener("keydown", event => {
                if (event.key === "Enter") {
                    event.preventDefault();
                    columnTitleEl.blur();
                }
            });
            columnTitleEl.addEventListener("blur", () => {
                if (!columnTitleEl.textContent.trim()) {
                    columnTitleEl.textContent = fallbackStage;
                }
            });

            column.querySelectorAll(".section-label").forEach(bindSectionLabel);

            column.querySelectorAll(".section").forEach(sectionEl => {
                const sectionKey = sectionEl.dataset.section;
                const label = sectionEl.querySelector(".section-label");
                const textarea = sectionEl.querySelector("textarea");
                const textareaWrapper = sectionEl.querySelector(".textarea-wrapper");
                const stageForSection = column.dataset.stage;
                const sectionSeed = seed.sections && sectionKey ? seed.sections[sectionKey] : null;
                if (label) {
                    const defaultLabel = getDefaultSectionLabel(templateId, sectionKey);
                    label.textContent = sectionSeed?.label || defaultLabel;
                }
                if (textarea) {
                    const sectionMeta = getTemplateSection(templateId, sectionKey) || { examples: "" };
                    const exampleText =
                        getSectionExample(templateId, stageForSection, sectionKey) || sectionMeta.examples || "";
                    const placeholderValue = ((sectionSeed && sectionSeed.placeholder) || exampleText || "").replace(/🗹/g, "☐");
                    textarea.dataset.placeholder = placeholderValue;
                    // Intentionally leave the visible `placeholder` empty.
                    textarea.placeholder = "";
                    if (sectionSeed) {
                        textarea.value = sectionSeed.text || "";
                        const suggestionValue = sectionSeed.suggestions || "";
                        if (suggestionValue) {
                            if (label) {
                                label.classList.add("has-suggestion");
                                label.dataset.suggestions = suggestionValue;
                            }
                            textarea.dataset.suggestionPlaceholder = suggestionValue;
                        }
                    }
                    sectionCriteriaSentenceCount.set(textarea, countCompletedSentences(textarea.value || ""));
                    sectionCriteriaLastText.set(textarea, textarea.value || "");
                    monitorTextareaOverflow(textarea);
                }
                const deleteBtn = sectionEl.querySelector(".section-delete-btn");
                deleteBtn?.addEventListener("click", event => {
                    event.stopPropagation();
                    deleteSection(sectionEl);
                });
            });
            const columnDeleteBtn = column.querySelector(".column-delete-btn");
            columnDeleteBtn?.addEventListener("click", event => {
                event.stopPropagation();
                deleteColumn(column);
            });
            const columnCopyBtn = column.querySelector(".column-copy-btn");
            columnCopyBtn?.addEventListener("click", event => {
                event.stopPropagation();
                copyColumnToRight(column);
            });

            // Always display textarea suggestion placeholders for this column
            showColumnPlaceholders(column);
            column.addEventListener("focusin", () => {
                column.classList.add("column-focused");
            });
            column.addEventListener("focusout", () => {
                column.classList.remove("column-focused");
            });

            column.querySelectorAll("textarea").forEach(bindTextareaPlaceholder);

            column.addEventListener("click", () => {
                selectColumnForPalette(column);
            });

            requestAnimationFrame(() => redistributeSectionHeights(column));
            return column;
        }

        function deleteColumn(column) {
            if (!column) return;
            if (!confirm("Supprimer cette colonne ?")) {
                return;
            }
            const slide = column.closest(".slide");
            const nextColumn = column.nextElementSibling || column.previousElementSibling;
            column.remove();
            if (nextColumn) {
                selectColumnForPalette(nextColumn);
                nextColumn.querySelector(".column-title")?.focus();
            } else {
                selectColumnForPalette(null);
            }
            resizeAllColumnSections(slide);
            schedulePersist();
        }

        function copyColumnToRight(column) {
            if (!column) return;
            const slide = column.closest('.slide');
            const templateId = slide?.dataset.templateId || currentTemplateId || null;
            const columnsContainer = column.parentElement;
            if (!columnsContainer) return;

            const stage = column.dataset.stage;
            const stageLabel = column.querySelector('.column-title')?.textContent || '';
            const stageColor = column.style.getPropertyValue('--stage-color') || '';

            const sectionsSeed = {};
            Array.from(column.querySelectorAll('.section')).forEach(sectionEl => {
                const key = sectionEl.dataset.section;
                const label = sectionEl.querySelector('.section-label')?.textContent || getDefaultSectionLabel(templateId, key) || key;
                sectionsSeed[key] = { label, text: '' };
            });

            const seed = {
                stage: stage,
                stageLabel: stageLabel,
                stageColor: stageColor,
                sections: sectionsSeed
            };

            const templateColumns = getTemplateColumns(templateId);
            let columnIndex = -1;
            if (Array.isArray(templateColumns)) {
                columnIndex = templateColumns.findIndex(c => c.stage === stage);
            }
            if (columnIndex === -1) {
                columnIndex = Array.from(columnsContainer.children).indexOf(column);
            }

            const newColumn = createColumn(templateId, columnIndex, seed);
            if (column.nextElementSibling) {
                columnsContainer.insertBefore(newColumn, column.nextElementSibling);
            } else {
                columnsContainer.appendChild(newColumn);
            }
            selectColumnForPalette(newColumn);
            newColumn.querySelector('.column-title')?.focus();
            schedulePersist();
        }

        function deleteSection(sectionEl) {
            if (!sectionEl) return;
            if (!confirm("Supprimer cette section ?")) {
                return;
            }
            const column = sectionEl.closest(".column");
            const nextSection = sectionEl.nextElementSibling || sectionEl.previousElementSibling;
            sectionEl.remove();
            redistributeSectionHeights(column);
            if (nextSection) {
                nextSection.querySelector(".section-label")?.focus();
            } else if (column) {
                column.querySelector(".column-title")?.focus();
            }
            schedulePersist();
        }

        function createSectionElement(templateId, sectionKey, stage, seed = {}) {
            const sectionMeta = getTemplateSection(templateId, sectionKey) || { label: sectionKey, examples: "" };
            const exampleText = getSectionExample(templateId, stage, sectionKey) || sectionMeta.examples || "";
            const placeholder = exampleText.replace(/"/g, '&quot;');
            const labelText = seed.label || sectionMeta.label || sectionKey;

            const section = document.createElement("div");
            section.className = "section";
            section.dataset.section = sectionKey;

            const labelRow = document.createElement("div");
            labelRow.className = "section-label-row";
            const labelSpan = document.createElement("span");
            labelSpan.className = "section-label";
            labelSpan.dataset.section = sectionKey;
            labelSpan.contentEditable = "true";
            labelSpan.textContent = labelText;
            const deleteBtn = document.createElement("button");
            deleteBtn.type = "button";
            deleteBtn.className = "section-delete-btn";
            deleteBtn.setAttribute("aria-label", "Supprimer la section");
            deleteBtn.textContent = "×";
            labelRow.append(labelSpan, deleteBtn);

            const textRow = document.createElement("div");
            textRow.className = "section-text-row";
            const textareaWrapper = document.createElement("div");
            textareaWrapper.className = "textarea-wrapper";
            const textarea = document.createElement("textarea");
            textarea.className = "editable";
            textarea.dataset.section = sectionKey;
            textarea.dataset.placeholder = placeholder.replace(/🗹/g, "☐");
            // Keep placeholder empty by default; examples live in data-placeholder only.
            textarea.placeholder = "";
            textarea.value = seed.text || "";
            const suggestionValue = seed.suggestions || "";
            if (suggestionValue) {
                labelSpan.dataset.suggestions = suggestionValue;
                textarea.dataset.suggestionPlaceholder = suggestionValue;
            }
            const aiButton = document.createElement("button");
            aiButton.type = "button";
            aiButton.className = "field-ai-btn inside";
            aiButton.dataset.field = "section-text";
            aiButton.dataset.section = sectionKey;
            aiButton.title = "Générer le contenu";
            aiButton.setAttribute("aria-label", "Générer le contenu");
            aiButton.textContent = "⌘";
            textareaWrapper.append(textarea, aiButton);
            textRow.appendChild(textareaWrapper);

            section.append(labelRow, textRow);

            bindSectionLabel(labelSpan);
            monitorTextareaOverflow(textarea);
            sectionCriteriaSentenceCount.set(textarea, countCompletedSentences(textarea.value || ""));
            sectionCriteriaLastText.set(textarea, textarea.value || "");
            deleteBtn.addEventListener("click", event => {
                event.stopPropagation();
                deleteSection(section);
            });
            requestAnimationFrame(() => redistributeSectionHeights(section.closest(".column")));
            return section;
        }

        function ensureColumnSections(column, templateId) {
            if (!column) return;
            const columnBody = column.querySelector(".column-body");
            if (!columnBody) return;
            const templateSections = getTemplateSections(templateId);
            const stage = column.dataset.stage;
            templateSections.forEach(sectionMeta => {
                let sectionEl = columnBody.querySelector(`.section[data-section="${sectionMeta.key}"]`);
                if (!sectionEl) {
                    sectionEl = createSectionElement(templateId, sectionMeta.key, stage);
                    columnBody.appendChild(sectionEl);
                }
            });
        }

        function insertColumnAtOrder(columnsContainer, newColumn, templateColumns, columnIndex) {
            const upcoming = templateColumns.slice(columnIndex + 1);
            for (const nextConfig of upcoming) {
                const nextColumn = columnsContainer.querySelector(`.column[data-stage="${nextConfig.stage}"]`);
                if (nextColumn) {
                    columnsContainer.insertBefore(newColumn, nextColumn);
                    return;
                }
            }
            columnsContainer.appendChild(newColumn);
        }

        function captureSlideSnapshot(slide) {
            if (!slide) return { columns: [], bottom: "" };
            const columns = Array.from(slide.querySelectorAll(".column")).map(column => {
                const values = Array.from(column.querySelectorAll(".section textarea"))
                    .map(textarea => textarea.value);
                return { values };
            });
            const bottom = slide.querySelector(".bottom-section-text")?.value || "";
            return { columns, bottom };
        }

        function applyTemplateToActiveSlide(templateId) {
            const slide = getActiveSlideElement();
            if (!slide) return;
            const template = getTemplateById(templateId);
            if (!template) return;
            if (template.id && !templateCriteriaStatus[template.id]) {
                templateCriteriaStatus[template.id] = {};
            }
            const snapshot = captureSlideSnapshot(slide);
            const columnsContainer = slide.querySelector(".columns");
            if (!columnsContainer) return;

            columnsContainer.innerHTML = "";
            template.columns.forEach((columnConfig, columnIndex) => {
                const sectionSeeds = {};
                template.sections.forEach((sectionMeta, sectionIndex) => {
                    const preservedValue = snapshot.columns[columnIndex]?.values?.[sectionIndex] || "";
                    sectionSeeds[sectionMeta.key] = {
                        label: sectionMeta.label,
                        text: preservedValue
                    };
                });
                const seed = {
                    stage: columnConfig.stage,
                    stageLabel: columnConfig.label,
                    stageColor: stageColors[columnConfig.stage] || "#ffffff",
                    sections: sectionSeeds
                };
                const columnEl = createColumn(template.id, columnIndex, seed);
                columnsContainer.appendChild(columnEl);
            });

            const firstColumn = columnsContainer.querySelector(".column");
            if (firstColumn) {
                selectColumnForPalette(firstColumn);
            }

            const cleanTitle = (template.defaultTitle || "").trim() || (template.name || "").replace(/^\s*[^\w]+\s*/, "").trim();
            const titleInput = slide.querySelector(".slide-title-input");
            if (titleInput && cleanTitle) {
                titleInput.value = cleanTitle;
            }
            if (cleanTitle) {
                // Set slide title but DO NOT overwrite the tab label (user requested)
                slide.dataset.title = cleanTitle;
                if (titleInput) {
                    // keep title input updated (visible in slide header)
                    titleInput.value = cleanTitle;
                }
            }

            slide.dataset.templateId = template.id;
            currentTemplateId = template.id;
            lastAppliedTemplateId = template.id;
            activePromptTemplateId = template.id;
            setPromptFieldsForTemplate(template.id);
            updateSelectedTemplateLabelDisplay();
            triggerCriteriaAnalysis({ force: Boolean(pageContextField?.value?.trim()) });
            schedulePersist();
        }

        function restoreColumnsAndSections() {
            const slide = getActiveSlideElement();
            if (!slide) return;
            const templateId = slide.dataset.templateId || templates[0].id;
            const columnsContainer = slide.querySelector(".columns");
            if (!columnsContainer) return;
            const templateColumns = getTemplateColumns(templateId);
            templateColumns.forEach((columnConfig, columnIndex) => {
                let column = columnsContainer.querySelector(`.column[data-stage="${columnConfig.stage}"]`);
                if (!column) {
                    const seed = {
                        stage: columnConfig.stage,
                        stageLabel: columnConfig.label,
                        stageColor: stageColors[columnConfig.stage] || "#ffffff"
                    };
                    column = createColumn(templateId, columnIndex, seed);
                    insertColumnAtOrder(columnsContainer, column, templateColumns, columnIndex);
                }
                ensureColumnSections(column, templateId);
            });
            schedulePersist();
            updateSlideEmptyState();
            requestAnimationFrame(() => resizeAllColumnSections(slide));
        }

        function setBottomSectionFocusState(slide, focused) {
            const bottomSection = slide.querySelector(".slide-bottom-section");
            if (!bottomSection) return;
            bottomSection.classList.toggle("bottom-section-focused", Boolean(focused));
        }

        function deleteBottomSection(slide) {
            if (!slide) return;
            const bottomSection = slide.querySelector(".slide-bottom-section");
            if (!bottomSection) return;
            if (!confirm("Supprimer la synthèse ?")) {
                return;
            }
            bottomSection.remove();
            schedulePersist();
        }

        function createSlide(index, seed = {}) {
            const slide = document.createElement("div");
            slide.className = "slide";
            slide.dataset.index = index;
            const incomingTemplateId = seed.templateId || "";
            const templateId = templates.some(t => t.id === incomingTemplateId) ? incomingTemplateId : templates[0].id;
            const titleValue = (seed.title || getDefaultTitle(templateId)).replace(/"/g, '&quot;');
            const subtitleValue = (seed.subtitle || defaultSubtitle).replace(/"/g, '&quot;');
            slide.dataset.templateId = templateId;
            slide.dataset.tabLabel = seed.tabLabel || `Bloc ${index + 1}`;
            slide.dataset.pageContext = seed.pageContext ?? seed.context ?? "";
            const hasBottomSection = !seed.bottomSection?.deleted;
            const bottomSectionMarkup = hasBottomSection
                ? `
  <div class="slide-bottom-section">
    <div class="bottom-section-header">
      <span class="bottom-section-title"></span>
    <button type="button" class="bottom-section-delete" aria-label="Supprimer la synthèse">×</button>
    </div>
    <div class="textarea-wrapper">
      <textarea class="editable bottom-section-text" rows="3"></textarea>
    <button class="field-ai-btn inside" type="button" data-section="bottom-section" title="Générer la synthèse IA" aria-label="Synthèse IA">⌘</button>
    </div>
  </div>
  `
                : "";
            slide.innerHTML = `
  <div class="slide-header">
    <div class="slide-title-row">
      <input class="slide-title-input" type="text" value="${titleValue}">
    </div>
  </div>
  <div class="slide-body">
    <div class="columns"></div>
  </div>
  ${bottomSectionMarkup}
`;
            const columnsContainer = slide.querySelector(".columns");
            const templateColumns = getTemplateColumns(templateId);
            const storedColumns = Array.isArray(seed.columns) ? seed.columns : null;
            const columnsToRender = storedColumns && storedColumns.length
                ? storedColumns
                : templateColumns.map(columnConfig => ({ stage: columnConfig.stage, stageLabel: columnConfig.label }));
            columnsToRender.forEach((columnSeed, columnIndex) => {
                columnsContainer.appendChild(createColumn(templateId, columnIndex, columnSeed));
            });
            columnsContainer.querySelectorAll(".column").forEach((column, columnIndex) => {
                const columnTitle = column.querySelector(".column-title");
                if (!columnTitle.textContent.trim()) {
                    const seedLabel = columnsToRender[columnIndex]?.stageLabel;
                    columnTitle.textContent = seedLabel || templateColumns[columnIndex]?.label || `Colonne ${columnIndex + 1}`;
                }
            });

            columnsContainer.addEventListener("click", event => {
                const targetColumn = event.target.closest(".column");
                if (targetColumn) {
                    selectColumnForPalette(targetColumn);
                }
            });
            const bottomTextarea = slide.querySelector(".bottom-section-text");
            if (bottomTextarea) {
                bottomTextarea.value = (seed.bottomSection && seed.bottomSection.text) || "";
                // Use template-specific placeholder if available, otherwise fall back
                // to the existing generic placeholder text.
                const slideTemplateId = slide.dataset.templateId || templates[0].id;
                const slideTemplate = getTemplateById(slideTemplateId);
                const bottomPlaceholder = (slideTemplate && slideTemplate.bottomPlaceholder) || bottomSectionPlaceholderText;
                // No native tooltip for the bottom textarea (keep empty / placeholder-driven)
                bindTextareaPlaceholder(bottomTextarea);
                monitorTextareaOverflow(bottomTextarea);
                bottomTextarea.addEventListener("input", () => schedulePersist());
                bottomTextarea.addEventListener("focus", () => setBottomSectionFocusState(slide, true));
                bottomTextarea.addEventListener("blur", () => setBottomSectionFocusState(slide, false));
                const bottomDeleteBtn = slide.querySelector(".bottom-section-delete");
                bottomDeleteBtn?.addEventListener("click", event => {
                    event.stopPropagation();
                    deleteBottomSection(slide);
                });
            }
            const bgColor = seed.bgColor ?? "transparent";
            applyBackgroundToSlide(slide, bgColor);
            const styleIndex = typeof seed.textStyleIndex === "number" ? seed.textStyleIndex : currentTextStyleIndex;
            const fontSize = typeof seed.fontSize === "number" ? seed.fontSize : currentFontSize;
            applyTextStyleToSlide(slide, styleIndex, fontSize);
            requestAnimationFrame(() => resizeAllColumnSections(slide));
            return slide;
        }

        function renderSlides() {
            slidesContainer.innerHTML = "";
            slideCount = 0;
            const slidesToRender = [];
            templates.forEach(template => {
                const slides = templateSlides[template.id] || [];
                slides.forEach(slideData => {
                    slidesToRender.push(slideData);
                });
            });
            slidesToRender.forEach((slideData, index) => {
                const slide = createSlide(index, slideData);
                slidesContainer.appendChild(slide);
                slideCount++;
            });
            refreshTabs();
            setActiveTab(0);
            scheduleSlideClampUpdate();
        }

        function storeCurrentSlides() {
            const slides = collectSlidesFromDOM();
            const map = templates.reduce((acc, template) => {
                acc[template.id] = [];
                return acc;
            }, {});
            slides.forEach(slide => {
                const incomingId = slide.templateId || "";
                const templateId = templates.some(t => t.id === incomingId) ? incomingId : templates[0].id;
                slide.templateId = templateId;
                if (!map[templateId]) {
                    map[templateId] = [];
                }
                map[templateId].push(slide);
            });
            templates.forEach(template => {
                if (!map[template.id].length) {
                    map[template.id].push({ templateId: template.id });
                }
            });
            templateSlides = map;
        }

        function createTabButton(index) {
            const btn = document.createElement("button");
            btn.className = "tab";
            btn.dataset.index = index;
            const slide = slidesContainer.querySelector(`.slide[data-index="${index}"]`);
            const label = (slide?.dataset.tabLabel || `Bloc ${index + 1}`).trim();
            btn.textContent = label;
            btn.addEventListener("click", () => setActiveTab(index));
            btn.addEventListener("dblclick", () => {
                const newName = prompt("Renommer l'onglet", btn.textContent);
                if (!newName) return;
                btn.textContent = newName;
                if (slide) {
                    slide.dataset.tabLabel = newName;
                }
            });
            tabsContainer.appendChild(btn);
        }

        function refreshTabs() {
            tabsContainer.innerHTML = "";
            const slides = slidesContainer.querySelectorAll(".slide");
            slides.forEach((slide, idx) => {
                slide.dataset.index = idx;
                createTabButton(idx);
            });
            slideCount = slides.length;
            updateDeleteButtonState();
            scheduleSlideClampUpdate();
        }

        function getSlidePageContext(slide) {
            return slide?.dataset.pageContext || "";
        }

        function getActivePageContext(targetSlide) {
            const slide = targetSlide || getActiveSlideElement();
            return getSlidePageContext(slide);
        }

        function setActivePageContext(value) {
            const slide = getActiveSlideElement();
            if (!slide) return;
            slide.dataset.pageContext = value || "";
        }

        function syncPageContextFieldWithActiveSlide() {
            if (!pageContextField) return;
            const contextValue = getActivePageContext();
            if (pageContextField.value !== contextValue) {
                pageContextField.value = contextValue;
            }
        }

        function isSlideEmpty(slide) {
            if (!slide) return true;
            const columns = slide.querySelectorAll(".column");
            if (!columns.length) return true;
            for (const column of columns) {
                const title = column.querySelector(".column-title")?.textContent.trim();
                if (title) return false;
                const textareas = column.querySelectorAll("textarea");
                for (const textarea of textareas) {
                    if (textarea.value.trim()) {
                        return false;
                    }
                }
            }
            return true;
        }

        function updateSlideEmptyState() {
            if (!slideEmptyState) return;
            const activeSlide = getActiveSlideElement();
            const shouldShow = isSlideEmpty(activeSlide);
            slideEmptyState.classList.toggle("visible", shouldShow);
        }

        function setActiveTab(index) {
            closeContextMenus();
            activeIndex = index;
            const slides = slidesContainer.querySelectorAll(".slide");
            const tabBtns = tabsContainer.querySelectorAll(".tab");
            slides.forEach(s => {
                s.classList.toggle("hidden", s.dataset.index != index);
            });
            tabBtns.forEach(b => {
                b.classList.toggle("active", b.dataset.index == index);
            });
            const activeSlide = slidesContainer.querySelector(`.slide[data-index="${index}"]`);
            const firstColumn = activeSlide ? activeSlide.querySelector(".column") : null;
            if (firstColumn) {
                selectColumnForPalette(firstColumn);
            }
            if (activeSlide) {
                currentTextStyleIndex = parseStyleIndex(activeSlide.dataset.textStyleIndex);
                currentFontSize = normalizeFontSize(activeSlide.dataset.fontSize ?? currentFontSize);
                syncFontControls();
                syncBackgroundSelector();
                currentTemplateId = activeSlide.dataset.templateId || templates[0].id;
                lastAppliedTemplateId = currentTemplateId;
            }
            setPromptFieldsForTemplate(currentTemplateId);
            syncPageContextFieldWithActiveSlide();
            updateSlideEmptyState();
            updateSelectedTemplateLabelDisplay();
            triggerCriteriaAnalysis({ force: Boolean(pageContextField?.value?.trim()) });
            requestAnimationFrame(() => resizeAllColumnSections(activeSlide));
        }

        function buildColumnSeeds(slide, options = {}) {
            if (!slide) {
                return [];
            }
            const includeText = options.includeText !== false;
            return Array.from(slide.querySelectorAll(".column")).map((column, columnIndex) => {
                const templateId = slide.dataset.templateId || templates[0].id;
                const columnTitleEl = column.querySelector(".column-title");
                const stageLabel = columnTitleEl ? columnTitleEl.textContent.trim() : column.dataset.stage || "";
                const columnStage = column.dataset.stage || getTemplateColumn(templateId, columnIndex).stage;
                const stageColor = column.style.getPropertyValue("--stage-color").trim() || "#ffffff";
                const sections = {};
                column.querySelectorAll(".section").forEach(sectionEl => {
                    const sectionKey = sectionEl.dataset.section;
                    if (!sectionKey) {
                        return;
                    }
                    const label = sectionEl.querySelector(".section-label");
                    const textarea = sectionEl.querySelector("textarea");
                    const fallbackLabel = getDefaultSectionLabel(templateId, sectionKey);
                    const suggestionHint = label?.dataset.suggestions || label?.title || textarea?.dataset.suggestionPlaceholder || "";
                    sections[sectionKey] = {
                        label: label ? (label.textContent.trim() || fallbackLabel) : fallbackLabel,
                        text: textarea ? (includeText ? textarea.value : "") : "",
                        suggestions: suggestionHint
                    };
                });
                return { stage: columnStage, stageLabel, stageColor, sections };
            });
        }

        function getDefaultFromCurrentSlide() {
            const slide = slidesContainer.querySelector(`.slide[data-index="${activeIndex}"]`);
            if (!slide) {
                return null;
            }
            const titleEl = slide.querySelector(".slide-title-input");
            const subtitleEl = slide.querySelector(".slide-subtitle-input");
            const bgColor = slide.dataset.bgColor || "#ffffff";
            const textStyleIndex = parseStyleIndex(slide.dataset.textStyleIndex);
            const fontSize = normalizeFontSize(slide.dataset.fontSize ?? currentFontSize);
            const columns = buildColumnSeeds(slide, { includeText: false });
            const templateId = slide.dataset.templateId || templates[0].id;
            const bottomSectionEl = slide.querySelector(".slide-bottom-section");
            return {
                title: titleEl?.value || getDefaultTitle(templateId),
                subtitle: subtitleEl?.value || defaultSubtitle,
                bgColor,
                textStyleIndex,
                fontSize,
                templateId,
                columns,
                bottomSection: {
                    text: bottomSectionEl?.querySelector(".bottom-section-text")?.value || "",
                    deleted: !Boolean(bottomSectionEl)
                }
            };
        }

        function getDefaultFromLastSlide() {
            if (slideCount === 0) {
                return {
                    title: getDefaultTitle(templates[0].id),
                    subtitle: defaultSubtitle,
                    templateId: templates[0].id,
                    bgColor: "transparent",
                    textStyleIndex: currentTextStyleIndex,
                    fontSize: currentFontSize,
                    bottomSection: {
                        text: "",
                        deleted: false
                    }
                };
            }
            const previousSlide = slidesContainer.querySelector(`.slide[data-index="${slideCount - 1}"]`);
            if (!previousSlide) {
                return {
                    title: getDefaultTitle(templates[0].id),
                    subtitle: defaultSubtitle,
                    templateId: templates[0].id,
                    bgColor: "transparent",
                    textStyleIndex: currentTextStyleIndex,
                    fontSize: currentFontSize,
                    bottomSection: {
                        text: ""
                    }
                };
            }
            const prevTitleEl = previousSlide.querySelector(".slide-title-input");
            const prevSubtitleEl = previousSlide.querySelector(".slide-subtitle-input");
            const prevTemplateId = previousSlide.dataset.templateId || templates[0].id;
            return {
                title: prevTitleEl ? prevTitleEl.value : getDefaultTitle(prevTemplateId),
                subtitle: prevSubtitleEl ? prevSubtitleEl.value : defaultSubtitle,
                templateId: prevTemplateId,
                bgColor: previousSlide.dataset.bgColor || "transparent",
                textStyleIndex: parseStyleIndex(previousSlide.dataset.textStyleIndex),
                fontSize: normalizeFontSize(previousSlide.dataset.fontSize ?? currentFontSize),
                columns: buildColumnSeeds(previousSlide, { includeText: false }),
                bottomSection: {
                    text: previousSlide.querySelector(".bottom-section-text")?.value || "",
                    deleted: !Boolean(previousSlide.querySelector(".slide-bottom-section"))
                }
            };
        }

        function addTab() {
            const idx = slideCount;
            const seed = getDefaultFromCurrentSlide() || getDefaultFromLastSlide();
            const slide = createSlide(idx, seed);
            slidesContainer.appendChild(slide);
            createTabButton(idx);
            slideCount++;
            updateDeleteButtonState();
            setActiveTab(idx);
            // Auto-open Gutenberg on creation when on desktop
            try {
                if (isDesktopGutenberg()) {
                    setGutenbergOpen(true);
                }
            } catch (err) {
                /* noop */
            }
            schedulePersist();
            if (!hasPromptzillaOpenedForNewSlide) {
                hasPromptzillaOpenedForNewSlide = true;
                openTemplateModal();
            }
        }

        function updateDeleteButtonState() {
            deleteTabBtn.disabled = slideCount <= 1;
        }

        addTabBtn.addEventListener("click", addTab);
        restoreStructureBtn?.addEventListener("click", () => {
            restoreColumnsAndSections();
        });
        generateFullSlideBtn?.addEventListener("click", () => {
            generateFullSlideContent();
        });

        templateBtn?.addEventListener("click", () => {
            closeContextMenus();
            openTemplateModal();
        });

        templateApplyBtn?.addEventListener("click", () => {
            const templateId = selectedTemplateId || templates[0].id;
            handleTemplateSelection(templateId);
            applyTemplateToActiveSlide(templateId);
            closeTemplateModal();
        });



        templateModal?.addEventListener("click", event => {
            if (event.target === templateModal) {
                closeTemplateModal();
            }
        });

        templateModal?.querySelectorAll(".modal-close").forEach(btn => {
            btn.addEventListener("click", () => closeTemplateModal());
        });


        function clearActiveSlide(options = {}) {
            const clearRecits = !!options.clearRecits;
            const slide = slidesContainer.querySelector(`.slide[data-index="${activeIndex}"]`);
            if (!slide) return;
            slide.querySelectorAll(".editable").forEach(el => {
                if (el.tagName === "TEXTAREA" || el.tagName === "INPUT") {
                    el.value = "";
                } else {
                    el.textContent = "";
                }
            });
            const bottomSection = slide.querySelector(".bottom-section-text");
            if (bottomSection) bottomSection.value = "";
            if (clearRecits) {
                if (globalContextField) globalContextField.value = "";
                if (pageContextField) pageContextField.value = "";
                slide.dataset.pageContext = "";
            }
        }

        deleteTabBtn.addEventListener("click", () => {
            const slide = slidesContainer.querySelector(`.slide[data-index="${activeIndex}"]`);
            if (!slide) return;
            if (slideCount <= 1) return;
            const label = (slide.dataset.tabLabel || `Bloc ${activeIndex + 1}`).trim();
            if (!confirm(`Supprimer la vue '${label}' ? Cette action est irréversible.`)) {
                return;
            }
            slide.remove();
            slideCount--;
            refreshTabs();
            if (activeIndex >= slideCount) {
                activeIndex = slideCount - 1;
            }
            setActiveTab(activeIndex);
            schedulePersist();
        });

        textStyleBtn.addEventListener("click", event => {
            event.stopPropagation();
            toggleSettingsMenu();
        });
        fileMenuBtn?.addEventListener("click", event => {
            event.stopPropagation();
            toggleMenu(fileMenu);
        });

        if (applyPromptToAllBtn) {
            applyPromptToAllBtn.addEventListener("click", () => {
                const sourceValue = (lastFocusedPromptTextarea?.value ?? mainPromptField?.value ?? "").trim();
                const promptValue = sourceValue || defaultPromptTemplate;
                const bottomValue = bottomPromptField?.value || bottomSectionDefaultPrompt;
                const suggestionValue = suggestionPromptField?.value || defaultSuggestionsPrompt;
                const modeKey = promptKeyFromMode(activeIaMode);
                templates.forEach(template => {
                    const library = promptLibrary[template.id] || {};
                    library[modeKey] = promptValue;
                    library.bottom = bottomValue;
                    library.suggestions = suggestionValue;
                    promptLibrary[template.id] = library;
                });
                setPromptFieldsForTemplate(activePromptTemplateId);
                schedulePersist();
            });
        }

        if (resetPromptsBtn) {
            resetPromptsBtn.addEventListener("click", () => {
                templates.forEach(template => {
                    promptLibrary[template.id] = {
                        express: defaultPromptTemplate,
                        lab: defaultPromptTemplate,
                        bottom: bottomSectionDefaultPrompt,
                        suggestions: defaultSuggestionsPrompt
                    };
                });
                setPromptFieldsForTemplate(activePromptTemplateId);
                schedulePersist();
            });
        }

        importJsonBtn.addEventListener("click", () => {
            importInput.value = "";
            importInput.click();
            closeContextMenus();
        });

        importInput.addEventListener("change", event => {
            const files = event.target.files;
            const file = files && files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = () => {
                try {
                    const parsed = JSON.parse(reader.result);
                    const payload = Array.isArray(parsed) ? { slides: parsed, settings: {} } : parsed;
                    importSlidesFromData(payload.slides ?? payload, payload.settings ?? {});
                } catch (err) {
                    alert("Import JSON invalide.");
                    console.error(err);
                }
            };
            reader.readAsText(file);
        });

        exportJsonBtn.addEventListener("click", () => {
            const data = collectAllSlides();
            const globalContextValue = globalContextField?.value || "";
            const payload = {
                slides: data,
                settings: {
                    ratioIndex: currentRatioIndex,
                    textStyleIndex: currentTextStyleIndex,
                    fontSize: currentFontSize,
                    apiKey: localStorage.getItem('go-toolkit-api-key') || '',
                    globalContext: globalContextValue,
                    context: globalContextValue,
                    prompts: promptLibrary,
                    promptTemplateId: activePromptTemplateId,
                    iaMode: activeIaMode,
                    defaultTemplateId: currentTemplateId
                }
            };
            const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = getExportFilename("json");
            link.click();
            URL.revokeObjectURL(link.href);
            closeContextMenus();
        });

        function getExportFilename(ext) {
            try {
                const rawTitle = (document.title || "export").toString().trim();
                const safe = rawTitle.replace(/[^a-z0-9\-_.]/gi, "_").replace(/_+/g, "_");
                const ts = new Date().toISOString().replace(/[:.]/g, "-");
                return `${safe}_${ts}.${ext}`;
            } catch (e) {
                return `export_${Date.now()}.${ext}`;
            }
        }

        function importSlidesFromData(slidesData, settings = {}) {
            const slideList = Array.isArray(slidesData) ? slidesData : [];
            initializeTemplateSlides(slideList);
            applySettingsFromPayload(settings);
            renderSlides();
            schedulePersist();
        }

        function renderTemplateTooltip(template, statusMap) {
            if (!canvasTemplateTooltip) return;
            const lines = GoToolkitTemplateCriteria.renderTooltipLines(template, statusMap);
            canvasTemplateTooltip.innerHTML = lines.join("<br>");
            canvasTemplateTooltip.setAttribute("aria-hidden", lines.length ? "false" : "true");
        }

        function updateSelectedTemplateLabelDisplay() {
            const tpl = getActiveTemplate();
            if (selectedTemplateLabelEl) {
                selectedTemplateLabelEl.textContent = tpl ? `Modèle : ${tpl.name || tpl.defaultTitle || tpl.id}` : "";
            }
            if (tpl && tpl.id) {
                const status = templateCriteriaStatus[tpl.id] || null;
                renderTemplateTooltip(tpl, status);
            }
        }

        function countCompletedSentences(text) {
            return GoToolkitTemplateCriteria.countCompletedSentences(text);
        }

        async function analyzePromptCriteria(text, template) {
            if (!template || !template.id) return;
            const criteria = getTemplateCriteria(template);
            if (!criteria.length) return;
            if (criteriaAnalysisAbortController) {
                try { criteriaAnalysisAbortController.abort(); } catch (e) { /* noop */ }
            }
            const controller = new AbortController();
            criteriaAnalysisAbortController = controller;
            const apiKey = (readSharedApiKey() || "").trim();
            const useProxy = !apiKey;
            const endpoint = useProxy
                ? GoToolkitTemplateCriteria.DEFAULT_PROXY_ENDPOINT
                : GoToolkitTemplateCriteria.DEFAULT_DIRECT_ENDPOINT;
            try {
                const normalized = await GoToolkitTemplateCriteria.analyzeCriteria({
                    text,
                    template,
                    apiKey: useProxy ? "" : apiKey,
                    endpoint,
                    signal: controller.signal,
                    model: "gpt-5-nano"
                });
                templateCriteriaStatus[template.id] = normalized;
                renderTemplateTooltip(template, normalized);
            } catch (err) {
                if (err?.name === "AbortError") return;
                console.warn("Analyse des critères impossible", err);
            } finally {
                if (criteriaAnalysisAbortController === controller) {
                    criteriaAnalysisAbortController = null;
                }
            }
        }

        function triggerCriteriaAnalysis(options = {}) {
            const force = options.force || false;
            const tpl = getActiveTemplate();
            const tplId = tpl?.id;
            if (tplId && !templateCriteriaStatus[tplId]) {
                templateCriteriaStatus[tplId] = {};
            }
            if (tplId !== lastAnalyzedTemplateId) {
                lastAnalyzedSentenceCount = 0;
                lastAnalyzedTemplateId = tplId;
            }
            const status = tplId ? templateCriteriaStatus[tplId] : null;
            renderTemplateTooltip(tpl, status);
            if (!pageContextField) return;
            const text = pageContextField.value || "";
            const trimmed = text.trim();
            const criteria = getTemplateCriteria(tpl);
            if (!trimmed || !criteria.length) {
                lastAnalyzedSentenceCount = countCompletedSentences(text);
                if (tplId) {
                    templateCriteriaStatus[tplId] = {};
                    renderTemplateTooltip(tpl, templateCriteriaStatus[tplId]);
                }
                if (criteriaAnalysisAbortController) {
                    try { criteriaAnalysisAbortController.abort(); } catch (e) { /* noop */ }
                    criteriaAnalysisAbortController = null;
                }
                return;
            }
            const sentenceCount = countCompletedSentences(text);
            if (!force && sentenceCount === lastAnalyzedSentenceCount) {
                return;
            }
            lastAnalyzedSentenceCount = sentenceCount;
            analyzePromptCriteria(trimmed, tpl);
        }

        function closeMenu(menu) {
            menu?.classList.remove("open");
        }

        function toggleMenu(menu) {
            if (!menu) return;
            const isOpen = menu.classList.contains("open");
            closeContextMenus();
            if (!isOpen) {
                menu.classList.add("open");
            }
        }

        function closeContextMenus() {
            [settingsMenu, fileMenu, shareMenu].forEach(menu => menu?.classList.remove("open"));
            if (navSwitcherMenu) {
                navSwitcherMenu.classList.remove("open");
            }
            navSwitcherBtn?.setAttribute("aria-expanded", "false");
        }

        function handleTemplateSelection(templateId) {
            selectedTemplateId = templateId || templates[0].id;
            templateList?.querySelectorAll(".promptzilla-card").forEach(row => {
                const isActive = row.dataset.templateId === selectedTemplateId;
                row.setAttribute("aria-checked", isActive ? "true" : "false");
                row.classList.toggle("selected", isActive);
            });
        }

        function renderTemplateList(selectedId) {
            if (!templateList) return;
            selectedTemplateId = selectedId || selectedTemplateId || templates[0].id;
            templateList.innerHTML = "";
            templates.forEach(template => {
                const row = document.createElement("div");
                row.className = "promptzilla-card";
                row.dataset.templateId = template.id;
                row.setAttribute("role", "radio");
                row.setAttribute("aria-checked", template.id === selectedTemplateId ? "true" : "false");
                row.tabIndex = 0;

                const title = document.createElement("h4");
                title.textContent = template.name;
                const desc = document.createElement("p");
                const rawDesc = template.description ||
                    `Colonnes : ${template.columns.map(col => col.label).join(" – ")} | Lignes : ${template.sections.map(sec => sec.label).join(" – ")}`;
                desc.innerHTML = escapeHtml(rawDesc).replace(/\n/g, "<br>");

                row.append(title, desc);

                row.addEventListener("click", () => {
                    handleTemplateSelection(template.id);
                });
                row.addEventListener("keydown", event => {
                    if (event.key === "Enter" || event.key === " ") {
                        event.preventDefault();
                        handleTemplateSelection(template.id);
                    }
                });

                templateList.appendChild(row);
            });
            handleTemplateSelection(selectedTemplateId);
        }

        function openTemplateModal() {
            if (!templateModal) return;
            if (tourOverlay?.classList.contains("visible")) {
                return;
            }
            renderTemplateList(lastAppliedTemplateId || currentTemplateId || selectedTemplateId || templates[0].id);
            templateModal.classList.add("open");
        }

        function closeTemplateModal() {
            templateModal?.classList.remove("open");
        }

        function withExportMode(action) {
            return (async () => {
                closeContextMenus();
                document.body.classList.add("exporting");
                try {
                    return await action();
                } finally {
                    document.body.classList.remove("exporting");
                }
            })();
        }

        function prepareSlideForExport(slide) {
            const wrapper = document.createElement("div");
            wrapper.style.position = "fixed";
            wrapper.style.top = "-9999px";
            wrapper.style.left = "-9999px";
            wrapper.style.opacity = "0";
            wrapper.style.pointerEvents = "none";
            wrapper.style.zIndex = "-1";
            const clone = slide.cloneNode(true);
            wrapper.appendChild(clone);
            document.body.appendChild(wrapper);
            clone.querySelectorAll("textarea").forEach(textarea => {
                const computed = window.getComputedStyle(textarea);
                const replacement = document.createElement("div");
                replacement.textContent = textarea.value || textarea.placeholder || "";
                replacement.style.cssText = computed.cssText;
                replacement.style.whiteSpace = "pre-wrap";
                replacement.style.wordBreak = "break-word";
                replacement.style.overflow = "visible";
                replacement.style.width = computed.width;
                replacement.style.minHeight = computed.height;
                replacement.style.boxSizing = "border-box";
                textarea.replaceWith(replacement);
            });
            clone.querySelectorAll(".column-title").forEach(input => {
                const computed = window.getComputedStyle(input);
                const replacement = document.createElement("div");
                replacement.textContent = input.value || "";
                replacement.style.cssText = computed.cssText;
                replacement.style.whiteSpace = "nowrap";
                replacement.style.overflow = "visible";
                replacement.style.width = computed.width;
                replacement.style.height = computed.height;
                replacement.style.fontSize = `calc(${computed.fontSize} + 5px)`;
                replacement.style.position = "relative";
                replacement.style.top = "10px";
                replacement.style.boxSizing = "border-box";
                input.replaceWith(replacement);
            });
            return { wrapper, clone };
        }

        function buildSlideTextContent(slide) {
            const lines = [];
            const title = slide.querySelector(".slide-title-input")?.value.trim();
            if (title) {
                lines.push(title);
            }
            const subtitle = slide.querySelector(".slide-subtitle-input")?.value.trim();
            if (subtitle) {
                if (lines.length) {
                    lines.push("");
                }
                lines.push(subtitle);
            }

            Array.from(slide.querySelectorAll(".column")).forEach(column => {
                const columnLines = [];
                const columnTitle = column.querySelector(".column-title")?.textContent.trim();
                if (columnTitle) {
                    columnLines.push(columnTitle);
                }
                Array.from(column.querySelectorAll(".section")).forEach(section => {
                    const label = section.querySelector(".section-label")?.textContent.trim() || "Section";
                    const textarea = section.querySelector("textarea");
                    const placeholder = textarea?.dataset.placeholder?.trim() || "";
                    const value = textarea?.value?.trim() || "";
                    const content = value || placeholder;
                    columnLines.push(`${label}:`);
                    columnLines.push(content || "(vide)");
                });
                if (columnLines.length) {
                    if (lines.length) {
                        lines.push("");
                    }
                    lines.push(...columnLines);
                }
            });

            const bottomSectionText = slide.querySelector(".bottom-section-text")?.value.trim();
            if (bottomSectionText) {
                if (lines.length) {
                    lines.push("");
                }
                lines.push(bottomSectionText);
            }

            return lines.join("\n");
        }

        function gatherColumnSectionSummary(slide) {
            if (!slide) {
                return "";
            }
            const parts = [];
            Array.from(slide.querySelectorAll(".column")).forEach(column => {
                const columnTitle = column.querySelector(".column-title")?.textContent.trim();
                Array.from(column.querySelectorAll(".section")).forEach(section => {
                    const sectionLabel = section.querySelector(".section-label")?.textContent.trim() || "Section";
                    const textarea = section.querySelector("textarea");
                    const value = textarea?.value.trim() || textarea?.dataset.placeholder?.trim() || "";
                    const content = value || "(vide)";
                    const prefix = columnTitle ? `${columnTitle} — ${sectionLabel}` : sectionLabel;
                    parts.push(`${prefix}: ${content}`);
                });
            });
            return parts.join(" | ");
        }

        function copyTextToClipboard(text) {
            if (navigator.clipboard && typeof navigator.clipboard.writeText === "function") {
                return navigator.clipboard.writeText(text);
            }
            return new Promise((resolve, reject) => {
                const textarea = document.createElement("textarea");
                textarea.value = text;
                textarea.setAttribute("readonly", "");
                textarea.style.position = "absolute";
                textarea.style.left = "-9999px";
                document.body.appendChild(textarea);
                textarea.select();
                textarea.setSelectionRange(0, textarea.value.length);
                const success = document.execCommand("copy");
                document.body.removeChild(textarea);
                if (success) {
                    resolve();
                } else {
                    reject(new Error("Fallback copy failed"));
                }
            });
        }

        function showCopyToast(message) {
            if (!copyToast) return;
            copyToast.textContent = message;
            copyToast.classList.add("visible");
            if (copyToastTimer) {
                clearTimeout(copyToastTimer);
            }
            copyToastTimer = setTimeout(() => {
                copyToast.classList.remove("visible");
                copyToastTimer = null;
            }, 2200);
        }

        function showErrorToast(message) {
            if (!errorToast) return;
            errorToast.textContent = message;
            errorToast.classList.add("visible");
            if (errorToastTimer) {
                clearTimeout(errorToastTimer);
            }
            errorToastTimer = setTimeout(() => {
                errorToast.classList.remove("visible");
                errorToastTimer = null;
            }, 3200);
        }

        exportBtn.addEventListener("click", async () => {
            closeContextMenus();
            const slide = slidesContainer.querySelector(`.slide[data-index="${activeIndex}"]`);
            if (!slide) return;
            const oldText = exportBtn.textContent;
            const frames = ["◴", "◷", "◶", "◵"];
            let frameIndex = 0;
            exportBtn.textContent = frames[frameIndex];
            exportBtn.disabled = true;
            try {
                await withExportMode(async () => {
                    const { wrapper, clone } = prepareSlideForExport(slide);
                    try {
                        const canvas = await html2canvas(clone, { scale: 2, backgroundColor: null, useCORS: true });
                        const link = document.createElement("a");
                        link.href = canvas.toDataURL("image/png");
                        link.download = getExportFilename('png');
                        link.click();
                    } finally {
                        wrapper.remove();
                    }
                });
            } catch (err) {
                alert("Export impossible. Tu peux utiliser l'impression PDF en secours.");
                console.error(err);
            } finally {
                exportBtn.textContent = oldText;
                exportBtn.disabled = false;
            }
        });

        exportTextBtn?.addEventListener("click", async () => {
            if (!exportTextBtn) return;
            closeContextMenus();
            exportTextBtn.disabled = true;
            try {
                const slide = slidesContainer.querySelector(`.slide[data-index="${activeIndex}"]`);
                if (!slide) return;
                const textContent = buildSlideTextContent(slide);
                const payload = textContent || "(Aucun contenu)";
                await copyTextToClipboard(payload);
                showCopyToast("Texte copié dans le presse-papier");
            } catch (err) {
                console.error("Copie texte impossible", err);
                alert("Impossible de copier le texte. Tu peux réessayer.");
            } finally {
                exportTextBtn.disabled = false;
            }
        });

        function buildTableDataForSlide(slideData) {
            const columns = slideData.columns || [];
            if (!columns.length) {
                return [];
            }
            const formatSectionContent = (section) =>
                (section?.text || "")
                    .split(/\n+/)
                    .map(line => line.trim())
                    .filter(Boolean)
                    .join("\n");
            const formatSectionCell = (section) => {
                const label = section?.label?.trim();
                const content = formatSectionContent(section);
                const parts = [];
                if (label) {
                    parts.push({
                        text: label + (content ? "\n" : ""),
                        options: { bold: true, fontSize: 10 }
                    });
                }
                if (content) {
                    parts.push({
                        text: content,
                        options: { fontSize: 10 }
                    });
                }
                return parts.length ? parts : { text: "", options: { fontSize: 10 } };
            };
            const headerRow = columns.map(column => ({
                text: `${column.stageLabel || column.stage || ""}`.trim(),
                options: { bold: true, fontSize: 10 }
            }));
            const templateSections = getTemplateSections(slideData.templateId);
            const rows = templateSections.map(section =>
                columns.map(column => ({
                    text: formatSectionCell(column.sections[section.key]),
                    options: { fontSize: 10 }
                }))
            );
            return [headerRow, ...rows];
        }

        async function exportPptxFromSlides() {
            const ratio = ratioOptions[currentRatioIndex] || ratioOptions[0];
            const data = collectSlidesFromDOM();
            if (!data.length) return;
            const pptx = new PptxGenJS();
            const layoutName = `CUSTOM_${ratio.name.replace(/[^a-zA-Z0-9]/g, "_")}`;
            pptx.defineLayout({ name: layoutName, width: ratio.pptx.width, height: ratio.pptx.height });
            pptx.layout = layoutName;
            for (const slideData of data) {
                const pptSlide = pptx.addSlide();
                const table = buildTableDataForSlide(slideData);
                pptSlide.addTable(table, {
                    x: 0.4,
                    y: 0.4,
                    w: ratio.pptx.width - 0.8,
                    border: { type: "none" },
                    fontSize: 10,
                    rowH: 0.4,
                    valign: "top",
                    color: "363636"
                });
                pptSlide.addText(`${slideData.title}`, {
                    x: 0.4,
                    y: 0.1,
                    w: ratio.pptx.width - 0.8,
                    fontSize: 12,
                    bold: true
                });
            }
            await pptx.writeFile({ fileName: getExportFilename('pptx') });
        }

        exportPptxBtn.addEventListener("click", async () => {
            exportPptxBtn.disabled = true;
            try {
                await withExportMode(async () => {
                    await exportPptxFromSlides();
                });
            } catch (err) {
                alert("Export PPTX impossible. Tu peux réessayer.");
                console.error(err);
            } finally {
                exportPptxBtn.disabled = false;
            }
            closeContextMenus();
        });

        function fillTemplate(template, data) {
            return template.replace(/\{\{(\w+)\}\}/g, (_, key) => data[key] ?? "");
        }

        function getPromptTemplateForSection(templateId, sectionKey) {
            if (sectionKey === "bottom-section") {
                return getPromptLibraryForTemplate(templateId).bottom || bottomSectionDefaultPrompt;
            }
            return getMainPromptTemplate(templateId);
        }

        function getMainPromptTemplate(templateId) {
            const library = getPromptLibraryForTemplate(templateId);
            const modeKey = promptKeyFromMode(activeIaMode);
            const fallbackTemplate = defaultPromptTemplate;
            return library[modeKey] || fallbackTemplate;
        }

        function getSectionPromptTemplate(templateId, sectionKey, contextData = {}) {
            const stage = contextData.columnStage || contextData.columnId;
            const guidance =
                getSectionExample(templateId, stage, sectionKey) || contextData.sectionGuidance || "";
            const library = getPromptLibraryForTemplate(templateId);
            const modeKey = promptKeyFromMode(activeIaMode);
            const userTemplate = (library[modeKey] || "").trim();
            const baseTemplate = userTemplate || defaultPromptTemplate;
            const templateHasGuidanceVar = baseTemplate.includes("{{sectionGuidance}}");
            const finalTemplate =
                templateHasGuidanceVar || !guidance
                    ? baseTemplate
                    : [guidance, baseTemplate].filter(Boolean).join("\n\n");
            return { template: finalTemplate, guidance };
        }

        function getPromptTemplateForMode(section, templateId, contextData) {
            if (section === "bottom-section") {
                return getPromptTemplateForSection(templateId, section);
            }
            const { template, guidance } = getSectionPromptTemplate(templateId, section, contextData);
            if (guidance && guidance !== contextData.sectionGuidance) {
                contextData.sectionGuidance = guidance;
            }
            return template;
        }

        function buildFieldPrompt(section, templateId, contextData) {
            const template = getPromptTemplateForMode(section, templateId, contextData);
            return fillTemplate(template, contextData);
        }

        function buildAssistantMessages(messageText) {
            return [
                { role: "system", content: "Tu es un assistant product owner." },
                { role: "user", content: messageText }
            ];
        }

        function getReasoningEffort() {
            const value = reasoningEffortSelect?.value || "low";
            return reasoningEfforts.includes(value) ? value : "low";
        }

        async function callOpenAI(messages) {
            try {
                if (!window.GoToolkitOpenAI) {
                    throw new Error("Client OpenAI indisponible");
                }
                const apiKey = (localStorage.getItem("go-toolkit-api-key") || "").trim();
                const useProxy = !apiKey;
                console.warn(useProxy ? "Appel OpenAI via le proxy gotoolkit.workers.dev" : "Appel OpenAI officiel");
                const endpoint = useProxy
                    ? "https://openai.gotoolkit.workers.dev/v1/responses"
                    : "https://api.openai.com/v1/responses";
                const requestText = messages
                    .map(message => (typeof message.content === "string" ? message.content : ""))
                    .filter(Boolean)
                    .join("\n---\n");
                console.log("AI request text:", requestText);
                const content = await GoToolkitOpenAI.chatCompletion({
                    endpoint,
                    apiKey: useProxy ? "" : apiKey,
                    payload: {
                        model: "gpt-5-nano",
                        messages,
                        reasoning: { effort: getReasoningEffort() },
                        temperature: 1,
                        stream: true
                    }
                });
                console.log("AI response text:", typeof content === "string" ? content : "");
                return content;
            } catch (err) {
                console.error("Erreur OpenAI", err);
                showErrorToast(
                    "Impossible de contacter OpenAI (accès non autorisé ou quota excédé). Utilise ta propre clé OpenAI"
                );
                return null;
            }
        }

        let activeModalTab = "settings";

        function switchModalTab(tabName) {
            activeModalTab = tabName;
            contextModalTabs.forEach(tab => {
                tab.classList.toggle("active", tab.dataset.tab === tabName);
            });
            contextModalPanels.forEach(panel => {
                panel.classList.toggle("hide", panel.dataset.panel !== tabName);
            });
        }

        contextModalTabs.forEach(tab => {
            tab.addEventListener("click", () => {
                switchModalTab(tab.dataset.tab);
            });
        });

        function openContextEditorModalForEmptyState() {
            syncPageContextFieldWithActiveSlide();
            toggleGutenberg(true);
            pageContextField?.focus();
        }

        function handleSettingsSave() {
            schedulePersist();
            closeModal(contextModal);
        }
        ;

        function buildSectionPromptContext(slide, column, sectionKey, textarea, templateId) {
            const safeTemplateId = templateId || currentTemplateId || templates[0].id;
            const columnStage = column?.dataset.stage || "";
            const columnTitle = column?.querySelector(".column-title")?.textContent.trim() || "";
            const columnId = columnStage || columnTitle || "cette colonne";
            const sectionLabel =
                column?.querySelector(`.section-label[data-section="${sectionKey}"]`)?.textContent.trim() ||
                getDefaultSectionLabel(safeTemplateId, sectionKey);
            const globalContextValue = globalContextField?.value.trim() || "";
            const slideTitle =
                slide?.querySelector(".slide-title-input")?.value.trim() ||
                slide?.dataset.tabLabel ||
                "";
            const sectionGuidance = getSectionGuidance(
                safeTemplateId,
                columnStage || columnId,
                sectionKey,
                sectionLabel,
                columnTitle
            );
            return {
                globalContext: globalContextValue,
                contextField: globalContextValue,
                pageContext: getSlidePageContext(slide).trim(),
                columnTitle,
                columnId,
                columnStage: columnStage || columnId,
                fieldValue: textarea?.value.trim() || "",
                sectionTitle: sectionLabel,
                sectionLabel,
                sectionGuidance,
                slideTitle
            };
        }

        function buildBottomPromptContext(slide) {
            const slideTitle = slide?.querySelector(".slide-title-input")?.value.trim() || "Slide";
            const globalContextValue = globalContextField?.value.trim() || "";
            const pageContextValue = getSlidePageContext(slide).trim();
            return {
                globalContext: globalContextValue,
                contextField: globalContextValue,
                pageContext: pageContextValue,
                slideTitle,
                columnSections: gatherColumnSectionSummary(slide)
            };
        }

        function escapeHtml(value) {
            if (!value) return "";
            return value.replace(/[&<>"']/g, char => {
                switch (char) {
                    case "&":
                        return "&amp;";
                    case "<":
                        return "&lt;";
                    case ">":
                        return "&gt;";
                    case '"':
                        return "&quot;";
                    case "'":
                        return "&#39;";
                    default:
                        return char;
                }
            });
        }

        function renderPromptEditorContext(context = null) {
            if (!promptEditorContextPreview) {
                return;
            }
            if (!context) {
                promptEditorContextPreview.innerHTML = "";
                promptEditorContextPreview.classList.add("hidden");
                return;
            }
            const items = [
                { label: "Titre de la page", value: context.slideTitle },
                { label: "Colonne", value: context.columnTitle },
                { label: "Section", value: context.sectionTitle }
            ]
                .filter(entry => entry.value && entry.value.trim())
                .map(
                    entry =>
                        `<div class="prompt-editor-context-row"><span class="prompt-editor-context-label">${entry.label} :</span> <strong>${escapeHtml(
                            entry.value.trim()
                        )}</strong></div>`
                )
                .join("");

            if (items) {
                promptEditorContextPreview.innerHTML = items;
                promptEditorContextPreview.classList.remove("hidden");
            } else {
                promptEditorContextPreview.innerHTML = "";
                promptEditorContextPreview.classList.add("hidden");
            }
        }

        function buildPromptEditorPreview(template, context = {}) {
            if (!template) {
                return "";
            }
            const normalizedContext = context || {};
            const pattern = /\{\{(\w+)\}\}/g;
            pattern.lastIndex = 0;
            let match;
            let lastIndex = 0;
            const parts = [];
            while ((match = pattern.exec(template)) !== null) {
                parts.push(escapeHtml(template.slice(lastIndex, match.index)));
                const key = match[1];
                const keyHtml = escapeHtml(key);
                const value = normalizedContext[key];
                const hasValue =
                    !promptPreviewMaskedKeys.has(key) && value !== undefined && value !== null && value !== "";
                if (hasValue) {
                    const display = escapeHtml(String(value));
                    parts.push(
                        `<span class="prompt-editor-placeholder" data-placeholder-key="${keyHtml}"><strong>${display}</strong></span>`
                    );
                } else {
                    parts.push(
                        `<span class="prompt-editor-placeholder prompt-editor-placeholder-empty" data-placeholder-key="${keyHtml}">{{${keyHtml}}}</span>`
                    );
                }
                lastIndex = match.index + match[0].length;
            }
            parts.push(escapeHtml(template.slice(lastIndex)));
            return parts.join("");
        }

        function renderPromptEditorPreview(templateValue, context = null) {
            if (!promptEditorPreview) {
                return;
            }
            if (!templateValue) {
                promptEditorPreview.innerHTML = "";
                promptEditorPreview.classList.add("hidden");
                return;
            }
            const content = buildPromptEditorPreview(templateValue, context);
            if (!content) {
                promptEditorPreview.innerHTML = "";
                promptEditorPreview.classList.add("hidden");
                return;
            }
            promptEditorPreview.innerHTML = content;
            promptEditorPreview.classList.remove("hidden");
        }

        function collectTemplateFromPreview() {
            if (!promptEditorPreview) {
                return "";
            }
            const blockTags = new Set(["DIV", "P", "LI"]);
            const serializeNode = node => {
                if (node.nodeType === Node.TEXT_NODE) {
                    return node.textContent || "";
                }
                if (node.nodeType !== Node.ELEMENT_NODE) {
                    return "";
                }
                const el = node;
                if (el.dataset.placeholderKey) {
                    return `{{${el.dataset.placeholderKey}}}`;
                }
                if (el.tagName === "BR") {
                    return "\n";
                }
                const children = Array.from(el.childNodes).map(serializeNode).join("");
                return blockTags.has(el.tagName) ? `${children}\n` : children;
            };
            return Array.from(promptEditorPreview.childNodes).map(serializeNode).join("");
        }

        let promptEditorResolve = null;

        function finishPromptEditor(result) {
            const resolver = promptEditorResolve;
            if (!resolver) return;
            promptEditorResolve = null;
            if (promptEditorTextarea) {
                promptEditorTextarea.value = collectTemplateFromPreview();
            }
            renderPromptEditorContext(null);
            promptEditorCurrentContext = null;
            renderPromptEditorPreview("", null);
            closeModal(promptEditorModal, true);
            resolver(result);
        }

        function openPromptEditor(initialTemplate, contextValues = null) {
            if (!promptEditorModal || !promptEditorTextarea) {
                return Promise.resolve(initialTemplate);
            }
            promptEditorCurrentContext = contextValues;
            renderPromptEditorContext(contextValues);
            promptEditorTextarea.value = initialTemplate;
            renderPromptEditorPreview(initialTemplate, promptEditorCurrentContext);
            openModal(promptEditorModal);
            if (promptEditorPreview) {
                promptEditorPreview.focus();
            }
            return new Promise(resolve => {
                promptEditorResolve = result => resolve(result);
            });
        }

        function executeAiRequest(button, textarea, messagesPromise) {
            return (async () => {
                const messages = await Promise.resolve(messagesPromise);
                if (!messages || !messages.length) {
                    return;
                }
                const countdownDuration = 30;
                let remainingSeconds = countdownDuration;
                let countdownInterval = null;
                const updateCountdownLabel = () => {
                    const frames = ["◴", "◷", "◶", "◵"];
                    const frame = frames[remainingSeconds % frames.length];
                    button.textContent = `${frame} ${remainingSeconds}s`;
                };
                updateCountdownLabel();
                countdownInterval = setInterval(() => {
                    remainingSeconds = Math.max(0, remainingSeconds - 1);
                    updateCountdownLabel();
                    if (remainingSeconds === 0) {
                        clearInterval(countdownInterval);
                    }
                }, 1000);
                button.disabled = true;
                try {
                    const aiText = await callOpenAI(messages);
                    console.log("OpenAI field response", aiText);
                    if (aiText == null) return;
                    textarea.value = aiText.trim();
                    updateTextareaOverflowState(textarea);
                    schedulePersist();
                } finally {
                    if (countdownInterval) {
                        clearInterval(countdownInterval);
                    }
                    button.textContent = "⌘";
                    button.disabled = false;
                }
            })();
        }

        promptEditorSendBtn?.addEventListener("click", () => {
            finishPromptEditor(promptEditorTextarea?.value ?? "");
        });
        promptEditorCancelBtn?.addEventListener("click", () => {
            finishPromptEditor(null);
        });
        promptEditorModal?.addEventListener("click", event => {
            if (event.target === promptEditorModal) {
                finishPromptEditor(null);
            }
        });

        async function handleFieldAi(button) {
            const section = button.dataset.section;
            const wrapper = button.closest(".textarea-wrapper");
            const textarea = wrapper?.querySelector("textarea");
            if (!textarea || !section) return;
            const slide = button.closest(".slide");
            const templateId = slide?.dataset.templateId || templates[0].id;
            const column = button.closest(".column");
            const promptContext = section === "bottom-section"
                ? buildBottomPromptContext(slide)
                : buildSectionPromptContext(slide, column, section, textarea, templateId);
            const promptTemplate = getPromptTemplateForMode(section, templateId, promptContext);

            if (section === "bottom-section") {
                const message = fillTemplate(promptTemplate, promptContext);
                await executeAiRequest(button, textarea, buildAssistantMessages(message));
                return;
            }

            if (activeIaMode === IA_MODE_EXPERIMENTAL) {
                const editedTemplate = await openPromptEditor(promptTemplate, promptContext);
                if (!editedTemplate) return;
                const message = fillTemplate(editedTemplate, promptContext);
                await executeAiRequest(button, textarea, buildAssistantMessages(message));
                return;
            }

            const message = fillTemplate(promptTemplate, promptContext);
            await executeAiRequest(button, textarea, buildAssistantMessages(message));
        }

        document.addEventListener("click", event => {
            const btn = event.target.closest(".field-ai-btn");
            if (btn) {
                event.stopPropagation();
                handleFieldAi(btn);
                return;
            }
            if (!event.target.closest(".menu-trigger")) {
                closeContextMenus();
            }
        });

        window.addEventListener("beforeunload", persistState);

        function openModal(modal) {
            modal?.classList.add("open");
        }

        function closeModal(modal, skipPromptEditor = false) {
            if (modal === promptEditorModal && !skipPromptEditor) {
                finishPromptEditor(null);
                return;
            }
            modal?.classList?.remove("open");
        }

        document.querySelectorAll(".modal-close").forEach(btn => {
            btn.addEventListener("click", () => {
                const targetId = btn.dataset.close;
                if (targetId) {
                    closeModal(document.getElementById(targetId));
                }
            });
        });

        document.addEventListener("keydown", event => {
            if (event.key === "Escape") {
                document.querySelectorAll(".modal-overlay.open").forEach(modal => closeModal(modal));
                if (isGutenbergOpen()) {
                    setGutenbergOpen(false);
                }
            }
        });

        contextBtn.addEventListener("click", () => {
            activePromptTemplateId = currentTemplateId;
            setPromptFieldsForTemplate(activePromptTemplateId);
            switchModalTab("settings");
            openModal(contextModal);
        });
        contextApplyBtn?.addEventListener("click", () => {
            persistState();
            closeModal(contextModal);
        });
        contextEditorBtn?.addEventListener("click", () => {
            toggleGutenberg();
        });
        gutenbergBackdrop?.addEventListener("click", () => {
            setGutenbergOpen(false);
        });
        // Close gutenberg drawer when clicking outside in drawer mode (<900px)
        document.addEventListener("click", (ev) => {
            try {
                if ((window.innerWidth || 0) >= 900) return; // desktop - do nothing
                if (!gutenbergCard || !gutenbergCard.classList.contains('open')) return;
                var t = ev.target;
                if (t && t.closest && (t.closest('.gutenberg-card') || t.closest('#contextEditorBtn') || t.closest('#contextBtn'))) return;
                // clicking outside should close the drawer
                setGutenbergOpen(false);
            } catch (e) {
                /* noop */
            }
        }, true);
        switchModalTab("settings");
        slideContextLink?.addEventListener("click", event => {
            event.stopPropagation();
            openContextEditorModalForEmptyState();
        });
        async function initializeAppState() {
            initShareWorkerService();
            const sharedLoaded = await tryLoadSharedStateFromUrl();
            let hasLocalSlides = false;
            if (!sharedLoaded) {
                hasLocalSlides = loadSavedState();
            }
            // Load shared Settings (global Réglages) if present so this page
            // respects the central API key and reasoning effort selection.
            try {
                if (window.localStorage) {
                    const sharedApi = localStorage.getItem(API_KEY_STORAGE_KEY) || "";
                    if (sharedApi) {
                        // Shared API key present; persisted in localStorage for shared use.
                        if (!localStorage.getItem(API_KEY_STORAGE_KEY)) {
                            localStorage.setItem(API_KEY_STORAGE_KEY, sharedApi);
                        }
                    }
                    // Reasoning effort: prefer the global key used by timeline, fallback
                    // to this page's existing key for compatibility.
                    const PAGE_REASONING_KEY = reasoningEffortKey || "robert-reasoning-effort";
                    const sharedReasoning = localStorage.getItem("plan-reasoning-effort") || localStorage.getItem(PAGE_REASONING_KEY) || "";
                    if (sharedReasoning) {
                        const sel = document.getElementById("reasoningEffortSelect");
                        if (sel) sel.value = sharedReasoning;
                        // Also persist to the page key so code reading it later sees the value
                        try { localStorage.setItem(PAGE_REASONING_KEY, sharedReasoning); } catch (e) { }
                    }
                }
            } catch (e) {
                /* noop */
            }
            renderSlides();
            requestAnimationFrame(() => resizeAllColumnSections());
            applyRatio(currentRatioIndex);
            if (sharedLoaded) {
                persistState();
            }
            if (!sharedLoaded && !hasLocalSlides) {
                openTemplateModal();
            }
            maybeAutoOpenGutenberg();
        }
        initializeAppState().catch(err => {
            console.error("Impossible d'initialiser l'état :", err);
            maybeAutoOpenGutenberg();
        });

        window.addEventListener("resize", () => resizeAllColumnSections());

        // React to global Settings changes saved in other tabs/windows
        window.addEventListener('storage', function (ev) {
            if (!ev || !ev.key) return;
            try {
                if (ev.key === 'plan-reasoning-effort' || ev.key === reasoningEffortKey) {
                    const val = ev.newValue || 'low';
                    const sel = document.getElementById('reasoningEffortSelect');
                    if (sel) sel.value = val;
                    try { localStorage.setItem(reasoningEffortKey, val); } catch (e) { }
                }
            } catch (err) {
                /* noop */
            }
        });

        const shareBtn = document.getElementById("shareBtn");
        const shareLinkField = document.getElementById("shareLinkField");
        const shareMenuStatus = document.getElementById("shareMenuStatus");
        const shareCreateBtn = document.getElementById("shareCreateBtn");
        const shareUpdateBtn = document.getElementById("shareUpdateBtn");
        const shareHistory = window.goToolkitShareHistory;

        function getRobertSharePreview() {
            const slides = collectAllSlides();
            const firstSlide = Array.isArray(slides) && slides.length ? slides[0] : null;
            const title = (firstSlide?.title || "Sans titre").trim();
            const desc = (globalContextField?.value || "")
                .split(/\r?\n/)
                .map(line => line.trim())
                .filter(Boolean)
                .slice(0, 2)
                .join(" · ");
            return {
                title,
                description: desc || "Complète le contexte pour l'afficher ici."
            };
        }

        function persistShareHistoryRecord(token, updatedAt) {
            if (!shareHistory || !token) {
                return;
            }
            try {
                const preview = getRobertSharePreview();
                shareHistory.upsertRecord("robert", {
                    token,
                    updatedAt: updatedAt || new Date().toISOString(),
                    title: preview.title,
                    description: preview.description
                });
            } catch (err) {
                console.warn("Impossible d'archiver le lien Petit Robert", err);
            }
        }

        function getShareDefaultStatusText() {
            if (!shareWorkerAvailable) {
                return SHARE_WORKER_UNAVAILABLE_MESSAGE;
            }
            if (shareLastUpdatedAt) {
                return formatRelativeTime(shareLastUpdatedAt);
            }
            if (shareLoadedFromRemote && currentShareToken) {
                return "Ce lien charge la version enregistrée via le worker Cloudflare.";
            }
            if (currentShareToken) {
                return "Un lien privé existe déjà pour cette session.";
            }
            return "Seules les personnes disposant du lien peuvent y accéder.";
        }

        function updateShareMenuUI() {
            if (shareLinkField) {
                const hasToken = Boolean(currentShareToken);
                shareLinkField.value = hasToken ? buildShareUrl(currentShareToken) : "";
                shareLinkField.placeholder = hasToken ? "" : "Appuie sur Créer pour générer un lien privé.";
            }
            if (shareUpdateBtn) {
                const hasToken = Boolean(currentShareToken);
                shareUpdateBtn.hidden = !hasToken;
                shareUpdateBtn.disabled =
                    shareRequestInProgress || !hasToken || !shareWorkerAvailable;
            }
            if (shareCreateBtn) {
                shareCreateBtn.disabled = shareRequestInProgress || !shareWorkerAvailable;
                if (!currentShareToken) {
                    shareCreateBtn.classList.add("btn-primary");
                } else {
                    shareCreateBtn.classList.remove("btn-primary");
                }
            }
            if (shareMenuStatus) {
                const text = shareStatusMessage || getShareDefaultStatusText();
                shareMenuStatus.textContent = text;
                const isError =
                    (shareStatusType === "error" && Boolean(text)) ||
                    (!shareWorkerAvailable && !shareStatusMessage);
                shareMenuStatus.classList.toggle("error", isError);
            }
            if (shareUpdateBtn) {
                if (currentShareToken) {
                    shareUpdateBtn.classList.add("primary");
                } else {
                    shareUpdateBtn.classList.remove("primary");
                }
            }
        }

        async function copyCurrentShareLinkToClipboard() {
            if (!currentShareToken) return false;
            const link = buildShareUrl(currentShareToken);
            if (!link) return false;
            try {
                await copyTextToClipboard(link);
                showCopyToast("Lien privé copié");
                return true;
            } catch (err) {
                console.error("Copie du lien privé impossible", err);
                return false;
            }
        }

        async function handleShareCreateClick() {
            if (!shareWorkerAvailable) {
                setShareStatus(SHARE_WORKER_UNAVAILABLE_MESSAGE, "error");
                updateShareMenuUI();
                return;
            }
            if (shareRequestInProgress) return;
            shareRequestInProgress = true;
            updateShareMenuUI();
            try {
                const token = createShareToken();
                const updatedAt = await saveSharePayload(token, buildStatePayload());
                currentShareToken = token;
                shareLoadedFromRemote = true;
                shareLastUpdatedAt = updatedAt;
                updateUrlWithShareToken(token);
                setShareStatus(formatRelativeTime(updatedAt));
                updateShareMenuUI();
                const payload = buildStatePayload();
                persistShareHistoryRecord(token, updatedAt);
                writeShareDraft(token, payload, updatedAt);
                await copyCurrentShareLinkToClipboard();
            } catch (err) {
                console.error("Erreur lors de la création du lien partagé :", err);
                setShareStatus("Impossible de créer le lien partagé.", "error");
            } finally {
                shareRequestInProgress = false;
                updateShareMenuUI();
            }
        }

        async function handleShareUpdateClick() {
            if (!shareWorkerAvailable) {
                setShareStatus(SHARE_WORKER_UNAVAILABLE_MESSAGE, "error");
                updateShareMenuUI();
                return;
            }
            if (!currentShareToken) {
                setShareStatus("Pas de lien privé à mettre à jour.", "error");
                updateShareMenuUI();
                return;
            }
            if (shareRequestInProgress) return;
            shareRequestInProgress = true;
            updateShareMenuUI();
            try {
                const payload = buildStatePayload();
                const updatedAt = await saveSharePayload(currentShareToken, payload);
                shareLoadedFromRemote = true;
                shareLastUpdatedAt = updatedAt;
                setShareStatus(formatRelativeTime(updatedAt));
                updateShareMenuUI();
                persistShareHistoryRecord(currentShareToken, updatedAt);
                writeShareDraft(currentShareToken, payload, updatedAt);
                await copyCurrentShareLinkToClipboard();
            } catch (err) {
                console.error("Erreur lors de la mise à jour du lien partagé :", err);
                setShareStatus("Impossible de mettre à jour le lien partagé.", "error");
            } finally {
                shareRequestInProgress = false;
                updateShareMenuUI();
            }
        }

        if (navSwitcherBtn && navSwitcherMenu) {
            navSwitcherBtn.addEventListener("click", event => {
                event.stopPropagation();
                const wasOpen = navSwitcherMenu.classList.contains("open");
                closeContextMenus();
                if (!wasOpen) {
                    navSwitcherMenu.classList.add("open");
                    navSwitcherBtn.setAttribute("aria-expanded", "true");
                }
            });
            navSwitcherMenu.addEventListener("click", event => {
                event.stopPropagation();
            });
        }

        shareBtn?.addEventListener("click", event => {
            event.stopPropagation();
            // If info popup is open, close it when opening the share menu
            closeInfoPopup();
            toggleMenu(shareMenu);
            updateShareMenuUI();
        });
        shareCreateBtn?.addEventListener("click", handleShareCreateClick);
        shareUpdateBtn?.addEventListener("click", handleShareUpdateClick);
        shareLinkField?.addEventListener("focus", () => {
            shareLinkField.select();
        });
        shareLinkField?.addEventListener("click", () => {
            shareLinkField.select();
        });

        const infoButton = document.getElementById("infoButton");
        const infoPopup = document.getElementById("infoPopup");
        const updateAppBtn = document.getElementById("updateAppBtn");

        function closeInfoPopup() {
            infoPopup?.classList.remove("open");
        }

        function clearAppCacheAndReload() {
            // Preserve the shared OpenAI key across a reset
            var __preservedOpenAiKey = null;
            try { __preservedOpenAiKey = localStorage.getItem('go-toolkit-api-key'); } catch (e) { }
            try {
                localStorage.clear();
                if (__preservedOpenAiKey) {
                    try { localStorage.setItem('go-toolkit-api-key', __preservedOpenAiKey); } catch (e) { }
                }
            } catch (err) {
                console.warn("Impossible de vider localStorage", err);
            }
            try {
                sessionStorage.clear();
            } catch (err) {
                console.warn("Impossible de vider sessionStorage", err);
            }
            try {
                sessionStorage.setItem(tourSkipFlag, "1");
            } catch (err) {
                console.warn("Impossible de préparer l'indicateur de mise à jour", err);
            }
            (document.cookie || "")
                .split(";")
                .forEach(function (cookie) {
                    var eqPos = cookie.indexOf("=");
                    var name = eqPos > -1 ? cookie.substr(0, eqPos) : cookie;
                    name = name.trim();
                    if (!name) return;
                    document.cookie = name + "=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/";
                });
            var reload = function () {
                window.location.reload();
            };
            if (window.caches && typeof window.caches.keys === "function") {
                window.caches
                    .keys()
                    .then(function (keys) {
                        return Promise.all(
                            keys.map(function (key) {
                                return window.caches.delete(key);
                            })
                        );
                    })
                    .catch(function () { })
                    .finally(reload);
            } else {
                reload();
            }
        }

        function promptManualUpdate() {
            var warning =
                "La mise à jour effacera les données locales (cache, cookies, préférences). Continuer ?";
            if (!confirm(warning)) return;
            closeInfoPopup();
            clearAppCacheAndReload();
        }

        infoButton?.addEventListener("click", event => {
            event.stopPropagation();
            closeContextMenus();
            infoPopup?.classList.toggle("open");
        });
        updateAppBtn?.addEventListener("click", event => {
            event.stopPropagation();
            promptManualUpdate();
        });
        document.addEventListener("click", event => {
            if (!infoPopup?.contains(event.target) && event.target !== infoButton) {
                closeInfoPopup();
            }
        });

        // Load runtime config synchronously so tour behavior can be controlled
        window.GoToolkitConfig = window.GoToolkitConfig || { enableTours: false };
        try {
            var __cfg_xhr = new XMLHttpRequest();
            __cfg_xhr.open('GET', '/config.json', false);
            __cfg_xhr.send(null);
            if (__cfg_xhr.status >= 200 && __cfg_xhr.status < 300) {
                try { window.GoToolkitConfig = Object.assign({}, window.GoToolkitConfig, JSON.parse(__cfg_xhr.responseText)); } catch (e) { }
            }
        } catch (e) { }
        document.addEventListener('DOMContentLoaded', function () {
            if (window.GoToolkitConfig && window.GoToolkitConfig.enableTours === false) {
                var btn = document.getElementById('tourReplayBtn');
                if (btn) btn.style.display = 'none';
                var overlay = document.getElementById('tourOverlay');
                if (overlay) {
                    overlay.setAttribute('aria-hidden', 'true');
                    overlay.style.display = 'none';
                }
            }
        });

        const tourSteps = [
            {
                title: "Petit Robert, ton assistant vocabulaire",
                description: "Petit Robert t'aide à structurer et aligner ton vocabulaire avec les intérêts de tes interlocuteurs",
                selector: null
            },
            {
                title: "Choisis un modèle",
                description: "Ouvre ⛶ Promptzilla pour parcourir et appliquer différents modèles de canvas.",
                selector: "#promptzillaBtn"
            },
            {
                title: "Structure entièrement personnalisable",
                description: "Chaque page propose un titre, des colonnes, des section et des champs éditables pour structurer ton propos.",
                selectors: [".slide-title-input", ".column-title", ".section-label"]
            },
            {
                title: "Gutenberg",
                description: "Alimente le contexte et récupère des suggestions de saisie ou génère tout le contenu depuis la carte Gutenberg.",
                selector: ".gutenberg-card"
            },
            {
                title: "IA sur chaque champ",
                description: "Le bouton ⌘ te renvoie une réponse claire et structurée en 15-30 secondes à partir des éléments renseignés.",
                selector: ".field-ai-btn"
            },
            {
                title: "Exports",
                description: "Le bouton ⬠ Capsule ouvre le menu d’export : texte, image, PowerPoint ou capsule JSON.",
                selector: "#fileMenuTrigger"
            },
        ];

        const tourOverlay = document.getElementById("tourOverlay");
        const tourHighlight = tourOverlay?.querySelector(".tour-highlight");
        const tourPanel = tourOverlay?.querySelector(".tour-panel");
        const tourTitle = document.getElementById("tourStepTitle");
        const tourDescription = document.getElementById("tourStepDescription");
        const tourCounter = document.getElementById("tourStepCounter");
        const tourPrevBtn = document.getElementById("tourPrevBtn");
        const tourNextBtn = document.getElementById("tourNextBtn");
        const tourCloseBtn = document.getElementById("tourCloseBtn");
        const tourSkipBtn = document.getElementById("tourSkipBtn");
        const tourReplayBtn = document.getElementById("tourReplayBtn");
        const tourStorageKey = "goToolkitTourCompleted";
        const tourSkipFlag = "goToolkitTourSkipAfterUpdate";
        let currentTourIndex = 0;

        function getSelectorsFromStep(step) {
            if (!step) {
                return [];
            }
            if (Array.isArray(step.selectors)) {
                return step.selectors;
            }
            if (step.selector) {
                return [step.selector];
            }
            return [];
        }

        function getSelectorsBoundingRect(selectors) {
            if (!selectors?.length) {
                return null;
            }
            let unionRect = null;
            selectors.forEach(selector => {
                const target = document.querySelector(selector);
                if (!target) {
                    return;
                }
                const rect = target.getBoundingClientRect();
                if (!unionRect) {
                    unionRect = {
                        top: rect.top,
                        left: rect.left,
                        right: rect.right,
                        bottom: rect.bottom,
                        width: rect.width,
                        height: rect.height
                    };
                } else {
                    unionRect.top = Math.min(unionRect.top, rect.top);
                    unionRect.left = Math.min(unionRect.left, rect.left);
                    unionRect.right = Math.max(unionRect.right, rect.right);
                    unionRect.bottom = Math.max(unionRect.bottom, rect.bottom);
                    unionRect.width = unionRect.right - unionRect.left;
                    unionRect.height = unionRect.bottom - unionRect.top;
                }
            });
            return unionRect;
        }

        function positionTourPanel(selectors) {
            if (!tourPanel) return;
            const spacing = 14;
            const defaultStyles = {
                top: "auto",
                bottom: "28px",
                left: "50%",
                right: "auto",
                transform: "translateX(-50%)"
            };
            Object.assign(tourPanel.style, defaultStyles);
            const rect = getSelectorsBoundingRect(selectors);
            if (!rect) return;
            const panelRect = tourPanel.getBoundingClientRect();
            let top = rect.bottom + spacing;
            if (top + panelRect.height > window.innerHeight - spacing) {
                top = rect.top - panelRect.height - spacing;
            }
            let left = rect.left + rect.width / 2 - panelRect.width / 2;
            left = Math.max(spacing, Math.min(left, window.innerWidth - panelRect.width - spacing));
            tourPanel.style.top = `${Math.max(spacing, top)}px`;
            tourPanel.style.left = `${left}px`;
            tourPanel.style.bottom = "auto";
            tourPanel.style.right = "auto";
            tourPanel.style.transform = "none";
        }

        function updateHighlight(selectors) {
            if (!tourHighlight) return;
            const rect = getSelectorsBoundingRect(selectors);
            if (!rect) {
                tourHighlight.classList.add("hidden");
                tourOverlay?.classList.add("dimmed");
                return;
            }
            tourOverlay?.classList.remove("dimmed");
            tourHighlight.classList.remove("hidden");
            const offset = 10;
            tourHighlight.style.width = `${rect.width + offset * 2}px`;
            tourHighlight.style.height = `${rect.height + offset * 2}px`;
            tourHighlight.style.transform = "translate(0, 0)";
            tourHighlight.style.left = `${rect.left - offset}px`;
            tourHighlight.style.top = `${rect.top - offset}px`;
        }

        function handleTourModal(step) {
            if (!contextModal) return;
            if (step?.openContextModal) {
                openModal(contextModal);
            } else {
                closeModal(contextModal);
            }
        }

        function renderTourStep() {
            if (!tourOverlay || !tourSteps.length) return;
            const step = tourSteps[currentTourIndex];
            tourTitle.textContent = step.title;
            tourDescription.textContent = step.description;
            tourCounter.textContent = `Étape ${currentTourIndex + 1} / ${tourSteps.length}`;
            tourPrevBtn.disabled = currentTourIndex === 0;
            tourNextBtn.textContent = currentTourIndex === tourSteps.length - 1 ? "Terminé" : "Suivant";
            const selectors = getSelectorsFromStep(step);
            updateHighlight(selectors);
            positionTourPanel(selectors);
            handleTourModal(step);
        }

        function openTour(startIndex = 0) {
            if (!tourOverlay) return;
            closeTemplateModal();
            closeInfoPopup();
            currentTourIndex = startIndex;
            tourOverlay.classList.add("visible");
            tourOverlay.setAttribute("aria-hidden", "false");
            renderTourStep();
        }

        function closeTour(markSeen = false) {
            if (markSeen && window.localStorage) {
                window.localStorage.setItem(tourStorageKey, "1");
            }
            if (!tourOverlay) return;
            tourOverlay.classList.remove("visible");
            tourOverlay.setAttribute("aria-hidden", "true");
            tourOverlay.classList.remove("dimmed");
            if (tourHighlight) {
                tourHighlight.classList.add("hidden");
            }
        }

        if (tourPrevBtn) {
            tourPrevBtn.addEventListener("click", () => {
                if (currentTourIndex === 0) return;
                currentTourIndex = Math.max(0, currentTourIndex - 1);
                renderTourStep();
            });
        }

        tourNextBtn?.addEventListener("click", () => {
            if (currentTourIndex >= tourSteps.length - 1) {
                closeTour(true);
                return;
            }
            currentTourIndex = Math.min(tourSteps.length - 1, currentTourIndex + 1);
            renderTourStep();
        });

        tourCloseBtn?.addEventListener("click", () => closeTour(true));
        tourSkipBtn?.addEventListener("click", () => closeTour(true));
        tourReplayBtn?.addEventListener("click", () => {
            if (window.GoToolkitConfig && window.GoToolkitConfig.enableTours === false) {
                setStatus("Tours guidés désactivés");
                return;
            }
            if (window.localStorage) {
                window.localStorage.removeItem(tourStorageKey);
            }
            openTour(0);
        });

        window.addEventListener("resize", () => {
            if (!tourOverlay?.classList.contains("visible")) return;
            renderTourStep();
        });

        const tourSkipOnReload = window.sessionStorage?.getItem(tourSkipFlag);
        if (tourSkipOnReload) {
            window.localStorage?.setItem(tourStorageKey, "1");
            window.sessionStorage?.removeItem(tourSkipFlag);
        }
        const tourSeen = window.localStorage?.getItem(tourStorageKey);
        if (!tourSeen && (window.GoToolkitConfig?.enableTours !== false)) {
            setTimeout(() => openTour(0), 200);
        }
    </script>

</body>

</html>