<!DOCTYPE html>
<html lang="fr">

<head>
    <script>window.GO_TOOLKIT_SHARE_API_URL = 'https://share.gotoolkit.workers.dev/'</script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grid | Go-Toolkit</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap">
    <link rel="stylesheet" href="styles/app-shell.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ag-grid-community@32.3.3/styles/ag-grid.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ag-grid-community@32.3.3/styles/ag-theme-quartz.css">
    <script
        src="https://cdn.jsdelivr.net/npm/@ag-grid-community/locale@32.3.3/dist/umd/@ag-grid-community/locale.min.js"></script>
    <style>
        #clearGridBtn {
            margin-left: auto;
            margin-right: 6px;
        }

        .template-tooltip {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.06);
            padding: 8px 10px;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            z-index: 2200;
            max-width: 360px;
            font-size: 12px;
            color: #ffffff;
            line-height: 1.3;
            backdrop-filter: blur(2px);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s ease;
        }

        .template-tooltip[aria-hidden="false"]:not(:empty) {
            display: block;
            opacity: 1;
        }

        :root {
            font-size: 12px;
            --app-text: #101428;
            --app-bg: #f3f4f6;
            --app-border: #cdd4ed;
            --app-border-strong: #cdd4ed;
            --app-primary-strong: #1f2a56;
        }

        .tabs-actions {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
            flex-wrap: nowrap;
        }

        .nav-switch {
            position: relative;
            display: inline-flex;
            align-items: center;
        }

        .nav-switch-menu {
            position: absolute;
            top: calc(100% + 6px);
            left: 0;
            min-width: 180px;
            background: #ffffff;
            border-radius: 14px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            padding: 6px;
            display: none;
            z-index: 50;
        }

        .nav-switch-menu.open {
            display: block;
        }

        .nav-switch-link {
            display: flex;
            align-items: center;
            gap: 6px;
            width: 100%;
            border: none;
            background: transparent;
            border-radius: 10px;
            padding: 8px 12px;
            font-size: 12px;
            cursor: pointer;
            text-decoration: none;
            color: #1f2a56;
        }

        .nav-switch-link:hover,
        .nav-switch-link:focus-visible {
            background: rgba(42, 122, 87, 0.08);
        }

        .connect-layout {
            flex: 1;
            padding: 0px 0px;
            display: flex;
            gap: 4px;
        }

        .connect-left {
            background: #ffffff;
            border-radius: 8px;
            padding: 10px;
            border: 1px solid #dfe3f5;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .connect-left.collapsed {
            display: none;
        }

        .connect-right.full-width {
            flex: 1 1 100%;
            width: 100%;
        }


        .connect-right {
            background: #ffffff;
            border-radius: 8px;
            padding: 0px;
            border: 1px solid #dfe3f5;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .connect-left,
        .connect-right {
            flex: 1;
        }

        .connect-left textarea {
            font-size: 12px;
            font-family: var(--app-font, "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif);
        }

        .connect-left {
            flex: 0 0 350px;
            max-width: 350px;
            width: 100%;
        }

        .prompt-input-wrapper {
            position: relative;
        }

        .prompt-input-wrapper textarea {
            position: relative;
            background: #fbfbff;
            z-index: 1;
            padding: 8px;
            margin: 0;
            border: 1px solid #d6dbf2;
            border-radius: 4px;
            color: #101428;
            box-sizing: border-box;
        }

        .speech-field-wrapper {
            position: relative;
            height: 100%;
        }

        .speech-field-wrapper textarea {
            padding-right: 40px;
            padding-bottom: 42px;
            position: relative;
            z-index: 2;
        }

        .prompt-file-row {
            display: none;
            position: absolute;
            left: 6px;
            right: 6px;
            bottom: 6px;
            width: 100%;
            flex-wrap: nowrap;
            align-items: center;
            justify-content: space-between;
            padding: 4px 6px;
            border-radius: 8px;
            background: transparent;
            border: none;
            z-index: 4;
        }

        .prompt-file-row.visible {
            display: flex;
        }

        .prompt-file-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            align-items: center;
            flex: 1 1 auto;
            min-height: 24px;
        }

        .prompt-file-item {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 2px 6px;
            border-radius: 6px;
            border: 1px solid #bfc6dc;
            background: #f4f5fb;
            font-size: 11px;
        }

        .prompt-file-item.is-error {
            border-color: #b42318;
            color: #b42318;
        }

        .prompt-file-item button {
            border: none;
            background: transparent;
            color: #7f1d1d;
            cursor: pointer;
            padding: 0;
            font-size: 12px;
            margin-right: 4px;
        }

        .prompt-file-btn {
            position: relative;
            width: 24px;
            height: 24px;
            border-radius: 999px;
            border: none;
            background: transparent;
            color: var(--app-muted);
            font-size: 14px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .speech-button {
            position: absolute;
            top: 6px;
            right: 6px;
            width: 24px;
            height: 24px;
            background: rgba(255, 255, 255, 0.85);
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border: none;
            color: var(--app-muted);
            border-radius: 999px;
            transition: box-shadow 0.2s ease, opacity 0.2s ease;
            opacity: 0;
            pointer-events: none;
            z-index: 3;
            transform: translateX(2px);
        }

        .speech-field-wrapper:hover .speech-button,
        .speech-field-wrapper:focus-within .speech-button {
            opacity: 1;
            pointer-events: auto;
        }

        .speech-button--active,
        .speech-button:active {
            color: #B11226;
            animation: speech-blink 2s infinite linear;
            opacity: 1;
        }

        @keyframes speech-blink {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.4;
            }
        }

        .speech-suggestion {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            bottom: 10px;
            pointer-events: none;
            font: inherit;
            line-height: 1.4;
            white-space: pre-wrap;
            word-break: break-word;
            z-index: 3;
        }

        .speech-suggestion span {
            display: inline;
        }

        .speech-suggestion-current {
            color: transparent;
        }

        .speech-suggestion-partial {
            color: rgba(15, 23, 42, 0.45);
        }

        .speech-suggestion:not(.visible) {
            visibility: hidden;
        }

        @keyframes speech-border {

            0%,
            100% {
                box-shadow: 0 0 0 0 rgba(177, 18, 38, 0.2);
            }

            50% {
                box-shadow: 0 0 0 6px rgba(177, 18, 38, 0.12);
            }
        }

        .speech-field-wrapper.speech-active textarea {
            border: 2px solid #B11226;
            animation: speech-border 2s infinite ease-in-out;
        }

        .speech-field-wrapper.speech-active textarea:focus {
            border-color: #B11226;
        }

        .prompt-suggestion {
            pointer-events: none;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            padding: 0;
            box-sizing: border-box;
            white-space: pre-wrap;
            word-break: break-word;
            font-family: inherit;
            font-size: inherit;
            line-height: inherit;
            color: #c8cee8;
            overflow: hidden;
            z-index: 40;
        }

        .prompt-suggestion .prompt-suggestion-mask {
            color: transparent;
        }

        .prompt-suggestion .prompt-suggestion-hint {
            color: #c8cee8;
        }

        .prompt-alt-row {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }

        .prompt-alt-badge {
            border: 1px solid #d6dbf2;
            background: #ffffff;
            color: #1f2a56;
            border-radius: 12px;
            padding: 3px 6px;
            font-size: 11px;
            cursor: pointer;
            transition: background 0.15s ease, border-color 0.15s ease;
            text-transform: capitalize;
        }

        .prompt-alt-badge:hover,
        .prompt-alt-badge:focus-visible {
            background: #f0f4ff;
            border-color: #c0c8ee;
            outline: none;
        }

        .drawer-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.25);
            backdrop-filter: blur(2px);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 60;
        }

        .template-modal {
            max-width: 620px;
            width: 90vw;
        }

        .template-card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 10px;
            margin: 10px 0 0;
        }

        .template-card {
            border: 1px solid #dfe3f5;
            border-radius: 12px;
            padding: 10px;
            cursor: pointer;
            background: #fbfbff;
            transition: border-color 0.15s ease, box-shadow 0.15s ease, background 0.15s ease;
        }

        .template-card:hover,
        .template-card:focus-visible {
            border-color: #2a7a57;
            box-shadow: 0 10px 30px rgba(15, 23, 42, 0.08);
            outline: none;
        }

        .template-card.selected {
            border-color: #2a7a57;
            background: #f1f8f4;
        }

        .template-card strong {
            display: block;
            font-size: 13px;
            margin-bottom: 6px;
        }

        .template-card p {
            margin: 0;
            font-size: 12px;
            color: #566188;
            line-height: 1.4;
        }

        .modal-actions.template-actions {
            justify-content: flex-end;
        }

        .tree-template .treeCell {
            display: flex;
            align-items: center;
            gap: 0px;
            height: 100%;
            position: relative;
            padding: 0 2px;
        }

        .tree-template .indent {
            width: calc(var(--indent, 14px) * var(--depth, 0));
            flex: 0 0 auto;
            height: 100%;
            position: relative;
        }

        .tree-template .indent::before {
            content: "";
            position: absolute;
            right: 8px;
            top: -999px;
            bottom: -999px;
            width: 1px;
            background: #dfe3f5;
            opacity: 0.9;
        }

        .tree-template .indent.depth-0::before {
            display: none;
        }

        .tree-template .dragHandle {
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #64748b;
            border-radius: 6px;
            cursor: grab;
        }

        .tree-template .dragHandle:active {
            cursor: grabbing;
        }

        .tree-template .dragHandle:hover {
            background: rgba(15, 23, 42, 0.08);
        }

        .tree-template .badge {
            font-weight: 800;
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 8px;
            border: 1px solid #bde6c9;
            background: #eaf7ee;
            color: #0b5133;
            cursor: pointer;
            line-height: 1;
            white-space: nowrap;
        }

        .tree-template .badge.orange {
            border-color: #ffd7ad;
            background: #fff3e5;
            color: #783800;
        }

        .tree-template .label {
            font-weight: 700;
            padding: 2px 4px;
            border-radius: 8px;
            flex: 1;
            min-width: 0;
        }

        .tree-template .label.editing {
            outline: 2px solid rgba(59, 130, 246, 0.55);
            background: rgba(59, 130, 246, 0.08);
        }

        .tree-template .addBtn {
            margin-left: 2px;
            width: 26px;
            height: 26px;
            border-radius: 8px;
            border: 1px solid #d6dde8;
            background: #ffffff;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .tree-template .addBtn:hover {
            background: rgba(15, 23, 42, 0.05);
        }

        .tree-template .relation-badge {
            border: 1px solid #bde6c9;
            background: #eaf7ee;
            color: #0b5133;
            border-radius: 8px;
            padding: 4px 8px;
            font-size: 12px;
            font-weight: 800;
            cursor: pointer;
        }

        .tree-template .relation-badge.orange {
            border-color: #ffd7ad;
            background: #fff3e5;
            color: #783800;
        }

        .tree-template .ag-theme-quartz {
            --ag-font-family: var(--app-font, "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif);
            --ag-border-color: transparent;
            --ag-row-hover-color: rgba(0, 0, 0, 0.04);
            --ag-row-border-color: #e6e9ef;
            --ag-grid-size: 6px;
            --ag-row-height: 44px;
        }

        .tree-template .ag-row {
            border-bottom: 1px solid #e6e9ef;
        }

        .tree-template .ag-row:last-child {
            border-bottom: none;
        }

        .tree-template .ag-cell[col-id="__actions"] .ag-drag-handle {
            display: none !important;
        }

        .tree-template .treeCell[data-drop="above"] {
            box-shadow: inset 0 2px 0 0 #2563eb;
        }

        .tree-template .treeCell[data-drop="below"] {
            box-shadow: inset 0 -2px 0 0 #2563eb;
        }

        .tree-template .treeCell[data-drop="child"] {
            box-shadow: inset 0 0 0 2px rgba(37, 99, 235, 0.35);
        }

        /* Reduce horizontal padding for specific columns (name, relation, actions) */
        .tree-template .ag-cell[col-id="name"],
        .tree-template .ag-cell[col-id="__actions"],
        .tree-template .ag-cell[col-id="relation"] {
            padding-left: 2px !important;
            padding-right: 2px !important;
        }

        /* Apply same padding to header cells for those columns */
        .tree-template .ag-header-cell[col-id="name"],
        .tree-template .ag-header-cell[col-id="__actions"],
        .tree-template .ag-header-cell[col-id="relation"] {
            padding-left: 2px !important;
            padding-right: 2px !important;
        }

        /* Make the Relation header label more compact */
        .tree-template .ag-header-cell[col-id="relation"] .ag-header-cell-label {
            min-width: 0;
            /* allow shrinking */
        }

        .tree-template .ag-header-cell[col-id="relation"] .ag-header-cell-text {
            font-size: 11px;
            max-width: 56px;
            display: inline-block;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            vertical-align: middle;
        }

        /* Reduce left/right margins (cells + headers) for specific columns */
        .tree-template .ag-cell[col-id="name"] .treeCell,
        .tree-template .ag-cell[col-id="__actions"] .treeCell,
        .tree-template .ag-cell[col-id="relation"] .treeCell {
            margin-left: 2px !important;
            margin-right: 2px !important;
        }

        .tree-template .ag-header-cell[col-id="name"] .ag-header-cell-label,
        .tree-template .ag-header-cell[col-id="__actions"] .ag-header-cell-label,
        .tree-template .ag-header-cell[col-id="relation"] .ag-header-cell-label {
            margin-left: 2px !important;
            margin-right: 2px !important;
        }


        .card-title {
            font-size: 13px;
            font-weight: 600;
        }

        .card-title-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0px;
            margin-bottom: 0px;
        }

        .card-actions {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .template-meta {
            font-size: 11px;
            color: #566188;
            margin: -4px 0 6px;
        }

        textarea {
            width: 100%;
            border-radius: 4px;
            border: 1px solid #d6dbf2;
            padding: 8px;
            resize: none;
            font-family: inherit;
            font-size: 12px;
            line-height: 1.5;
            background: #fbfbff;
            color: #101428;
        }

        textarea:focus {
            outline: none;
            border-color: var(--app-primary);
            scrollbar-width: thin;
        }

        #gridScript:not(:focus) {
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        #gridScript:not(:focus)::-webkit-scrollbar {
            width: 0;
            height: 0;
        }

        .prompt-input-card {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .prompt-input-card textarea {
            height: 260px;
            margin-bottom: 0px;
        }

        .mermaid-output-card {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-height: 0;
        }

        .mermaid-output-card textarea {
            flex: 1;
            min-height: 0;
        }

        .generate-btn,
        .refresh-btn {
            align-self: flex-start;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .generate-btn {
            border: none;
            background: #2a7a57;
            color: #ffffff;
            box-shadow: none;
            border-radius: 8px;
            padding: 6px 10px;
        }

        .generate-btn:disabled {
            opacity: 0.6;
        }

        .status-label {
            font-size: 12px;
            color: #566188;
            min-height: 18px;
        }

        .status-toast {
            position: fixed;
            left: 24px;
            bottom: 24px;
            max-width: 280px;
            background: rgba(16, 20, 40, 0.92);
            color: #ffffff;
            padding: 12px 16px;
            border-radius: 8px;
            box-shadow: 0 12px 24px rgba(16, 20, 40, 0.35);
            font-size: 13px;
            line-height: 1.4;
            opacity: 0;
            transform: translateY(8px);
            transition: opacity 0.2s ease, transform 0.2s ease;
            pointer-events: none;
            z-index: 100;
        }

        .status-toast.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .grid-card {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
            padding: 2px 6px;
            min-height: 0;
        }

        .diagram-title-row {
            margin: 0 10px 0px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .diagram-title-input {
            width: 100%;
            padding: 6px 6px 0px 6px;
            font-size: 14px;
            font-weight: 700;
            border: 1px solid transparent;
            border-radius: 8px;
            background: #ffffff;
            color: #0f172a;
            flex: 1 1 auto;
        }

        .grid-filter-wrapper {
            position: relative;
            flex: 0 0 420px;
            max-width: min(520px, 48vw);
            display: flex;
            align-items: center;
        }

        .grid-filter-input {
            width: 100%;
            border-radius: 10px;
            border: 1px solid #dfe3f5;
            padding: 8px 10px;
            font-size: 12px;
            background: #fbfbff;
            color: #101428;
            outline: none;
        }

        .grid-filter-input:focus {
            border-color: #2a7a57;
            box-shadow: 0 0 0 3px rgba(42, 122, 87, 0.14);
        }

        .grid-filter-wrapper[data-status="ok"] .grid-filter-input {
            border-color: rgba(42, 122, 87, 0.65);
            box-shadow: 0 0 0 3px rgba(42, 122, 87, 0.12);
        }

        .grid-filter-ghost {
            position: absolute;
            pointer-events: none;
            font-size: 12px;
            line-height: 1.5;
            color: rgba(101, 116, 138, 0.85);
            white-space: pre;
            z-index: 121;
            display: none;
            user-select: none;
        }

        .grid-filter-suggestions {
            position: absolute;
            left: 0;
            right: 0;
            top: calc(100% + 6px);
            background: #ffffff;
            border: 1px solid rgba(15, 23, 42, 0.12);
            border-radius: 14px;
            box-shadow: 0 12px 28px rgba(15, 23, 42, 0.16);
            padding: 6px;
            z-index: 120;
            display: none;
            max-height: 450px;
            overflow: auto;
        }

        .grid-filter-suggestions.open {
            display: block;
        }

        .grid-filter-suggestion {
            display: flex;
            align-items: baseline;
            justify-content: space-between;
            gap: 8px;
            width: 100%;
            padding: 8px 10px;
            border: none;
            background: transparent;
            border-radius: 10px;
            cursor: pointer;
            text-align: left;
        }

        .grid-filter-suggestion:hover,
        .grid-filter-suggestion.active {
            background: rgba(42, 122, 87, 0.08);
        }

        .grid-filter-suggestion-title {
            font-size: 12px;
            color: #0f172a;
            font-weight: 600;
        }

        .grid-filter-suggestion-meta {
            font-size: 11px;
            color: #65748a;
            white-space: nowrap;
        }

        /* Native ag-Grid column filtering disabled (external filter only). */
        .ag-icon-filter,
        .ag-header-cell-filter-button {
            display: none !important;
        }

        .grid-toolbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
        }

        .grid-toolbar-actions {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .menu-trigger {
            position: relative;
            display: inline-flex;
        }

        .context-menu {
            position: absolute;
            top: calc(100% + 6px);
            right: 0;
            background: #ffffff;
            border: 1px solid rgba(15, 23, 42, 0.1);
            border-radius: 16px;
            box-shadow: 0 16px 32px rgba(15, 23, 42, 0.2);
            display: none;
            min-width: 220px;
            z-index: 60;
        }

        .context-menu.open {
            display: block;
        }

        .context-menu label {
            font-size: 13px;
            color: #0f172a;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .context-menu select {
            border-radius: 8px;
            border: 1px solid #dfe3f5;
            padding: 6px 8px;
            font-size: 13px;
            background: #ffffff;
            color: #0f172a;
        }

        .column-pin-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .share-menu-wrapper {
            position: relative;
            display: inline-flex;
        }

        .share-menu {
            position: absolute;
            top: calc(100% + 6px);
            right: 0;
            width: 260px;
            background: #ffffff;
            border-radius: 16px;
            border: 1px solid rgba(15, 23, 42, 0.1);
            box-shadow: 0 18px 40px rgba(0, 0, 0, 0.15);
            display: none;
            z-index: 120;
        }

        .share-menu.open {
            display: block;
        }

        .share-menu-header {
            font-size: 12px;
            font-weight: 500;
            padding: 10px 12px 6px;
            color: #65748a;
        }

        .share-link-line {
            padding: 0 12px;
        }

        .share-link-field {
            width: 100%;
            border: 1px solid #dfe3f5;
            border-radius: 8px;
            padding: 6px 8px;
            font-size: 12px;
            background: #f7f8ff;
            color: #101428;
        }

        .share-actions {
            display: flex;
            gap: 8px;
            padding: 8px 8px 0px;
        }

        .share-menu-status {
            padding: 0px 12px 0px;
            font-size: 11px;
            color: #566188;
            min-height: 18px;
        }

        .share-menu-status.error {
            color: #b42318;
        }

        .info-popup {
            position: absolute;
            top: 56px;
            right: 12px;
            width: 280px;
            background: #fff;
            border-radius: 14px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            padding: 15px;
            display: none;
            flex-direction: column;
            gap: 6px;
            font-size: 12px;
            z-index: 60;
        }

        .info-popup.open {
            display: flex;
        }

        .display-panel {
            padding: 10px;
        }

        .info-popup img {
            width: 48px;
            height: 48px;
            object-fit: contain;
            align-self: center;
        }

        .info-popup a {
            color: #2a7a57;
            text-decoration: none;
            font-weight: 600;
        }

        .info-popup button {
            border-radius: 8px;
            padding: 6px 12px;
            font-size: 12px;
            background: var(--app-primary, #2a7a57);
            border-color: var(--app-primary, #2a7a57);
            cursor: pointer;
        }

        #gridContainer {
            flex: 1;
            min-height: 420px;
            width: 100%;
        }

        .ag-theme-quartz {
            --ag-font-size: var(--grid-font-size, 12px);
            --ag-border-color: #dfe3f5;
            --ag-header-foreground-color: #0f172a;
            --ag-foreground-color: #0f172a;
            --ag-background-color: #ffffff;
        }

        .ag-theme-quartz .ag-body-viewport,
        .ag-theme-quartz .ag-body-horizontal-scroll {
            scrollbar-width: thin;
            scrollbar-color: rgba(15, 23, 42, 0.45) rgba(255, 255, 255, 0.8);
        }

        .ag-theme-quartz ::-webkit-scrollbar {
            width: 4px;
            height: 3px;
        }

        .ag-theme-quartz ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.9);
        }

        .ag-theme-quartz ::-webkit-scrollbar-thumb {
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.35);
        }

        @media (max-width: 1200px) {
            .connect-layout {
                position: relative;
                gap: 6px;
            }

            .connect-right {
                width: 100%;
            }

            .connect-left {
                position: fixed;
                top: 0;
                right: 0;
                height: 100vh;
                max-width: min(420px, 90vw);
                width: 90vw;
                box-shadow: -12px 0 30px rgba(16, 20, 40, 0.25);
                transform: translateX(110%);
                transition: transform 0.22s ease;
                z-index: 70;
                overflow-y: auto;
            }

            .connect-left.open {
                transform: translateX(0);
            }

            .drawer-overlay.visible {
                opacity: 1;
                pointer-events: all;
            }

            #gridContainer {
                min-height: 60vh;
            }
        }
    </style>
</head>


<body class="app-body">
    <div class="app">
        <header class="app-header">
            <a class="app-home-link" href="index.html" title="Revenir √† l'accueil">‚òç</a>
            <div class="nav-switch">
                <button id="navSwitcherBtn" class="nav-switch-btn" type="button">‚ñ¶ Grid ‚ñæ</button>
                <div id="navSwitcherMenu" class="nav-switch-menu">
                    <a class="nav-switch-link" href="canvas.html">‚óç Canvas</a>
                    <a class="nav-switch-link" href="draw.html">‚óá Draw</a>
                    <a class="nav-switch-link" href="timeline.html">‚á• Timeline</a>
                </div>
            </div>

            <div class="tabs-actions">
                <div id="pageTabs" class="tabs"></div>
                <button id="addPageBtn" class="tab-action" title="Ajouter une page">+</button>
                <button id="deletePageBtn" class="tab-action" title="Supprimer la page">√ó</button>
            </div>
            <div class="global-actions">
                <button id="toggleDrawerBtn" class="btn drawer-toggle-btn" type="button" title="‚∏ô Gutenberg">‚∏ô
                    Contexte</button>
                <button id="aiSettingsBtn" class="btn ai-button" type="button" title="‚åò Promptzilla">‚åò Prompt</button>
                <button id="templateModalBtn" class="btn" type="button" title="‚äû Mod√®le">‚äû Mod√®le</button>
                <div class="menu-trigger">
                    <button id="affichageBtn" class="btn" type="button" aria-label="Affichage" title="Affichage">‚óØ
                        Affichage</button>
                    <div class="context-menu" id="affichageMenu">
                        <div class="menu-panel display-panel">
                            <label>
                                Taille (px)
                                <select id="gridFontSize" aria-label="Taille des cellules"></select>
                            </label>
                        </div>
                    </div>
                </div>
                <div class="menu-trigger" id="capsuleMenuTrigger">
                    <button id="capsuleMenuBtn" class="btn" type="button" title="Capsule">‚¨† Capsule</button>
                    <div class="context-menu" id="capsuleMenu">
                        <div class="menu-panel">
                            <button id="capsuleNewBtn" type="button" class="menu-panel-btn">üóã Nouveau</button>
                            <button id="saveDocumentBtn" type="button" class="menu-panel-btn">üñ´ Enregistrer</button>
                            <button id="capsuleDownloadBtn" type="button" class="menu-panel-btn">‚≠≥ Export CSV</button>
                            <button id="infoButton" type="button" class="menu-panel-btn">‚éâ √Ä propos</button>
                        </div>
                    </div>
                </div>

                <div class="share-menu-wrapper">
                    <button id="shareBtn" class="btn btn-secondary" type="button" aria-label="Partager"
                        title="Lien de la capsule">‚òç Nexus</button>
                    <div id="shareMenu" class="share-menu" role="dialog" aria-live="polite">
                        <div class="menu-panel">
                            <div class="share-menu-header">Lien de la capsule</div>
                            <div class="share-link-line">
                                <input id="shareLinkField" class="share-link-field" type="text" readonly
                                    placeholder="Cr√©er un lien priv√©">
                            </div>
                            <div class="share-actions">
                                <button id="shareUpdateBtn" type="button" class="btn-primary" hidden>üîÑ
                                    Actualiser</button>
                                <button id="shareCreateBtn" type="button" class="btn-primary">‚òç
                                    Cr√©er</button>
                            </div>
                            <p class="share-menu-status" id="shareMenuStatus"></p>
                        </div>
                    </div>
                </div>

            </div>
        </header>

        <div id="drawerOverlay" class="drawer-overlay" aria-hidden="true"></div>

        <main class="connect-layout">
            <section class="connect-right">
                <div class="diagram-title-row">
                    <input id="gridTitleInput" class="diagram-title-input" type="text"
                        placeholder="Titre du jeu de donn√©es">
                    <div id="gridNaturalFilter" class="grid-filter-wrapper" data-status="partial">
                        <input id="gridNaturalFilterInput" class="grid-filter-input" type="text" placeholder="‚åï">
                        <div id="gridNaturalFilterGhost" class="grid-filter-ghost" aria-hidden="true"></div>
                        <div id="gridNaturalFilterSuggestions" class="grid-filter-suggestions" role="listbox"
                            aria-label="Suggestions de filtre" aria-hidden="true"></div>
                    </div>
                </div>
                <div class="grid-card">
                    <div id="gridContainer" class="ag-theme-quartz"></div>
                </div>
            </section>

            <section class="connect-left">
                <div class="prompt-input-card" id="prompt-input-card">
                    <div class="card-title-row">
                        <label>Sc√©nario</label>
                        <button id="clearGridBtn" class="btn" type="button">‚äò Vider</button>
                        <button id="generateBtn" class="btn-primary generate-btn" type="button">‚åò R√©pondre</button>
                    </div>
                    <div id="templateMeta" class="template-meta"></div>
                    <div class="prompt-input-wrapper">
                        <div id="promptSuggestion" class="prompt-suggestion" aria-hidden="true"></div>
                        <div id="templateTooltip" class="template-tooltip" aria-hidden="true"></div>
                        <div class="speech-field-wrapper">
                            <div class="speech-suggestion" data-speech-suggestion="promptInput" aria-hidden="true">
                            </div>
                            <textarea id="promptInput" rows="5"
                                placeholder="D√©cris le contexte des donn√©es attendues (acteur, p√©rim√®tre, r√®gles)..."></textarea>
                            <button class="speech-button" type="button" data-speech-target="promptInput"
                                title="Dict√©e vocale" aria-label="Activer la dict√©e vocale">‚óâ</button>
                            <div id="promptFileRow" class="prompt-file-row" aria-hidden="true">
                                <div id="promptFileList" class="prompt-file-list"></div>
                                <div class="prompt-file-actions">
                                    <input id="promptFileInput" type="file" multiple style="display: none;"
                                        aria-hidden="true">
                                    <button id="promptFileBtn" class="prompt-file-btn" type="button"
                                        title="Ajouter des fichiers" aria-label="Ajouter des fichiers">üóÅ</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="promptAltRow" class="prompt-alt-row" aria-live="polite"></div>
                </div>
                <div class="mermaid-output-card">
                    <div class="card-title-row">
                        <label>Script</label>
                        <div class="card-actions">
                            <button id="applyScriptBtn" class="btn" type="button">‚Ü∫ Restaurer</button>
                        </div>
                    </div>
                    <textarea id="gridScript" spellcheck="false"></textarea>
                </div>
            </section>
        </main>
    </div>

    <div id="statusToast" class="status-toast" role="status"></div>
    <div id="infoPopup" class="context-menu info-popup" role="dialog" aria-live="polite">
        <img src="logo.gif" alt="Logo Go-Toolkit">
        <strong>Module Grid (Le Cardinal)</strong>
        <p>Les tableaux g√©n√©r√©s ici peuvent √™tre partag√©s et export√©s pour enrichir vos capsules m√©tier.</p>
        <button id="closeInfoPopup" type="button" class="btn-primary">R√©initialiser</button>
    </div>

    <div class="modal-overlay" id="templateModal">
        <div class="modal template-modal">
            <header class="modal-header">
                <h3 title="‚äû Mod√®le">‚äû Mod√®le</h3>
                <button id="closeTemplateModal" class="btn-secondary" type="button" aria-label="Fermer">‚úï</button>
            </header>
            <p style="font-size:12px;color:#566188;margin:0 0 6px;">Choisis le type de g√©n√©ration pour cette capsule.
            </p>
            <div class="template-card-grid" id="templateCardList"></div>
            <div class="modal-actions template-actions">
                <button id="templateApplyBtn" class="btn-primary" type="button">Appliquer</button>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="aiModal">
        <div class="modal">
            <header class="modal-header">
                <h3 title="‚åò Promptzilla">‚åò Prompt</h3>
                <button id="closeAiModal" class="btn-secondary" type="button">‚úï</button>
            </header>
            <label>
                <span>Mod√®le</span>
                <select id="aiTemplateSelect"></select>
            </label>
            <label>
                <span>Prompt utilisateur</span>
                <textarea id="promptTemplateField" rows="4"
                    style="font-family: Menlo, Consolas, 'Courier New', monospace;"></textarea>
            </label>
            <label>
                <span>System prompt</span>
                <textarea id="systemPromptField" rows="10"
                    style="font-family: Menlo, Consolas, 'Courier New', monospace;"></textarea>
            </label>
            <div class="modal-actions">
                <button id="resetPromptBtn" class="btn" type="button">‚Ü∫ R√©initialiser</button>
                <button id="applyAiSettingsBtn" class="btn-primary" type="button">Appliquer</button>
            </div>
        </div>
    </div>

    <script src="js/prompt.js"></script>
    <script src="js/ia-config.js"></script>
    <script src="js/ia-client.js"></script>
    <script src="js/idb-doc-store.js"></script>
    <script src="js/share-worker-client.js"></script>
    <script src="js/share-history.js"></script>
    <script src="js/capsule-drafts.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ag-grid-community@32.3.3/dist/ag-grid-community.min.noStyle.js"></script>
    <script>
            (() => {
                const DEFAULT_PROMPT_TEMPLATE =
                    (window.GoPrompts && window.GoPrompts.gridPromptTemplates?.dataGeneration) ||
                    (window.GoPrompts && window.GoPrompts.gridDefaultPromptTemplate) ||
                    "G√©n√®re 60 exemples bas√©s sur {{scenario_prompt}}.";
                const DEFAULT_SYSTEM_PROMPT =
                    (window.GoPrompts && window.GoPrompts.gridSystemPrompts?.dataGeneration) ||
                    (window.GoPrompts && window.GoPrompts.gridSystemPrompt) ||
                    "";
                const TREE_SYSTEM_PROMPT =
                    (window.GoPrompts && window.GoPrompts.gridSystemPrompts?.treeStructure) ||
                    `Tu es un g√©n√©rateur de sch√©mas arborescents pour AG Grid (community, sans treeData). La sortie doit √™tre un **unique objet JSON** contenant un tableau aplati de lignes, et rien d'autre :
{
  "rows": [
    {
      "id": "string (identifiant unique)",
      "name": "string (libell√© affich√©)",
      "path": ["racine", "sous-ensemble", "feuille"], // tableau hi√©rarchique (obligatoire)
      "type": "string (object | varchar | number | boolean | date | dateTime | timestamp)",
      "format": "string (ex: object, email, ISO date, currency)",
      "definition": "string (phrase courte)",
      "sample": "string (exemple)",
      "source": "string (origine)",
      "relation": "string (cardinalit√©: 1..1 | 0..1 | 1..n | 0..n)"
    }
  ]
}
- AUCUN markdown, AUCUN texte hors de cet objet JSON.
- L'identifiant \`id\` doit √™tre alphanum√©rique (lettres/chiffres/underscore, pas d'espace).
- Le champ \`type\` doit √™tre choisi parmi : object, varchar, number, boolean, date, dateTime, timestamp.
- La cardinalit√© peut √™tre 1..1, 0..1, 1..n ou 0..n.
- Chaque entr√©e du tableau rows doit avoir le champ path (hi√©rarchie compl√®te) et relation.
- Respecte les colonnes de l'interface : Structure / Relation / Type / Format / D√©finition / Exemple / Source.
`;
                const GRID_TEMPLATES = [
                    {
                        id: "data-example",
                        label: "Donn√©es d'exemple",
                        description: "Dataset tabulaire plat, id√©al pour g√©n√©rer des exemples concrets.",
                        defaultPromptTemplate:
                            (window.GoPrompts && window.GoPrompts.gridPromptTemplates?.dataGeneration) ||
                            DEFAULT_PROMPT_TEMPLATE,
                        defaultSystemPrompt:
                            (window.GoPrompts && window.GoPrompts.gridSystemPrompts?.dataGeneration) ||
                            DEFAULT_SYSTEM_PROMPT,
                        parser: "flat"
                    },
                    {
                        id: "tree-structure",
                        label: "Structure de donn√©es",
                        description: "Sch√©ma arborescent (Structure / Type / Format / D√©finition / Exemple / Source).",
                        defaultPromptTemplate:
                            (window.GoPrompts && window.GoPrompts.gridPromptTemplates?.treeStructure) ||
                            "G√©n√®re une arborescence structur√©e r√©pondant √† {{scenario_prompt}}. Retourne { \"rows\": [] } avec pour chaque ligne : id, name, path (tableau hi√©rarchique), type, format, definition, sample, source et relation (1..1 | 0..1 | 1..n).",
                        defaultSystemPrompt:
                            (window.GoPrompts && window.GoPrompts.gridSystemPrompts?.treeStructure) ||
                            TREE_SYSTEM_PROMPT,
                        parser: "tree"
                    }
                ];
                const DEFAULT_TEMPLATE_ID = GRID_TEMPLATES[0].id;
                const STORAGE_KEY = "grid-ai-state";
                const TEMPLATE_MODAL_SEEN_KEY = "grid-template-modal-seen";
                const OPEN_AI_MESSAGE_MAX_CHARS = 3000;
                const AI_BACKEND_STORAGE_KEY = "go-toolkit-ai-backend";

                const navSwitcherBtn = document.getElementById("navSwitcherBtn");
                const navSwitcherMenu = document.getElementById("navSwitcherMenu");
                const promptInput = document.getElementById("promptInput");
                const promptTemplateField = document.getElementById("promptTemplateField");
                const systemPromptField = document.getElementById("systemPromptField");
                const aiModal = document.getElementById("aiModal");
                const aiSettingsBtn = document.getElementById("aiSettingsBtn");
                const closeAiModal = document.getElementById("closeAiModal");
                const aiTemplateSelect = document.getElementById("aiTemplateSelect");
                const templateModal = document.getElementById("templateModal");
                const templateModalBtn = document.getElementById("templateModalBtn");
                const templateApplyBtn = document.getElementById("templateApplyBtn");
                const templateCardList = document.getElementById("templateCardList");
                const closeTemplateModal = document.getElementById("closeTemplateModal");
                const resetPromptBtn = document.getElementById("resetPromptBtn");
                const applyAiSettingsBtn = document.getElementById("applyAiSettingsBtn");
                const generateBtn = document.getElementById("generateBtn");
                const clearGridBtn = document.getElementById("clearGridBtn");
                const applyScriptBtn = document.getElementById("applyScriptBtn");
                const gridScript = document.getElementById("gridScript");
                const gridTitleInput = document.getElementById("gridTitleInput");
                const gridNaturalFilter = document.getElementById("gridNaturalFilter");
                const gridNaturalFilterInput = document.getElementById("gridNaturalFilterInput");
                const gridNaturalFilterGhost = document.getElementById("gridNaturalFilterGhost");
                const gridNaturalFilterSuggestions = document.getElementById("gridNaturalFilterSuggestions");
                let gridNaturalFilterInputOriginalPlaceholder = gridNaturalFilterInput?.placeholder || "";
                const statusToast = document.getElementById("statusToast");
                const statusLabel = document.querySelector(".status-label");
                const pageTabs = document.getElementById("pageTabs");
                const addPageBtn = document.getElementById("addPageBtn");
                const deletePageBtn = document.getElementById("deletePageBtn");
                const drawerOverlay = document.getElementById("drawerOverlay");
                const drawerBtn = document.getElementById("toggleDrawerBtn");
                const sidebar = document.querySelector(".connect-left");
                const connectRight = document.querySelector(".connect-right");
                const promptSpeechSuggestion = document.querySelector('[data-speech-suggestion="promptInput"]');
                const promptFileRow = document.getElementById("promptFileRow");
                const promptFileList = document.getElementById("promptFileList");
                const promptFileInput = document.getElementById("promptFileInput");
                const promptFileBtn = document.getElementById("promptFileBtn");
                const affichageBtn = document.getElementById("affichageBtn");
                const affichageMenu = document.getElementById("affichageMenu");
                const fontSizeInput = document.getElementById("gridFontSize");
                const columnPinBtn = document.querySelector("[data-column-pin-trigger]");
                const columnPinMenu = document.getElementById("columnPinMenu");
                const columnPinList = document.getElementById("columnPinList");
                const shareBtn = document.getElementById("shareBtn");
                const shareMenu = document.getElementById("shareMenu");
                const shareLinkField = document.getElementById("shareLinkField");
                const shareCreateBtn = document.getElementById("shareCreateBtn");
                const shareUpdateBtn = document.getElementById("shareUpdateBtn");
                const shareMenuStatus = document.getElementById("shareMenuStatus");
                const capsuleMenuBtn = document.getElementById("capsuleMenuBtn");
                const capsuleMenu = document.getElementById("capsuleMenu");
                const capsuleNewBtn = document.getElementById("capsuleNewBtn");
                const saveDocumentBtn = document.getElementById("saveDocumentBtn");
                const capsuleDownloadBtn = document.getElementById("capsuleDownloadBtn");
                const infoButton = document.getElementById("infoButton");
                const infoPopup = document.getElementById("infoPopup");
                const closeInfoPopup = document.getElementById("closeInfoPopup");
                const templateMeta = document.getElementById("templateMeta");
                const shareHistory = window.goToolkitShareHistory;
                const shareService = window.goToolkitShareWorker;
                const capsuleDrafts = window.goToolkitCapsuleDrafts;
                const generateDefaultLabel = generateBtn?.textContent || "‚åò R√©pondre";
                const drawerDefaultLabel = drawerBtn?.textContent || "‚∏ô Contexte";
                const hasSeenTemplateModal =
                    typeof localStorage !== "undefined" &&
                    localStorage.getItem(TEMPLATE_MODAL_SEEN_KEY) === "1";
                let generateCooldownTimer = null;
                let generateCooldownEndTime = 0;

                let activeRequestController = null;
                let pendingAbortStatus = false;

                const FONT_SIZE_CHOICES = [8, 9, 10, 11, 12, 13, 14, 15, 16];
                const FIRESTORE_COLLECTION = "grids";
                const SHARE_QUERY_PARAM = "share";
                const EDIT_QUERY_PARAM = "edit";
                const SHARE_WORKER_UNAVAILABLE_MESSAGE =
                    "Le partage priv√© n√©cessite le worker Cloudflare li√© √† Go-Toolkit (go-toolkit-share).";
                const SHARE_DRAFT_PREFIX = `${STORAGE_KEY}-share-`;
                let shareWorkerAvailable = Boolean(shareService && shareService.isReady);
                let shareRequestInProgress = false;
                let shareLastUpdatedAt = null;
                let shareLoadedFromRemote = false;
                let shareStatusMessage = "";
                let shareStatusType = "";
                let currentShareToken = null;
                let currentDraftId = null;
                let isDraftSaving = false;
                const DISPLAY_PREFERENCE_DEFAULTS = {
                    fontSize: 12,
                    rowHeight: 32
                };
                const DEFAULT_PINNED_FIELDS = new Set(["id", "name"]);
                const DESKTOP_DRAWER_BREAKPOINT = 1200;
                let sidebarOpenDesktop = true;
                let fileUploads = [];
                let autoSizeTimer = null;
                const gridElement = document.getElementById("gridContainer");

                const naturalFilterState = {
                    active: false,
                    status: "partial",
                    input: "",
                    ast: null,
                    lastGoodAst: null,
                    error: "",
                    lastDisplayedRowCount: null,
                    lastAcceptedInput: ""
                };

                const gridOptions = {
                    defaultColDef: {
                        editable: true,
                        sortable: true,
                        filter: false,
                        resizable: true,
                        tooltipValueGetter: params => {
                            if (!params || params.value == null) return "";
                            const val = Array.isArray(params.value) ? params.value.join(" / ") : params.value;
                            return typeof val === "string" ? val : String(val);
                        }
                    },
                    localeText: typeof AG_GRID_LOCALE_FR !== "undefined" ? AG_GRID_LOCALE_FR : undefined,
                    autoSizeStrategy: {
                        type: "fitGridWidth",
                        defaultMinWidth: 85
                    },
                    rowHeight: DISPLAY_PREFERENCE_DEFAULTS.rowHeight,
                    rowData: [],
                    columnDefs: [],
                    isExternalFilterPresent: () => Boolean(naturalFilterState.active),
                    doesExternalFilterPass: (node) => {
                        try {
                            const tableId = getActivePage()?.tableId || "";
                            const evalRow = buildExternalFilterRow(node?.data || {}, tableId);
                            return evaluateAST(naturalFilterState.ast, evalRow);
                        } catch (err) {
                            return true;
                        }
                    },
                    onCellValueChanged: syncScriptFromGrid,
                    onColumnMoved: syncScriptFromGrid,
                    onColumnPinned: syncScriptFromGrid,
                    onColumnResized: syncScriptFromGrid
                };
                const gridApi = agGrid.createGrid(gridElement, gridOptions);
                const gridColumnApi = gridOptions.columnApi;
                if (typeof window !== "undefined") {
                    window.goToolkitGridApi = gridApi;
                    window.goToolkitGridOptions = gridOptions;
                }

                const DEFAULT_PRIMARY_KEY = "id";

                function createTableId(index) {
                    const safeIndex = Math.max(1, Number.isFinite(index) ? index : 1);
                    return `table${safeIndex}`;
                }

                function createPage(index) {
                    const tableId = createTableId(index);
                    return {
                        id: `page-${Date.now()}-${index}-${Math.floor(Math.random() * 10000)}`,
                        tableId,
                        title: `Table ${index}`,
                        primaryKey: DEFAULT_PRIMARY_KEY,
                        relations: [],
                        scenario: "",
                        script: "",
                        lastAiScript: "",
                        data: { columnDefs: [], rowData: [] }
                    };
                }

                function normalizePage(page, index) {
                    if (!page || typeof page !== "object") {
                        return createPage(index + 1);
                    }
                    const tableId =
                        typeof page.tableId === "string" && page.tableId.trim()
                            ? page.tableId.trim()
                            : createTableId(index + 1);
                    return {
                        id: page.id || `page-${Date.now()}-${index}`,
                        tableId,
                        title: page.title || `Table ${index + 1}`,
                        primaryKey:
                            typeof page.primaryKey === "string" && page.primaryKey.trim()
                                ? page.primaryKey.trim()
                                : DEFAULT_PRIMARY_KEY,
                        relations: Array.isArray(page.relations) ? page.relations : [],
                        scenario: page.scenario || "",
                        script: page.script || "",
                        lastAiScript: page.lastAiScript || "",
                        data: page.data && typeof page.data === "object"
                            ? {
                                columnDefs: Array.isArray(page.data.columnDefs) ? page.data.columnDefs : [],
                                rowData: Array.isArray(page.data.rowData) ? page.data.rowData : []
                            }
                            : { columnDefs: [], rowData: [] }
                    };
                }

                function normalizeRelation(rel) {
                    if (!rel || typeof rel !== "object") return null;
                    const type = typeof rel.type === "string" ? rel.type.trim() : "";
                    const fromTable = typeof rel.fromTable === "string" ? rel.fromTable.trim() : "";
                    const fromColumn = typeof rel.fromColumn === "string" ? rel.fromColumn.trim() : "";
                    const toTable = typeof rel.toTable === "string" ? rel.toTable.trim() : "";
                    const toColumn = typeof rel.toColumn === "string" ? rel.toColumn.trim() : "";
                    const label = typeof rel.label === "string" ? rel.label.trim() : "";
                    if (!fromTable || !fromColumn || !toTable || !toColumn) return null;
                    return { type, fromTable, fromColumn, toTable, toColumn, label };
                }

                function normalizeDatasetSchema(dataset) {
                    const tables = Array.isArray(dataset?.schema?.tables) ? dataset.schema.tables : [];
                    return {
                        tables: tables
                            .map(table => {
                                if (!table || typeof table !== "object") return null;
                                const id = typeof table.id === "string" ? table.id.trim() : "";
                                if (!id) return null;
                                const title = typeof table.title === "string" && table.title.trim() ? table.title.trim() : id;
                                const primaryKey =
                                    typeof table.primaryKey === "string" && table.primaryKey.trim()
                                        ? table.primaryKey.trim()
                                        : DEFAULT_PRIMARY_KEY;
                                const columns = Array.isArray(table.columns) ? table.columns : [];
                                const relations = (Array.isArray(table.relations) ? table.relations : [])
                                    .map(normalizeRelation)
                                    .filter(Boolean);
                                return { id, title, primaryKey, columns, relations };
                            })
                            .filter(Boolean)
                    };
                }

                function buildDatasetFromState() {
                    const schemaTablesFromState = Array.isArray(state?.schema?.tables) ? state.schema.tables : [];
                    const schemaTables = schemaTablesFromState.length
                        ? schemaTablesFromState.map(table => ({
                            id: table.id,
                            title: table.title,
                            primaryKey: table.primaryKey || DEFAULT_PRIMARY_KEY,
                            columns: Array.isArray(table.columns) ? table.columns : [],
                            relations: Array.isArray(table.relations) ? table.relations : []
                        }))
                        : state.pages.map(page => ({
                            id: page.tableId,
                            title: page.title,
                            primaryKey: page.primaryKey || DEFAULT_PRIMARY_KEY,
                            columns: [],
                            relations: Array.isArray(page.relations) ? page.relations : []
                        }));
                    const data = {};
                    state.pages.forEach(page => {
                        data[page.tableId] = {
                            columnDefs: Array.isArray(page.data?.columnDefs) ? page.data.columnDefs : [],
                            rowData: Array.isArray(page.data?.rowData) ? page.data.rowData : []
                        };
                    });
                    return { schema: { tables: schemaTables }, data };
                }

                const TREE_SAMPLE_DATASET = {
                    rows: [
                        {
                            id: "contract",
                            name: "contract",
                            path: ["contract"],
                            type: "object",
                            format: "object",
                            definition: "Contrat principal",
                            sample: "",
                            source: "Src",
                            relation: "1..1"
                        },
                        {
                            id: "contract_id",
                            name: "contract_id",
                            path: ["contract", "contract_id"],
                            type: "varchar",
                            format: "varchar",
                            definition: "Identifiant du contrat",
                            sample: "1-XXXX",
                            source: "SAP",
                            relation: "1..1"
                        },
                        {
                            id: "payment_terms",
                            name: "payment_terms",
                            path: ["contract", "payment_terms"],
                            type: "object",
                            format: "object",
                            definition: "Modalit√©s de paiement",
                            sample: "",
                            source: "Src",
                            relation: "1..n"
                        },
                        {
                            id: "invoice_type",
                            name: "invoice_type",
                            path: ["contract", "payment_terms", "invoice_type"],
                            type: "varchar",
                            format: "varchar",
                            definition: "Type de facture",
                            sample: "ex: email",
                            source: "Src",
                            relation: "1..1"
                        },
                        {
                            id: "value",
                            name: "value",
                            path: ["contract", "payment_terms", "value"],
                            type: "varchar",
                            format: "varchar",
                            definition: "Pourcentage √† appliquer",
                            sample: "ex: email",
                            source: "Src",
                            relation: "1..1"
                        }
                    ]
                };
                const TREE_EMPTY_ROW = {
                    id: "objet",
                    name: "Objet",
                    path: ["Objet"],
                    type: "object",
                    format: "",
                    definition: "Point d'entr√©e de la structure.",
                    sample: "",
                    source: "Src",
                    relation: "1..1"
                };
                const TREE_TYPE_OPTIONS = ["object", "varchar", "number", "boolean", "date", "dateTime", "timestamp"];

                function buildTreeColumnDefs() {
                    return [
                        {
                            field: "name",
                            headerName: "Structure",
                            editable: true,
                            sortable: false,
                            filter: false,
                            resizable: true,
                            pinned: "left",
                            rowDrag: false,
                            width: 260,
                            minWidth: 180,
                            suppressSizeToFit: true,
                            cellRenderer: structureCellRenderer,
                            tooltipField: "name"
                        },
                        {
                            field: "__actions",
                            colId: "__actions",
                            headerName: "",
                            width: 110,
                            maxWidth: 130,
                            pinned: "left",
                            sortable: false,
                            filter: false,
                            resizable: false,
                            rowDrag: false,
                            suppressMovable: true,
                            valueGetter: () => null,
                            valueFormatter: () => "",
                            suppressKeyboardEvent: () => true,
                            cellRenderer: treeActionRenderer
                        },
                        {
                            field: "relation",
                            headerName: "Relation",
                            editable: false,
                            sortable: false,
                            filter: false,
                            resizable: false,
                            pinned: "left",
                            width: 110,
                            cellRenderer: relationCellRenderer
                        },
                        {
                            field: "type",
                            headerName: "Type",
                            editable: true,
                            sortable: false,
                            filter: false,
                            resizable: true,
                            cellEditor: "agSelectCellEditor",
                            cellEditorParams: { values: TREE_TYPE_OPTIONS },
                            tooltipField: "type"
                        },
                        {
                            field: "format",
                            headerName: "Format",
                            editable: true,
                            sortable: false,
                            filter: false,
                            resizable: true,
                            tooltipField: "format"
                        },
                        {
                            field: "definition",
                            headerName: "D√©finition",
                            editable: true,
                            sortable: false,
                            filter: false,
                            resizable: true,
                            tooltipField: "definition"
                        },
                        {
                            field: "sample",
                            headerName: "Exemple",
                            editable: true,
                            sortable: false,
                            filter: false,
                            resizable: true,
                            tooltipField: "sample"
                        },
                        {
                            field: "source",
                            headerName: "Source",
                            editable: true,
                            sortable: false,
                            filter: false,
                            resizable: true,
                            tooltipField: "source"
                        }
                    ];
                }

                function normalizeTreePath(rawPath, fallback = []) {
                    if (Array.isArray(rawPath)) {
                        return rawPath.map(item => (item == null ? "" : String(item))).filter(Boolean);
                    }
                    if (typeof rawPath === "string" && rawPath.trim()) {
                        return rawPath
                            .split(/[>\/|]+/)
                            .map(part => part.trim())
                            .filter(Boolean);
                    }
                    return Array.isArray(fallback) ? [...fallback] : [];
                }

                function normalizeTreeRowInput(row, parentPath = []) {
                    if (!row || typeof row !== "object") return null;
                    const fallbackName = row.name || row.id || "item";
                    const rawPath = row.path ?? row.__path;
                    const fallbackPath = rawPath ? [] : [...parentPath, fallbackName];
                    const path = normalizeTreePath(rawPath, fallbackPath);
                    const level = Math.max(0, path.length - 1);
                    return {
                        id: row.id || path.join("::") || fallbackName,
                        name: fallbackName,
                        type: row.type || "",
                        format: row.format || "",
                        definition: row.definition || "",
                        sample: row.sample || "",
                        source: row.source || "",
                        relation: row.relation || "1..1",
                        path,
                        __path: path,
                        level
                    };
                }

                function flattenTreeNodes(nodes = [], parentPath = []) {
                    const rows = [];
                    nodes.forEach(node => {
                        if (!node) return;
                        const normalized = normalizeTreeRowInput(node, parentPath);
                        if (normalized) {
                            rows.push(normalized);
                        }
                        if (Array.isArray(node.children) && node.children.length) {
                            const nextParent = normalized?.__path?.length ? normalized.__path : parentPath;
                            rows.push(...flattenTreeNodes(node.children, nextParent));
                        }
                    });
                    return rows;
                }

                function normalizeTreeRows(rows = []) {
                    return rows
                        .map(row => normalizeTreeRowInput(row))
                        .filter(Boolean);
                }

                function pathKey(path = []) {
                    return Array.isArray(path) ? path.join(" / ") : "";
                }

                function sortRowsByPath(rows = []) {
                    return [...rows].sort((a, b) => {
                        const pa = Array.isArray(a.__path) ? a.__path : [];
                        const pb = Array.isArray(b.__path) ? b.__path : [];
                        const len = Math.max(pa.length, pb.length);
                        for (let i = 0; i < len; i++) {
                            const av = pa[i];
                            const bv = pb[i];
                            if (av == null && bv == null) continue;
                            if (av == null) return -1;
                            if (bv == null) return 1;
                            if (av === bv) continue;
                            return av < bv ? -1 : 1;
                        }
                        return pa.length - pb.length;
                    });
                }

                function decorateTreeRows(rows = [], options = {}) {
                    const normalizedRows = normalizeTreeRows(rows);
                    const baseRows = options?.sortPaths ? sortRowsByPath(normalizedRows) : normalizedRows;
                    const childrenByParent = new Map();

                    baseRows.forEach(row => {
                        const parentKey = pathKey(row.__path.slice(0, -1));
                        const list = childrenByParent.get(parentKey) || [];
                        list.push(row);
                        childrenByParent.set(parentKey, list);
                    });

                    const isLastMap = new Map();
                    childrenByParent.forEach(list => {
                        list.forEach((row, idx) => {
                            const key = pathKey(row.__path);
                            isLastMap.set(key, idx === list.length - 1);
                        });
                    });

                    baseRows.forEach(row => {
                        const segments = Array.isArray(row.__path) && row.__path.length
                            ? row.__path
                            : [row.name || "item"];
                        const isRoot = segments.length <= 1;
                        if (isRoot) {
                            row.__prefix = "";
                        } else {
                            const parts = [];
                            segments.forEach((_, idx) => {
                                const key = pathKey(segments.slice(0, idx + 1));
                                const isLast = isLastMap.get(key) ?? true;
                                if (idx === segments.length - 1) {
                                    parts.push(isLast ? "‚îî‚îÄ " : "‚îú‚îÄ ");
                                } else {
                                    parts.push(isLast ? "   " : "‚îÇ  ");
                                }
                            });
                            row.__prefix = parts.join("");
                        }
                        row.level = Math.max(0, segments.length - 1);
                        row.path = segments;
                        row.__path = segments;
                    });

                    return baseRows;
                }

                function buildTreeDatasetFromRows(rows) {
                    const columnDefs = buildTreeColumnDefs();
                    const rowData = decorateTreeRows(rows, { sortPaths: true });
                    return {
                        schema: {
                            tables: [
                                {
                                    id: "structure",
                                    title: "Structure de donn√©es",
                                    primaryKey: "id",
                                    columns: [
                                        { field: "name" },
                                        { field: "type" },
                                        { field: "format" },
                                        { field: "definition" },
                                        { field: "sample" },
                                        { field: "source" },
                                        { field: "relation" }
                                    ],
                                    relations: []
                                }
                            ]
                        },
                        data: {
                            structure: {
                                columnDefs,
                                rowData
                            }
                        }
                    };
                }

                function buildTreeDatasetFromNodes(nodes) {
                    return buildTreeDatasetFromRows(flattenTreeNodes(nodes));
                }

                function normalizeTreePayload(payload) {
                    if (!payload || typeof payload !== "object") return null;
                    if (Array.isArray(payload.rows)) {
                        return buildTreeDatasetFromRows(payload.rows);
                    }
                    if (Array.isArray(payload.tree)) {
                        return buildTreeDatasetFromNodes(payload.tree);
                    }
                    if (Array.isArray(payload.nodes)) {
                        return buildTreeDatasetFromNodes(payload.nodes);
                    }
                    if (Array.isArray(payload?.data?.structure?.rowData)) {
                        return buildTreeDatasetFromRows(payload.data.structure.rowData);
                    }
                    return null;
                }

                function setTreeRowData(rows = []) {
                    const prepared = decorateTreeRows(rows);
                    if (gridApi) {
                        if (typeof gridApi.setGridOption === "function") {
                            gridApi.setGridOption("rowData", prepared);
                        } else if (typeof gridApi.setRowData === "function") {
                            gridApi.setRowData(prepared);
                        }
                    }
                    const page = getActivePage();
                    if (page?.data) {
                        page.data.rowData = prepared;
                    }
                    return prepared;
                }

                function deleteTreeRow(node) {
                    if (!node?.data) return;
                    const selfPath = Array.isArray(node.data.__path) ? node.data.__path : [];
                    const rows = collectAllRows().filter(row => {
                        const path = Array.isArray(row.__path) ? row.__path : normalizeTreePath(row.path || []);
                        return !isPathPrefix(selfPath, path);
                    });
                    setTreeRowData(rows);
                    syncScriptFromGrid();
                }

                function prepareTreeRowsForExport(rows = []) {
                    const cloned = Array.isArray(rows) ? rows.map(row => ({ ...row })) : [];
                    return decorateTreeRows(cloned).map(row => ({
                        id: row.id || pathKey(row.__path),
                        name: row.name || "",
                        path: Array.isArray(row.__path) ? row.__path : [],
                        type: row.type || "",
                        format: row.format || "",
                        definition: row.definition || "",
                        sample: row.sample || "",
                        source: row.source || "",
                        relation: row.relation || "1..1"
                    }));
                }

                function hasDatasetContent(dataset) {
                    if (!dataset || typeof dataset !== "object") return false;
                    const data = dataset.data;
                    if (!data || typeof data !== "object") return false;
                    return Object.values(data).some(pageData => {
                        const cols = Array.isArray(pageData?.columnDefs) ? pageData.columnDefs : [];
                        const rows = Array.isArray(pageData?.rowData) ? pageData.rowData : [];
                        return cols.length > 0 || rows.length > 0;
                    });
                }

                function cycleRelation(value) {
                    const order = ["1..1", "0..1", "1..n", "0..n"];
                    const idx = order.indexOf(value);
                    if (idx === -1 || idx === order.length - 1) return order[0];
                    return order[idx + 1];
                }

                function collectAllRows() {
                    const rows = [];
                    try {
                        gridApi?.forEachNode(node => {
                            if (node && node.data) {
                                rows.push({ ...node.data });
                            }
                        });
                    } catch (err) { /* ignore */ }
                    return rows;
                }

                function addChildRow(parentNode) {
                    if (!parentNode) return;
                    const parentPath = Array.isArray(parentNode?.data?.__path) ? parentNode.data.__path : [];
                    const newPath = [...parentPath, `New_${Date.now().toString().slice(-4)}`];
                    const rows = collectAllRows();
                    const newRow = {
                        id: `new_${Date.now()}`,
                        __path: newPath,
                        path: newPath,
                        level: parentPath.length,
                        name: "New",
                        type: "",
                        format: "",
                        definition: "",
                        sample: "",
                        source: "",
                        relation: "1..1"
                    };
                    try {
                        const insertAt = (() => {
                            const idx = rows.findIndex(row => isPathPrefix(parentPath, row.__path || row.path || []));
                            if (idx === -1) return rows.length;
                            let cursor = idx + 1;
                            while (
                                cursor < rows.length &&
                                isPathPrefix(parentPath, rows[cursor].__path || rows[cursor].path || [])
                            ) {
                                cursor += 1;
                            }
                            return cursor;
                        })();
                        const nextRows = [...rows];
                        nextRows.splice(insertAt, 0, newRow);
                        const prepared = setTreeRowData(nextRows);
                        requestAnimationFrame(() => {
                            try {
                                const node = gridApi?.getRowNode?.(newRow.id);
                                if (node) {
                                    gridApi.ensureNodeVisible(node, "middle");
                                    gridApi.startEditingCell({
                                        rowIndex: prepared.findIndex(r => r.id === newRow.id),
                                        colKey: "name"
                                    });
                                }
                            } catch (err) { /* ignore */ }
                        });
                        syncScriptFromGrid();
                    } catch (err) {
                        console.warn("Impossible d'ajouter un enfant", err);
                    }
                }

                function isPathPrefix(prefix, path) {
                    if (!Array.isArray(prefix) || !Array.isArray(path)) return false;
                    if (prefix.length > path.length) return false;
                    return prefix.every((item, idx) => item === path[idx]);
                }

                function updateSubtreePaths(rows, oldPrefix, newPrefix) {
                    return rows.map(row => {
                        const path = Array.isArray(row.__path) ? row.__path : normalizeTreePath(row.path || []);
                        if (!isPathPrefix(oldPrefix, path)) return row;
                        const suffix = path.slice(oldPrefix.length);
                        const nextPath = [...newPrefix, ...suffix];
                        return { ...row, __path: nextPath, path: nextPath };
                    });
                }

                function splitSubtree(rows = [], rootPath = []) {
                    const subtree = [];
                    const remaining = [];
                    rows.forEach(row => {
                        const path = Array.isArray(row.__path) ? row.__path : normalizeTreePath(row.path || []);
                        if (isPathPrefix(rootPath, path)) {
                            subtree.push(row);
                        } else {
                            remaining.push(row);
                        }
                    });
                    return { subtree, remaining };
                }

                function pathEquals(a = [], b = []) {
                    if (!Array.isArray(a) || !Array.isArray(b)) return false;
                    if (a.length !== b.length) return false;
                    return a.every((val, idx) => val === b[idx]);
                }

                function findSubtreeStartIndex(rows = [], targetPath = []) {
                    const key = pathKey(targetPath);
                    return rows.findIndex(r => pathKey(r.__path || normalizeTreePath(r.path || [])) === key);
                }

                function findSubtreeEndIndex(rows = [], targetPath = []) {
                    const idx = findSubtreeStartIndex(rows, targetPath);
                    if (idx === -1) return rows.length;
                    let end = idx;
                    for (let i = idx + 1; i < rows.length; i++) {
                        const path = Array.isArray(rows[i].__path) ? rows[i].__path : normalizeTreePath(rows[i].path || []);
                        if (isPathPrefix(targetPath, path)) {
                            end = i;
                        } else {
                            break;
                        }
                    }
                    return end + 1;
                }

                function moveTreeSubtree(draggedPath, overPath, dropMode) {
                    if (!Array.isArray(draggedPath) || !draggedPath.length || !Array.isArray(overPath)) return;
                    if (isPathPrefix(draggedPath, overPath)) return;
                    const rows = collectAllRows();
                    const { subtree, remaining } = splitSubtree(rows, draggedPath);
                    const overStartIdx = findSubtreeStartIndex(remaining, overPath);
                    const overEndIdx = findSubtreeEndIndex(remaining, overPath);

                    let newParentPath = overPath;
                    let insertIndex = remaining.length;
                    const newBase = draggedPath[draggedPath.length - 1] || "item";

                    if (dropMode === "above") {
                        newParentPath = overPath.slice(0, -1);
                        insertIndex = overStartIdx === -1 ? remaining.length : overStartIdx;
                    } else if (dropMode === "below") {
                        newParentPath = overPath.slice(0, -1);
                        insertIndex = overEndIdx === -1 ? remaining.length : overEndIdx;
                    } else {
                        newParentPath = overPath;
                        insertIndex = findSubtreeEndIndex(remaining, overPath);
                    }

                    const newPath = [...newParentPath, newBase];
                    const updatedSubtree = updateSubtreePaths(subtree, draggedPath, newPath);
                    const nextRows = [...remaining];
                    nextRows.splice(insertIndex, 0, ...updatedSubtree);
                    setTreeRowData(nextRows);
                    syncScriptFromGrid();
                }

                function handleTreeRowDragEnd(event) {
                    // Drag-and-drop now handled by custom renderer; noop here.
                }

                function relationCellRenderer(params) {
                    const relation = params.value || params.data?.relation || "1..1";
                    const btn = document.createElement("button");
                    btn.type = "button";
                    btn.className = `relation-badge ${relation === "1..n" || relation === "1..1" ? "orange" : ""}`;
                    btn.textContent = relation;
                    btn.title = "Basculer la cardinalit√©";
                    btn.addEventListener("click", event => {
                        event.stopPropagation();
                        const next = cycleRelation(params.data?.relation);
                        params.node.setDataValue("relation", next);
                        btn.textContent = next;
                        btn.className = `relation-badge ${next === "1..n" || next === "1..1" ? "orange" : ""}`;
                        syncScriptFromGrid();
                    });
                    return btn;
                }

                const treeDragState = { draggingPath: null };

                function structureCellRenderer(params) {
                    const level = Math.max(0, (params.data?.level ?? 0));
                    const wrapper = document.createElement("div");
                    wrapper.className = "treeCell";
                    wrapper.setAttribute("draggable", "true");

                    const indent = document.createElement("span");
                    indent.className = "indent";
                    indent.style.setProperty("--depth", level);
                    indent.classList.add(`depth-${level}`);

                    const label = document.createElement("span");
                    label.className = "label";
                    label.textContent = params.value || "";

                    function clearDropState() {
                        wrapper.removeAttribute("data-drop");
                    }

                    wrapper.addEventListener("dragstart", event => {
                        treeDragState.draggingPath = Array.isArray(params.data?.__path)
                            ? params.data.__path
                            : normalizeTreePath(params.data?.path || []);
                        event.dataTransfer.effectAllowed = "move";
                    });

                    wrapper.addEventListener("dragend", () => {
                        treeDragState.draggingPath = null;
                        clearDropState();
                    });

                    wrapper.addEventListener("dragover", event => {
                        if (!treeDragState.draggingPath) return;
                        event.preventDefault();
                        const rect = wrapper.getBoundingClientRect();
                        const relY = (event.clientY - rect.top) / rect.height;
                        if (relY < 0.25) {
                            wrapper.setAttribute("data-drop", "above");
                        } else if (relY > 0.75) {
                            wrapper.setAttribute("data-drop", "below");
                        } else {
                            wrapper.setAttribute("data-drop", "child");
                        }
                    });

                    wrapper.addEventListener("dragleave", () => clearDropState());

                    wrapper.addEventListener("drop", event => {
                        if (!treeDragState.draggingPath) return;
                        event.preventDefault();
                        const dropMode = wrapper.getAttribute("data-drop") || "child";
                        const targetPath = Array.isArray(params.data?.__path)
                            ? params.data.__path
                            : normalizeTreePath(params.data?.path || []);
                        moveTreeSubtree(treeDragState.draggingPath, targetPath, dropMode);
                        treeDragState.draggingPath = null;
                        clearDropState();
                    });

                    wrapper.append(indent, label);
                    return wrapper;
                }

                function treeActionRenderer(params) {
                    const wrapper = document.createElement("div");
                    wrapper.className = "treeCell";

                    const addBtn = document.createElement("button");
                    addBtn.type = "button";
                    addBtn.className = "addBtn";
                    addBtn.textContent = "+";
                    addBtn.title = "Ajouter un enfant";
                    addBtn.addEventListener("click", event => {
                        event.stopPropagation();
                        addChildRow(params.node);
                    });

                    const deleteBtn = document.createElement("button");
                    deleteBtn.type = "button";
                    deleteBtn.className = "addBtn";
                    deleteBtn.textContent = "√ó";
                    deleteBtn.title = "Supprimer la ligne";
                    deleteBtn.addEventListener("click", event => {
                        event.stopPropagation();
                        deleteTreeRow(params.node);
                    });

                    wrapper.append(addBtn, deleteBtn);
                    return wrapper;
                }

                function syncDatasetScriptFromState(options = {}) {
                    const dataset = buildDatasetFromState();
                    const isTree = isTreeTemplateActive();
                    let next = "";
                    if (isTree) {
                        const activePage = getActivePage();
                        const rows = prepareTreeRowsForExport(activePage?.data?.rowData || []);
                        next = rows.length ? JSON.stringify({ rows }, null, 2) : "";
                    } else {
                        const hasContent = hasDatasetContent(dataset);
                        next = hasContent ? JSON.stringify(dataset, null, 2) : "";
                    }
                    const tplState = getActiveTemplateState();
                    tplState.datasetScript = next;
                    state.datasetScript = next;
                    if (gridScript) {
                        gridScript.value = next;
                    }
                    if (options.persist !== false) {
                        persistState();
                    }
                    return dataset;
                }

                function normalizeTemplateState(raw, templateConfig) {
                    const basePrompt = templateConfig?.defaultPromptTemplate || DEFAULT_PROMPT_TEMPLATE;
                    const baseSystem = templateConfig?.defaultSystemPrompt || DEFAULT_SYSTEM_PROMPT;
                    if (!raw || typeof raw !== "object") {
                        return {
                            promptTemplate: basePrompt,
                            systemPrompt: baseSystem,
                            scenario: "",
                            datasetScript: "",
                            lastAiDatasetScript: ""
                        };
                    }
                    return {
                        promptTemplate: raw.promptTemplate || basePrompt,
                        systemPrompt: raw.systemPrompt || baseSystem,
                        scenario: raw.scenario || "",
                        datasetScript: typeof raw.datasetScript === "string" ? raw.datasetScript : "",
                        lastAiDatasetScript:
                            typeof raw.lastAiDatasetScript === "string" ? raw.lastAiDatasetScript : ""
                    };
                }

                function loadState() {
                    try {
                        const raw = localStorage.getItem(STORAGE_KEY);
                        if (!raw) {
                            const templateStates = {};
                            GRID_TEMPLATES.forEach(tpl => {
                                templateStates[tpl.id] = normalizeTemplateState(null, tpl);
                            });
                            return {
                                pages: [createPage(1)],
                                activeIndex: 0,
                                promptTemplate: DEFAULT_PROMPT_TEMPLATE,
                                systemPrompt: DEFAULT_SYSTEM_PROMPT,
                                reasoningEffort: "low",
                                displayPreferences: { ...DISPLAY_PREFERENCE_DEFAULTS },
                                activeTemplateId: DEFAULT_TEMPLATE_ID,
                                templateStates,
                                schema: { tables: [] },
                                datasetScript: "",
                                lastAiDatasetScript: ""
                            };
                        }
                        const parsed = JSON.parse(raw);
                        const templateStates = {};
                        GRID_TEMPLATES.forEach(tpl => {
                            const rawTpl = parsed?.templateStates?.[tpl.id];
                            templateStates[tpl.id] = normalizeTemplateState(rawTpl, tpl);
                        });
                        const activeTemplateId =
                            (parsed && typeof parsed.activeTemplateId === "string" && parsed.activeTemplateId.trim()) ||
                            DEFAULT_TEMPLATE_ID;
                        const pages = Array.isArray(parsed.pages)
                            ? parsed.pages.map(normalizePage)
                            : [createPage(1)];
                        const activeIndex = Math.max(0, Math.min((parsed.activeIndex || 0), pages.length - 1));
                        const schemaTables = Array.isArray(parsed?.schema?.tables)
                            ? parsed.schema.tables
                                .map(table => {
                                    if (!table || typeof table !== "object") return null;
                                    const id = typeof table.id === "string" ? table.id.trim() : "";
                                    if (!id) return null;
                                    const title = typeof table.title === "string" && table.title.trim() ? table.title.trim() : id;
                                    const primaryKey =
                                        typeof table.primaryKey === "string" && table.primaryKey.trim()
                                            ? table.primaryKey.trim()
                                            : DEFAULT_PRIMARY_KEY;
                                    const columns = Array.isArray(table.columns) ? table.columns : [];
                                    const relations = (Array.isArray(table.relations) ? table.relations : [])
                                        .map(normalizeRelation)
                                        .filter(Boolean);
                                    return { id, title, primaryKey, columns, relations };
                                })
                                .filter(Boolean)
                            : [];
                        return {
                            pages,
                            activeIndex,
                            promptTemplate: parsed.promptTemplate || DEFAULT_PROMPT_TEMPLATE,
                            systemPrompt: parsed.systemPrompt || DEFAULT_SYSTEM_PROMPT,
                            reasoningEffort: parsed.reasoningEffort || "low",
                            displayPreferences: Object.assign({}, DISPLAY_PREFERENCE_DEFAULTS, parsed.displayPreferences || {}),
                            activeTemplateId,
                            templateStates,
                            schema: { tables: schemaTables },
                            datasetScript: typeof parsed.datasetScript === "string" ? parsed.datasetScript : "",
                            lastAiDatasetScript: typeof parsed.lastAiDatasetScript === "string" ? parsed.lastAiDatasetScript : ""
                        };
                    } catch (err) {
                        console.warn("Impossible de charger l'√©tat Grid", err);
                        const templateStates = {};
                        GRID_TEMPLATES.forEach(tpl => {
                            templateStates[tpl.id] = normalizeTemplateState(null, tpl);
                        });
                        return {
                            pages: [createPage(1)],
                            activeIndex: 0,
                            promptTemplate: DEFAULT_PROMPT_TEMPLATE,
                            systemPrompt: DEFAULT_SYSTEM_PROMPT,
                            reasoningEffort: "low",
                            displayPreferences: { ...DISPLAY_PREFERENCE_DEFAULTS },
                            activeTemplateId: DEFAULT_TEMPLATE_ID,
                            templateStates,
                            schema: { tables: [] },
                            datasetScript: "",
                            lastAiDatasetScript: ""
                        };
                    }
                }

                function getTemplateConfigById(id) {
                    if (!id) return GRID_TEMPLATES[0];
                    return GRID_TEMPLATES.find(tpl => tpl.id === id) || GRID_TEMPLATES[0];
                }

                function getTemplateIcon(templateId) {
                    const tpl = getTemplateConfigById(templateId);
                    if (tpl.parser === "tree") return "üß¨";
                    return "üß™";
                }

                function ensureTemplateState(id) {
                    const tpl = getTemplateConfigById(id);
                    state.templateStates = state.templateStates || {};
                    if (!state.templateStates[tpl.id]) {
                        state.templateStates[tpl.id] = normalizeTemplateState(null, tpl);
                    }
                    return state.templateStates[tpl.id];
                }

                function getActiveTemplateState() {
                    return ensureTemplateState(state.activeTemplateId || DEFAULT_TEMPLATE_ID);
                }

                function getActiveTemplateConfig() {
                    return getTemplateConfigById(state.activeTemplateId || DEFAULT_TEMPLATE_ID);
                }

                function isTreeTemplateActive() {
                    return getActiveTemplateConfig()?.parser === "tree";
                }

                function renderTemplateSelect() {
                    if (!aiTemplateSelect) return;
                    aiTemplateSelect.innerHTML = "";
                    GRID_TEMPLATES.forEach(tpl => {
                        const option = document.createElement("option");
                        option.value = tpl.id;
                        option.textContent = tpl.label;
                        aiTemplateSelect.appendChild(option);
                    });
                    aiTemplateSelect.value = state.activeTemplateId || DEFAULT_TEMPLATE_ID;
                }

                function renderTemplateMeta() {
                    if (!templateMeta) return;
                    const tpl = getActiveTemplateConfig();
                    const icon = getTemplateIcon(tpl.id);
                    templateMeta.textContent = `Mod√®le : ${icon} ${tpl.label}`;
                }

                function renderTemplateCards(selectedId = state.activeTemplateId || DEFAULT_TEMPLATE_ID) {
                    if (!templateCardList) return;
                    templateCardList.innerHTML = "";
                    GRID_TEMPLATES.forEach(tpl => {
                        const card = document.createElement("div");
                        card.className = "template-card";
                        if (tpl.id === selectedId) {
                            card.classList.add("selected");
                        }
                        card.tabIndex = 0;
                        card.dataset.id = tpl.id;
                        card.innerHTML = `<strong>${tpl.label}</strong><p>${tpl.description}</p>`;
                        card.addEventListener("click", () => {
                            renderTemplateCards(tpl.id);
                            templateCardList.dataset.selectedId = tpl.id;
                        });
                        card.addEventListener("keypress", event => {
                            if (event.key === "Enter" || event.key === " ") {
                                event.preventDefault();
                                renderTemplateCards(tpl.id);
                                templateCardList.dataset.selectedId = tpl.id;
                            }
                        });
                        templateCardList.appendChild(card);
                    });
                    templateCardList.dataset.selectedId = selectedId;
                }

                function setActiveTemplate(templateId, options = {}) {
                    const { skipApplyScript = true } = options;
                    const tpl = getTemplateConfigById(templateId);
                    const previousId = state.activeTemplateId || DEFAULT_TEMPLATE_ID;
                    syncTemplateStateFromUI();
                    state.activeTemplateId = tpl.id;
                    state.activeParser = tpl.parser || "flat";
                    const tplState = getActiveTemplateState();
                    state.promptTemplate = tplState.promptTemplate;
                    state.systemPrompt = tplState.systemPrompt;
                    state.datasetScript = tplState.datasetScript || "";
                    state.lastAiDatasetScript = tplState.lastAiDatasetScript || "";
                    if (templateCardList) {
                        templateCardList.dataset.selectedId = tpl.id;
                    }
                    const page = getActivePage();
                    if (page) {
                        page.scenario = tplState.scenario || page.scenario || "";
                    }
                    applyTemplateStateToUI();
                    renderTemplateSelect();
                    renderTemplateMeta();
                    if (!skipApplyScript) {
                        try {
                            applyScriptToGrid({ silentOnError: true, silentOnSuccess: true });
                        } catch (err) {
                            console.warn("Impossible d'appliquer le script du mod√®le", err);
                        }
                    }
                    persistState();
                    if (options.onChange && typeof options.onChange === "function" && tpl.id !== previousId) {
                        options.onChange(tpl);
                    }
                }

                function openTemplateModalUi() {
                    if (!templateModal) return;
                    renderTemplateCards(state.activeTemplateId || DEFAULT_TEMPLATE_ID);
                    templateModal.classList.add("open");
                }

                function closeTemplateModalUi() {
                    if (!templateModal) return;
                    templateModal.classList.remove("open");
                }

                function syncTemplateStateFromUI() {
                    const tplState = getActiveTemplateState();
                    tplState.promptTemplate = promptTemplateField?.value || tplState.promptTemplate || DEFAULT_PROMPT_TEMPLATE;
                    tplState.systemPrompt = systemPromptField?.value || tplState.systemPrompt || DEFAULT_SYSTEM_PROMPT;
                    tplState.scenario = promptInput?.value || tplState.scenario || "";
                    tplState.datasetScript = gridScript?.value || tplState.datasetScript || "";
                    tplState.lastAiDatasetScript = tplState.lastAiDatasetScript || state.lastAiDatasetScript || "";
                    state.promptTemplate = tplState.promptTemplate;
                    state.systemPrompt = tplState.systemPrompt;
                    state.datasetScript = tplState.datasetScript;
                    state.lastAiDatasetScript = tplState.lastAiDatasetScript || "";
                    return tplState;
                }

                function applyTemplateStateToUI() {
                    const tplState = getActiveTemplateState();
                    if (promptTemplateField) {
                        promptTemplateField.value = tplState.promptTemplate || DEFAULT_PROMPT_TEMPLATE;
                    }
                    if (systemPromptField) {
                        systemPromptField.value = tplState.systemPrompt || DEFAULT_SYSTEM_PROMPT;
                    }
                    if (promptInput) {
                        promptInput.value = tplState.scenario || "";
                    }
                    if (gridScript) {
                        gridScript.value = tplState.datasetScript || "";
                    }
                    if (aiTemplateSelect) {
                        aiTemplateSelect.value = state.activeTemplateId || DEFAULT_TEMPLATE_ID;
                    }
                    renderTemplateMeta();
                }

                let state = loadState();
                state.templateStates = state.templateStates && typeof state.templateStates === "object"
                    ? state.templateStates
                    : {};
                GRID_TEMPLATES.forEach(tpl => {
                    if (!state.templateStates[tpl.id]) {
                        state.templateStates[tpl.id] = normalizeTemplateState(null, tpl);
                    }
                });
                state.activeTemplateId = state.activeTemplateId || DEFAULT_TEMPLATE_ID;
                const activeTemplateState = getActiveTemplateState();
                if (!activeTemplateState.datasetScript && state.datasetScript) {
                    activeTemplateState.datasetScript = state.datasetScript;
                }
                if (!activeTemplateState.lastAiDatasetScript && state.lastAiDatasetScript) {
                    activeTemplateState.lastAiDatasetScript = state.lastAiDatasetScript;
                }
                if (!activeTemplateState.promptTemplate && state.promptTemplate) {
                    activeTemplateState.promptTemplate = state.promptTemplate;
                }
                if (!activeTemplateState.systemPrompt && state.systemPrompt) {
                    activeTemplateState.systemPrompt = state.systemPrompt;
                }
                if (!activeTemplateState.scenario && Array.isArray(state.pages) && state.pages.length) {
                    activeTemplateState.scenario = state.pages[state.activeIndex]?.scenario || "";
                }
                state.activeParser = getActiveTemplateConfig().parser || "flat";
                state.promptTemplate = activeTemplateState.promptTemplate || state.promptTemplate || DEFAULT_PROMPT_TEMPLATE;
                state.systemPrompt = activeTemplateState.systemPrompt || state.systemPrompt || DEFAULT_SYSTEM_PROMPT;
                state.datasetScript = activeTemplateState.datasetScript || state.datasetScript || "";
                state.lastAiDatasetScript =
                    activeTemplateState.lastAiDatasetScript || state.lastAiDatasetScript || "";
                if (!state.schema || !Array.isArray(state.schema.tables) || state.schema.tables.length === 0) {
                    state.schema = {
                        tables: state.pages.map(page => ({
                            id: page.tableId,
                            title: page.title,
                            primaryKey: page.primaryKey || DEFAULT_PRIMARY_KEY,
                            columns: [],
                            relations: Array.isArray(page.relations) ? page.relations : []
                        }))
                    };
                }
                if (!state.datasetScript || !state.datasetScript.trim()) {
                    const dataset = buildDatasetFromState();
                    state.datasetScript = hasDatasetContent(dataset) ? JSON.stringify(dataset, null, 2) : "";
                }
                renderFontSizeOptions();
                applyGridDisplayPreferences({ persist: false });
                buildColumnPinMenu();
                renderTemplateSelect();
                renderTemplateCards(state.activeTemplateId || DEFAULT_TEMPLATE_ID);
                renderTemplateMeta();
                if (!hasSeenTemplateModal) {
                    setTimeout(() => {
                        openTemplateModalUi();
                        try {
                            localStorage.setItem(TEMPLATE_MODAL_SEEN_KEY, "1");
                        } catch (err) { /* ignore */ }
                    }, 50);
                }

                function persistState() {
                    try {
                        syncTemplateStateFromUI();
                        const payload = {
                            pages: state.pages.map((page, index) => normalizePage(page, index)),
                            activeIndex: Math.max(0, Math.min(state.activeIndex, state.pages.length - 1)),
                            promptTemplate: state.promptTemplate || DEFAULT_PROMPT_TEMPLATE,
                            systemPrompt: state.systemPrompt || DEFAULT_SYSTEM_PROMPT,
                            reasoningEffort: state.reasoningEffort || "low",
                            displayPreferences: state.displayPreferences || { ...DISPLAY_PREFERENCE_DEFAULTS },
                            activeTemplateId: state.activeTemplateId || DEFAULT_TEMPLATE_ID,
                            templateStates: state.templateStates || {},
                            schema: state.schema || { tables: [] },
                            datasetScript: state.datasetScript || "",
                            lastAiDatasetScript: state.lastAiDatasetScript || ""
                        };
                        localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
                    } catch (err) {
                        console.warn("Impossible de sauvegarder l'√©tat Grid", err);
                    }
                }

                function showStatus(message, isError) {
                    const text = message ? message.toString().trim() : "";
                    if (statusLabel) {
                        statusLabel.textContent = text;
                        statusLabel.style.color = isError ? "#b42318" : "#566188";
                    }
                    if (!text) {
                        statusToast?.classList.remove("visible");
                        return;
                    }
                    if (!statusToast) return;
                    statusToast.textContent = text;
                    statusToast.classList.add("visible");
                    if (isError) {
                        statusToast.style.background = "#7f1d1d";
                    } else {
                        statusToast.style.background = "rgba(16, 20, 40, 0.92)";
                    }
                    setTimeout(() => statusToast.classList.remove("visible"), 3200);
                }

                function getActivePage() {
                    return state.pages[state.activeIndex];
                }

                function renderTabs() {
                    if (!pageTabs) return;
                    pageTabs.innerHTML = "";
                    state.pages.forEach((page, index) => {
                        const btn = document.createElement("button");
                        btn.className = `tab${index === state.activeIndex ? " active" : ""}`;
                        btn.type = "button";
                        const label = (page?.title || "").trim() || `Table ${index + 1}`;
                        btn.textContent = label;
                        btn.title = label;
                        btn.addEventListener("click", () => setActivePage(index));
                        pageTabs.appendChild(btn);
                    });
                }

                function buildCsvFileName() {
                    const page = getActivePage();
                    const title = (gridTitleInput?.value || page?.title || "Grid").trim() || "Grid";
                    const normalizedTitle = title
                        .replace(/\s+/g, "-")
                        .replace(/[^A-Za-z0-9-_]/g, "")
                        .replace(/-+/g, "-")
                        .replace(/^-|-$/g, "");
                    const safeTitle = normalizedTitle || "Grid";
                    const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
                    return `${safeTitle}-${timestamp}.csv`;
                }

                function getAllRelationsFromSchema() {
                    const tables = Array.isArray(state?.schema?.tables) ? state.schema.tables : [];
                    return tables
                        .flatMap(table => (Array.isArray(table?.relations) ? table.relations : []))
                        .map(normalizeRelation)
                        .filter(Boolean);
                }

                function getForeignKeyRelationForField(field, page = getActivePage()) {
                    if (!field) return null;
                    const tableId = page?.tableId || "";
                    if (!tableId) return null;
                    const relations = getAllRelationsFromSchema();
                    for (const rel of relations) {
                        if (rel && rel.fromTable === tableId && rel.fromColumn === field) {
                            return rel;
                        }
                    }
                    return null;
                }

                const FOREIGN_KEY_DISPLAY_FIELD_PREFERENCES = [
                    "name",
                    "nom",
                    "title",
                    "titre",
                    "label",
                    "displayname",
                    "fullname",
                    "prenom",
                    "firstname"
                ];

                function findFrequentStringField(rows, skipFields = new Set()) {
                    if (!rows || !rows.length) return null;
                    const freq = new Map();
                    rows.forEach(row => {
                        if (!row || typeof row !== "object") return;
                        Object.keys(row).forEach(key => {
                            if (!key || skipFields.has(key) || key.startsWith("__")) return;
                            const value = row[key];
                            if (typeof value !== "string") return;
                            const normalized = value.trim();
                            if (!normalized) return;
                            freq.set(key, (freq.get(key) || 0) + 1);
                        });
                    });
                    if (!freq.size) return null;
                    let bestKey = null;
                    let bestCount = -1;
                    for (const [key, count] of freq.entries()) {
                        if (count > bestCount) {
                            bestCount = count;
                            bestKey = key;
                        }
                    }
                    return bestKey;
                }

                function getForeignKeyDisplayField(tableId, keyColumn, label) {
                    if (!tableId) return null;
                    state._fkDisplayField = state._fkDisplayField && typeof state._fkDisplayField === "object"
                        ? state._fkDisplayField
                        : {};
                    const cacheKey = `${tableId}:${keyColumn || ""}:${label || ""}`;
                    if (state._fkDisplayField[cacheKey]) {
                        return state._fkDisplayField[cacheKey];
                    }
                    const pageIndex = findPageIndexByTableId(tableId);
                    const page = pageIndex === -1 ? null : state.pages[pageIndex];
                    const columnDefs = Array.isArray(page?.data?.columnDefs) ? page.data.columnDefs : [];
                    const rows = Array.isArray(page?.data?.rowData) ? page.data.rowData : [];
                    const skipFields = new Set([keyColumn, DEFAULT_PRIMARY_KEY]);
                    const candidates = columnDefs
                        .filter(def => def && typeof def === "object")
                        .map(def => ({
                            field: typeof def.field === "string" ? def.field.trim() : "",
                            header: typeof def.headerName === "string" ? def.headerName.trim() : ""
                        }))
                        .filter(def => def.field && !def.field.startsWith("__relCount__") && !skipFields.has(def.field));
                    const matchTargets = [];
                    if (label) matchTargets.push(normalizeForCompare(label));
                    FOREIGN_KEY_DISPLAY_FIELD_PREFERENCES.forEach(pref => {
                        matchTargets.push(normalizeForCompare(pref));
                    });
                    for (const target of matchTargets) {
                        if (!target) continue;
                        const candidate = candidates.find(def => {
                            const headerNorm = normalizeForCompare(def.header);
                            const fieldNorm = normalizeForCompare(def.field);
                            return (
                                fieldNorm === target ||
                                headerNorm === target ||
                                headerNorm.includes(target) ||
                                fieldNorm.includes(target)
                            );
                        });
                        if (candidate) {
                            state._fkDisplayField[cacheKey] = candidate.field;
                            return candidate.field;
                        }
                    }
                    if (candidates.length) {
                        state._fkDisplayField[cacheKey] = candidates[0].field;
                        return candidates[0].field;
                    }
                    const fallback = findFrequentStringField(rows, skipFields);
                    state._fkDisplayField[cacheKey] = fallback || null;
                    return fallback || null;
                }

                function findFirstStringValue(row, skipFields = new Set()) {
                    if (!row || typeof row !== "object") return null;
                    for (const key of Object.keys(row)) {
                        if (!key || skipFields.has(key) || key.startsWith("__")) continue;
                        const value = row[key];
                        if (typeof value !== "string") continue;
                        const trimmed = value.trim();
                        if (!trimmed) continue;
                        return trimmed;
                    }
                    return null;
                }

                function formatNaturalFilterLiteral(value) {
                    if (value == null) return "";
                    const raw = String(value).trim();
                    if (!raw) return "";
                    if (/^".*"$/.test(raw)) return raw;
                    if (/^[0-9]+(?:\.[0-9]+)?$/.test(raw)) return raw;
                    if (isIsoDate(raw) || isIsoDateTime(raw) || isIsoTime(raw)) return raw;
                    if (/\s/.test(raw)) {
                        return `"${raw.replace(/"/g, '\\"')}"`;
                    }
                    return raw;
                }

                function getForeignKeyFilterValues(field, rawValue) {
                    const fallback = { raw: rawValue, display: rawValue };
                    const relation = getForeignKeyRelationForField(field);
                    if (!relation) return fallback;
                    if (rawValue == null || rawValue === "") return fallback;
                    const lookup = ensureForeignKeyLookup(relation.toTable, relation.toColumn, { label: relation.label });
                    const display = lookup?.[String(rawValue)];
                    if (display == null || display === "") return fallback;
                    return { raw: rawValue, display };
                }

                function findPageIndexByTableId(tableId) {
                    if (!tableId) return -1;
                    return state.pages.findIndex(page => page?.tableId === tableId);
                }

                function getRelationCountFieldId(sides) {
                    if (!sides) return "";
                    return `__relCount__${sides.manyTable}__${sides.manyFk}__${sides.onePk}`;
                }

                function getRelationCountFieldDefsForTable(tableId) {
                    if (!tableId) return [];
                    const relations = getAllRelationsFromSchema()
                        .map(getRelationSides)
                        .filter(Boolean)
                        .filter(sides => sides.oneTable === tableId);
                    if (!relations.length) return [];
                    return relations.map(sides => {
                        const manyTitle = getTableTitle(sides.manyTable) || sides.manyTable;
                        return {
                            field: getRelationCountFieldId(sides),
                            headerName: `Nb ${manyTitle}`,
                            dataType: "number"
                        };
                    });
                }

                function buildExternalFilterRow(rawRow, tableId) {
                    const base = rawRow && typeof rawRow === "object" ? { ...rawRow } : {};
                    if (!tableId) return base;
                    const relations = getAllRelationsFromSchema()
                        .map(getRelationSides)
                        .filter(Boolean)
                        .filter(sides => sides.oneTable === tableId);
                    if (!relations.length) return base;
                    relations.forEach(sides => {
                        const field = getRelationCountFieldId(sides);
                        if (!field) return;
                        const oneId = base?.[sides.onePk];
                        if (oneId == null || oneId === "") {
                            base[field] = 0;
                            return;
                        }
                        const map = ensureRelationCountLookup(sides.manyTable, sides.manyFk);
                        base[field] = map?.[String(oneId)] || 0;
                    });
                    return base;
                }

                function applyFilterToCurrentGrid(field, value) {
                    try {
                        if (!gridApi) return;
                        if (typeof gridApi.setFilterModel === "function") {
                            // Native ag-Grid column filtering is disabled: always clear any filter model.
                            gridApi.setFilterModel(null);
                            gridApi.onFilterChanged?.();
                        }
                    } catch (err) {
                        console.warn("Impossible d'appliquer le filtre", err);
                    }
                }

                function resetForeignKeyLookups() {
                    state._fkLookup = {};
                    state._fkDisplayField = {};
                }

                function resetRelationCountLookups() {
                    state._relCountLookup = {};
                }

                function resetRelationLookups() {
                    resetForeignKeyLookups();
                    resetRelationCountLookups();
                }

                function ensureForeignKeyLookup(tableId, keyColumn, options = {}) {
                    if (!tableId || !keyColumn) return {};
                    state._fkLookup = state._fkLookup && typeof state._fkLookup === "object" ? state._fkLookup : {};
                    state._fkLookup[tableId] = state._fkLookup[tableId] && typeof state._fkLookup[tableId] === "object"
                        ? state._fkLookup[tableId]
                        : {};
                    if (state._fkLookup[tableId][keyColumn]) {
                        return state._fkLookup[tableId][keyColumn];
                    }
                    const pageIndex = findPageIndexByTableId(tableId);
                    const page = pageIndex === -1 ? null : state.pages[pageIndex];
                    const rows = Array.isArray(page?.data?.rowData) ? page.data.rowData : [];
                    const displayField = getForeignKeyDisplayField(tableId, keyColumn, options.label);
                    const skipFields = new Set([keyColumn, DEFAULT_PRIMARY_KEY, displayField]);
                    const map = {};
                    rows.forEach(row => {
                        if (!row || typeof row !== "object") return;
                        const key = row[keyColumn];
                        if (key == null || key === "") return;
                        const candidateValues = [];
                        const tryStringValue = value => {
                            if (typeof value === "string") {
                                const trimmed = value.trim();
                                return trimmed ? trimmed : null;
                            }
                            return null;
                        };
                        if (displayField) {
                            candidateValues.push(tryStringValue(row[displayField]));
                        }
                        candidateValues.push(tryStringValue(row.name));
                        candidateValues.push(findFirstStringValue(row, skipFields));
                        const display = candidateValues.find(val => !!val);
                        if (!display) return;
                        map[String(key)] = display;
                    });
                    state._fkLookup[tableId][keyColumn] = map;
                    return map;
                }

                function getTableTitle(tableId) {
                    if (!tableId) return "";
                    const tables = Array.isArray(state?.schema?.tables) ? state.schema.tables : [];
                    const table = tables.find(item => item?.id === tableId);
                    return (table?.title || "").trim();
                }

                function getRelationSides(relation) {
                    if (!relation || typeof relation !== "object") return null;
                    const type = typeof relation.type === "string" ? relation.type.trim().toLowerCase() : "";
                    if (type !== "one-to-many" && type !== "many-to-one") return null;
                    const fromColumn = typeof relation.fromColumn === "string" ? relation.fromColumn.trim() : "";
                    const toColumn = typeof relation.toColumn === "string" ? relation.toColumn.trim() : "";
                    const fromTable = typeof relation.fromTable === "string" ? relation.fromTable.trim() : "";
                    const toTable = typeof relation.toTable === "string" ? relation.toTable.trim() : "";
                    if (!fromTable || !toTable || !fromColumn || !toColumn) return null;

                    const fromLooksLikeFk = /id$/i.test(fromColumn);
                    const toLooksLikeFk = /id$/i.test(toColumn);

                    if (fromLooksLikeFk && toColumn === DEFAULT_PRIMARY_KEY) {
                        return { oneTable: toTable, onePk: toColumn, manyTable: fromTable, manyFk: fromColumn };
                    }
                    if (toLooksLikeFk && fromColumn === DEFAULT_PRIMARY_KEY) {
                        return { oneTable: fromTable, onePk: fromColumn, manyTable: toTable, manyFk: toColumn };
                    }
                    if (toColumn === DEFAULT_PRIMARY_KEY) {
                        return { oneTable: toTable, onePk: toColumn, manyTable: fromTable, manyFk: fromColumn };
                    }
                    if (fromColumn === DEFAULT_PRIMARY_KEY) {
                        return { oneTable: fromTable, onePk: fromColumn, manyTable: toTable, manyFk: toColumn };
                    }
                    return null;
                }

                function ensureRelationCountLookup(manyTable, manyFk) {
                    if (!manyTable || !manyFk) return {};
                    state._relCountLookup = state._relCountLookup && typeof state._relCountLookup === "object"
                        ? state._relCountLookup
                        : {};
                    const key = `${manyTable}:${manyFk}`;
                    if (state._relCountLookup[key]) {
                        return state._relCountLookup[key];
                    }
                    const pageIndex = findPageIndexByTableId(manyTable);
                    const page = pageIndex === -1 ? null : state.pages[pageIndex];
                    const rows = Array.isArray(page?.data?.rowData) ? page.data.rowData : [];
                    const map = {};
                    rows.forEach(row => {
                        if (!row || typeof row !== "object") return;
                        const raw = row[manyFk];
                        if (raw == null || raw === "") return;
                        const id = String(raw);
                        map[id] = (map[id] || 0) + 1;
                    });
                    state._relCountLookup[key] = map;
                    return map;
                }

                function navigateToRelation(relation, value) {
                    if (!relation) return;
                    const targetIndex = findPageIndexByTableId(relation.toTable);
                    if (targetIndex === -1) {
                        showStatus(`Table cible introuvable: ${relation.toTable}`, true);
                        return;
                    }
                    const rawLookupValue = typeof value === "string" ? value.trim() : value;
                    let normalizedValue = rawLookupValue;
                    if (typeof normalizedValue === "string" && /^[0-9]+$/.test(normalizedValue)) {
                        normalizedValue = Number(normalizedValue);
                    }
                    setActivePage(targetIndex);
                    const knownFieldMap = getKnownFieldMap();
                    const fieldInfo = knownFieldMap.get(relation.toColumn);
                    const fieldLabel = fieldInfo?.headerName || relation.toColumn;
                    const lookup = ensureForeignKeyLookup(relation.toTable, relation.toColumn, { label: relation.label });
                    const displayValue = lookup?.[String(rawLookupValue)] || normalizedValue;
                    const condition = `${fieldLabel} est ${formatNaturalFilterLiteral(displayValue)}`;
                    if (gridNaturalFilterInput) {
                        gridNaturalFilterInput.value = condition;
                        naturalFilterState.lastAcceptedInput = condition;
                        scheduleNaturalFilterApply({ delayMs: 0 });
                        updateNaturalSuggestions({ forced: true });
                    }
                    // Ensure native filter model is cleared.
                    applyFilterToCurrentGrid();
                    showStatus(`Filtr√©: ${condition}`);
                }

                function createForeignKeyCellRenderer(relation) {
                    return params => {
                        const rawValue = params?.value;
                        if (rawValue == null || rawValue === "") return "";
                        const lookup = ensureForeignKeyLookup(relation?.toTable, relation?.toColumn, { label: relation?.label });
                        const displayValue = lookup?.[String(rawValue)] || "";
                        const link = document.createElement("a");
                        link.href = "#";
                        link.textContent = displayValue || String(rawValue);
                        link.style.color = "#2a7a57";
                        link.style.textDecoration = "underline";
                        link.style.cursor = "pointer";
                        link.title = relation?.label
                            ? `Aller vers ${relation.label} (${relation.toTable}) ‚Äî id=${rawValue}`
                            : `Aller vers ${relation.toTable} ‚Äî id=${rawValue}`;
                        link.addEventListener("click", event => {
                            event.preventDefault();
                            event.stopPropagation();
                            navigateToRelation(relation, rawValue);
                        });
                        return link;
                    };
                }

                function createRelationCountCellRenderer(manyTable, manyFk, oneId) {
                    const link = document.createElement("a");
                    link.href = "#";
                    link.style.color = "#2a7a57";
                    link.style.textDecoration = "underline";
                    link.style.cursor = "pointer";
                    link.addEventListener("click", event => {
                        event.preventDefault();
                        event.stopPropagation();
                        const idx = findPageIndexByTableId(manyTable);
                        if (idx === -1) {
                            showStatus(`Table cible introuvable: ${manyTable}`, true);
                            return;
                        }
                        let normalizedId = oneId;
                        if (typeof normalizedId === "string" && /^[0-9]+$/.test(normalizedId.trim())) {
                            normalizedId = Number(normalizedId.trim());
                        }
                        setActivePage(idx);
                        const knownFieldMap = getKnownFieldMap();
                        const fieldInfo = knownFieldMap.get(manyFk);
                        const fieldLabel = fieldInfo?.headerName || manyFk;
                        const lookup = ensureForeignKeyLookup(manyTable, manyFk);
                        const displayValue = lookup?.[String(normalizedId)] || normalizedId;
                        const condition = `${fieldLabel} est ${formatNaturalFilterLiteral(displayValue)}`;
                        if (gridNaturalFilterInput) {
                            gridNaturalFilterInput.value = condition;
                            naturalFilterState.lastAcceptedInput = condition;
                            scheduleNaturalFilterApply({ delayMs: 0 });
                            updateNaturalSuggestions({ forced: true });
                        }
                        // Ensure native filter model is cleared.
                        applyFilterToCurrentGrid();
                        showStatus(`Filtr√©: ${condition}`);
                    });
                    return link;
                }

                function addRelationCountColumns(columnDefs = [], tableId) {
                    const relations = getAllRelationsFromSchema()
                        .map(getRelationSides)
                        .filter(Boolean)
                        .filter(sides => sides.oneTable === tableId);
                    if (!relations.length) return columnDefs;

                    const existingFields = new Set(
                        columnDefs
                            .map(def => (def && typeof def === "object" && typeof def.field === "string" ? def.field : ""))
                            .filter(Boolean)
                    );

                    const appended = [];
                    relations.forEach(sides => {
                        const field = `__relCount__${sides.manyTable}__${sides.manyFk}__${sides.onePk}`;
                        if (existingFields.has(field)) return;
                        const manyTitle = getTableTitle(sides.manyTable) || sides.manyTable;
                        appended.push({
                            field,
                            headerName: `Nb ${manyTitle}`,
                            editable: false,
                            cellDataType: "number",
                            sortable: true,
                            filter: false,
                            valueGetter: params => {
                                const oneId = params?.data?.[sides.onePk];
                                if (oneId == null || oneId === "") return 0;
                                const map = ensureRelationCountLookup(sides.manyTable, sides.manyFk);
                                return map?.[String(oneId)] || 0;
                            },
                            cellRenderer: params => {
                                const oneId = params?.data?.[sides.onePk];
                                if (oneId == null || oneId === "") return "";
                                const map = ensureRelationCountLookup(sides.manyTable, sides.manyFk);
                                const count = map?.[String(oneId)] || 0;
                                const link = createRelationCountCellRenderer(sides.manyTable, sides.manyFk, oneId);
                                link.textContent = String(count);
                                link.title = `Voir ${manyTitle} li√©s ‚Äî id=${oneId}`;
                                return link;
                            }
                        });
                        existingFields.add(field);
                    });
                    if (!appended.length) return columnDefs;
                    return [...columnDefs, ...appended];
                }

                function addForeignKeyRenderers(columnDefs = [], tableId) {
                    const relations = getAllRelationsFromSchema().filter(rel => rel.fromTable === tableId);
                    if (!relations.length) return columnDefs;
                    const relByField = new Map(relations.map(rel => [rel.fromColumn, rel]));
                    return columnDefs.map(def => {
                        if (!def || typeof def !== "object") return def;
                        const field = typeof def.field === "string" ? def.field : "";
                        if (!field) return def;
                        const relation = relByField.get(field);
                        if (!relation) return def;
                        if (def.cellRenderer) return def;
                        return { ...def, cellRenderer: createForeignKeyCellRenderer(relation) };
                    });
                }

                function applyGridData(data, options = {}) {
                    if (!data) return;
                    const tableId = options.tableId || getActivePage()?.tableId || "";
                    const rowData = Array.isArray(data.rowData) ? data.rowData : [];
                    const isTree = isTreeTemplateActive();
                    let finalRowData = rowData;
                    let gridColumnDefs;
                    if (isTree) {
                        gridColumnDefs = buildTreeColumnDefs();
                        gridElement?.classList?.add("tree-template");
                        if (!finalRowData.length) {
                            finalRowData = [TREE_EMPTY_ROW];
                        }
                        finalRowData = decorateTreeRows(finalRowData);
                        data.rowData = finalRowData;
                    } else {
                        gridElement?.classList?.remove("tree-template");
                        const columnDefs = Array.isArray(data.columnDefs) ? data.columnDefs : [];
                        const normalizedColumnDefs = disableNativeFilterColumns(
                            ensureDefaultPinned(normalizeColumnComponentNames(columnDefs))
                        );
                        data.columnDefs = normalizedColumnDefs;
                        const withFkLinks = addForeignKeyRenderers(normalizedColumnDefs, tableId);
                        gridColumnDefs = addRelationCountColumns(withFkLinks, tableId);
                    }
                    if (gridOptions) {
                        gridOptions.treeData = false;
                        gridOptions.groupDefaultExpanded = undefined;
                        gridOptions.rowDragManaged = false;
                        gridOptions.rowDragEntireRow = isTree;
                        gridOptions.animateRows = true;
                        gridOptions.getRowId = params => {
                            const path = Array.isArray(params?.data?.__path) ? params.data.__path : [];
                            if (params?.data?.id) return params.data.id;
                            return path.length ? path.join(" / ") : undefined;
                        };
                        gridOptions.onRowDragEnd = undefined;
                        gridOptions.suppressMovableColumns = isTree;
                    }
                    if (typeof gridApi.setGridOption === "function") {
                        gridApi.setGridOption("columnDefs", gridColumnDefs);
                        gridApi.setGridOption("rowData", isTree ? finalRowData : rowData);
                    } else {
                        gridApi.setColumnDefs(gridColumnDefs);
                        gridApi.setRowData(isTree ? finalRowData : rowData);
                    }
                    if (isTree) {
                        console.info("Tree applyGridData rows=", finalRowData.length, "names=", finalRowData.map(r => r.name));
                    }
                    scheduleAutoSizeAndPinMenu();
                    scheduleNaturalFilterRecalc();
                }

                function syncScriptFromGrid() {
                    const page = getActivePage();
                    if (!page) return;
                    const gridData = collectGridData();
                    page.data = gridData;
                    resetRelationLookups();
                    syncDatasetScriptFromState();
                }

                function collectGridData() {
                    const columnDefs =
                        typeof gridApi.getColumnDefs === "function"
                            ? gridApi.getColumnDefs() || []
                            : (typeof gridApi.getGridOption === "function"
                                ? gridApi.getGridOption("columnDefs") || []
                                : []);
                    const sanitizedColumnDefs = (Array.isArray(columnDefs) ? columnDefs : []).map(def => {
                        if (!def || typeof def !== "object") return def;
                        const cleaned = {};
                        Object.keys(def).forEach(key => {
                            const value = def[key];
                            if (typeof value === "function") return;
                            cleaned[key] = value;
                        });
                        return cleaned;
                    }).filter(def => {
                        const field = def && typeof def === "object" && typeof def.field === "string" ? def.field : "";
                        return field ? !field.startsWith("__relCount__") : true;
                    });
                    const rowData = [];
                    gridApi.forEachNode(node => {
                        if (node && node.data) {
                            rowData.push({ ...node.data });
                        }
                    });
                    return { columnDefs: sanitizedColumnDefs, rowData };
                }

                function ensureDefaultPinned(columnDefs = []) {
                    return columnDefs.map(def => {
                        if (!def || typeof def !== "object") return def;
                        const identifiers = [
                            typeof def.field === "string" ? def.field.toLowerCase() : "",
                            typeof def.colId === "string" ? def.colId.toLowerCase() : "",
                            typeof def.headerName === "string" ? def.headerName.toLowerCase() : ""
                        ];
                        const shouldPin = identifiers.some(id => DEFAULT_PINNED_FIELDS.has(id));
                        if (shouldPin && def.pinned !== "left") {
                            return { ...def, pinned: "left" };
                        }
                        return def;
                    });
                }

                // Map legacy AG Grid component names to their current built-in equivalents.
                const COMPONENT_NAME_ALIASES = {
                    agNumericCellEditor: "agNumberCellEditor"
                };

                function normalizeColumnComponentNames(columnDefs = []) {
                    const componentProps = [
                        "cellRenderer",
                        "cellEditor",
                        "floatingCellRenderer",
                        "pinnedRowCellRenderer"
                    ];
                    return columnDefs.map(def => {
                        if (!def || typeof def !== "object") return def;
                        const normalized = { ...def };
                        componentProps.forEach(prop => {
                            const value = normalized[prop];
                            if (typeof value === "string") {
                                normalized[prop] = COMPONENT_NAME_ALIASES[value] || value;
                            }
                        });
                        return normalized;
                    });
                }

                function disableNativeFilterColumns(columnDefs = []) {
                    return columnDefs.map(def => {
                        if (!def || typeof def !== "object") return def;
                        const cleaned = { ...def, filter: false };
                        if ("floatingFilter" in cleaned) cleaned.floatingFilter = false;
                        if ("filterParams" in cleaned) delete cleaned.filterParams;
                        if ("filterValueGetter" in cleaned) delete cleaned.filterValueGetter;
                        return cleaned;
                    });
                }

                function buildChunkedDatasetMessages(rawText) {
                    const instruction =
                        "Voici le dataset complet actuel (schema + data). Conserve les ids si fournis et renvoie tout le contenu :\n";
                    if (!rawText) {
                        return [];
                    }
                    const trimmed = rawText.trim();
                    if (!trimmed) {
                        return [];
                    }
                    if (trimmed.length <= OPEN_AI_MESSAGE_MAX_CHARS) {
                        return [{ role: "user", content: instruction + trimmed }];
                    }
                    const parts = [];
                    for (let i = 0; i < trimmed.length; i += OPEN_AI_MESSAGE_MAX_CHARS) {
                        parts.push(trimmed.slice(i, i + OPEN_AI_MESSAGE_MAX_CHARS));
                    }
                    const total = parts.length;
                    return parts.map((chunk, index) => {
                        const header = `Partie ${index + 1} / ${total} du JSON du dataset actuel.`;
                        const footer = index === total - 1 ? "\n(Fin du JSON du dataset actuel.)" : "";
                        return {
                            role: "user",
                            content: `${instruction}${header}\n${chunk}${footer}`
                        };
                    });
                }

                function autoSizeColumns() {
                    if (!gridColumnApi || typeof gridColumnApi.autoSizeAllColumns !== "function") return;
                    const isTree = isTreeTemplateActive();
                    gridColumnApi.autoSizeAllColumns({
                        scaleUpToFitGridWidth: false,
                        defaultMinWidth: isTree ? 140 : 85,
                        defaultMaxWidth: isTree ? 520 : 200
                    });
                }

                function scheduleAutoSizeAndPinMenu() {
                    if (autoSizeTimer) {
                        clearTimeout(autoSizeTimer);
                    }
                    autoSizeTimer = setTimeout(() => {
                        autoSizeTimer = null;
                        autoSizeColumns();
                        buildColumnPinMenu();
                    }, 0);
                }

                function buildColumnPinMenu() {
                    if (!columnPinList) return;
                    if (!gridColumnApi) {
                        columnPinList.textContent = "Aucune colonne";
                        return;
                    }
                    const columns = gridColumnApi.getAllColumns?.() || [];
                    columnPinList.innerHTML = "";
                    if (!columns.length) {
                        columnPinList.textContent = "Aucune colonne";
                        return;
                    }
                    columns.forEach(column => {
                        const row = document.createElement("div");
                        row.className = "column-pin-row";
                        const span = document.createElement("span");
                        const headerName = column.getColDef()?.headerName || column.getColId();
                        span.textContent = headerName || column.getColId();
                        const action = document.createElement("button");
                        action.type = "button";
                        action.className = "btn btn-small";
                        const pinnedLeft = column.getPinned() === "left";
                        action.textContent = pinnedLeft ? "D√©pingler" : "√âpingler √† gauche";
                        action.addEventListener("click", event => {
                            event.stopPropagation();
                            const targetState = pinnedLeft ? null : "left";
                            gridColumnApi.setColumnPinned(column.getColId(), targetState);
                            buildColumnPinMenu();
                        });
                        row.append(span, action);
                        columnPinList.append(row);
                    });
                }

                function getShareDraftKey(token) {
                    return token ? `${SHARE_DRAFT_PREFIX}${token}` : "";
                }

                function readShareDraft(token) {
                    if (!token || typeof window === "undefined" || !window.localStorage) return null;
                    try {
                        const raw = localStorage.getItem(getShareDraftKey(token));
                        if (!raw) return null;
                        const parsed = JSON.parse(raw);
                        if (!parsed || typeof parsed !== "object") return null;
                        return parsed;
                    } catch (err) {
                        console.warn("Impossible de lire le cache de partage Grid", err);
                        return null;
                    }
                }

                function writeShareDraft(token, payload, updatedAt) {
                    if (!token || typeof window === "undefined" || !window.localStorage) return;
                    try {
                        const value = {
                            payload,
                            updatedAt: updatedAt || new Date().toISOString()
                        };
                        localStorage.setItem(getShareDraftKey(token), JSON.stringify(value));
                    } catch (err) {
                        console.warn("Impossible de sauvegarder le cache de partage", err);
                    }
                }

                function copyTextToClipboard(text) {
                    if (!text) return false;
                    if (navigator.clipboard && typeof navigator.clipboard.writeText === "function") {
                        return navigator.clipboard.writeText(text).then(() => true);
                    }
                    const textarea = document.createElement("textarea");
                    textarea.value = text;
                    textarea.setAttribute("readonly", "");
                    textarea.style.position = "absolute";
                    textarea.style.left = "-9999px";
                    document.body.appendChild(textarea);
                    textarea.select();
                    try {
                        document.execCommand("copy");
                        return true;
                    } finally {
                        textarea.remove();
                    }
                }

                function getShareTokenFromUrl() {
                    try {
                        const params = new URLSearchParams(window.location.search || "");
                        const value = params.get(SHARE_QUERY_PARAM);
                        return value ? value.trim() : null;
                    } catch (err) {
                        return null;
                    }
                }

                function updateUrlWithShareToken(token) {
                    try {
                        const url = new URL(window.location.href);
                        if (token) {
                            url.searchParams.set(SHARE_QUERY_PARAM, token);
                        } else {
                            url.searchParams.delete(SHARE_QUERY_PARAM);
                        }
                        history.replaceState(null, "", url.toString());
                    } catch (err) {
                        console.warn("Impossible de mettre √† jour l'URL de partage", err);
                    }
                }

                function createShareToken() {
                    if (typeof crypto !== "undefined" && typeof crypto.randomUUID === "function") {
                        return crypto.randomUUID();
                    }
                    const bytes = new Uint8Array(16);
                    if (typeof crypto !== "undefined" && typeof crypto.getRandomValues === "function") {
                        crypto.getRandomValues(bytes);
                    } else {
                        for (let i = 0; i < bytes.length; i += 1) {
                            bytes[i] = Math.floor(Math.random() * 256);
                        }
                    }
                    return Array.from(bytes)
                        .map(byte => byte.toString(16).padStart(2, "0"))
                        .join("");
                }

                function clearAppCookies() {
                    if (typeof document === "undefined" || !document.cookie) return;
                    document.cookie.split(";").forEach(cookie => {
                        const [namePart] = cookie.split("=");
                        const name = namePart?.trim();
                        if (!name) return;
                        document.cookie = `${name}=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/`;
                        document.cookie = `${name}=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/;domain=${location.hostname}`;
                    });
                }

                function resetGridState() {
                    const confirmed = window.confirm(
                        "R√©initialiser supprimera le cache, les pr√©f√©rences et les cookies. Continuer ?"
                    );
                    if (!confirmed) return;
                    try {
                        if (window.localStorage) {
                            localStorage.removeItem(STORAGE_KEY);
                            if (shareHistory?.STORAGE_KEY) localStorage.removeItem(shareHistory.STORAGE_KEY);
                            if (capsuleDrafts?.STORAGE_KEY) localStorage.removeItem(capsuleDrafts.STORAGE_KEY);
                            Object.keys(localStorage)
                                .filter(key => key.startsWith(SHARE_DRAFT_PREFIX))
                                .forEach(key => localStorage.removeItem(key));
                        }
                    } catch (err) {
                        console.warn("R√©initialisation locale impossible", err);
                    }
                    clearAppCookies();
                    window.location.reload();
                }

                function buildShareUrl(token) {
                    if (!token) return "";
                    try {
                        const url = new URL(window.location.href);
                        url.searchParams.set(SHARE_QUERY_PARAM, token);
                        return url.toString();
                    } catch (err) {
                        console.warn("Impossible de construire l'URL partag√©e", err);
                        return "";
                    }
                }

                function setShareStatus(message, type) {
                    shareStatusMessage = message || "";
                    shareStatusType = type || "";
                }

                function formatRelativeTime(value) {
                    if (!value) return "";
                    try {
                        const timestamp = new Date(value).getTime();
                        if (Number.isNaN(timestamp)) return "";
                        const deltaSeconds = Math.max(0, Math.floor((Date.now() - timestamp) / 1000));
                        if (deltaSeconds < 60) {
                            return "Mis √† jour √† l'instant";
                        }
                        const deltaMinutes = Math.floor(deltaSeconds / 60);
                        if (deltaMinutes < 60) {
                            return `Mis √† jour il y a ${deltaMinutes} minute${deltaMinutes > 1 ? "s" : ""}`;
                        }
                        const deltaHours = Math.floor(deltaMinutes / 60);
                        if (deltaHours < 24) {
                            return `Mis √† jour il y a ${deltaHours} heure${deltaHours > 1 ? "s" : ""}`;
                        }
                        const deltaDays = Math.floor(deltaHours / 24);
                        return `Mis √† jour il y a ${deltaDays} jour${deltaDays > 1 ? "s" : ""}`;
                    } catch (err) {
                        return "";
                    }
                }

                function buildGridSharePayload() {
                    const page = getActivePage();
                    const gridData = collectGridData();
                    const title = (gridTitleInput?.value || page?.title || "Grid").trim();
                    const scenario = (promptInput?.value || "").trim();
                    const script = gridScript?.value || "";
                    return {
                        title,
                        columnDefs: gridData.columnDefs,
                        rowData: gridData.rowData,
                        scenario,
                        script,
                        lastAiScript: page?.lastAiScript || ""
                    };
                }

                function buildGridSharePreview() {
                    const title = (gridTitleInput?.value || getActivePage()?.title || "Grid").trim();
                    const scenario = (promptInput?.value || "").trim();
                    return {
                        title: title || "Grid",
                        description: scenario || "Sans contexte"
                    };
                }

                async function persistGridShareRecord(token, updatedAt) {
                    if (!shareHistory || !token) return;
                    try {
                        const preview = buildGridSharePreview();
                        await shareHistory.upsertRecord("grid", {
                            token,
                            updatedAt: updatedAt || new Date().toISOString(),
                            title: preview.title,
                            description: preview.description
                        });
                    } catch (err) {
                        console.warn("Impossible d'archiver le lien partag√© Grid", err);
                    }
                }

                function applySharedPayload(payload) {
                    if (!payload) return;
                    const columnDefs = Array.isArray(payload.columnDefs) ? payload.columnDefs : [];
                    const rowData = Array.isArray(payload.rowData) ? payload.rowData : [];
                    const page = getActivePage();
                    page.data = { columnDefs, rowData };
                    resetRelationLookups();
                    if (gridTitleInput && payload.title) {
                        gridTitleInput.value = payload.title;
                        page.title = payload.title;
                        if (Array.isArray(state?.schema?.tables)) {
                            const table = state.schema.tables.find(item => item?.id === page.tableId);
                            if (table) table.title = page.title;
                        }
                    }
                    if (promptInput && typeof payload.scenario === "string") {
                        promptInput.value = payload.scenario;
                        page.scenario = payload.scenario;
                    }
                    if (typeof payload.lastAiScript === "string") {
                        page.lastAiScript = payload.lastAiScript;
                    }
                    applyGridData(page.data, { tableId: page.tableId });
                    syncDatasetScriptFromState();
                    renderTabs();
                    persistState();
                }

                function getEditIdFromUrl() {
                    try {
                        const params = new URLSearchParams(window.location.search || "");
                        const value = params.get(EDIT_QUERY_PARAM);
                        return value ? value.trim() : null;
                    } catch (err) {
                        return null;
                    }
                }

                function updateUrlWithEditId(id) {
                    try {
                        const url = new URL(window.location.href);
                        if (id) {
                            url.searchParams.set(EDIT_QUERY_PARAM, id);
                        } else {
                            url.searchParams.delete(EDIT_QUERY_PARAM);
                        }
                        history.replaceState(null, "", url.toString());
                    } catch (err) {
                        console.warn("Impossible de mettre √† jour l'URL d'√©dition", err);
                    }
                }

                function createDraftId() {
                    if (capsuleDrafts && typeof capsuleDrafts.generateId === "function") {
                        return capsuleDrafts.generateId();
                    }
                    return createShareToken();
                }

                async function saveGridDraft(options = {}) {
                    if (!capsuleDrafts || isDraftSaving) return null;
                    isDraftSaving = true;
                    try {
                        persistState();
                        const payload = buildGridSharePayload();
                        const preview = buildGridSharePreview();
                        let id = currentDraftId || createDraftId();
                        if (!id) {
                            id = createShareToken();
                        }
                        const now = new Date().toISOString();
                        const record = await capsuleDrafts.upsertRecord({
                            id,
                            app: "grid",
                            payload,
                            title: preview.title,
                            description: preview.description,
                            updatedAt: now
                        });
                        if (record) {
                            currentDraftId = record.id;
                            if (options.updateUrl !== false) {
                                updateUrlWithEditId(record.id);
                            }
                            if (options.showToast) {
                                showStatus("Capsule enregistr√©e localement.");
                            }
                        }
                        return record;
                    } catch (err) {
                        console.error("Erreur Capsule", err);
                        showStatus("Impossible de sauvegarder la capsule.", true);
                        return null;
                    } finally {
                        isDraftSaving = false;
                    }
                }

                async function handleSaveDocumentClick() {
                    closeGridMenus();
                    if (!capsuleDrafts) {
                        showStatus("Module Capsule indisponible.", true);
                        return null;
                    }
                    if (saveDocumentBtn) {
                        saveDocumentBtn.disabled = true;
                    }
                    try {
                        return await saveGridDraft({ showToast: true });
                    } finally {
                        if (saveDocumentBtn) {
                            saveDocumentBtn.disabled = false;
                        }
                    }
                }

                async function tryLoadLocalDraftFromUrl() {
                    if (!capsuleDrafts || typeof capsuleDrafts.getRecord !== "function") {
                        return false;
                    }
                    const editId = getEditIdFromUrl();
                    if (!editId) {
                        return false;
                    }
                    try {
                        const record = await capsuleDrafts.getRecord(editId);
                        if (!record || !record.payload) {
                            return false;
                        }
                        applySharedPayload(record.payload);
                        currentDraftId = record.id;
                        updateUrlWithEditId(record.id);
                        return true;
                    } catch (err) {
                        console.warn("Impossible de charger la capsule locale", err);
                        return false;
                    }
                }

                function openNewGridDocument() {
                    try {
                        if (window.localStorage) {
                            localStorage.removeItem(STORAGE_KEY);
                        }
                    } catch (err) {
                        console.warn("Impossible de r√©initialiser l'√©tat local", err);
                    }
                    if (currentShareToken) {
                        updateUrlWithShareToken(null);
                        currentShareToken = null;
                    }
                    currentDraftId = null;
                    updateUrlWithEditId(null);
                    const url = new URL(window.location.href);
                    url.searchParams.delete(SHARE_QUERY_PARAM);
                    url.searchParams.delete(EDIT_QUERY_PARAM);
                    url.hash = "";
                    window.location.href = url.toString();
                }

                async function handleNewDocumentClick() {
                    closeGridMenus();
                    const page = getActivePage();
                    const scriptHasContent = Boolean(gridScript?.value?.trim());
                    const dataHasContent =
                        Array.isArray(page?.data?.rowData) && page.data.rowData.length > 0;
                    if (scriptHasContent || dataHasContent || currentDraftId) {
                        const confirmSave = window.confirm(
                            "Sauvegarder la capsule actuelle avant d'ouvrir un nouveau document ?"
                        );
                        if (confirmSave) {
                            await handleSaveDocumentClick();
                        }
                    }
                    openNewGridDocument();
                }

                async function fetchSharePayload(token) {
                    if (!shareWorkerAvailable || !shareService) {
                        throw new Error(SHARE_WORKER_UNAVAILABLE_MESSAGE);
                    }
                    return shareService.fetchSharePayload(FIRESTORE_COLLECTION, token);
                }

                async function tryLoadSharedStateFromUrl() {
                    const token = getShareTokenFromUrl();
                    if (!token) return false;
                    if (!shareWorkerAvailable) {
                        setShareStatus(SHARE_WORKER_UNAVAILABLE_MESSAGE, "error");
                        updateShareMenuUI();
                        return false;
                    }
                    const localDraft = readShareDraft(token);
                    let remoteResult = null;
                    try {
                        remoteResult = await fetchSharePayload(token);
                    } catch (err) {
                        console.error("Erreur de chargement distant du lien partag√© :", err);
                    }
                    const remotePayload = remoteResult?.payload;
                    const remoteUpdatedAt = remoteResult?.meta?.updatedAt;
                    const localPayload = localDraft?.payload;
                    const localUpdatedAt = localDraft?.updatedAt;
                    const remoteTime = remoteUpdatedAt ? new Date(remoteUpdatedAt).getTime() : 0;
                    const localTime = localUpdatedAt ? new Date(localUpdatedAt).getTime() : 0;
                    let selectedPayload = null;
                    let selectedUpdatedAt = null;
                    if (remotePayload && (!localPayload || remoteTime >= localTime)) {
                        selectedPayload = remotePayload;
                        selectedUpdatedAt = remoteUpdatedAt;
                        shareLoadedFromRemote = true;
                    } else if (localPayload) {
                        selectedPayload = localPayload;
                        selectedUpdatedAt = localUpdatedAt;
                    }
                    if (!selectedPayload) {
                        setShareStatus("Lien priv√© introuvable.", "error");
                        updateShareMenuUI();
                        return false;
                    }
                    applySharedPayload(selectedPayload);
                    currentShareToken = token;
                    shareLastUpdatedAt = selectedUpdatedAt || new Date().toISOString();
                    setShareStatus(formatRelativeTime(shareLastUpdatedAt));
                    updateShareMenuUI();
                    await persistGridShareRecord(token, shareLastUpdatedAt);
                    writeShareDraft(token, selectedPayload, shareLastUpdatedAt);
                    return true;
                }

                async function saveSharePayload(token, payload) {
                    if (!shareWorkerAvailable || !shareService) {
                        throw new Error(SHARE_WORKER_UNAVAILABLE_MESSAGE);
                    }
                    const meta = await shareService.saveSharePayload(FIRESTORE_COLLECTION, token, payload);
                    return (meta && meta.updatedAt) || new Date().toISOString();
                }

                function updateShareMenuUI() {
                    const hasToken = Boolean(currentShareToken);
                    if (shareLinkField) {
                        shareLinkField.value = hasToken ? buildShareUrl(currentShareToken) : "";
                        shareLinkField.placeholder = hasToken ? "" : "Cr√©er un lien priv√©";
                    }
                    if (shareUpdateBtn) {
                        shareUpdateBtn.hidden = !hasToken;
                        shareUpdateBtn.disabled = shareRequestInProgress || !hasToken || !shareWorkerAvailable;
                    }
                    if (shareCreateBtn) {
                        shareCreateBtn.disabled = shareRequestInProgress || !shareWorkerAvailable;
                        if (hasToken) {
                            shareCreateBtn.classList.remove("btn-primary");
                            shareCreateBtn.classList.add("btn");
                        } else {
                            shareCreateBtn.classList.add("btn-primary");
                            shareCreateBtn.classList.remove("btn");
                        }
                    }
                    if (shareMenuStatus) {
                        const text = shareStatusMessage || buildShareStatusText();
                        shareMenuStatus.textContent = text;
                        const isError =
                            (shareStatusType === "error" && Boolean(text)) ||
                            (!shareWorkerAvailable && !shareStatusMessage);
                        shareMenuStatus.classList.toggle("error", isError);
                    }
                }

                function buildShareStatusText() {
                    if (!shareWorkerAvailable) {
                        return SHARE_WORKER_UNAVAILABLE_MESSAGE;
                    }
                    if (shareLastUpdatedAt) {
                        return formatRelativeTime(shareLastUpdatedAt);
                    }
                    if (shareLoadedFromRemote && currentShareToken) {
                        return "Ce lien charge la version enregistr√©e via le worker Cloudflare.";
                    }
                    if (currentShareToken) {
                        return "Un lien priv√© existe d√©j√† pour cette session.";
                    }
                    return "Seules les personnes disposant du lien peuvent y acc√©der.";
                }

                async function copyCurrentShareLinkToClipboard() {
                    if (!currentShareToken) return false;
                    const link = buildShareUrl(currentShareToken);
                    if (!link) return false;
                    try {
                        await copyTextToClipboard(link);
                        showStatus("Lien priv√© copi√© dans le presse-papier.");
                        return true;
                    } catch (err) {
                        console.error("Copie du lien priv√© impossible", err);
                        return false;
                    }
                }

                async function handleShareCreateClick() {
                    if (!shareWorkerAvailable) {
                        setShareStatus(SHARE_WORKER_UNAVAILABLE_MESSAGE, "error");
                        updateShareMenuUI();
                        return;
                    }
                    if (shareRequestInProgress) return;
                    shareRequestInProgress = true;
                    updateShareMenuUI();
                    try {
                        const payload = buildGridSharePayload();
                        const token = createShareToken();
                        const updatedAt = await saveSharePayload(token, payload);
                        currentShareToken = token;
                        shareLoadedFromRemote = true;
                        shareLastUpdatedAt = updatedAt;
                        updateUrlWithShareToken(token);
                        setShareStatus(formatRelativeTime(updatedAt));
                        updateShareMenuUI();
                        await persistGridShareRecord(token, updatedAt);
                        writeShareDraft(token, payload, updatedAt);
                        await copyCurrentShareLinkToClipboard();
                    } catch (err) {
                        console.error("Erreur lors de la cr√©ation du lien partag√© :", err);
                        setShareStatus("Impossible de cr√©er le lien partag√©.", "error");
                        updateShareMenuUI();
                    } finally {
                        shareRequestInProgress = false;
                        updateShareMenuUI();
                    }
                }

                async function handleShareUpdateClick() {
                    if (!shareWorkerAvailable) {
                        setShareStatus(SHARE_WORKER_UNAVAILABLE_MESSAGE, "error");
                        updateShareMenuUI();
                        return;
                    }
                    if (!currentShareToken) {
                        setShareStatus("Pas de lien priv√© √† mettre √† jour.", "error");
                        updateShareMenuUI();
                        return;
                    }
                    if (shareRequestInProgress) return;
                    shareRequestInProgress = true;
                    updateShareMenuUI();
                    try {
                        const payload = buildGridSharePayload();
                        const updatedAt = await saveSharePayload(currentShareToken, payload);
                        shareLoadedFromRemote = true;
                        shareLastUpdatedAt = updatedAt;
                        setShareStatus(formatRelativeTime(updatedAt));
                        updateShareMenuUI();
                        await persistGridShareRecord(currentShareToken, updatedAt);
                        writeShareDraft(currentShareToken, payload, updatedAt);
                        await copyCurrentShareLinkToClipboard();
                    } catch (err) {
                        console.error("Erreur lors de la mise √† jour du lien partag√© :", err);
                        setShareStatus("Impossible de mettre √† jour le lien partag√©.", "error");
                        updateShareMenuUI();
                    } finally {
                        shareRequestInProgress = false;
                        updateShareMenuUI();
                    }
                }

                function renderFontSizeOptions() {
                    if (!fontSizeInput) return;
                    fontSizeInput.innerHTML = "";
                    FONT_SIZE_CHOICES.forEach(size => {
                        const option = document.createElement("option");
                        option.value = size;
                        option.textContent = `${size} px`;
                        option.style.fontSize = `${size}px`;
                        fontSizeInput.appendChild(option);
                    });
                }

                function syncDisplayControls() {
                    if (fontSizeInput) {
                        const fontSize = state.displayPreferences?.fontSize || DISPLAY_PREFERENCE_DEFAULTS.fontSize;
                        fontSizeInput.value = fontSize;
                    }
                }

                function applyGridFontSize(value, options = {}) {
                    const normalized = parseInt(value, 10);
                    if (isNaN(normalized)) return;
                    if (gridElement) {
                        gridElement.style.setProperty("--grid-font-size", `${normalized}px`);
                    }
                    state.displayPreferences = state.displayPreferences || { ...DISPLAY_PREFERENCE_DEFAULTS };
                    state.displayPreferences.fontSize = normalized;
                    if (options.persist !== false) {
                        persistState();
                    }
                    if (fontSizeInput && fontSizeInput.value !== String(normalized)) {
                        fontSizeInput.value = normalized;
                    }
                    scheduleAutoSizeAndPinMenu();
                }

                function applyRowHeight(value, options = {}) {
                    const normalized = parseInt(value, 10);
                    if (isNaN(normalized)) return;
                    gridOptions.rowHeight = normalized;
                    if (gridApi && typeof gridApi.resetRowHeights === "function") {
                        gridApi.resetRowHeights();
                    }
                    state.displayPreferences = state.displayPreferences || { ...DISPLAY_PREFERENCE_DEFAULTS };
                    state.displayPreferences.rowHeight = normalized;
                    if (options.persist !== false) {
                        persistState();
                    }
                }

                function applyGridDisplayPreferences(options = {}) {
                    const shouldPersist = options.persist !== false;
                    const preferences = state.displayPreferences || { ...DISPLAY_PREFERENCE_DEFAULTS };
                    applyGridFontSize(preferences.fontSize || DISPLAY_PREFERENCE_DEFAULTS.fontSize, {
                        persist: shouldPersist
                    });
                    applyRowHeight(preferences.rowHeight || DISPLAY_PREFERENCE_DEFAULTS.rowHeight, {
                        persist: shouldPersist
                    });
                    syncDisplayControls();
                }

                function closeGridMenus(except) {
                    if (affichageMenu && affichageMenu !== except) {
                        affichageMenu.classList.remove("open");
                    }
                    if (columnPinMenu && columnPinMenu !== except) {
                        columnPinMenu.classList.remove("open");
                    }
                    if (shareMenu && shareMenu !== except) {
                        shareMenu.classList.remove("open");
                    }
                    if (capsuleMenu && capsuleMenu !== except) {
                        capsuleMenu.classList.remove("open");
                    }
                }

                function isOpenAIBackendSelected() {
                    const backendValue =
                        (window.GoToolkitIAConfig && typeof window.GoToolkitIAConfig.getBackend === "function"
                            ? window.GoToolkitIAConfig.getBackend()
                            : "openai") || "openai";
                    return String(backendValue).toLowerCase() === "openai";
                }

                function getOpenAIApiKey() {
                    return (
                        (window.GoToolkitIAConfig && typeof window.GoToolkitIAConfig.getApiKey === "function"
                            ? window.GoToolkitIAConfig.getApiKey()
                            : "") || ""
                    ).trim();
                }

                function updateFileRowVisibility() {
                    if (!promptFileRow || !promptFileBtn) return;
                    const visible = isOpenAIBackendSelected() && Boolean(getOpenAIApiKey());
                    promptFileRow.classList.toggle("visible", visible);
                    promptFileRow.setAttribute("aria-hidden", visible ? "false" : "true");
                    promptFileBtn.disabled = !visible;
                }

                function renderFileList() {
                    if (!promptFileList) return;
                    promptFileList.innerHTML = "";
                    fileUploads.forEach(entry => {
                        const item = document.createElement("div");
                        item.className = "prompt-file-item";
                        item.dataset.fileId = entry.id;
                        if (entry.status === "error") {
                            item.classList.add("is-error");
                        }
                        const label = document.createElement("span");
                        if (entry.status === "uploading") {
                            const pct = Number.isFinite(entry.progress) ? Math.max(0, Math.min(100, entry.progress)) : 0;
                            label.textContent = `${pct}%`;
                        } else if (entry.status === "error") {
                            label.textContent = entry.error || entry.name || "Erreur";
                        } else {
                            label.textContent = entry.name || "Fichier";
                        }
                        const removeBtn = document.createElement("button");
                        removeBtn.type = "button";
                        removeBtn.dataset.removeFileId = entry.id;
                        removeBtn.title = "Retirer le fichier";
                        removeBtn.textContent = "√ó";
                        item.append(label, removeBtn);
                        promptFileList.appendChild(item);
                    });
                }

                function removeFileUpload(id) {
                    const index = fileUploads.findIndex(entry => entry.id === id);
                    if (index === -1) return;
                    const entry = fileUploads[index];
                    if (entry && entry.xhr && entry.status === "uploading") {
                        try {
                            entry.xhr.abort();
                        } catch (err) { /* ignore */ }
                    }
                    fileUploads.splice(index, 1);
                    renderFileList();
                }

                function uploadFileToOpenAI(entry) {
                    const apiKey = getOpenAIApiKey();
                    if (!apiKey) {
                        entry.status = "error";
                        entry.error = "Cl√© OpenAI manquante.";
                        renderFileList();
                        showStatus("Ajoute une cl√© OpenAI pour t√©l√©verser un fichier.", true);
                        return;
                    }
                    entry.status = "uploading";
                    entry.progress = 0;
                    renderFileList();

                    const formData = new FormData();
                    formData.append("file", entry.file);
                    formData.append("purpose", "assistants");

                    const xhr = new XMLHttpRequest();
                    entry.xhr = xhr;
                    xhr.open("POST", "https://api.openai.com/v1/files");
                    xhr.setRequestHeader("Authorization", `Bearer ${apiKey}`);
                    xhr.upload.onprogress = event => {
                        if (!event || !event.lengthComputable) return;
                        const pct = Math.round((event.loaded / Math.max(event.total, 1)) * 100);
                        entry.progress = pct;
                        renderFileList();
                    };
                    xhr.onerror = () => {
                        entry.status = "error";
                        entry.error = "Erreur r√©seau.";
                        entry.xhr = null;
                        renderFileList();
                        showStatus("T√©l√©versement interrompu.", true);
                    };
                    xhr.onabort = () => {
                        entry.status = "error";
                        entry.error = "T√©l√©versement annul√©.";
                        entry.xhr = null;
                        renderFileList();
                    };
                    xhr.onreadystatechange = () => {
                        if (xhr.readyState !== 4) return;
                        entry.xhr = null;
                        if (xhr.status >= 200 && xhr.status < 300) {
                            let data = null;
                            try {
                                data = JSON.parse(xhr.responseText);
                            } catch (err) { /* ignore */ }
                            entry.status = "uploaded";
                            entry.progress = 100;
                            entry.openaiId = data?.id || "";
                            entry.url = data?.url || data?.id || "";
                            renderFileList();
                            showStatus("Fichier t√©l√©vers√©.");
                        } else {
                            entry.status = "error";
                            entry.error = xhr.responseText || "√âchec du t√©l√©versement.";
                            renderFileList();
                            showStatus("√âchec du t√©l√©versement de fichier.", true);
                        }
                    };
                    xhr.send(formData);
                }

                function handlePromptFileInputChange(event) {
                    const files = (event && event.target && event.target.files) || (promptFileInput && promptFileInput.files);
                    if (!files || !files.length) return;
                    const items = Array.from(files);
                    if (promptFileInput) {
                        promptFileInput.value = "";
                    }
                    items.forEach(file => {
                        const entry = {
                            id: `file-${Date.now()}-${Math.random().toString(16).slice(2)}`,
                            file,
                            name: file.name,
                            status: "queued",
                            progress: 0,
                            xhr: null,
                            openaiId: "",
                            url: "",
                            error: ""
                        };
                        fileUploads.push(entry);
                        uploadFileToOpenAI(entry);
                    });
                    renderFileList();
                }

                function getUploadedFileAttachments() {
                    return fileUploads
                        .filter(entry => entry.status === "uploaded" && entry.openaiId)
                        .map(entry => ({
                            file_id: entry.openaiId,
                            name: entry.name,
                            url: entry.url || entry.openaiId
                        }));
                }

                function isDesktopDrawerMode() {
                    return typeof window !== "undefined" && window.innerWidth > DESKTOP_DRAWER_BREAKPOINT;
                }

                function getGridScriptValue() {
                    const tplState = getActiveTemplateState();
                    const trimmedStateScript = ((tplState?.datasetScript || state.datasetScript || "") || "").trim();
                    if (trimmedStateScript) return trimmedStateScript;
                    const dataset = buildDatasetFromState();
                    if (!hasDatasetContent(dataset)) return "";
                    return JSON.stringify(dataset, null, 2);
                }

                function setDesktopSidebarState(open) {
                    if (!sidebar) return;
                    sidebarOpenDesktop = Boolean(open);
                    sidebar.classList.remove("open");
                    if (drawerOverlay) {
                        drawerOverlay.classList.remove("visible");
                        drawerOverlay.setAttribute("aria-hidden", "true");
                    }
                    sidebar.classList.toggle("collapsed", !sidebarOpenDesktop);
                    if (connectRight) {
                        connectRight.classList.toggle("full-width", !sidebarOpenDesktop);
                    }
                }

                function setMobileSidebarState(open) {
                    if (!sidebar) return;
                    const shouldOpen = Boolean(open);
                    sidebar.classList.toggle("open", shouldOpen);
                    if (!drawerOverlay) return;
                    drawerOverlay.classList.toggle("visible", shouldOpen);
                    drawerOverlay.setAttribute("aria-hidden", shouldOpen ? "false" : "true");
                }

                function syncSidebarLayout() {
                    if (!sidebar) return;
                    if (isDesktopDrawerMode()) {
                        setDesktopSidebarState(sidebarOpenDesktop);
                    } else {
                        sidebar.classList.remove("collapsed");
                        if (connectRight) {
                            connectRight.classList.remove("full-width");
                        }
                        setMobileSidebarState(false);
                    }
                }

                function toggleSidebar(force) {
                    if (!sidebar) return;
                    if (isDesktopDrawerMode()) {
                        const shouldOpen =
                            typeof force === "boolean" ? force : !sidebarOpenDesktop;
                        setDesktopSidebarState(shouldOpen);
                    } else {
                        const shouldOpen =
                            typeof force === "boolean" ? force : !sidebar.classList.contains("open");
                        setMobileSidebarState(shouldOpen);
                    }
                }


                function setActivePage(index) {
                    const targetIndex = Math.max(0, Math.min(index, state.pages.length - 1));
                    state.activeIndex = targetIndex;
                    const page = getActivePage();
                    if (gridTitleInput) gridTitleInput.value = page.title || "";
                    const tplState = getActiveTemplateState();
                    if (promptInput) promptInput.value = tplState.scenario || page.scenario || "";
                    if (gridScript) gridScript.value = tplState.datasetScript || getGridScriptValue();
                    try {
                        gridApi?.setFilterModel?.(null);
                        gridApi?.onFilterChanged?.();
                    } catch (err) { /* ignore */ }
                    applyGridData(page.data, { tableId: page.tableId });
                    renderTabs();
                    persistState();
                    scheduleNaturalFilterRecalc();
                }

                function addPage() {
                    const newPage = createPage(state.pages.length + 1);
                    state.pages.push(newPage);
                    state.schema = state.schema || { tables: [] };
                    if (!Array.isArray(state.schema.tables)) state.schema.tables = [];
                    state.schema.tables.push({
                        id: newPage.tableId,
                        title: newPage.title,
                        primaryKey: newPage.primaryKey || DEFAULT_PRIMARY_KEY,
                        columns: [],
                        relations: []
                    });
                    resetRelationLookups();
                    syncDatasetScriptFromState({ persist: false });
                    setActivePage(state.pages.length - 1);
                }

                function deleteActivePage() {
                    if (state.pages.length <= 1) return;
                    const pageToDelete = getActivePage();
                    state.pages.splice(state.activeIndex, 1);
                    if (pageToDelete?.tableId && Array.isArray(state?.schema?.tables)) {
                        state.schema.tables = state.schema.tables.filter(table => table?.id !== pageToDelete.tableId);
                    }
                    state.activeIndex = Math.max(0, state.activeIndex - 1);
                    setActivePage(state.activeIndex);
                    renderTabs();
                    resetRelationLookups();
                    syncDatasetScriptFromState();
                }

                function toggleNavMenu(force) {
                    if (!navSwitcherMenu) return;
                    const shouldOpen = typeof force === "boolean" ? force : !navSwitcherMenu.classList.contains("open");
                    navSwitcherMenu.classList.toggle("open", shouldOpen);
                }

                function openModal() {
                    aiModal?.classList.add("open");
                    renderTemplateSelect();
                    applyTemplateStateToUI();
                }

                function closeModal() {
                    aiModal?.classList.remove("open");
                }

                function resetPrompt() {
                    const tplConfig = getActiveTemplateConfig();
                    if (promptTemplateField) {
                        promptTemplateField.value = tplConfig.defaultPromptTemplate || DEFAULT_PROMPT_TEMPLATE;
                    }
                    if (systemPromptField) {
                        systemPromptField.value = tplConfig.defaultSystemPrompt || DEFAULT_SYSTEM_PROMPT;
                    }
                }

                function applyPromptSettings() {
                    const tplState = syncTemplateStateFromUI();
                    state.promptTemplate = tplState.promptTemplate;
                    state.systemPrompt = tplState.systemPrompt;
                    state.reasoningEffort = state.reasoningEffort || "low";
                    persistState();
                    closeModal();
                    updateFileRowVisibility();
                }

                function setLoading(isLoading) {
                    if (clearGridBtn) {
                        clearGridBtn.disabled = isLoading;
                    }
                    if (isLoading) {
                        startGenerateCooldown();
                    } else {
                        clearGenerateCooldown();
                    }
                }

                function getSelectedAiBackend() {
                    try {
                        const forced = window.GoToolkitSelectedAIBackend;
                        if (forced) {
                            return String(forced).trim().toLowerCase();
                        }
                    } catch (err) {
                        /* noop */
                    }
                    try {
                        if (window.localStorage) {
                            const stored = window.localStorage.getItem(AI_BACKEND_STORAGE_KEY);
                            if (stored) {
                                return stored.trim().toLowerCase();
                            }
                        }
                    } catch (err) {
                        console.warn("Impossible de lire le backend IA", err);
                    }
                    return "openai";
                }

                function isWebllmBackendSelected() {
                    return getSelectedAiBackend() === "webllm";
                }

                function shouldSignalWebllmServiceWorker() {
                    if (typeof navigator === "undefined" || !navigator.serviceWorker || !navigator.serviceWorker.controller) {
                        return false;
                    }
                    if (!window.GoToolkitWebLLM || typeof window.GoToolkitWebLLM.getEngineKind !== "function") {
                        return false;
                    }
                    return window.GoToolkitWebLLM.getEngineKind() === "service-worker";
                }

                function signalWebllmServiceWorkerAbort() {
                    if (!isWebllmBackendSelected() || !shouldSignalWebllmServiceWorker()) {
                        return;
                    }
                    try {
                        const uuid =
                            typeof crypto !== "undefined" && typeof crypto.randomUUID === "function"
                                ? crypto.randomUUID()
                                : `grid-webllm-abort-${Date.now()}`;
                        navigator.serviceWorker.controller.postMessage({
                            kind: "interruptGenerate",
                            uuid,
                            content: null
                        });
                    } catch (err) {
                        console.warn("Impossible d'interrompre le worker WebLLM", err);
                    }
                }

                function cancelActiveAiRequest() {
                    if (!activeRequestController) {
                        return;
                    }
                    pendingAbortStatus = true;
                    activeRequestController.abort();
                    signalWebllmServiceWorkerAbort();
                    showStatus("Requ√™te annul√©e.", true);
                }

                function handleGenerateClick(event) {
                    if (event) {
                        event.preventDefault();
                    }
                    if (activeRequestController) {
                        cancelActiveAiRequest();
                        return;
                    }
                    requestData();
                }

                function updateGenerateLabel(label) {
                    if (generateBtn) {
                        generateBtn.textContent = label;
                    }
                }

                function clearGenerateCooldown() {
                    if (generateCooldownTimer) {
                        clearInterval(generateCooldownTimer);
                        generateCooldownTimer = null;
                    }
                    generateCooldownEndTime = 0;
                    updateGenerateLabel(generateDefaultLabel);
                    if (toggleDrawerBtn) {
                        toggleDrawerBtn.disabled = false;
                        toggleDrawerBtn.textContent = drawerDefaultLabel;
                    }
                }

                function startGenerateCooldown(seconds = 30) {
                    if (!generateBtn) return;
                    clearGenerateCooldown();
                    const duration = Math.max(1, seconds);
                    generateCooldownEndTime = Date.now() + duration * 1000;
                    if (toggleDrawerBtn) {
                        toggleDrawerBtn.disabled = true;
                    }
                    const frames = ["‚ó¥", "‚ó∑", "‚ó∂", "‚óµ"];
                    const updateLabel = () => {
                        if (!generateBtn) {
                            clearGenerateCooldown();
                            return;
                        }
                        const remainingMs = generateCooldownEndTime - Date.now();
                        const remainingSeconds = Math.max(0, Math.ceil(remainingMs / 1000));
                        if (remainingSeconds <= 0 && activeRequestController) {
                            // If a request is still active when the countdown reaches 0,
                            // restart the countdown (e.g., to 30s) instead of showing a static "‚åõ en cours" label.
                            generateCooldownEndTime = Date.now() + duration * 1000;
                            return;
                        }
                        const frame = frames[remainingSeconds % frames.length];
                        const label = `${frame} ${remainingSeconds}s`;
                        updateGenerateLabel(label);
                        if (remainingSeconds <= 0 && !activeRequestController) {
                            clearGenerateCooldown();
                        }
                    };
                    updateLabel();
                    generateCooldownTimer = setInterval(updateLabel, 1000);
                }

                function cleanJson(raw) {
                    if (!raw) return "";
                    const trimmed = raw.trim();
                    if (trimmed.startsWith("```")) {
                        const match = trimmed.match(/```(?:json)?\\s*([\\s\\S]*?)```/i);
                        if (match && match[1]) return match[1].trim();
                    }
                    return trimmed;
                }

                function parseJsonTolerant(raw) {
                    if (!raw || typeof raw !== "string") return null;
                    // Try strict parse first
                    try {
                        return JSON.parse(raw);
                    } catch (e) { }

                    // Extract probable JSON object between first { and last }
                    const first = raw.indexOf("{");
                    const last = raw.lastIndexOf("}");
                    let candidate = raw;
                    if (first !== -1 && last !== -1 && last > first) {
                        candidate = raw.slice(first, last + 1);
                    }

                    // Helper attempts in order of increasing aggressiveness
                    const attempts = [];

                    // 1) Remove common markdown fences (already handled by cleanJson, but keep safe)
                    attempts.push(candidate.replace(/^```[\s\S]*?```$/i, s => s.replace(/```/g, "")));

                    // 2) Remove trailing commas before ] or }
                    attempts.push(candidate.replace(/,\s*(?=[}\]])/g, ""));

                    // 3) Quote unquoted property names: { foo: -> { "foo":
                    attempts.push(candidate.replace(/([\{,\s])([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g, '$1"$2":'));

                    // 4) Convert single-quoted strings to double-quoted (basic heuristic)
                    attempts.push(candidate.replace(/'([^'\\]*(?:\\.[^'\\]*)*)'/g, function (m, p) {
                        return '"' + p.replace(/"/g, '\\"') + '"';
                    }));

                    for (const attempt of attempts) {
                        try {
                            return JSON.parse(attempt);
                        } catch (e) {
                            // continue
                        }
                    }

                    // Last resort: try progressively combining fixes
                    try {
                        let c = candidate.replace(/,\s*(?=[}\]])/g, "");
                        c = c.replace(/([\{,\s])([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g, '$1"$2":');
                        c = c.replace(/'([^'\\]*(?:\\.[^'\\]*)*)'/g, function (m, p) { return '"' + p.replace(/"/g, '\\"') + '"'; });
                        return JSON.parse(c);
                    } catch (e) {
                        console.warn("parseJsonTolerant: unable to parse JSON response", e);
                        return null;
                    }
                }

                function parseJsonQuiet(raw) {
                    try {
                        return JSON.parse(raw);
                    } catch (e) {
                        return null;
                    }
                }

                function parseNdjsonDataset(raw) {
                    if (!raw || typeof raw !== "string") return null;
                    const lines = raw
                        .split(/\r?\n/)
                        .map(line => line.trim())
                        .filter(Boolean);
                    if (!lines.length) return null;
                    let headerSchema = null;
                    const data = {};
                    lines.forEach(line => {
                        const parsedLine = parseJsonQuiet(line);
                        if (!parsedLine || typeof parsedLine !== "object") return;
                        if (parsedLine.type === "header" && parsedLine.schema) {
                            headerSchema = parsedLine.schema;
                            const tables = Array.isArray(headerSchema.tables) ? headerSchema.tables : [];
                            tables.forEach(table => {
                                const tableId = typeof table.id === "string" ? table.id : "";
                                if (!tableId) return;
                                const columnDefs = Array.isArray(table.columns) ? table.columns : [];
                                data[tableId] = {
                                    columnDefs,
                                    rowData: []
                                };
                            });
                        } else if (parsedLine.type === "row" && parsedLine.table && parsedLine.data) {
                            const tableId = parsedLine.table;
                            if (!data[tableId]) {
                                data[tableId] = { columnDefs: [], rowData: [] };
                            }
                            data[tableId].rowData.push(parsedLine.data);
                        }
                    });
                    if (!headerSchema) return null;
                    return { schema: headerSchema, data };
                }

                function createStreamingDatasetState() {
                    return {
                        buffer: "",
                        header: null,
                        data: {},
                        rowCounts: {},
                        finished: false
                    };
                }

                function applyStreamingHeader(state, schema, options = {}) {
                    if (!schema || typeof schema !== "object") return;
                    state.header = schema;
                    state.data = {};
                    state.rowCounts = {};
                    const tables = Array.isArray(schema.tables) ? schema.tables : [];
                    tables.forEach(table => {
                        const tableId = typeof table?.id === "string" ? table.id : "";
                        if (!tableId) return;
                        const columnDefs = Array.isArray(table.columns) ? table.columns : [];
                        state.data[tableId] = { columnDefs, rowData: [] };
                        state.rowCounts[tableId] = 0;
                    });
                    applyDatasetToState(
                        { schema, data: state.data },
                        { markAsAi: true, activeTableId: options.activeTableId }
                    );
                }

                function handleStreamingRow(state, rowPayload) {
                    if (!state.header || !rowPayload || typeof rowPayload !== "object") return;
                    const tableId = typeof rowPayload.table === "string" ? rowPayload.table : "";
                    if (!tableId) return;
                    const rowData = rowPayload.data && typeof rowPayload.data === "object" ? rowPayload.data : {};
                    if (!state.data[tableId]) {
                        state.data[tableId] = { columnDefs: [], rowData: [] };
                    }
                    state.data[tableId].rowData.push(rowData);
                    state.rowCounts[tableId] = (state.rowCounts[tableId] || 0) + 1;

                    const pageIndex = findPageIndexByTableId(tableId);
                    if (pageIndex === -1) return;
                    const page = state.pages[pageIndex];
                    page.data = {
                        columnDefs: state.data[tableId].columnDefs || [],
                        rowData: state.data[tableId].rowData
                    };
                    if (pageIndex === state.activeIndex && gridApi) {
                        if (typeof gridApi.applyTransaction === "function") {
                            try { gridApi.applyTransaction({ add: [rowData] }); } catch (err) { /* ignore */ }
                        } else if (typeof gridApi.setRowData === "function") {
                            try { gridApi.setRowData(state.data[tableId].rowData); } catch (err) { /* ignore */ }
                        }
                    }
                }

                function finalizeStreamingDataset(state, options = {}) {
                    if (!state.header) return;
                    const dataset = { schema: state.header, data: state.data };
                    applyDatasetToState(dataset, { markAsAi: true, activeTableId: options.activeTableId });
                    syncDatasetScriptFromState();
                    scheduleNaturalFilterRecalc();
                    state.finished = true;
                }

                function handleStreamingChunk(state, chunk, options = {}) {
                    if (!chunk) return;
                    state.buffer += chunk;
                    const parts = state.buffer.split(/\r?\n/);
                    state.buffer = parts.pop() || "";
                    parts.forEach(line => {
                        const trimmed = line.trim();
                        if (!trimmed) return;
                        const parsed = parseJsonQuiet(trimmed);
                        if (!parsed || typeof parsed !== "object") return;
                        if (parsed.type === "header" && parsed.schema) {
                            applyStreamingHeader(state, parsed.schema, { activeTableId: options.activeTableId });
                        } else if (parsed.type === "row") {
                            handleStreamingRow(state, parsed);
                        } else if (parsed.type === "done") {
                            finalizeStreamingDataset(state, { activeTableId: options.activeTableId });
                        }
                    });
                }

                // -----------------------------
                // Natural controlled French filter bar (external filtering)
                // -----------------------------
                //
                // Parser states:
                // - status="ok": full expression parsed successfully -> apply AST
                // - status="partial": input ends mid-clause but can be valid continuation -> apply last fully-formed AST if any
                // - status="error": hard syntax error -> DO NOT change last good AST (keeps previous filtering)
                //
                // This behavior avoids surprising "filter cleared" when the user makes a temporary typo.

                function normalizeAccents(text) {
                    if (text == null) return "";
                    return String(text)
                        .normalize("NFD")
                        .replace(/[\u0300-\u036f]/g, "");
                }

                function normalizeForCompare(text) {
                    return normalizeAccents(text)
                        .replace(/[‚Äô]/g, "'")
                        .toLowerCase()
                        .trim();
                }

                function isEmptyValue(value) {
                    return value == null || value === "";
                }

                function isIsoDate(value) {
                    return typeof value === "string" && /^[0-9]{4}-[0-9]{2}-[0-9]{2}$/.test(value);
                }

                function isIsoDateTime(value) {
                    return typeof value === "string" && /^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}$/.test(value);
                }

                function isIsoTime(value) {
                    return typeof value === "string" && /^[0-9]{2}:[0-9]{2}(?::[0-9]{2})?$/.test(value);
                }

                function pad2(value) {
                    return String(value).padStart(2, "0");
                }

                function formatIsoDateUtc(date) {
                    return `${date.getUTCFullYear()}-${pad2(date.getUTCMonth() + 1)}-${pad2(date.getUTCDate())}`;
                }

                function formatIsoDateTimeUtc(date, boundary = "start") {
                    const day = formatIsoDateUtc(date);
                    if (boundary === "end") return `${day}T23:59:59`;
                    return `${day}T00:00:00`;
                }

                function getTodayUtc() {
                    const now = new Date();
                    return new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));
                }

                function addDaysUtc(date, days) {
                    return new Date(date.getTime() + days * 24 * 60 * 60 * 1000);
                }

                function addMonthsUtc(date, months) {
                    const year = date.getUTCFullYear();
                    const month = date.getUTCMonth();
                    const day = date.getUTCDate();
                    const targetMonth = month + months;
                    const targetYear = year + Math.floor(targetMonth / 12);
                    const normalizedMonth = ((targetMonth % 12) + 12) % 12;
                    const lastDay = new Date(Date.UTC(targetYear, normalizedMonth + 1, 0)).getUTCDate();
                    const clampedDay = Math.min(day, lastDay);
                    return new Date(Date.UTC(targetYear, normalizedMonth, clampedDay));
                }

                function startOfWeekUtc(date) {
                    // Monday as start of week (ISO-8601).
                    const dow = date.getUTCDay(); // 0=Sun..6=Sat
                    const offset = (dow + 6) % 7;
                    return addDaysUtc(new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate())), -offset);
                }

                function startOfMonthUtc(date) {
                    return new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), 1));
                }

                function getKnownFieldMap() {
                    const page = getActivePage();
                    const defs = Array.isArray(page?.data?.columnDefs) ? page.data.columnDefs : [];
                    const rows = Array.isArray(page?.data?.rowData) ? page.data.rowData : [];
                    const keySet = new Set();
                    rows.forEach(row => {
                        if (!row || typeof row !== "object") return;
                        Object.keys(row).forEach(key => keySet.add(key));
                    });
                    const map = new Map();
                    defs.forEach(def => {
                        const field = def && typeof def === "object" ? def.field : null;
                        if (typeof field !== "string" || !field) return;
                        if (field.startsWith("__relCount__")) return;
                        if (!keySet.has(field) && keySet.size) return;
                        const fkRelation = getForeignKeyRelationForField(field, page);
                        const headerName =
                            fkRelation?.label && fkRelation.label.trim()
                                ? fkRelation.label.trim()
                                : (def && typeof def.headerName === "string" && def.headerName.trim()
                                    ? def.headerName.trim()
                                    : field);
                        map.set(field, {
                            field,
                            headerName,
                            dataType: typeof def.cellDataType === "string" && def.cellDataType.trim()
                                ? def.cellDataType.trim()
                                : null
                        });
                    });
                    // Ensure fields present in data but missing in columnDefs are still usable.
                    keySet.forEach(field => {
                        if (!field || typeof field !== "string") return;
                        if (field.startsWith("__relCount__")) return;
                        if (!map.has(field)) {
                            map.set(field, { field, headerName: field, dataType: null });
                        }
                    });

                    // Infer missing data types from data values when possible.
                    for (const [field, info] of map.entries()) {
                        if (info && typeof info === "object" && info.dataType) continue;
                        let inferred = null;
                        for (const row of rows) {
                            if (!row || typeof row !== "object") continue;
                            const v = row[field];
                            if (v == null) continue;
                            if (typeof v === "number") { inferred = "number"; break; }
                            if (typeof v === "boolean") { inferred = "boolean"; break; }
                            if (typeof v === "string") {
                                const raw = v.trim();
                                if (raw === "") continue;
                                if (isIsoDateTime(raw)) { inferred = "dateTime"; break; }
                                if (isIsoDate(raw)) { inferred = "date"; break; }
                                if (isIsoTime(raw)) { inferred = "time"; break; }
                                inferred = "text";
                                break;
                            }
                            inferred = "text";
                            break;
                        }
                        if (!inferred) inferred = "text";
                        const fkRelation = getForeignKeyRelationForField(field, page);
                        if (fkRelation) inferred = "text";
                        map.set(field, { ...info, dataType: inferred });
                    }

                    // Add synthetic relation-count fields (one-to-many), which are numeric.
                    const relCountDefs = getRelationCountFieldDefsForTable(page?.tableId || "");
                    relCountDefs.forEach(def => {
                        if (!def?.field) return;
                        map.set(def.field, { field: def.field, headerName: def.headerName, dataType: "number" });
                    });
                    return map;
                }

                function resolveFieldToken(fieldToken, knownFieldMap) {
                    const map = knownFieldMap || new Map();
                    const tokenRaw = (fieldToken || "").trim();
                    if (!tokenRaw) return null;
                    if (map.has(tokenRaw)) return tokenRaw;
                    const wanted = normalizeForCompare(tokenRaw);
                    for (const info of map.values()) {
                        const header = info?.headerName || "";
                        if (normalizeForCompare(header) === wanted) {
                            return info.field;
                        }
                    }
                    return null;
                }

                function tokenizeFrenchFilter(input) {
                    const src = String(input || "");
                    const tokens = [];
                    let i = 0;
                    const push = (type, value, start, end) => tokens.push({ type, value, start, end });

                    const isSpace = ch => /\s/.test(ch);
                    const isWordChar = ch => /[A-Za-z0-9_\-√Ä-√ø'‚Äô]/.test(ch);

                    while (i < src.length) {
                        const ch = src[i];
                        if (isSpace(ch)) {
                            i += 1;
                            continue;
                        }
                        const start = i;
                        if (ch === ",") {
                            push("comma", ch, start, start + 1);
                            i += 1;
                            continue;
                        }
                        // No bracket syntax for columns (v2).
                        if (ch === "!" && src[i + 1] === "=") {
                            push("op", "!=", start, start + 2);
                            i += 2;
                            continue;
                        }
                        if (ch === ">" || ch === "<" || ch === "=") {
                            if ((ch === ">" || ch === "<") && src[i + 1] === "=") {
                                push("op", ch + "=", start, start + 2);
                                i += 2;
                            } else {
                                push("op", ch, start, start + 1);
                                i += 1;
                            }
                            continue;
                        }
                        if (ch === "\"" || ch === "'") {
                            const quote = ch;
                            i += 1;
                            let value = "";
                            while (i < src.length) {
                                const c = src[i];
                                if (c === "\\" && i + 1 < src.length) {
                                    value += src[i + 1];
                                    i += 2;
                                    continue;
                                }
                                if (c === quote) {
                                    i += 1;
                                    break;
                                }
                                value += c;
                                i += 1;
                            }
                            push("string", value, start, i);
                            continue;
                        }
                        if (isWordChar(ch)) {
                            let word = "";
                            while (i < src.length && isWordChar(src[i])) {
                                word += src[i];
                                i += 1;
                            }
                            push("word", word, start, i);
                            continue;
                        }

                        // Unknown single char -> keep for error reporting
                        push("unknown", ch, start, start + 1);
                        i += 1;
                    }
                    return tokens;
                }

                function parseNaturalFilter(input, knownFieldMap) {
                    const fieldMap = knownFieldMap || new Map();
                    const tokens = tokenizeFrenchFilter(input);
                    const words = tokens.map(tok => ({
                        ...tok,
                        norm: tok.type === "word" ? normalizeForCompare(tok.value) : tok.value
                    }));

                    const parser = {
                        tokens: words,
                        pos: 0,
                        lastGoodAst: null,
                        lastGoodPos: 0,
                        peek(offset = 0) { return this.tokens[this.pos + offset] || null; },
                        eof() { return this.pos >= this.tokens.length; },
                        consume() { const t = this.peek(); if (t) this.pos += 1; return t; },
                        matchComma() {
                            const t = this.peek();
                            if (t && t.type === "comma") {
                                this.pos += 1;
                                return true;
                            }
                            return false;
                        },
                        matchWord(valueNorm) {
                            const t = this.peek();
                            if (t && t.type === "word" && t.norm === valueNorm) {
                                this.pos += 1;
                                return true;
                            }
                            return false;
                        },
                        matchOp(value) {
                            const t = this.peek();
                            if (t && t.type === "op" && t.value === value) {
                                this.pos += 1;
                                return true;
                            }
                            return false;
                        },
                        error(kind, message) {
                            const err = new Error(message);
                            err.kind = kind;
                            err.pos = this.pos;
                            throw err;
                        },
                        markGood(ast) {
                            this.lastGoodAst = ast;
                            this.lastGoodPos = this.pos;
                        }
                    };

                    const normalizeDataType = (rawType) => {
                        const t = typeof rawType === "string" ? rawType.trim().toLowerCase() : "";
                        if (!t) return "text";
                        if (t === "string" || t === "text") return "text";
                        if (t === "number" || t === "numeric" || t === "int" || t === "float") return "number";
                        if (t === "boolean" || t === "bool") return "boolean";
                        if (t === "date") return "date";
                        if (t === "datetime" || t === "datetime") return "dateTime";
                        if (t === "time") return "time";
                        return "text";
                    };

                    const getFieldDataType = (field) => {
                        const info = fieldMap.get(field);
                        return normalizeDataType(info?.dataType);
                    };

                    const isValueBoundary = (t) => {
                        if (!t) return true;
                        if (t.type === "comma") return true;
                        if (t.type === "word" && (t.norm === "ou" || t.norm === "et")) return true;
                        return false;
                    };

                    const parseRelativeDateValueNode = () => {
                        const t = parser.peek();
                        if (!t || t.type !== "word") return null;

                        const today = getTodayUtc();
                        const token = t.norm;

                        const dateNode = (date) => ({ type: "value", valueType: "date", raw: formatIsoDateUtc(date) });
                        const matchSeq = (normWords) => {
                            for (let i = 0; i < normWords.length; i += 1) {
                                const w = parser.peek(i);
                                if (!w || w.type !== "word" || w.norm !== normalizeForCompare(normWords[i])) return false;
                            }
                            parser.pos += normWords.length;
                            return true;
                        };

                        if (token === "aujourd'hui") {
                            parser.consume();
                            return dateNode(today);
                        }
                        if (token === "hier") {
                            parser.consume();
                            return dateNode(addDaysUtc(today, -1));
                        }
                        if (token === "demain") {
                            parser.consume();
                            return dateNode(addDaysUtc(today, 1));
                        }

                        const matchUnit = (unitNorm) => {
                            if (!unitNorm) return null;
                            if (unitNorm.startsWith("jour")) return "days";
                            if (unitNorm.startsWith("semaine")) return "weeks";
                            if (unitNorm === "mois") return "months";
                            return null;
                        };

                        const parseNumberWord = () => {
                            const nTok = parser.peek();
                            if (!nTok) parser.error("partial", "Nombre attendu.");
                            if (nTok.type !== "word") parser.error("error", "Nombre attendu.");
                            const raw = nTok.value;
                            if (!/^[0-9]+$/.test(raw)) parser.error("error", "Nombre attendu.");
                            parser.consume();
                            return parseInt(raw, 10);
                        };

                        if (token === "dans") {
                            parser.consume();
                            if (parser.eof()) parser.error("partial", "Nombre attendu apr√®s 'dans'.");
                            const n = parseNumberWord();
                            const unitTok = parser.peek();
                            if (!unitTok) parser.error("partial", "Unit√© attendue apr√®s le nombre.");
                            if (unitTok.type !== "word") parser.error("error", "Unit√© attendue.");
                            const unit = matchUnit(unitTok.norm);
                            if (!unit) parser.error("error", "Unit√© attendue: jours, semaines, mois.");
                            parser.consume();
                            if (unit === "days") return dateNode(addDaysUtc(today, n));
                            if (unit === "weeks") return dateNode(addDaysUtc(today, n * 7));
                            return dateNode(addMonthsUtc(today, n));
                        }

                        if (matchSeq(["il", "y", "a"])) {
                            if (parser.eof()) parser.error("partial", "Nombre attendu apr√®s 'il y a'.");
                            const n = parseNumberWord();
                            const unitTok = parser.peek();
                            if (!unitTok) parser.error("partial", "Unit√© attendue apr√®s le nombre.");
                            if (unitTok.type !== "word") parser.error("error", "Unit√© attendue.");
                            const unit = matchUnit(unitTok.norm);
                            if (!unit) parser.error("error", "Unit√© attendue: jours, semaines, mois.");
                            parser.consume();
                            if (unit === "days") return dateNode(addDaysUtc(today, -n));
                            if (unit === "weeks") return dateNode(addDaysUtc(today, -n * 7));
                            return dateNode(addMonthsUtc(today, -n));
                        }

                        if (matchSeq(["cette", "semaine"])) {
                            return dateNode(startOfWeekUtc(today));
                        }
                        if (matchSeq(["la", "semaine", "derniere"]) || matchSeq(["la", "semaine", "derni√®re"])) {
                            return dateNode(startOfWeekUtc(addDaysUtc(today, -7)));
                        }
                        if (matchSeq(["la", "semaine", "prochaine"])) {
                            return dateNode(startOfWeekUtc(addDaysUtc(today, 7)));
                        }

                        if (matchSeq(["ce", "mois"])) {
                            return dateNode(startOfMonthUtc(today));
                        }
                        if (matchSeq(["le", "mois", "dernier"])) {
                            return dateNode(startOfMonthUtc(addMonthsUtc(today, -1)));
                        }
                        if (matchSeq(["le", "mois", "prochain"])) {
                            return dateNode(startOfMonthUtc(addMonthsUtc(today, 1)));
                        }

                        return null;
                    };

                    const dateFromIsoDate = (raw) => {
                        const parts = String(raw || "").split("-");
                        if (parts.length !== 3) return null;
                        const y = parseInt(parts[0], 10);
                        const m = parseInt(parts[1], 10);
                        const d = parseInt(parts[2], 10);
                        if (!Number.isFinite(y) || !Number.isFinite(m) || !Number.isFinite(d)) return null;
                        return new Date(Date.UTC(y, m - 1, d));
                    };

                    const coerceToExpectedTemporalValue = (valueNode, expectedType, boundary = "start") => {
                        if (!valueNode) return valueNode;
                        if (expectedType === "date") {
                            if (valueNode.valueType === "date") return valueNode;
                            if (valueNode.valueType === "dateTime") {
                                return { type: "value", valueType: "date", raw: String(valueNode.raw).slice(0, 10) };
                            }
                            return valueNode;
                        }
                        if (expectedType === "dateTime") {
                            if (valueNode.valueType === "dateTime") return valueNode;
                            if (valueNode.valueType === "date") {
                                const d = dateFromIsoDate(valueNode.raw);
                                if (!d) return valueNode;
                                return { type: "value", valueType: "dateTime", raw: formatIsoDateTimeUtc(d, boundary) };
                            }
                            return valueNode;
                        }
                        return valueNode;
                    };

                    const parsePrimitiveSingleTokenValue = () => {
                        const t = parser.peek();
                        if (!t) parser.error("partial", "Valeur attendue.");
                        if (t.type === "string") {
                            parser.consume();
                            return { type: "value", valueType: "string", raw: t.value };
                        }
                        if (t.type === "word") {
                            const raw = t.value;
                            parser.consume();
                            if (/^[0-9]+(?:\.[0-9]+)?$/.test(raw)) {
                                return { type: "value", valueType: "number", raw };
                            }
                            if (isIsoDate(raw)) {
                                return { type: "value", valueType: "date", raw };
                            }
                            if (isIsoDateTime(raw)) {
                                return { type: "value", valueType: "dateTime", raw };
                            }
                            if (isIsoTime(raw)) {
                                return { type: "value", valueType: "time", raw };
                            }
                            return { type: "value", valueType: "identifier", raw };
                        }
                        parser.error("error", "Valeur attendue.");
                    };

                    const parseSingleTokenValue = () => {
                        const t = parser.peek();
                        if (!t) parser.error("partial", "Valeur attendue.");
                        if (t.type === "word") {
                            const rel = parseRelativeDateValueNode();
                            if (rel) return rel;
                        }
                        return parsePrimitiveSingleTokenValue();
                    };

                    const parseDateLikeValue = (expectedType, options = {}) => {
                        const boundary = options.boundary || "start";
                        const rel = parseRelativeDateValueNode();
                        if (rel) return coerceToExpectedTemporalValue(rel, expectedType, boundary);
                        const v = parsePrimitiveSingleTokenValue();
                        return coerceToExpectedTemporalValue(v, expectedType, boundary);
                    };

                    const parseEqualsValue = (field) => {
                        const t = parser.peek();
                        if (!t) parser.error("partial", "Valeur attendue.");
                        if (t.type === "string") return parseSingleTokenValue();
                        if (t.type !== "word") parser.error("error", "Valeur attendue.");

                        const fieldType = getFieldDataType(field);
                        if (fieldType !== "text") {
                            const v =
                                fieldType === "date" || fieldType === "dateTime"
                                    ? parseDateLikeValue(fieldType, { boundary: "start" })
                                    : parseSingleTokenValue();
                            if (fieldType === "number" && v.valueType !== "number") parser.error("error", "Nombre attendu.");
                            if (fieldType === "date" && v.valueType !== "date") parser.error("error", "Date attendue (YYYY-MM-DD).");
                            if (fieldType === "dateTime" && v.valueType !== "dateTime") parser.error("error", "Date/heure attendue (YYYY-MM-DDTHH:MM:SS).");
                            if (fieldType === "time" && v.valueType !== "time") parser.error("error", "Heure attendue (HH:MM[:SS]).");
                            return v;
                        }

                        const parts = [];
                        while (!parser.eof()) {
                            const next = parser.peek();
                            if (isValueBoundary(next)) break;
                            if (next.type === "word") {
                                parts.push(next.value);
                                parser.consume();
                                continue;
                            }
                            break;
                        }
                        if (!parts.length) parser.error("partial", "Valeur attendue.");
                        return { type: "value", valueType: "string", raw: parts.join(" ") };
                    };

                    const parseTextOpValue = () => {
                        const t = parser.peek();
                        if (!t) parser.error("partial", "Valeur attendue.");
                        // contient/commence par/finit par:
                        // - 1 mot sans guillemets accept√©
                        // - plusieurs mots => guillemets via token "string"
                        if (t.type === "string" || t.type === "word") return parseSingleTokenValue();
                        parser.error("error", "Valeur attendue.");
                    };

                    const isOperatorCompatibleWithField = (field, op) => {
                        const fieldType = getFieldDataType(field);
                        if (op === "between") return fieldType === "number" || fieldType === "date" || fieldType === "dateTime" || fieldType === "time";
                        if (op === "before" || op === "after") return fieldType === "date" || fieldType === "dateTime" || fieldType === "time";
                        if (op === "contains" || op === "starts" || op === "ends") return fieldType === "text";
                        if (op === "=" || op === "!=") return true;
                        if (op === ">=" || op === "<=") return fieldType === "number";
                        return true;
                    };

                    const looksLikeNewConditionFromPos = (pos) => {
                        const t = parser.tokens[pos];
                        if (!t) return false;
                        if (t.type !== "word") return false;

                        const operatorStarts = [
                            ["n'est", "pas"],
                            ["nest", "pas"],
                            ["commence", "par"],
                            ["finit", "par"],
                            ["superieur", "a"],
                            ["sup√©rieur", "√†"],
                            ["inferieur", "a"],
                            ["inf√©rieur", "√†"],
                            ["est"],
                            ["contient"],
                            ["avant"],
                            ["apres"],
                            ["apr√®s"],
                            ["entre"]
                        ];

                        const startsWithOperator = (p) => {
                            const tok = parser.tokens[p];
                            if (!tok) return false;
                            if (tok.type === "op") return true;
                            for (const seq of operatorStarts) {
                                let ok = true;
                                for (let i = 0; i < seq.length; i += 1) {
                                    const w = parser.tokens[p + i];
                                    if (!w || w.type !== "word" || w.norm !== normalizeForCompare(seq[i])) {
                                        ok = false;
                                        break;
                                    }
                                }
                                if (ok) return true;
                            }
                            return false;
                        };

                        const parts = [];
                        let p = pos;
                        while (p < parser.tokens.length) {
                            const tok = parser.tokens[p];
                            if (!tok || tok.type !== "word") break;
                            if (startsWithOperator(p)) break;
                            parts.push(tok.value);
                            p += 1;
                        }
                        const rawLabel = parts.join(" ").trim();
                        if (!rawLabel) return false;
                        const resolved = resolveFieldToken(rawLabel, fieldMap);
                        if (!resolved) return false;
                        return startsWithOperator(p);
                    };

                    const parseField = () => {
                        const t = parser.peek();
                        if (!t) parser.error("partial", "Champ attendu.");

                        // Column token is the display label (headerName) OR the system field.
                        // It can be multi-word: we consume words until we detect an operator start.
                        if (t.type === "string") {
                            parser.consume();
                            const resolved = resolveFieldToken(t.value, fieldMap);
                            if (!resolved) {
                                if (parser.eof()) parser.error("partial", "Champ incomplet.");
                                parser.error("error", `Champ inconnu: ${t.value}`);
                            }
                            return resolved;
                        }
                        if (t.type !== "word") parser.error("error", "Champ attendu.");

                        const operatorStarts = [
                            ["n'est", "pas"],
                            ["nest", "pas"],
                            ["commence", "par"],
                            ["finit", "par"],
                            ["superieur", "a"],
                            ["sup√©rieur", "√†"],
                            ["inferieur", "a"],
                            ["inf√©rieur", "√†"],
                            ["est"],
                            ["contient"],
                            ["avant"],
                            ["apres"],
                            ["apr√®s"],
                            ["entre"]
                        ];

                        const startsWithOperator = (pos) => {
                            const tok = parser.tokens[pos];
                            if (!tok) return false;
                            if (tok.type === "op") return true;
                            for (const seq of operatorStarts) {
                                let ok = true;
                                for (let i = 0; i < seq.length; i += 1) {
                                    const w = parser.tokens[pos + i];
                                    if (!w || w.type !== "word" || w.norm !== normalizeForCompare(seq[i])) {
                                        ok = false;
                                        break;
                                    }
                                }
                                if (ok) return true;
                            }
                            return false;
                        };

                        const parts = [];
                        while (!parser.eof() && parser.peek()?.type === "word") {
                            if (startsWithOperator(parser.pos)) break;
                            const w = parser.consume();
                            parts.push(w.value);
                        }
                        const rawLabel = parts.join(" ").trim();
                        if (!rawLabel) parser.error("partial", "Champ attendu.");
                        const resolved = resolveFieldToken(rawLabel, fieldMap);
                        if (!resolved) {
                            const wanted = normalizeForCompare(rawLabel);
                            const hasPrefix = Array.from(fieldMap.values()).some(info => {
                                const label = normalizeForCompare(info?.headerName || "");
                                const field = normalizeForCompare(info?.field || "");
                                return label.startsWith(wanted) || field.startsWith(wanted);
                            });
                            if (parser.eof() && hasPrefix) {
                                parser.error("partial", "Champ incomplet.");
                            }
                            parser.error("error", `Champ inconnu: ${rawLabel}`);
                        }
                        return resolved;
                    };

                    const matchMultiWord = (normWords) => {
                        for (let i = 0; i < normWords.length; i += 1) {
                            const t = parser.peek(i);
                            if (!t || t.type !== "word" || t.norm !== normWords[i]) return false;
                        }
                        parser.pos += normWords.length;
                        return true;
                    };

                    function isoDateFromDate(d) {
                        const y = d.getFullYear();
                        const m = String(d.getMonth() + 1).padStart(2, "0");
                        const day = String(d.getDate()).padStart(2, "0");
                        return `${y}-${m}-${day}`;
                    }

                    function startOfWeekDate(d) {
                        const copy = new Date(d.getFullYear(), d.getMonth(), d.getDate());
                        const day = copy.getDay(); // 0=Sun,1=Mon
                        const offset = (day + 6) % 7; // days since Monday
                        copy.setDate(copy.getDate() - offset);
                        copy.setHours(0, 0, 0, 0);
                        return copy;
                    }

                    function startOfMonthDate(d) {
                        return new Date(d.getFullYear(), d.getMonth(), 1);
                    }

                    function parseRelativeDate() {
                        // Attempt to parse French relative date expressions starting at current parser.pos
                        const today = new Date();
                        const norm = s => normalizeForCompare(s);

                        const tryMatch = (words) => matchMultiWord(words.map(w => norm(w)));

                        const peekWord = (offset = 0) => {
                            const t = parser.peek(offset);
                            return t && t.type === "word" ? t : null;
                        };

                        // aujourd'hui / hier / demain
                        const t0 = peekWord(0);
                        if (t0) {
                            const n = t0.norm;
                            if (n === norm("aujourd'hui") || n === "aujourdhui") {
                                parser.consume();
                                return { type: "value", valueType: "date", raw: isoDateFromDate(today) };
                            }
                            if (n === norm("hier")) {
                                parser.consume();
                                const d = new Date(today);
                                d.setDate(d.getDate() - 1);
                                return { type: "value", valueType: "date", raw: isoDateFromDate(d) };
                            }
                            if (n === norm("demain")) {
                                parser.consume();
                                const d = new Date(today);
                                d.setDate(d.getDate() + 1);
                                return { type: "value", valueType: "date", raw: isoDateFromDate(d) };
                            }
                        }

                        // il y a N jours/semaines/mois  -> past
                        if (tryMatch(["il", "y", "a"])) {
                            // expect number
                            const numTok = peekWord(0);
                            if (!numTok) {
                                parser.error("partial", "Nombre attendu apr√®s 'il y a'.");
                            }
                            if (!/^[0-9]+$/.test(numTok.value)) {
                                parser.error("error", "Nombre attendu apr√®s 'il y a'.");
                            }
                            const n = Number(numTok.value);
                            parser.consume();
                            const unitTok = peekWord(0);
                            if (!unitTok) parser.error("partial", "Unit√© temporelle attendue (jours, semaines, mois).");
                            const unit = unitTok.norm;
                            parser.consume();
                            const d = new Date(today);
                            if (/^jours?$/.test(unit) || unit === norm("jours") || unit === "jour") {
                                d.setDate(d.getDate() - n);
                            } else if (/^semaines?$/.test(unit) || unit === "semaine") {
                                d.setDate(d.getDate() - n * 7);
                            } else if (/^mois$/.test(unit) || unit === "mois") {
                                d.setMonth(d.getMonth() - n);
                            } else {
                                parser.error("error", "Unit√© temporelle inconnue.");
                            }
                            return { type: "value", valueType: "date", raw: isoDateFromDate(d) };
                        }

                        // dans N jours/semaines/mois -> future
                        if (tryMatch(["dans"])) {
                            const numTok = peekWord(0);
                            if (!numTok) parser.error("partial", "Nombre attendu apr√®s 'dans'.");
                            if (!/^[0-9]+$/.test(numTok.value)) parser.error("error", "Nombre attendu apr√®s 'dans'.");
                            const n = Number(numTok.value);
                            parser.consume();
                            const unitTok = peekWord(0);
                            if (!unitTok) parser.error("partial", "Unit√© temporelle attendue (jours, semaines, mois).");
                            const unit = unitTok.norm;
                            parser.consume();
                            const d = new Date(today);
                            if (/^jours?$/.test(unit) || unit === "jour") {
                                d.setDate(d.getDate() + n);
                            } else if (/^semaines?$/.test(unit) || unit === "semaine") {
                                d.setDate(d.getDate() + n * 7);
                            } else if (/^mois$/.test(unit) || unit === "mois") {
                                d.setMonth(d.getMonth() + n);
                            } else {
                                parser.error("error", "Unit√© temporelle inconnue.");
                            }
                            return { type: "value", valueType: "date", raw: isoDateFromDate(d) };
                        }

                        // week/month expressions: 'cette semaine', 'la semaine derni√®re', 'la semaine prochaine', 'le mois dernier', 'ce mois', 'le mois prochain'
                        if (tryMatch(["cette", "semaine"]) || tryMatch(["la", "semaine", "derniere"]) || tryMatch(["la", "semaine", "prochaine"])) {
                            const consumed = parser.tokens.slice(Math.max(0, parser.pos - 3), parser.pos).map(t => t.norm).join(" ");
                            const start = startOfWeekDate(new Date());
                            let d = new Date(start);
                            if (consumed.includes(norm("derniere")) || consumed.includes("derniere")) {
                                d.setDate(d.getDate() - 7);
                            } else if (consumed.includes(norm("prochaine")) || consumed.includes("prochaine")) {
                                d.setDate(d.getDate() + 7);
                            }
                            return { type: "value", valueType: "date", raw: isoDateFromDate(d) };
                        }

                        if (tryMatch(["le", "mois", "dernier"]) || tryMatch(["le", "mois", "prochain"]) || tryMatch(["ce", "mois"]) || tryMatch(["le", "mois", "dernier"])) {
                            const consumed = parser.tokens.slice(Math.max(0, parser.pos - 3), parser.pos).map(t => t.norm).join(" ");
                            const start = startOfMonthDate(new Date());
                            let d = new Date(start);
                            if (consumed.includes(norm("dernier")) || consumed.includes("dernier")) {
                                d.setMonth(d.getMonth() - 1);
                            } else if (consumed.includes(norm("prochain")) || consumed.includes("prochain")) {
                                d.setMonth(d.getMonth() + 1);
                            }
                            return { type: "value", valueType: "date", raw: isoDateFromDate(d) };
                        }

                        return null;
                    }

                    const parseCondition = () => {
                        const field = parseField();

                        // Unary empty checks
                        if (matchMultiWord(["est", "vide"])) {
                            const ast = { type: "empty", field, negated: false };
                            parser.markGood(ast);
                            return ast;
                        }
                        if (matchMultiWord(["n'est", "pas", "vide"]) || matchMultiWord(["nest", "pas", "vide"])) {
                            const ast = { type: "empty", field, negated: true };
                            parser.markGood(ast);
                            return ast;
                        }

                        // Between: champ entre v1 et v2
                        if (parser.matchWord("entre")) {
                            if (!isOperatorCompatibleWithField(field, "between")) {
                                parser.error("error", "Op√©rateur incompatible avec le type de la colonne.");
                            }
                            const fieldType = getFieldDataType(field);
                            const min =
                                fieldType === "date"
                                    ? parseDateLikeValue("date", { boundary: "start" })
                                    : fieldType === "dateTime"
                                        ? parseDateLikeValue("dateTime", { boundary: "start" })
                                        : parseSingleTokenValue();
                            if (!parser.matchWord("et")) {
                                if (parser.eof()) parser.error("partial", "Mot-cl√© 'et' attendu.");
                                parser.error("error", "Mot-cl√© 'et' attendu.");
                            }
                            const max =
                                fieldType === "date"
                                    ? parseDateLikeValue("date", { boundary: "start" })
                                    : fieldType === "dateTime"
                                        ? parseDateLikeValue("dateTime", { boundary: "end" })
                                        : parseSingleTokenValue();
                            if (fieldType === "number" && (min.valueType !== "number" || max.valueType !== "number")) {
                                parser.error("error", "Nombre attendu.");
                            }
                            if (fieldType === "date" && (min.valueType !== "date" || max.valueType !== "date")) {
                                parser.error("error", "Date attendue (YYYY-MM-DD).");
                            }
                            if (fieldType === "dateTime" && (min.valueType !== "dateTime" || max.valueType !== "dateTime")) {
                                parser.error("error", "Date/heure attendue (YYYY-MM-DDTHH:MM:SS).");
                            }
                            if (fieldType === "time" && (min.valueType !== "time" || max.valueType !== "time")) {
                                parser.error("error", "Heure attendue (HH:MM[:SS]).");
                            }
                            const exclusive = parser.matchWord("exclu");
                            const ast = { type: "between", field, min, max, exclusive };
                            parser.markGood(ast);
                            return ast;
                        }

                        // Operators (multi-word + symbols)
                        let op = null;
                        if (matchMultiWord(["n'est", "pas"]) || matchMultiWord(["nest", "pas"])) op = "!=";
                        else if (parser.matchWord("est")) op = "=";
                        else if (parser.matchWord("contient")) op = "contains";
                        else if (matchMultiWord(["commence", "par"])) op = "starts";
                        else if (matchMultiWord(["finit", "par"])) op = "ends";
                        else if (matchMultiWord(["superieur", "a"]) || matchMultiWord(["sup√©rieur", "√†"])) op = ">=";
                        else if (matchMultiWord(["inferieur", "a"]) || matchMultiWord(["inf√©rieur", "√†"])) op = "<=";
                        else if (parser.matchWord("avant")) op = "before";
                        else if (parser.matchWord("apres") || parser.matchWord("apr√®s")) op = "after";

                        if (!op) {
                            if (parser.eof()) parser.error("partial", "Op√©rateur attendu.");
                            parser.error("error", "Op√©rateur attendu.");
                        }

                        if (!isOperatorCompatibleWithField(field, op)) {
                            parser.error("error", "Op√©rateur incompatible avec le type de la colonne.");
                        }

                        const parseValueForOp = () => {
                            if (op === "=" || op === "!=") return parseEqualsValue(field);
                            if (op === "contains" || op === "starts" || op === "ends") return parseTextOpValue();
                            const fieldType = getFieldDataType(field);
                            const v =
                                (op === "before" || op === "after") && (fieldType === "date" || fieldType === "dateTime")
                                    ? parseDateLikeValue(fieldType, { boundary: "start" })
                                    : parseSingleTokenValue();
                            if ((op === "before" || op === "after") && !["date", "dateTime", "time"].includes(fieldType)) {
                                parser.error("error", "Op√©rateur incompatible avec le type de la colonne.");
                            }
                            if ((op === "before" || op === "after") && fieldType === "date" && v.valueType !== "date") {
                                parser.error("error", "Date attendue (YYYY-MM-DD).");
                            }
                            if ((op === "before" || op === "after") && fieldType === "dateTime" && v.valueType !== "dateTime") {
                                parser.error("error", "Date/heure attendue (YYYY-MM-DDTHH:MM:SS).");
                            }
                            if ((op === "before" || op === "after") && fieldType === "time" && v.valueType !== "time") {
                                parser.error("error", "Heure attendue (HH:MM[:SS]).");
                            }
                            if (["<=", ">="].includes(op) && fieldType === "number" && v.valueType !== "number") {
                                parser.error("error", "Nombre attendu.");
                            }
                            return v;
                        };

                        const firstValue = parseValueForOp();
                        const exclusive = (op === ">=" || op === "<=") ? parser.matchWord("exclu") : false;
                        const baseAst = { type: "cond", field, op, value: firstValue, exclusive };

                        // Allow "ou" ONLY as additional values for the current condition.
                        // If the user typed "ou" but hasn't provided the next value yet, the condition is considered incomplete
                        // (so we deliberately do NOT mark baseAst as "good" in that case).
                        if (parser.peek()?.type === "word" && parser.peek()?.norm === "ou") {
                            let ast = baseAst;
                            while (parser.peek()?.type === "word" && parser.peek()?.norm === "ou") {
                                parser.consume(); // consume "ou"
                                if (parser.eof()) {
                                    parser.error("partial", "Valeur attendue apr√®s 'ou'.");
                                }
                                if (looksLikeNewConditionFromPos(parser.pos)) {
                                    parser.error("error", "Utilisez ', ou' pour faire un OU entre deux conditions.");
                                }
                                const nextValue = parseValueForOp();
                                ast = { type: "or", left: ast, right: { type: "cond", field, op, value: nextValue } };
                                parser.markGood(ast);
                            }
                            return ast;
                        }

                        parser.markGood(baseAst);
                        return baseAst;
                    };

                    const parseAtom = () => {
                        const t = parser.peek();
                        if (t && t.type === "unknown" && (t.value === "(" || t.value === ")")) {
                            parser.error("error", "Parenth√®ses non support√©es.");
                        }
                        return parseCondition();
                    };

                    const parseNot = () => {
                        if (parser.matchWord("non") || parser.matchWord("sauf")) {
                            if (parser.eof()) parser.error("partial", "Expression attendue apr√®s n√©gation.");
                            const expr = parseNot();
                            const ast = { type: "not", expr };
                            parser.markGood(ast);
                            return ast;
                        }
                        return parseAtom();
                    };

                    const parseSequence = () => {
                        let left = parseNot();
                        while (true) {
                            let connector = null;
                            if (parser.matchComma()) {
                                // ", ou" means OR between conditions; plain "," is AND.
                                if (parser.matchWord("ou")) connector = "or";
                                else connector = "and";
                            } else if (parser.peek()?.type === "word" && parser.peek()?.norm === "ou") {
                                // "ou" cannot start a new condition; it is reserved for additional values in a condition.
                                parser.error("error", "Utilisez ', ou' pour faire un OU entre deux conditions.");
                            } else {
                                break;
                            }

                            if (parser.eof()) {
                                parser.markGood(left);
                                parser.error("partial", "Condition attendue apr√®s le connecteur.");
                            }
                            const right = parseNot();
                            left = { type: connector, left, right };
                            parser.markGood(left);
                        }
                        return left;
                    };

                    try {
                        if (!tokens.length) {
                            return { status: "partial", ast: null, error: "" };
                        }
                        const ast = parseSequence();
                        parser.markGood(ast);
                        if (!parser.eof()) {
                            // Remaining tokens => error (e.g., garbage at end)
                            parser.error("error", "Syntaxe invalide.");
                        }
                        return { status: "ok", ast, error: "" };
                    } catch (err) {
                        const kind = err?.kind || "error";
                        if (kind === "partial") {
                            return {
                                status: "partial",
                                ast: parser.lastGoodAst,
                                error: err?.message || ""
                            };
                        }
                        // On hard error: still return the last valid AST so the grid can ignore the invalid tail.
                        return {
                            status: "error",
                            ast: parser.lastGoodAst,
                            error: err?.message || "Erreur de syntaxe."
                        };
                    }
                }

                function coerceComparable(value, valueNode) {
                    const raw = valueNode?.raw;
                    if (valueNode?.valueType === "number") {
                        const n = parseFloat(String(raw));
                        return Number.isFinite(n) ? n : null;
                    }
                    if (valueNode?.valueType === "date" || valueNode?.valueType === "dateTime" || valueNode?.valueType === "time") {
                        return typeof raw === "string" ? raw : null;
                    }
                    // identifier / string -> string
                    return raw == null ? "" : String(raw);
                }

                function evaluateAST(ast, row) {
                    if (!ast) return true;
                    const node = ast;
                    switch (node.type) {
                        case "and":
                            return evaluateAST(node.left, row) && evaluateAST(node.right, row);
                        case "or":
                            return evaluateAST(node.left, row) || evaluateAST(node.right, row);
                        case "not":
                            return !evaluateAST(node.expr, row);
                        case "empty": {
                            const rawValue = row ? row[node.field] : undefined;
                            const empty = isEmptyValue(rawValue);
                            return node.negated ? !empty : empty;
                        }
                        case "between": {
                            const rawValue = row ? row[node.field] : undefined;
                            if (isEmptyValue(rawValue)) return false;
                            const { display } = getForeignKeyFilterValues(node.field, rawValue);
                            const v = display;
                            const min = coerceComparable(v, node.min);
                            const max = coerceComparable(v, node.max);
                            const exclusive = node.exclusive === true;
                            if (typeof min === "number" && typeof max === "number") {
                                const n = parseFloat(String(v));
                                if (!Number.isFinite(n)) return false;
                                return exclusive ? (n > min && n < max) : (n >= min && n <= max);
                            }
                            const raw = String(v == null ? "" : v);
                            if (isIsoDate(raw) || isIsoDateTime(raw) || isIsoTime(raw)) {
                                return exclusive
                                    ? (raw > String(min) && raw < String(max))
                                    : (raw >= String(min) && raw <= String(max));
                            }
                            const s = normalizeForCompare(raw);
                            return exclusive
                                ? (s > normalizeForCompare(String(min)) && s < normalizeForCompare(String(max)))
                                : (s >= normalizeForCompare(String(min)) && s <= normalizeForCompare(String(max)));
                        }
                        case "cond": {
                            const rawValue = row ? row[node.field] : undefined;
                            const { display } = getForeignKeyFilterValues(node.field, rawValue);
                            const v = display;
                            if (node.op === "contains" || node.op === "starts" || node.op === "ends") {
                                const left = normalizeForCompare(v == null ? "" : String(v));
                                const right = normalizeForCompare(String(coerceComparable(v, node.value)));
                                if (!right) return true;
                                if (node.op === "contains") return left.includes(right);
                                if (node.op === "starts") return left.startsWith(right);
                                if (node.op === "ends") return left.endsWith(right);
                                return true;
                            }

                            const exclusive = node.exclusive === true;
                            let op = node.op === "before" ? "<" : node.op === "after" ? ">" : node.op;
                            if (exclusive && op === ">=") op = ">";
                            if (exclusive && op === "<=") op = "<";

                            // Equality/inequality and comparisons: try number/date first, fallback to string.
                            const cmpRight = coerceComparable(v, node.value);
                            const rawLeft = v == null ? null : v;
                            const leftString = rawLeft == null ? "" : String(rawLeft);

                            const bothNumeric =
                                (typeof cmpRight === "number") ||
                                (typeof rawLeft === "number") ||
                                (/^[0-9]+(?:\.[0-9]+)?$/.test(leftString) && typeof cmpRight === "string" && /^[0-9]+(?:\.[0-9]+)?$/.test(cmpRight));
                            if (bothNumeric && ["=", "!=", ">", ">=", "<", "<="].includes(op)) {
                                const ln = parseFloat(leftString);
                                const rn = typeof cmpRight === "number" ? cmpRight : parseFloat(String(cmpRight));
                                if (!Number.isFinite(ln) || !Number.isFinite(rn)) return false;
                                if (op === "=") return ln === rn;
                                if (op === "!=") return ln !== rn;
                                if (op === ">") return ln > rn;
                                if (op === ">=") return ln >= rn;
                                if (op === "<") return ln < rn;
                                if (op === "<=") return ln <= rn;
                            }

                            const isDateLike = isIsoDate(leftString) || isIsoDateTime(leftString) || isIsoTime(leftString);
                            if (isDateLike && ["=", "!=", ">", ">=", "<", "<="].includes(op)) {
                                const r = String(cmpRight || "");
                                if (!(isIsoDate(r) || isIsoDateTime(r) || isIsoTime(r))) return false;
                                if (op === "=") return leftString === r;
                                if (op === "!=") return leftString !== r;
                                if (op === ">") return leftString > r;
                                if (op === ">=") return leftString >= r;
                                if (op === "<") return leftString < r;
                                if (op === "<=") return leftString <= r;
                            }

                            // Boolean-ish identifiers
                            const leftNorm = normalizeForCompare(leftString);
                            const rightNorm = normalizeForCompare(String(cmpRight || ""));
                            const boolMap = new Map([
                                ["true", true],
                                ["vrai", true],
                                ["1", true],
                                ["false", false],
                                ["faux", false],
                                ["0", false]
                            ]);
                            if (boolMap.has(leftNorm) || boolMap.has(rightNorm)) {
                                const lb = boolMap.get(leftNorm);
                                const rb = boolMap.get(rightNorm);
                                if (lb == null || rb == null) return false;
                                if (op === "=") return lb === rb;
                                if (op === "!=") return lb !== rb;
                            }

                            if (op === "=") return leftNorm === rightNorm;
                            if (op === "!=") return leftNorm !== rightNorm;
                            if (op === ">") return leftNorm > rightNorm;
                            if (op === ">=") return leftNorm >= rightNorm;
                            if (op === "<") return leftNorm < rightNorm;
                            if (op === "<=") return leftNorm <= rightNorm;
                            return true;
                        }
                        default:
                            return true;
                    }
                }

                function setNaturalFilterUiStatus(status, displayedRowCount, hint) {
                    if (!gridNaturalFilter) return;
                    gridNaturalFilter.dataset.status = status || "partial";
                }

                let naturalFilterDebounceTimer = null;
                function scheduleNaturalFilterApply(options = {}) {
                    const delayMs = typeof options.delayMs === "number" ? options.delayMs : 200;
                    if (naturalFilterDebounceTimer) clearTimeout(naturalFilterDebounceTimer);
                    naturalFilterDebounceTimer = setTimeout(() => {
                        naturalFilterDebounceTimer = null;
                        applyNaturalFilterNow();
                    }, Math.max(150, Math.min(250, delayMs)));
                }

                function applyNaturalFilterNow() {
                    if (!gridApi) return;
                    if (!gridNaturalFilterInput) return;
                    const knownFieldMap = getKnownFieldMap();
                    const raw = gridNaturalFilterInput.value || "";
                    const result = parseNaturalFilter(raw, knownFieldMap);

                    naturalFilterState.input = raw;
                    naturalFilterState.status = result.status;
                    naturalFilterState.error = result.error || "";

                    if (result.status === "error") {
                        // Apply only the last valid part of the expression (ignore the invalid / incomplete tail).
                        naturalFilterState.ast = result.ast || null;
                        naturalFilterState.lastGoodAst = naturalFilterState.ast;
                        naturalFilterState.active = Boolean(naturalFilterState.ast);
                        try { gridApi.onFilterChanged?.(); } catch (err) { /* ignore */ }
                        const displayed = typeof gridApi.getDisplayedRowCount === "function" ? gridApi.getDisplayedRowCount() : null;
                        naturalFilterState.lastDisplayedRowCount = displayed;
                        setNaturalFilterUiStatus("error", displayed);
                        return;
                    }

                    // For ok/partial: apply the last complete expression available from this input.
                    naturalFilterState.ast = result.ast || null;
                    naturalFilterState.lastGoodAst = naturalFilterState.ast;

                    naturalFilterState.active = Boolean(naturalFilterState.ast);
                    try { gridApi.onFilterChanged?.(); } catch (err) { /* ignore */ }
                    setTimeout(() => {
                        const displayed = typeof gridApi.getDisplayedRowCount === "function" ? gridApi.getDisplayedRowCount() : null;
                        naturalFilterState.lastDisplayedRowCount = displayed;
                        if (result.status === "ok" && displayed != null && displayed > 0) {
                            setNaturalFilterUiStatus("ok", displayed);
                        } else {
                            setNaturalFilterUiStatus("partial", displayed);
                        }
                    }, 120);
                }

                function scheduleNaturalFilterRecalc() {
                    // Called when data/columns switch tabs or update; re-apply current input.
                    if (!gridNaturalFilterInput) return;
                    scheduleNaturalFilterApply({ delayMs: 180 });
                }

                function getTokenBounds(text, cursorPos) {
                    const src = String(text || "");
                    const pos = Math.max(0, Math.min(cursorPos || 0, src.length));
                    const isBoundary = ch => /\s/.test(ch) || ch === "(" || ch === ")";
                    let start = pos;
                    while (start > 0 && !isBoundary(src[start - 1])) start -= 1;
                    let end = pos;
                    while (end < src.length && !isBoundary(src[end])) end += 1;
                    return { start, end };
                }

                function insertAtCaret(inputEl, insertText, bounds) {
                    if (!inputEl) return;
                    const value = inputEl.value || "";
                    const start = bounds?.start ?? inputEl.selectionStart ?? value.length;
                    const end = bounds?.end ?? inputEl.selectionEnd ?? value.length;
                    let before = value.slice(0, start);
                    const after = value.slice(end);
                    let insert = String(insertText || "");
                    if (!insert) return;

                    const isCommaLike = insert.startsWith(",");
                    if (isCommaLike) {
                        before = before.replace(/\s+$/, "");
                    }

                    const beforeChar = before.slice(-1);
                    const afterChar = after.slice(0, 1);
                    const needsLeadingSpace =
                        !isCommaLike &&
                        before.length > 0 &&
                        !/\s|\(/.test(beforeChar) &&
                        insert !== ")" &&
                        !insert.startsWith(")");
                    const needsTrailingSpace =
                        isCommaLike ||
                        after.length > 0 &&
                        !/^\s|\)/.test(afterChar) &&
                        insert !== "(" &&
                        !insert.endsWith("(");

                    if (needsLeadingSpace) insert = " " + insert;
                    if (needsTrailingSpace) {
                        if (isCommaLike) {
                            if (!/^\s/.test(afterChar)) insert = insert + " ";
                        } else {
                            insert = insert + " ";
                        }
                    }

                    const nextValue = before + insert + after;
                    inputEl.value = nextValue;
                    const nextPos = (before + insert).length;
                    inputEl.setSelectionRange(nextPos, nextPos);
                    inputEl.dispatchEvent(new Event("input", { bubbles: true }));
                }

                function escapeRegex(str) {
                    return String(str || "").replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
                }

                function buildCaretMirrorElement(inputEl) {
                    const style = window.getComputedStyle(inputEl);
                    const div = document.createElement("div");
                    div.style.position = "fixed";
                    div.style.left = "-9999px";
                    div.style.top = "0";
                    div.style.visibility = "hidden";
                    div.style.whiteSpace = "pre";
                    div.style.fontFamily = style.fontFamily;
                    div.style.fontSize = style.fontSize;
                    div.style.fontWeight = style.fontWeight;
                    div.style.letterSpacing = style.letterSpacing;
                    div.style.padding = style.padding;
                    div.style.border = style.border;
                    div.style.boxSizing = style.boxSizing;
                    div.style.width = style.width;
                    div.style.lineHeight = style.lineHeight;
                    return div;
                }

                function getCaretClientPosition(inputEl, caretPos) {
                    if (!inputEl) return null;
                    const value = inputEl.value || "";
                    const pos = Math.max(0, Math.min(caretPos ?? inputEl.selectionStart ?? value.length, value.length));
                    const mirror = buildCaretMirrorElement(inputEl);
                    const before = value.slice(0, pos);
                    const after = value.slice(pos);
                    const marker = document.createElement("span");
                    marker.textContent = "\u200b";
                    mirror.textContent = "";
                    mirror.append(document.createTextNode(before), marker, document.createTextNode(after));
                    document.body.appendChild(mirror);
                    const rect = marker.getBoundingClientRect();
                    const mirrorRect = mirror.getBoundingClientRect();
                    mirror.remove();
                    const inputRect = inputEl.getBoundingClientRect();
                    return {
                        left: inputRect.left + (rect.left - mirrorRect.left),
                        top: inputRect.top + (rect.top - mirrorRect.top),
                        height: rect.height || parseFloat(window.getComputedStyle(inputEl).lineHeight) || 16
                    };
                }

                function showGhostCompletion(text) {
                    if (!gridNaturalFilterGhost) return;
                    const content = String(text || "");
                    if (!content) {
                        gridNaturalFilterGhost.style.display = "none";
                        gridNaturalFilterGhost.textContent = "";
                        return;
                    }
                    if (!gridNaturalFilterInput) return;
                    const caretPos = gridNaturalFilterInput.selectionStart ?? (gridNaturalFilterInput.value || "").length;
                    const caret = getCaretClientPosition(gridNaturalFilterInput, caretPos);
                    if (!caret) return;
                    const wrapperRect = gridNaturalFilter.getBoundingClientRect();
                    gridNaturalFilterGhost.textContent = content;
                    gridNaturalFilterGhost.style.display = "block";
                    gridNaturalFilterGhost.style.left = `${Math.max(8, caret.left - wrapperRect.left)}px`;
                    gridNaturalFilterGhost.style.top = `${Math.max(2, caret.top - wrapperRect.top)}px`;
                }

                function getDistinctValuesForField(field, limit = 20) {
                    const page = getActivePage();
                    const rows = Array.isArray(page?.data?.rowData) ? page.data.rowData : [];
                    const freq = new Map();
                    const order = [];
                    for (const row of rows) {
                        if (!row || typeof row !== "object") continue;
                        const tableId = page?.tableId || "";
                        const rawValue = field && field.startsWith("__relCount__")
                            ? buildExternalFilterRow(row, tableId)?.[field]
                            : row[field];
                        if (rawValue == null) continue;
                        const { display } = getForeignKeyFilterValues(field, rawValue);
                        const valueToUse = display == null ? rawValue : display;
                        const key = typeof valueToUse === "string" ? valueToUse.trim() : valueToUse;
                        if (key === "") continue;
                        const str = typeof key === "string" ? key : String(key);
                        if (!freq.has(str)) order.push(str);
                        freq.set(str, (freq.get(str) || 0) + 1);
                    }
                    order.sort((a, b) => (freq.get(b) || 0) - (freq.get(a) || 0));
                    return order.slice(0, Math.max(0, limit));
                }

                function buildNaturalSuggestions(text, cursorPos, options = {}) {
                    const forced = Boolean(options.forced);
                    const knownFieldMap = getKnownFieldMap();
                    const knownFields = Array.from(knownFieldMap.values());
                    const bounds = getTokenBounds(text, cursorPos);
                    const currentToken = (text || "").slice(bounds.start, cursorPos).trim();
                    let currentNorm = normalizeForCompare(currentToken);

                    const beforeText = (text || "").slice(0, cursorPos);
                    const tokens = tokenizeFrenchFilter(beforeText);
                    const words = tokens.map(t => ({
                        ...t,
                        norm: t.type === "word" ? normalizeForCompare(t.value) : t.value
                    }));

                    const operatorTailWords = new Set([
                        "est",
                        "contient",
                        "commence",
                        "finit",
                        "par",
                        "n'est",
                        "nest",
                        "pas",
                        "superieur",
                        "sup√©rieur",
                        "inferieur",
                        "inf√©rieur",
                        "a",
                        "√†",
                        "avant",
                        "apres",
                        "apr√®s",
                        "entre",
                        "exclu",
                        "vide"
                    ]);

                    // Connectors between conditions:
                    // - "," (AND) or ", ou" (OR)
                    // - "et" (AND)
                    // Note: "ou" alone is reserved for additional values inside a condition.
                    const isConnector = t =>
                        (t?.type === "comma");

                    // Consider the current segment since last connector/paren boundary.
                    let segStart = 0;
                    for (let i = words.length - 1; i >= 0; i -= 1) {
                        const t = words[i];
                        if (isConnector(t)) { segStart = i + 1; break; }
                    }
                    let segment = words.slice(segStart);
                    // Special connector: ", ou" means OR between conditions.
                    // When we are right after the comma, the segment can start with "ou" - ignore it for field/operator detection.
                    if (
                        segment.length &&
                        segment[0]?.type === "word" &&
                        segment[0]?.norm === "ou" &&
                        segStart > 0 &&
                        words[segStart - 1]?.type === "comma"
                    ) {
                        segment = segment.slice(1);
                    }

                    const prevChar = cursorPos > 0 ? String(text || "")[cursorPos - 1] : "";
                    const prevCharIsSpace = /\s/.test(prevChar);

                    // Detect whether an operator is present in this segment.
                    let operatorIndex = -1;
                    for (let i = 0; i < segment.length; i += 1) {
                        const t = segment[i];
                        if (!t) continue;
                        if (t.type === "op") { operatorIndex = i; break; }
                        if (t.type === "word" && operatorTailWords.has(t.norm)) { operatorIndex = i; break; }
                    }

                    const fieldTokenWords = operatorIndex === -1
                        ? segment.filter(t => t.type === "word").map(t => t.value)
                        : segment.slice(0, operatorIndex).filter(t => t.type === "word").map(t => t.value);
                    const fieldToken = fieldTokenWords.join(" ").trim();
                    let lastField = fieldToken ? resolveFieldToken(fieldToken, knownFieldMap) : null;

                    // If the segment is words-only and we can't resolve the whole thing as a field,
                    // try resolving the longest prefix as a field. This lets us keep suggesting verbs
                    // while the user is typing the verb right after a valid field name.
                    if (!lastField && operatorIndex === -1 && segment.length && segment.every(t => t.type === "word")) {
                        let best = null;
                        let bestLen = 0;
                        for (let len = segment.length; len >= 1; len -= 1) {
                            const candidate = segment.slice(0, len).map(t => t.value).join(" ").trim();
                            const resolved = resolveFieldToken(candidate, knownFieldMap);
                            if (resolved) {
                                best = resolved;
                                bestLen = len;
                                break;
                            }
                        }
                        if (best && bestLen < segment.length) {
                            lastField = best;
                            operatorIndex = bestLen;
                        }
                    }

                    const inferOperatorText = () => {
                        if (operatorIndex === -1) return null;
                        const t = segment[operatorIndex];
                        if (!t) return null;
                        if (t.type === "op") return t.value;
                        const w0 = t.type === "word" ? t.norm : "";
                        const w1 = segment[operatorIndex + 1]?.type === "word" ? segment[operatorIndex + 1].norm : "";
                        const w2 = segment[operatorIndex + 2]?.type === "word" ? segment[operatorIndex + 2].norm : "";

                        if (w0 === "n'est" && w1 === "pas") return "n'est pas";
                        if (w0 === "nest" && w1 === "pas") return "n'est pas";
                        if (w0 === "commence" && w1 === "par") return "commence par";
                        if (w0 === "finit" && w1 === "par") return "finit par";
                        if (w0 === "sup√©rieur" && w1 === "√†") return "sup√©rieur √†";
                        if (w0 === "superieur" && w1 === "a") return "sup√©rieur √†";
                        if (w0 === "inf√©rieur" && w1 === "√†") return "inf√©rieur √†";
                        if (w0 === "inferieur" && w1 === "a") return "inf√©rieur √†";
                        if (w0 === "est" && w1 === "vide") return "est vide";
                        if (w0 === "n'est" && w1 === "pas" && w2 === "vide") return "n'est pas vide";
                        if (w0 === "nest" && w1 === "pas" && w2 === "vide") return "n'est pas vide";
                        if (w0 === "est") return "est";
                        if (w0 === "contient") return "contient";
                        if (w0 === "avant") return "avant";
                        if (w0 === "apres" || w0 === "apr√®s") return "apr√®s";
                        if (w0 === "entre") return "entre";
                        return null;
                    };

                    const inferredOperator = inferOperatorText();
                    const valueQuoteMode =
                        inferredOperator === "contient" ||
                            inferredOperator === "commence par" ||
                            inferredOperator === "finit par"
                            ? "quoteIfSpace"
                            : "none";

                    const last = words[words.length - 1] || null;
                    const prev = words.length > 1 ? words[words.length - 2] : null;

                    const isStartOfAtom =
                        !words.length ||
                        (last?.type === "comma") ||
                        (last?.type === "word" && (last.norm === "non" || last.norm === "sauf")) ||
                        (last?.type === "word" && last.norm === "ou" && prev?.type === "comma");

                    const verbTypingMode =
                        Boolean(lastField) &&
                        operatorIndex !== -1 &&
                        !inferredOperator;

                    // Field exists, and user ended it with a space => propose verbs without typing.
                    // Also: if the user is actively typing a verb, keep suggesting verbs (do not jump to values).
                    const EXPECT_VERB =
                        verbTypingMode ||
                        (!isStartOfAtom && operatorIndex === -1 && fieldTokenWords.length > 0 && prevCharIsSpace);
                    const EXPECT_FIELD = (isStartOfAtom || operatorIndex === -1) && !EXPECT_VERB;

                    const afterOp = operatorIndex === -1 ? [] : segment.slice(operatorIndex + 1);
                    const valuePresent = afterOp.some(t => {
                        if (!t) return false;
                        if (t.type === "string") return true;
                        if (t.type !== "word") return false;
                        if (operatorTailWords.has(t.norm)) return false;
                        if (t.norm === "et" || t.norm === "ou" || t.norm === "non" || t.norm === "sauf") return false;
                        return true;
                    });
                    const valueComplete = valuePresent && prevCharIsSpace;
                    const hasExclu =
                        afterOp.some(t => t?.type === "word" && t.norm === "exclu") ||
                        (last?.type === "word" && last.norm === "exclu");

                    const betweenState = (() => {
                        if (inferredOperator !== "entre" || operatorIndex === -1 || !lastField) {
                            return { hasMin: false, hasEt: false, hasMax: false, complete: false };
                        }
                        let hasMin = false;
                        let hasEt = false;
                        let hasMax = false;
                        for (const t of afterOp) {
                            if (!t) continue;
                            if (t.type === "word" && t.norm === "exclu") continue;
                            if (!hasMin) {
                                if (t.type === "string") {
                                    hasMin = true;
                                    continue;
                                }
                                if (t.type === "word" && !operatorTailWords.has(t.norm) && !["ou", "et", "non", "sauf"].includes(t.norm)) {
                                    hasMin = true;
                                }
                                continue;
                            }
                            if (!hasEt) {
                                if (t.type === "word" && t.norm === "et") {
                                    hasEt = true;
                                }
                                continue;
                            }
                            if (!hasMax) {
                                if (t.type === "string") {
                                    hasMax = true;
                                    continue;
                                }
                                if (t.type === "word" && !operatorTailWords.has(t.norm) && !["ou", "et", "non", "sauf"].includes(t.norm)) {
                                    hasMax = true;
                                }
                                continue;
                            }
                        }
                        return { hasMin, hasEt, hasMax, complete: hasMin && hasEt && hasMax };
                    })();
                    const unaryEmptyComplete =
                        afterOp.some(t => t?.type === "word" && t.norm === "vide") &&
                        prevCharIsSpace;

                    const endsWithValueOu =
                        last?.type === "word" &&
                        last.norm === "ou" &&
                        prev?.type !== "comma";

                    const inValueOuMode =
                        endsWithValueOu &&
                        operatorIndex !== -1 &&
                        Boolean(lastField) &&
                        prevCharIsSpace &&
                        inferredOperator !== "entre" &&
                        inferredOperator !== "est vide" &&
                        inferredOperator !== "n'est pas vide";

                    const needsBetweenEt =
                        inferredOperator === "entre" &&
                        Boolean(lastField) &&
                        betweenState.hasMin &&
                        !betweenState.hasEt &&
                        prevCharIsSpace;

                    // Operator present but user hasn't typed a value yet (or ended operator with space).
                    const EXPECT_VALUE =
                        !verbTypingMode &&
                        (
                            (
                                inferredOperator &&
                                operatorIndex !== -1 &&
                                Boolean(lastField) &&
                                (
                                    inferredOperator === "entre"
                                        ? (!betweenState.complete && !needsBetweenEt)
                                        : !valueComplete
                                ) &&
                                !unaryEmptyComplete &&
                                (prevCharIsSpace || currentToken.length > 0 || forced)
                            ) ||
                            inValueOuMode
                        );

                    // After a value/expression: connectors/parentheses only.
                    const EXPECT_CONNECTOR =
                        !inValueOuMode &&
                        operatorIndex !== -1 &&
                        Boolean(lastField) &&
                        prevCharIsSpace &&
                        (
                            inferredOperator === "entre"
                                ? betweenState.complete
                                : (valuePresent || unaryEmptyComplete)
                        );

                    const normalizeDataType = (rawType) => {
                        const t = typeof rawType === "string" ? rawType.trim().toLowerCase() : "";
                        if (!t) return "text";
                        if (t === "string" || t === "text") return "text";
                        if (t === "number" || t === "numeric" || t === "int" || t === "float") return "number";
                        if (t === "boolean" || t === "bool") return "boolean";
                        if (t === "date") return "date";
                        if (t === "datetime") return "dateTime";
                        if (t === "time") return "time";
                        return "text";
                    };

                    const lastFieldType = lastField ? normalizeDataType(knownFieldMap.get(lastField)?.dataType) : null;
                    const operatorSuggestions = [
                        { insertText: "est", label: "est", meta: "=", kind: "op" },
                        { insertText: "n'est pas", label: "n'est pas", meta: "!=", kind: "op" },
                        { insertText: "contient", label: "contient", meta: "texte", kind: "op" },
                        { insertText: "commence par", label: "commence par", meta: "texte", kind: "op" },
                        { insertText: "finit par", label: "finit par", meta: "texte", kind: "op" },
                        { insertText: "sup√©rieur √†", label: "sup√©rieur √†", meta: "‚â•", kind: "op" },
                        { insertText: "inf√©rieur √†", label: "inf√©rieur √†", meta: "‚â§", kind: "op" },
                        { insertText: "avant", label: "avant", meta: "< date/time", kind: "op" },
                        { insertText: "apr√®s", label: "apr√®s", meta: "> date/time", kind: "op" },
                        { insertText: "entre", label: "entre", meta: "intervalle", kind: "op" },
                        { insertText: "est vide", label: "est vide", meta: "unary", kind: "op" },
                        { insertText: "n'est pas vide", label: "n'est pas vide", meta: "unary", kind: "op" }
                    ];
                    const keywordSuggestions = [
                        { insertText: ",", label: ",", meta: "ET", kind: "kw" },
                        { insertText: ", ou", label: ", ou", meta: "OU", kind: "kw" }
                    ];
                    const valueOrSuggestion = { insertText: "ou", label: "ou", meta: "valeur", kind: "kw" };
                    const betweenEtSuggestion = { insertText: "et", label: "et", meta: "entre", kind: "kw" };
                    const excluSuggestion = { insertText: "exclu", label: "exclu", meta: "bornes", kind: "kw" };

                    const filterOperatorSuggestionsByType = (items, fieldType) => {
                        if (!fieldType) return items;
                        const allow = new Set(["est", "n'est pas", "est vide", "n'est pas vide"]);
                        if (fieldType === "text") {
                            ["contient", "commence par", "finit par"].forEach(v => allow.add(v));
                        } else if (fieldType === "number") {
                            ["sup√©rieur √†", "inf√©rieur √†", "entre"].forEach(v => allow.add(v));
                        } else if (fieldType === "date" || fieldType === "dateTime" || fieldType === "time") {
                            ["avant", "apr√®s", "entre"].forEach(v => allow.add(v));
                        } else if (fieldType === "boolean") {
                            // Keep equality only.
                        }
                        return items.filter(it => allow.has(it.insertText));
                    };

                    const suggestions = [];
                    if (EXPECT_FIELD) {
                        // Only columns.
                        knownFields.forEach(fieldInfo => {
                            suggestions.push({
                                insertText: fieldInfo.headerName || fieldInfo.field,
                                label: fieldInfo.headerName || fieldInfo.field,
                                meta: fieldInfo.field,
                                kind: "field"
                            });
                        });
                    } else if (EXPECT_VERB) {
                        // Only logical verbs/operators.
                        filterOperatorSuggestionsByType(operatorSuggestions, lastFieldType)
                            .forEach(s => suggestions.push({ ...s, meta: "verbe" }));
                    } else if (needsBetweenEt) {
                        suggestions.push({ ...betweenEtSuggestion, meta: "entre" });
                    } else if (EXPECT_VALUE && lastField) {
                        // Only values for that field.
                        if (currentToken === "\"" || currentToken === "'" || currentToken === "‚Äú") {
                            currentNorm = "";
                        } else if (/^["'‚Äú]/.test(currentToken)) {
                            currentNorm = normalizeForCompare(currentToken.replace(/^["'‚Äú]+/, ""));
                        }
                        if (lastFieldType === "date" || lastFieldType === "dateTime") {
                            [
                                { insertText: "aujourd'hui", label: "aujourd'hui", meta: "date" },
                                { insertText: "hier", label: "hier", meta: "date" },
                                { insertText: "demain", label: "demain", meta: "date" },
                                { insertText: "cette semaine", label: "cette semaine", meta: "date" },
                                { insertText: "la semaine derni√®re", label: "la semaine derni√®re", meta: "date" },
                                { insertText: "la semaine prochaine", label: "la semaine prochaine", meta: "date" },
                                { insertText: "ce mois", label: "ce mois", meta: "date" },
                                { insertText: "le mois dernier", label: "le mois dernier", meta: "date" },
                                { insertText: "le mois prochain", label: "le mois prochain", meta: "date" },
                                { insertText: "dans 7 jours", label: "dans 7 jours", meta: "relatif" },
                                { insertText: "il y a 7 jours", label: "il y a 7 jours", meta: "relatif" },
                                { insertText: "dans 2 semaines", label: "dans 2 semaines", meta: "relatif" },
                                { insertText: "il y a 2 semaines", label: "il y a 2 semaines", meta: "relatif" },
                                { insertText: "dans 1 mois", label: "dans 1 mois", meta: "relatif" },
                                { insertText: "il y a 1 mois", label: "il y a 1 mois", meta: "relatif" }
                            ].forEach(s => suggestions.push({ ...s, kind: "value" }));
                        }
                        getDistinctValuesForField(lastField, 20).forEach(v => {
                            const isNumber = /^[0-9]+(?:\.[0-9]+)?$/.test(v);
                            const isDate = isIsoDate(v) || isIsoDateTime(v);
                            const insertText = isNumber || isDate ? v : v;
                            suggestions.push({ insertText, label: v, meta: "valeur", kind: "value" });
                        });
                    } else if (EXPECT_CONNECTOR) {
                        // After a complete condition: allow AND ("," / "et"), OR between conditions (", ou"),
                        // and value-OR ("ou") only to add another possible value for the same field.
                        if (
                            prevCharIsSpace &&
                            !hasExclu &&
                            (inferredOperator === "entre" || inferredOperator === "sup√©rieur √†" || inferredOperator === "inf√©rieur √†") &&
                            inferredOperator !== "est vide" &&
                            inferredOperator !== "n'est pas vide"
                        ) {
                            suggestions.push({ ...excluSuggestion, meta: "option" });
                        }
                        keywordSuggestions.forEach(s => suggestions.push({ ...s, meta: "logique" }));
                        if (inferredOperator && inferredOperator !== "entre" && inferredOperator !== "est vide" && inferredOperator !== "n'est pas vide") {
                            suggestions.push({ ...valueOrSuggestion, meta: "valeur" });
                        }
                    } else {
                        // Default: if we can't infer, propose connectors (safe) when forced, otherwise nothing.
                        if (forced) {
                            keywordSuggestions.forEach(s => suggestions.push({ ...s, meta: "logique" }));
                        }
                    }

                    const filtered = suggestions.filter(s => {
                        if (forced) return true;
                        if (!currentNorm && !prevCharIsSpace) return false;
                        return normalizeForCompare(s.label).includes(currentNorm) || normalizeForCompare(s.meta).includes(currentNorm);
                    });

                    return { items: filtered.slice(0, 24), bounds, context: { valueQuoteMode, inferredOperator, lastField, lastFieldType } };
                }

                const naturalSuggestionState = {
                    open: false,
                    forced: false,
                    activeIndex: 0,
                    items: [],
                    bounds: { start: 0, end: 0 },
                    context: { valueQuoteMode: "none", inferredOperator: null, lastField: null, lastFieldType: null }
                };

                function closeNaturalSuggestions() {
                    naturalSuggestionState.open = false;
                    naturalSuggestionState.forced = false;
                    naturalSuggestionState.activeIndex = 0;
                    naturalSuggestionState.items = [];
                    naturalSuggestionState.context = { valueQuoteMode: "none", inferredOperator: null, lastField: null, lastFieldType: null };
                    if (gridNaturalFilterSuggestions) {
                        gridNaturalFilterSuggestions.classList.remove("open");
                        gridNaturalFilterSuggestions.setAttribute("aria-hidden", "true");
                        gridNaturalFilterSuggestions.innerHTML = "";
                    }
                    showGhostCompletion("");
                }

                function renderNaturalSuggestions() {
                    if (!gridNaturalFilterSuggestions) return;
                    gridNaturalFilterSuggestions.innerHTML = "";
                    if (!naturalSuggestionState.items.length) {
                        closeNaturalSuggestions();
                        return;
                    }
                    naturalSuggestionState.open = true;
                    gridNaturalFilterSuggestions.classList.add("open");
                    gridNaturalFilterSuggestions.setAttribute("aria-hidden", "false");
                    naturalSuggestionState.items.forEach((s, idx) => {
                        const btn = document.createElement("button");
                        btn.type = "button";
                        btn.className = "grid-filter-suggestion" + (idx === naturalSuggestionState.activeIndex ? " active" : "");
                        btn.setAttribute("role", "option");
                        btn.dataset.index = String(idx);
                        const left = document.createElement("span");
                        left.className = "grid-filter-suggestion-title";
                        left.textContent = s.label;
                        const right = document.createElement("span");
                        right.className = "grid-filter-suggestion-meta";
                        right.textContent = s.meta || s.kind || "";
                        btn.append(left, right);
                        btn.addEventListener("mousedown", e => e.preventDefault());
                        btn.addEventListener("click", () => {
                            if (!gridNaturalFilterInput) return;
                            naturalSuggestionState.activeIndex = idx;
                            acceptActiveNaturalSuggestion({ appendSpace: true });
                            // Keep suggestions open to immediately propose the next token.
                            gridNaturalFilterInput.focus();
                        });
                        gridNaturalFilterSuggestions.appendChild(btn);
                    });

                    const active = naturalSuggestionState.items[naturalSuggestionState.activeIndex] || naturalSuggestionState.items[0];
                    const inputValue = gridNaturalFilterInput?.value || "";
                    const caretPos = gridNaturalFilterInput?.selectionStart ?? inputValue.length;
                    const token = inputValue.slice(naturalSuggestionState.bounds.start, caretPos);
                    let suggestionText = active?.insertText || "";
                    if (active?.kind === "value") {
                        const raw = String(active.label || "").trim();
                        const isNumericOrTemporal =
                            /^[0-9]+(?:\.[0-9]+)?$/.test(raw) ||
                            isIsoDate(raw) ||
                            isIsoDateTime(raw) ||
                            isIsoTime(raw);
                        const mode = naturalSuggestionState.context?.valueQuoteMode || "none";
                        const needsQuotes = !isNumericOrTemporal && mode === "quoteIfSpace" && /\s/.test(raw);
                        suggestionText = needsQuotes ? `"${raw.replace(/\"/g, "\\\"")}"` : raw;
                    }
                    let tail = suggestionText;
                    if (token) {
                        const normalizedToken = token.replace(/^["'‚Äú]+/, "");
                        if (suggestionText.toLowerCase().startsWith(token.toLowerCase())) {
                            tail = suggestionText.slice(token.length);
                        } else if (normalizedToken && suggestionText.toLowerCase().startsWith(("\"" + normalizedToken).toLowerCase())) {
                            tail = suggestionText.slice(normalizedToken.length);
                        } else if (normalizedToken && suggestionText.toLowerCase().startsWith(normalizedToken.toLowerCase())) {
                            tail = suggestionText.slice(normalizedToken.length);
                        }
                    }
                    showGhostCompletion(tail);
                }

                function updateNaturalSuggestions(options = {}) {
                    if (!gridNaturalFilterInput) return;
                    if (!document.activeElement || document.activeElement !== gridNaturalFilterInput) {
                        closeNaturalSuggestions();
                        return;
                    }
                    const value = gridNaturalFilterInput.value || "";
                    const cursorPos = gridNaturalFilterInput.selectionStart ?? value.length;
                    const forced = Boolean(options.forced);
                    const { items, bounds, context } = buildNaturalSuggestions(value, cursorPos, { forced });
                    const prevActive = naturalSuggestionState.items[naturalSuggestionState.activeIndex];
                    naturalSuggestionState.items = items;
                    naturalSuggestionState.bounds = bounds;
                    naturalSuggestionState.context = context || { valueQuoteMode: "none", inferredOperator: null, lastField: null, lastFieldType: null };
                    if (prevActive) {
                        const nextIndex = items.findIndex(it => it.insertText === prevActive.insertText);
                        naturalSuggestionState.activeIndex = nextIndex === -1 ? 0 : nextIndex;
                    } else {
                        naturalSuggestionState.activeIndex = 0;
                    }
                    naturalSuggestionState.forced = forced;
                    renderNaturalSuggestions();
                }

                function acceptActiveNaturalSuggestion(options = {}) {
                    if (!gridNaturalFilterInput) return;
                    const active = naturalSuggestionState.items[naturalSuggestionState.activeIndex];
                    if (!active) return;
                    const appendSpace = options.appendSpace === true;
                    let insertText = active.insertText;
                    if (active.kind === "value") {
                        const raw = String(active.label || "").trim();
                        const alreadyQuoted = /^".*"$/.test(insertText);
                        const isNumericOrTemporal =
                            /^[0-9]+(?:\.[0-9]+)?$/.test(raw) ||
                            isIsoDate(raw) ||
                            isIsoDateTime(raw) ||
                            isIsoTime(raw);
                        const mode = naturalSuggestionState.context?.valueQuoteMode || "none";
                        const needsQuotes = !isNumericOrTemporal && mode === "quoteIfSpace" && /\s/.test(raw);
                        if (needsQuotes && !alreadyQuoted) {
                            insertText = `"${raw.replace(/\"/g, "\\\"")}"`;
                        } else if (!alreadyQuoted) {
                            insertText = raw;
                        }
                    }
                    if (appendSpace) insertText = `${insertText} `;
                    insertAtCaret(gridNaturalFilterInput, insertText, naturalSuggestionState.bounds);
                    // Keep dropdown open and refresh suggestions for the next token (based on trailing space).
                    updateNaturalSuggestions({ forced: false });
                }

                function buildDatasetFromSingleTablePayload(payload, fallbackTableId, fallbackTitle) {
                    const tableId = (fallbackTableId || "").trim() || createTableId(1);
                    const title = (fallbackTitle || "").trim() || (payload?.title || "").trim() || tableId;
                    const primaryKey = DEFAULT_PRIMARY_KEY;
                    const columnDefs = Array.isArray(payload?.columnDefs) ? payload.columnDefs : [];
                    const rowData = Array.isArray(payload?.rowData) ? payload.rowData : [];
                    return {
                        schema: {
                            tables: [
                                {
                                    id: tableId,
                                    title,
                                    primaryKey,
                                    columns: [],
                                    relations: []
                                }
                            ]
                        },
                        data: {
                            [tableId]: { columnDefs, rowData }
                        }
                    };
                }

                function applyDatasetToState(dataset, options = {}) {
                    const normalizedSchema = normalizeDatasetSchema(dataset);
                    if (!normalizedSchema.tables.length) {
                        throw new Error("Dataset sans schema.tables");
                    }
                    const dataByTable = dataset?.data && typeof dataset.data === "object" ? dataset.data : {};
                    const previousActiveTableId = getActivePage()?.tableId || "";
                    resetRelationLookups();

                    const pages = normalizedSchema.tables.map((table, index) => {
                        const existing = state.pages.find(page => page?.tableId === table.id);
                        const tableData = dataByTable?.[table.id] || {};
                        const normalized = normalizePage(
                            {
                                id: existing?.id || `table-${table.id}`,
                                tableId: table.id,
                                title: table.title,
                                primaryKey: table.primaryKey || DEFAULT_PRIMARY_KEY,
                                relations: table.relations || [],
                                scenario: existing?.scenario || getActivePage()?.scenario || "",
                                data: {
                                    columnDefs: Array.isArray(tableData.columnDefs) ? tableData.columnDefs : [],
                                    rowData: Array.isArray(tableData.rowData) ? tableData.rowData : []
                                }
                            },
                            index
                        );
                        return normalized;
                    });

                    state.pages = pages;
                    state.schema = {
                        tables: normalizedSchema.tables.map(table => ({
                            id: table.id,
                            title: table.title,
                            primaryKey: table.primaryKey || DEFAULT_PRIMARY_KEY,
                            columns: Array.isArray(table.columns) ? table.columns : [],
                            relations: Array.isArray(table.relations) ? table.relations : []
                        }))
                    };

                    const requestedActiveTableId = options.activeTableId || previousActiveTableId;
                    const nextActiveIndex = Math.max(0, findPageIndexByTableId(requestedActiveTableId));
                    state.activeIndex = nextActiveIndex === -1 ? 0 : nextActiveIndex;

                    syncDatasetScriptFromState({ persist: false });
                    if (options.markAsAi) {
                        const tplState = getActiveTemplateState();
                        tplState.lastAiDatasetScript = state.datasetScript || tplState.datasetScript || "";
                        state.lastAiDatasetScript = tplState.lastAiDatasetScript;
                    }

                    renderTabs();
                    setActivePage(state.activeIndex);
                    persistState();
                }

                async function requestData() {
                    const tplState = syncTemplateStateFromUI();
                    const tplConfig = getActiveTemplateConfig();
                    const controller = new AbortController();
                    activeRequestController = controller;
                    setLoading(true);
                    showStatus("G√©n√©ration en cours‚Ä¶");
                    const page = getActivePage();
                    const scenarioText = (promptInput?.value || "").trim();
                    const scriptText = (gridScript?.value || tplState.datasetScript || state.datasetScript || "").trim();
                    const promptTemplate = tplState.promptTemplate || tplConfig.defaultPromptTemplate || DEFAULT_PROMPT_TEMPLATE;
                    const systemPrompt = tplState.systemPrompt || tplConfig.defaultSystemPrompt || DEFAULT_SYSTEM_PROMPT;
                    const userPrompt = promptTemplate.replace("{{scenario_prompt}}", scenarioText || "ton sujet");
                    const fileAttachments = isOpenAIBackendSelected() ? getUploadedFileAttachments() : [];

                    const messages = [
                        { role: "system", content: systemPrompt }
                    ];
                    if (scriptText) {
                        const datasetMessages = buildChunkedDatasetMessages(scriptText);
                        datasetMessages.forEach(chunk => messages.push(chunk));
                    }
                    if (fileAttachments.length) {
                        const listText = fileAttachments
                            .map(file => `- ${file.name || file.file_id} (${file.url || file.file_id})`)
                            .join("\n");
                        messages.push({
                            role: "user",
                            content: `Fichiers joints disponibles via OpenAI Files:\n${listText}`
                        });
                    }
                    messages.push({ role: "user", content: userPrompt });

                    const streamingState = createStreamingDatasetState();

                    try {
                        const payload = {
                            model:
                                window.GoToolkitIAConfig && typeof window.GoToolkitIAConfig.getOpenAiModel === "function"
                                    ? window.GoToolkitIAConfig.getOpenAiModel()
                                    : "gpt-5-nano",
                            messages,
                            reasoning: { effort: state.reasoningEffort || "low" },
                            attachments: fileAttachments,
                            stream: true
                        };
                        const response = await window.GoToolkitIA.chatCompletion({
                            payload,
                            stopCondition: () => false,
                            signal: controller.signal,
                            onChunk: chunk => {
                                handleStreamingChunk(streamingState, chunk, { activeTableId: page?.tableId });
                            }
                        });
                        const cleaned = cleanJson(response);
                        if (gridScript) {
                            gridScript.value = cleaned;
                        }
                        const activeTplState = getActiveTemplateState();
                        activeTplState.datasetScript = cleaned;
                        state.datasetScript = cleaned;
                        const ndjsonDataset = parseNdjsonDataset(cleaned);
                        const parsed = streamingState.finished ? null : (ndjsonDataset || parseJsonTolerant(cleaned));
                        if (!parsed || typeof parsed !== "object") {
                            if (streamingState.header) {
                                finalizeStreamingDataset(streamingState, { activeTableId: page?.tableId });
                                showStatus("Jeu de donn√©es mis √† jour.");
                                return;
                            }
                            throw new Error("R√©ponse IA invalide");
                        }
                        const isTree = isTreeTemplateActive();
                        const treeDataset = isTree ? normalizeTreePayload(parsed) : null;
                        if (treeDataset) {
                            const treeRows = Array.isArray(treeDataset?.data?.structure?.rowData)
                                ? treeDataset.data.structure.rowData.length
                                : 0;
                            console.info("Go-Toolkit Grid: tree dataset rows=", treeRows, treeDataset.data.structure.rowData);
                            const structure = treeDataset.data.structure || { columnDefs: [], rowData: [] };
                            state.pages = [
                                {
                                    id: "page-structure",
                                    tableId: "structure",
                                    title: "Structure de donn√©es",
                                    primaryKey: "id",
                                    relations: [],
                                    scenario: page?.scenario || "",
                                    data: {
                                        columnDefs: Array.isArray(structure.columnDefs) ? structure.columnDefs : [],
                                        rowData: Array.isArray(structure.rowData) ? structure.rowData : []
                                    }
                                }
                            ];
                            state.activeIndex = 0;
                            state.schema = {
                                tables: [
                                    {
                                        id: "structure",
                                        title: "Structure de donn√©es",
                                        primaryKey: "id",
                                        columns: [],
                                        relations: []
                                    }
                                ]
                            };
                            applyGridData(structure, { tableId: "structure" });
                            const exportedRows = prepareTreeRowsForExport(structure.rowData || []);
                            const treeScriptPayload = exportedRows.length ? { rows: exportedRows } : treeDataset;
                            if (gridScript && typeof gridScript.value === "string") {
                                gridScript.value = JSON.stringify(treeScriptPayload, null, 2);
                            }
                            syncDatasetScriptFromState({ persist: false });
                            persistState();
                        } else if (parsed?.schema && parsed?.data) {
                            applyDatasetToState(parsed, { markAsAi: true, activeTableId: page?.tableId });
                        } else if (!isTree) {
                            const dataset =
                                parsed?.schema && parsed?.data
                                    ? parsed
                                    : buildDatasetFromSingleTablePayload(parsed, page?.tableId, page?.title);
                            applyDatasetToState(dataset, { markAsAi: true, activeTableId: page?.tableId });
                        } else {
                            console.warn("Mod√®le 'Structure de donn√©es' : aucun champ 'rows', 'tree' ou 'nodes' d√©tect√©.");
                            showStatus("R√©ponse IA sans arbre ('rows' ou 'tree'). Ajoute \"rows\": [...] dans la sortie.", true);
                            throw new Error("R√©ponse IA invalide pour le mod√®le 'Structure de donn√©es' (champ rows/tree manquant)");
                        }
                        syncDatasetScriptFromState();
                        showStatus("Jeu de donn√©es mis √† jour.");
                        scheduleNaturalFilterRecalc();
                    } catch (err) {
                        if (err && err.name === "AbortError") {
                            if (!pendingAbortStatus) {
                                showStatus("Requ√™te annul√©e.", true);
                            }
                        } else {
                            console.error("Erreur IA", err);
                            showStatus("Impossible de g√©n√©rer le dataset.", true);
                        }
                    } finally {
                        pendingAbortStatus = false;
                        setLoading(false);
                        activeRequestController = null;
                    }
                }

                function clearGrid() {
                    state.pages.forEach(page => {
                        const columnDefs = Array.isArray(page?.data?.columnDefs) ? page.data.columnDefs : [];
                        page.data = { columnDefs, rowData: [] };
                    });
                    resetRelationLookups();
                    const activePage = getActivePage();
                    if (activePage) {
                        applyGridData(activePage.data, { tableId: activePage.tableId });
                    }
                    resetRelationLookups();
                    syncDatasetScriptFromState();
                    scheduleNaturalFilterRecalc();
                    showStatus("Grille et script vid√©s.");
                }

                function applyScriptToGrid(options = {}) {
                    const raw = gridScript.value || "";
                    if (!raw.trim()) {
                        clearGrid();
                        return;
                    }
                    try {
                        const parsed = parseJsonTolerant(cleanJson(raw));
                        if (!parsed || typeof parsed !== "object") {
                            throw new Error("JSON invalide");
                        }
                        const page = getActivePage();
                        const isTree = isTreeTemplateActive();
                        const treeDataset = isTree ? normalizeTreePayload(parsed) : null;
                        if (treeDataset) {
                            const treeRows = Array.isArray(treeDataset?.data?.structure?.rowData)
                                ? treeDataset.data.structure.rowData.length
                                : 0;
                            console.info("Go-Toolkit Grid: tree dataset rows=", treeRows);
                            applyDatasetToState(treeDataset, { activeTableId: page?.tableId });
                        } else if (parsed?.schema && parsed?.data) {
                            applyDatasetToState(parsed, { activeTableId: page?.tableId });
                        } else if (!isTree) {
                            const columnDefs = Array.isArray(parsed.columnDefs) ? parsed.columnDefs : [];
                            const rowData = Array.isArray(parsed.rowData) ? parsed.rowData : [];
                            page.data = { columnDefs, rowData };
                            resetRelationLookups();
                            applyGridData(page.data, { tableId: page.tableId });
                            syncDatasetScriptFromState();
                            persistState();
                        } else {
                            console.warn("Mod√®le 'Structure de donn√©es' : aucun champ 'rows', 'tree' ou 'nodes' d√©tect√©.");
                            showStatus("R√©ponse IA sans arbre ('rows' ou 'tree'). Ajoute \"rows\": [...] dans la sortie.", true);
                            throw new Error("R√©ponse IA invalide pour le mod√®le 'Structure de donn√©es' (champ rows/tree manquant)");
                        }
                        const tplState = getActiveTemplateState();
                        tplState.datasetScript = state.datasetScript || gridScript.value || "";
                        tplState.lastAiDatasetScript = tplState.datasetScript;
                        state.lastAiDatasetScript = tplState.lastAiDatasetScript;
                        persistState();
                        if (!options.silentOnSuccess) {
                            showStatus("Script appliqu√© sur la grille.");
                        }
                    } catch (err) {
                        console.error("Erreur de parsing JSON", err);
                        if (!options.silentOnError) {
                            showStatus("JSON invalide dans le Script.", true);
                        }
                    }
                }

                function restoreLastAiResponse() {
                    const tplState = getActiveTemplateState();
                    const script =
                        tplState?.lastAiDatasetScript ||
                        tplState?.datasetScript ||
                        state?.lastAiDatasetScript ||
                        state?.datasetScript ||
                        "";
                    if (!script.trim()) {
                        showStatus("Aucune r√©ponse IA √† restaurer.", true);
                        return;
                    }
                    tplState.datasetScript = script;
                    state.datasetScript = script;
                    gridScript.value = script;
                    applyScriptToGrid();
                }

                function wireNavSwitcher() {
                    if (navSwitcherBtn) {
                        navSwitcherBtn.addEventListener("click", () => toggleNavMenu());
                    }
                    document.addEventListener("click", event => {
                        if (!navSwitcherMenu) return;
                        const isInside = navSwitcherMenu.contains(event.target) || navSwitcherBtn.contains(event.target);
                        if (!isInside) {
                            navSwitcherMenu.classList.remove("open");
                        }
                    });
                }

                if (affichageBtn && affichageMenu) {
                    affichageBtn.addEventListener("click", event => {
                        event.stopPropagation();
                        closeGridMenus(affichageMenu);
                        syncDisplayControls();
                        affichageMenu.classList.toggle("open");
                    });
                    affichageMenu.addEventListener("click", event => event.stopPropagation());
                }
                if (columnPinBtn && columnPinMenu) {
                    columnPinBtn.addEventListener("click", event => {
                        event.stopPropagation();
                        closeGridMenus(columnPinMenu);
                        buildColumnPinMenu();
                        columnPinMenu.classList.toggle("open");
                    });
                    columnPinMenu.addEventListener("click", event => event.stopPropagation());
                }
                if (capsuleMenuBtn && capsuleMenu) {
                    capsuleMenuBtn.addEventListener("click", event => {
                        event.stopPropagation();
                        closeGridMenus(capsuleMenu);
                        capsuleMenu.classList.toggle("open");
                    });
                    capsuleMenu.addEventListener("click", event => event.stopPropagation());
                }
                if (capsuleNewBtn) {
                    capsuleNewBtn.addEventListener("click", async event => {
                        event.preventDefault();
                        event.stopPropagation();
                        await handleNewDocumentClick();
                    });
                }
                if (saveDocumentBtn) {
                    saveDocumentBtn.addEventListener("click", event => {
                        event.preventDefault();
                        event.stopPropagation();
                        void handleSaveDocumentClick();
                    });
                }
                if (capsuleDownloadBtn) {
                    capsuleDownloadBtn.addEventListener("click", event => {
                        event.preventDefault();
                        event.stopPropagation();
                        if (gridApi && typeof gridApi.exportDataAsCsv === "function") {
                            gridApi.exportDataAsCsv({ fileName: buildCsvFileName() });
                            showStatus("Export CSV g√©n√©r√©.");
                        } else {
                            showStatus("Export CSV indisponible.", true);
                        }
                        closeGridMenus();
                    });
                }
                if (shareBtn && shareMenu) {
                    shareBtn.addEventListener("click", event => {
                        event.stopPropagation();
                        closeGridMenus(shareMenu);
                        shareMenu.classList.toggle("open");
                        updateShareMenuUI();
                    });
                    shareMenu.addEventListener("click", event => event.stopPropagation());
                }
                if (templateModalBtn) {
                    templateModalBtn.addEventListener("click", event => {
                        event.preventDefault();
                        openTemplateModalUi();
                    });
                }
                if (templateApplyBtn) {
                    templateApplyBtn.addEventListener("click", event => {
                        event.preventDefault();
                        const selectedId = templateCardList?.dataset?.selectedId || state.activeTemplateId || DEFAULT_TEMPLATE_ID;
                        setActiveTemplate(selectedId, { skipApplyScript: true });
                        closeTemplateModalUi();
                    });
                }
                if (closeTemplateModal) {
                    closeTemplateModal.addEventListener("click", event => {
                        event.preventDefault();
                        closeTemplateModalUi();
                    });
                }
                if (templateModal) {
                    templateModal.addEventListener("click", event => {
                        if (event.target === templateModal) {
                            closeTemplateModalUi();
                        }
                    });
                }
                if (aiTemplateSelect) {
                    aiTemplateSelect.addEventListener("change", event => {
                        setActiveTemplate(event.target.value, { skipApplyScript: true });
                    });
                }
                if (shareCreateBtn) {
                    shareCreateBtn.addEventListener("click", event => {
                        event.stopPropagation();
                        handleShareCreateClick();
                    });
                }
                if (shareUpdateBtn) {
                    shareUpdateBtn.addEventListener("click", event => {
                        event.stopPropagation();
                        handleShareUpdateClick();
                    });
                }
                if (infoButton && infoPopup) {
                    infoButton.addEventListener("click", event => {
                        event.stopPropagation();
                        infoPopup.classList.toggle("open");
                    });
                }
                if (closeInfoPopup) {
                    closeInfoPopup.addEventListener("click", event => {
                        event.stopPropagation();
                        resetGridState();
                    });
                }
                document.addEventListener("click", event => {
                    if (affichageMenu && !affichageMenu.contains(event.target) && event.target !== affichageBtn) {
                        affichageMenu.classList.remove("open");
                    }
                    if (columnPinMenu && !columnPinMenu.contains(event.target) && event.target !== columnPinBtn) {
                        columnPinMenu.classList.remove("open");
                    }
                    if (capsuleMenu && !capsuleMenu.contains(event.target) && event.target !== capsuleMenuBtn) {
                        capsuleMenu.classList.remove("open");
                    }
                    if (shareMenu && !shareMenu.contains(event.target) && event.target !== shareBtn) {
                        shareMenu.classList.remove("open");
                    }
                    if (infoPopup && !infoPopup.contains(event.target) && event.target !== infoButton) {
                        infoPopup.classList.remove("open");
                    }
                    if (gridNaturalFilter && naturalSuggestionState.open && !gridNaturalFilter.contains(event.target)) {
                        closeNaturalSuggestions();
                    }
                });
                if (fontSizeInput) {
                    fontSizeInput.addEventListener("change", function () {
                        applyGridFontSize(this.value);
                    });
                }
                function wireSpeech() {
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    if (!SpeechRecognition) return;
                    let recognizer = null;
                    let lastSpeechInterim = "";
                    const originalPromptPlaceholder = promptInput?.getAttribute("placeholder") || "";
                    function hideSpeechSuggestion() {
                        if (promptSpeechSuggestion) {
                            promptSpeechSuggestion.classList.remove("visible");
                            promptSpeechSuggestion.innerHTML = "";
                        }
                        lastSpeechInterim = "";
                        try {
                            if (promptInput) promptInput.setAttribute("placeholder", originalPromptPlaceholder);
                        } catch (e) { /* noop */ }
                    }
                    function stopRecognition() {
                        if (recognizer) {
                            recognizer.stop();
                            recognizer = null;
                        }
                        const activeBtn = document.querySelector(".speech-button--active");
                        const activeWrapper = document.querySelector(".speech-field-wrapper.speech-active");
                        activeBtn?.classList.remove("speech-button--active");
                        activeWrapper?.classList.remove("speech-active");
                        hideSpeechSuggestion();
                        lastSpeechInterim = "";
                    }
                    function renderSpeechSuggestion(current, partial) {
                        if (!promptSpeechSuggestion) return;
                        const safeCurrent = (current || "").replace(/</g, "&lt;").replace(/>/g, "&gt;");
                        const safePartial = (partial || "").replace(/</g, "&lt;").replace(/>/g, "&gt;");
                        if (!safePartial.trim()) {
                            hideSpeechSuggestion();
                            return;
                        }
                        lastSpeechInterim = partial || "";
                        try {
                            if (promptInput) promptInput.setAttribute("placeholder", "");
                        } catch (e) { /* noop */ }
                        promptSpeechSuggestion.innerHTML = `<span class="speech-suggestion-current">${safeCurrent}</span><span class="speech-suggestion-partial">${safePartial}</span>`;
                        promptSpeechSuggestion.classList.add("visible");
                    }
                    function appendSpeechText(field, transcript) {
                        if (!field || !transcript) {
                            return;
                        }
                        const normalized = transcript.trim();
                        if (!normalized) {
                            return;
                        }
                        const separator = field.value ? (/\s$/.test(field.value) ? "" : " ") : "";
                        field.value = field.value + (field.value ? separator : "") + normalized;
                        field.dispatchEvent(new Event("input", { bubbles: true }));
                        hideSpeechSuggestion();
                        lastSpeechInterim = "";
                    }
                    function startRecognition() {
                        const field = promptInput;
                        const btn = document.querySelector(`[data-speech-target="promptInput"]`);
                        if (!field || !btn) return;
                        stopRecognition();
                        const wrapper = btn.closest(".speech-field-wrapper");
                        recognizer = new SpeechRecognition();
                        recognizer.lang = "fr-FR";
                        recognizer.continuous = true;
                        recognizer.interimResults = true;
                        recognizer.onresult = event => {
                            let finalText = "";
                            let interimText = "";
                            for (let i = event.resultIndex; i < event.results.length; i++) {
                                const res = event.results[i];
                                if (res.isFinal) {
                                    finalText += (finalText ? " " : "") + (res[0].transcript || "");
                                } else {
                                    interimText += (interimText ? " " : "") + (res[0].transcript || "");
                                }
                            }
                            if (finalText) {
                                appendSpeechText(field, finalText);
                            }
                            if (interimText) {
                                renderSpeechSuggestion(field.value, interimText);
                            } else {
                                hideSpeechSuggestion();
                            }
                        };
                        recognizer.onend = () => {
                            if (promptInput) {
                                promptInput.value = promptInput.value.trim();
                                promptInput.dispatchEvent(new Event("input", { bubbles: true }));
                            }
                            stopRecognition();
                        };
                        recognizer.start();
                        btn.classList.add("speech-button--active");
                        wrapper?.classList.add("speech-active");
                    }

                    document.addEventListener("click", event => {
                        const btn = event.target?.closest?.(".speech-button");
                        if (!btn) return;
                        const targetId = btn.getAttribute("data-speech-target");
                        if (targetId !== "promptInput") return;
                        if (btn.classList.contains("speech-button--active")) {
                            stopRecognition();
                        } else {
                            startRecognition();
                        }
                    });
                    window.addEventListener("beforeunload", stopRecognition);
                }

                function wireEvents() {
                    renderTabs();
                    setActivePage(state.activeIndex);
                    wireNavSwitcher();
                    wireSpeech();

                    if (addPageBtn) addPageBtn.addEventListener("click", addPage);
                    if (deletePageBtn) deletePageBtn.addEventListener("click", deleteActivePage);
                    if (aiSettingsBtn) aiSettingsBtn.addEventListener("click", openModal);
                    if (closeAiModal) closeAiModal.addEventListener("click", closeModal);
                    if (resetPromptBtn) resetPromptBtn.addEventListener("click", resetPrompt);
                    if (applyAiSettingsBtn) applyAiSettingsBtn.addEventListener("click", applyPromptSettings);
                    if (generateBtn) generateBtn.addEventListener("click", handleGenerateClick);
                    if (clearGridBtn) clearGridBtn.addEventListener("click", clearGrid);
                    if (applyScriptBtn) applyScriptBtn.addEventListener("click", restoreLastAiResponse);
                    if (gridTitleInput) {
                        gridTitleInput.addEventListener("input", () => {
                            const page = getActivePage();
                            if (!page) return;
                            page.title = gridTitleInput.value;
                            if (Array.isArray(state?.schema?.tables)) {
                                const table = state.schema.tables.find(item => item?.id === page.tableId);
                                if (table) {
                                    table.title = page.title;
                                }
                            }
                            renderTabs();
                            syncDatasetScriptFromState();
                        });
                    }
                    if (promptInput) {
                        promptInput.addEventListener("input", () => {
                            const page = getActivePage();
                            const value = promptInput.value || "";
                            if (page) page.scenario = value;
                            const tplState = getActiveTemplateState();
                            tplState.scenario = value;
                            persistState();
                        });
                    }
                    if (gridScript) {
                        gridScript.addEventListener("input", () => {
                            const tplState = getActiveTemplateState();
                            tplState.datasetScript = gridScript.value;
                            state.datasetScript = tplState.datasetScript;
                            persistState();
                        });
                        gridScript.addEventListener("blur", () => {
                            applyScriptToGrid({ silentOnError: true, silentOnSuccess: true });
                        });
                    }
                    if (promptFileBtn && promptFileInput) {
                        promptFileBtn.addEventListener("click", () => promptFileInput.click());
                        promptFileInput.addEventListener("change", handlePromptFileInputChange);
                    }
                    if (promptFileList) {
                        promptFileList.addEventListener("click", event => {
                            const target = event.target;
                            const removeId = target?.getAttribute?.("data-remove-file-id");
                            if (removeId) {
                                removeFileUpload(removeId);
                            }
                        });
                    }
                    if (gridNaturalFilterInput) {
                        gridNaturalFilterInput.addEventListener("input", () => {
                            const inputEl = gridNaturalFilterInput;
                            const prevCursor = inputEl.selectionStart ?? (inputEl.value || "").length;

                            let nextValue = inputEl.value || "";
                            if (/[()]/.test(nextValue)) {
                                const before = nextValue;
                                nextValue = nextValue.replace(/[()]/g, "");
                                inputEl.value = nextValue;
                                const removed = before.length - nextValue.length;
                                const nextCursor = Math.max(0, prevCursor - Math.max(0, removed));
                                try { inputEl.setSelectionRange(nextCursor, nextCursor); } catch (err) { /* ignore */ }
                            }
                            scheduleNaturalFilterApply({ delayMs: 200 });
                            updateNaturalSuggestions({ forced: false });
                        });
                        gridNaturalFilterInput.addEventListener("focus", () => {
                            // Hide placeholder while user is focused in the input
                            try {
                                gridNaturalFilterInputOriginalPlaceholder = gridNaturalFilterInputOriginalPlaceholder || (gridNaturalFilterInput.placeholder || "");
                                gridNaturalFilterInput.placeholder = "";
                            } catch (e) { /* ignore */ }
                            updateNaturalSuggestions({ forced: true });
                        });
                        gridNaturalFilterInput.addEventListener("click", () => {
                            updateNaturalSuggestions({ forced: true });
                        });
                        gridNaturalFilterInput.addEventListener("keydown", event => {
                            const isCtrlSpace = (event.ctrlKey || event.metaKey) && (event.code === "Space" || event.key === " ");
                            if (isCtrlSpace) {
                                event.preventDefault();
                                updateNaturalSuggestions({ forced: true });
                                return;
                            }
                            if (event.key === "Backspace") {
                                // Default: let Backspace behave normally (single-char delete) so users
                                // can edit words/verbs character-by-character.
                                // If the user holds Ctrl/Meta + Backspace, perform word/operator deletion.
                                if (!(event.ctrlKey || event.metaKey)) {
                                    return;
                                }
                                try {
                                    const inputEl = gridNaturalFilterInput;
                                    const value = inputEl.value || "";
                                    const selStart = inputEl.selectionStart ?? value.length;
                                    const selEnd = inputEl.selectionEnd ?? selStart;
                                    // If there's a selection, allow default behavior
                                    if (selStart !== selEnd) return;
                                    const before = value.slice(0, selStart);
                                    const after = value.slice(selEnd);

                                    // If suggestions are not open, only act when caret follows an operator word
                                    // (English: AND/OR/NOT, French: ET/OU/PAS). Otherwise allow normal Ctrl+Backspace.
                                    if (!naturalSuggestionState.open) {
                                        const opMatch = before.match(/(?:\b(?:AND|OR|NOT|ET|OU|PAS)\b)\s*$/i);
                                        if (!opMatch) return;
                                    }

                                    // If the character before caret is whitespace, remove a single space
                                    let newBefore;
                                    if (/\s$/.test(before)) {
                                        newBefore = before.replace(/\s$/u, "");
                                    } else {
                                        // Otherwise remove the last contiguous non-space chunk plus any preceding spaces
                                        newBefore = before.replace(/\s*\S+$/u, "");
                                    }
                                    const newCaret = newBefore.length;
                                    inputEl.value = newBefore + after;
                                    try { inputEl.setSelectionRange(newCaret, newCaret); } catch (e) { /* ignore */ }
                                    // Refresh suggestions for the modified input; preserve open state
                                    updateNaturalSuggestions({ forced: Boolean(naturalSuggestionState.open) });
                                    event.preventDefault();
                                } catch (e) {
                                    // If anything goes wrong, don't block default Backspace
                                }
                                return;
                            }
                            if (!naturalSuggestionState.open) return;
                            if (event.key === "Tab") {
                                // Tab: accept current suggestion like Enter. Shift+Tab navigates suggestions backward.
                                event.preventDefault();
                                if (event.shiftKey) {
                                    const dir = -1;
                                    const next = naturalSuggestionState.activeIndex + dir;
                                    const max = naturalSuggestionState.items.length;
                                    naturalSuggestionState.activeIndex = ((next % max) + max) % max;
                                    renderNaturalSuggestions();
                                    return;
                                }
                                // Accept active suggestion and append a space to continue typing
                                acceptActiveNaturalSuggestion({ appendSpace: true });
                                return;
                            }
                            // Spacebar: allow normal behavior (do not accept suggestion on Space)
                            if (event.key === "ArrowDown") {
                                event.preventDefault();
                                const max = naturalSuggestionState.items.length;
                                naturalSuggestionState.activeIndex = (naturalSuggestionState.activeIndex + 1) % max;
                                renderNaturalSuggestions();
                                gridNaturalFilterSuggestions?.querySelector(".grid-filter-suggestion.active")?.scrollIntoView?.({
                                    block: "nearest"
                                });
                                return;
                            }
                            if (event.key === "ArrowUp") {
                                event.preventDefault();
                                const max = naturalSuggestionState.items.length;
                                naturalSuggestionState.activeIndex = (naturalSuggestionState.activeIndex - 1 + max) % max;
                                renderNaturalSuggestions();
                                gridNaturalFilterSuggestions?.querySelector(".grid-filter-suggestion.active")?.scrollIntoView?.({
                                    block: "nearest"
                                });
                                return;
                            }
                            if (event.key === "Escape") {
                                event.preventDefault();
                                closeNaturalSuggestions();
                                return;
                            }
                            if (event.key === "Enter") {
                                event.preventDefault();
                                acceptActiveNaturalSuggestion({ appendSpace: true });
                            }
                        });
                        gridNaturalFilterInput.addEventListener("blur", () => {
                            // Delay so click on suggestion can be handled.
                            setTimeout(() => {
                                if (document.activeElement !== gridNaturalFilterInput) {
                                    closeNaturalSuggestions();
                                }
                                // Restore placeholder if input is empty
                                try {
                                    if ((gridNaturalFilterInput.value || "").trim() === "") {
                                        gridNaturalFilterInput.placeholder = gridNaturalFilterInputOriginalPlaceholder || "";
                                    }
                                } catch (e) { /* ignore */ }
                            }, 120);
                        });
                    }
                    if (drawerBtn) {
                        drawerBtn.addEventListener("click", () => toggleSidebar());
                    }
                    if (drawerOverlay) {
                        drawerOverlay.addEventListener("click", () => toggleSidebar(false));
                    }
                    window.addEventListener("resize", syncSidebarLayout);
                    syncSidebarLayout();
                    updateFileRowVisibility();
                    renderFileList();
                    // Initialize external filtering state/UI once the grid is ready.
                    applyNaturalFilterNow();
                }

                wireEvents();
                (async () => {
                    const sharedLoaded = await tryLoadSharedStateFromUrl().catch(err => {
                        console.error("Impossible de charger la capsule partag√©e", err);
                        return false;
                    });
                    if (!sharedLoaded) {
                        await tryLoadLocalDraftFromUrl().catch(err => {
                            console.warn("Impossible de charger la capsule locale", err);
                            return false;
                        });
                    }
                })().finally(() => {
                    updateShareMenuUI();
                });
            })();
    </script>
</body>

</html>