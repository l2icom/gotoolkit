<!DOCTYPE html>
<html lang="fr">

<head>
    <script>window.GO_TOOLKIT_SHARE_API_URL = 'https://share.gotoolkit.workers.dev/'</script>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Voice | Go-Toolkit</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap">
    <link rel="stylesheet" href="styles/app-shell.css">
    <style>
        :root {
            --bg: #f3f4f6;
            --surface: #ffffff;
            --surface-soft: #f8fafc;
            --border: #e5e7eb;
            --border-strong: #cbd5e1;
            --primary: #2a7a57;
            --primary-soft: rgba(42, 122, 87, 0.1);
            --text: #0f172a;
            --muted: #6b7280;
            --radius-lg: 16px;
            --radius-sm: 10px;
            --shadow-soft: 0 14px 34px rgba(15, 23, 42, 0.1);
        }

        body {
            margin: 0;
            background: var(--bg);
            color: var(--text);
            font-family: var(--app-font, "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif);
            overflow: hidden;
        }

        .app {
            height: 100vh;
            max-width: none;
        }

        .app-main {
            display: grid;
            grid-template-columns: 1fr;
            grid-template-rows: 1fr;
            gap: 12px;
            min-height: 0;
            height: calc(100vh - 20px);
        }

        .app-main.context-open {
            grid-template-columns: 1fr 350px;
        }

        .voice-card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-soft);
            padding: 8px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            min-height: 0;
            width: 100%;
        }

        .voice-main-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .voice-title {
            font-size: 15px;
            font-weight: 500;
            margin: 0;
            padding: 4px 8px;
            border-radius: 10px;
            border: 1px solid transparent;
            cursor: text;
            min-width: 120px;
            max-width: 100%;
        }

        .voice-title:focus-visible {
            outline: none;
            border-color: var(--primary);
            background: var(--primary-soft);
        }

        .voice-main-body {
            display: grid;
            grid-template-columns: 1.1fr 0.9fr;
            gap: 12px;
            min-height: 0;
            flex: 1 1 auto;
        }

        .app-main:not(.context-open) .voice-main-body {
            grid-template-columns: minmax(0, 1fr) 400px;
        }

        .panel {
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            background: var(--surface-soft);
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-height: 0;
            height: 100%;
            overflow: hidden;
        }

        .panel-columns {
            display: block;
        }

        @media (min-width: 1400px) {
            .app-main:not(.context-open) .panel-columns {
                display: grid;
                grid-template-columns: repeat(2, minmax(0, 1fr));
                gap: 12px;
                flex: 1 1 0;
                min-height: 0;
                align-content: stretch;
            }

            .app-main:not(.context-open) .summary-column {
                height: 100%;
            }

            .app-main:not(.context-open) .summary-wrapper {
                flex: 1 1 0;
                min-height: 0;
                display: flex;
                flex-direction: column;
            }

            .app-main:not(.context-open) .summary-area {
                flex: 1 1 0;
                min-height: 0;
                height: 100%;
                overflow-y: auto;
            }
        }

        .app-main.context-open .panel-columns {
            display: flex;
            flex-direction: column;
            flex: 1 1 0;
            min-height: 0;
            gap: 12px;
        }

        .app-main.context-open .note-column {
            flex: 1 1 0;
        }


        .note-column,
        .summary-column {
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-height: 0;
            height: 100%;
            margin-top: 0;
        }

        .summary-column {
            display: flex;
            flex-direction: column;
            gap: px;
            min-height: 0;
            height: 100%;
            margin-top: 0;
        }

        .note-column .transcribe-wrapper {
            flex: 1;
            min-height: 0;
            display: flex;
            flex-direction: column;
        }

        .note-column .transcribe-area {
            flex: 1;
            min-height: 0;
        }

        .summary-column .summary-wrapper {
            flex: 0 0 auto;
            min-height: 0;
        }

        .app-main.context-open .note-column,
        .app-main.context-open .summary-column {
            height: auto;
            margin-top: 6px;
        }

        @media (max-width: 1399px) {

            .app-main:not(.context-open) .note-column,
            .app-main:not(.context-open) .summary-column {
                margin-top: 6px;
            }
        }

        .panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            font-weight: 500;
            color: var(--text);
            font-size: 14px;
        }

        .note-mode-select {
            font-size: 13px;
            border-radius: 8px;
            border: 1px solid var(--border-strong);
            padding: 4px 10px;
            background: var(--surface);
            color: var(--text);
            cursor: pointer;
        }

        .recording-toolbar {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .audio-controls {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            min-width: 170px;
        }

        .audio-play-btn,
        .audio-download-btn {
            border: 1px solid var(--border-strong);
            background: transparent;
            border-radius: 8px;
            padding: 2px 6px;
            font-size: 14px;
            cursor: pointer;
        }

        .audio-progress {
            width: 120px;
            accent-color: var(--primary);
            appearance: none;
            height: 6px;
            border-radius: 6px;
            background: #e5e7eb;
            outline: none;
        }

        .audio-progress::-webkit-slider-thumb {
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            border: 2px solid #fff;
            box-shadow: 0 0 0 1px var(--border-strong);
        }

        .audio-progress::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            border: 2px solid #fff;
            box-shadow: 0 0 0 1px var(--border-strong);
        }

        .audio-speed {
            border: 1px solid var(--border-strong);
            border-radius: 10px;
            padding: 2px 6px;
            font-size: 13px;
            background: #fff;
        }

        .info-popup {
            position: absolute;
            top: 56px;
            right: 12px;
            width: 280px;
            background: #fff;
            border-radius: 14px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            padding: 15px;
            display: none;
            flex-direction: column;
            gap: 6px;
            font-size: 12px;
            z-index: 200;
        }

        .info-popup.open {
            display: flex;
        }

        .info-popup img {
            width: 48px;
            height: 48px;
            object-fit: contain;
            align-self: center;
        }

        .info-popup a {
            color: #2a7a57;
            text-decoration: none;
            font-weight: 600;
        }

        .info-popup button {
            border-radius: 8px;
            border: 1px solid rgba(15, 23, 42, 0.15);
            background: #fff;
            color: #0f172a;
            padding: 6px 10px;
            font-size: 12px;
            cursor: pointer;
            min-width: 110px;
        }

        .info-popup button.update-btn {
            background: #2a7a57;
            border-color: #2a7a57;
            color: #fff;
        }

        .info-popup button.secondary {
            background: #fff;
            border-color: rgba(15, 23, 42, 0.15);
            color: #0f172a;
        }

        .info-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        textarea {
            width: 100%;
            border-radius: 10px;
            border: 1px solid var(--border-strong);
            padding: 8px 10px;
            font-size: 13px;
            font-family: Menlo, Consolas, "Courier New", monospace;
            resize: none;
            min-height: 120px;
            background: #fff;
            line-height: 1.45;
        }

        textarea:focus,
        input:focus {
            outline: none;
            border: 1px solid var(--primary);
            box-shadow: 0 0 0 1px var(--primary-soft);
        }

        .speech-active {
            border: 2px solid #B11226 !important;
            animation: speech-border 2s infinite ease-in-out;
        }

        .speech-active:focus {
            border: 1px solid #B11226 !important;
            box-shadow: none;
        }

        @keyframes speech-border {
            0% {
                box-shadow: 0 0 0 0 rgba(177, 18, 38, 0.4);
            }

            50% {
                box-shadow: 0 0 0 4px rgba(177, 18, 38, 0.15);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(177, 18, 38, 0.4);
            }
        }

        .transcribe-area {
            font-family: "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
            line-height: 1.3;
            min-height: 0;
            height: 100%;
        }

        .transcribe-wrapper {
            position: relative;
            height: 100%;
            min-height: 0;
        }

        textarea::-webkit-scrollbar,
        .transcribe-area::-webkit-scrollbar,
        .summary-area::-webkit-scrollbar,
        .ia-prompt-field::-webkit-scrollbar,
        #iaTemplateEditor::-webkit-scrollbar,
        #promptCreate::-webkit-scrollbar,
        #promptModify::-webkit-scrollbar,
        #newSubjectPoints::-webkit-scrollbar {
            width: 2px;
        }

        textarea::-webkit-scrollbar-thumb,
        .transcribe-area::-webkit-scrollbar-thumb,
        .summary-area::-webkit-scrollbar-thumb,
        .ia-prompt-field::-webkit-scrollbar-thumb,
        #iaTemplateEditor::-webkit-scrollbar-thumb,
        #promptCreate::-webkit-scrollbar-thumb,
        #promptModify::-webkit-scrollbar-thumb,
        #newSubjectPoints::-webkit-scrollbar-thumb {
            background: rgba(156, 163, 175, 0.45);
            border-radius: 4px;
        }

        /* Firefox scrollbar color for textarea-like fields */
        textarea,
        .transcribe-area,
        .summary-area,
        .ia-prompt-field,
        #iaTemplateEditor,
        #promptCreate,
        #promptModify,
        #newSubjectPoints {
            scrollbar-color: rgba(156, 163, 175, 0.45) transparent;
        }

        .transcribe-ghost {
            position: absolute;
            inset: 0;
            padding: 8px 10px;
            pointer-events: none;
            transform: translate(0, 0);
            color: var(--muted);
            white-space: pre-wrap;
            font-size: 13px;
            line-height: 1.3;
            font-family: "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
            z-index: 3;
        }

        .transcribe-mirror {
            position: absolute;
            visibility: hidden;
            white-space: pre-wrap;
            word-wrap: break-word;
            padding: 8px 10px;
            font-family: "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
            line-height: 1.3;
            inset: 0;
        }

        .transcribe-ghost span {
            font-size: 13px;
        }

        .speech-field-wrapper {
            position: relative;
            height: 100%;
        }

        .speech-field-wrapper textarea {
            position: relative;
            z-index: 2;
        }

        .speech-button {
            position: absolute;
            top: 6px;
            right: 6px;
            width: 24px;
            height: 24px;
            background: rgba(255, 255, 255, 0.85);
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border: none;
            color: var(--muted);
            border-radius: 999px;
            transition: box-shadow 0.2s ease, opacity 0.2s ease;
            opacity: 1;
            pointer-events: auto;
            z-index: 3;
            transform: translateX(2px);
        }

        #audioImportBtn {
            right: 28px;
            top: 4px;
            transform: translateX(0);
        }

        .speech-button--active,
        .speech-button:active {
            color: #B11226;
            animation: speech-blink 2s infinite linear;
            opacity: 1;
        }

        .summary-wrapper {
            min-height: 0;
            height: 100%;
        }

        .summary-area {
            min-height: 0;
            height: 100%;
            line-height: 1.45;
            font-family: "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
        }

        .app-main.context-open .summary-wrapper,
        .app-main.context-open .summary-area {
            height: auto;
        }

        @keyframes speech-blink {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.4;
            }
        }

        .subject-ranges {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin: 10px 0 12px 0;
            width: 100%;
        }

        .subject-range-row {
            display: flex;
            gap: 8px;
            align-items: center;
            width: 100%;
        }

        .subject-range-row input[type="range"] {
            flex: 1 1 auto;
            appearance: none;
            height: 6px;
            border-radius: 6px;
            background: #e5e7eb;
            outline: none;
        }

        .subject-range-row input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            border: 2px solid #fff;
            box-shadow: 0 0 0 1px var(--border-strong);
        }

        .subject-range-row input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            border: 2px solid #fff;
            box-shadow: 0 0 0 1px var(--border-strong);
        }

        .subject-range-meta {
            font-size: 12px;
            color: var(--muted);
        }

        #guidelineDuration {
            font-size: 14px;
            border: 1px solid var(--border-strong);
            border-radius: 10px;
            padding: 4px 6px;
        }

        .guidelines-panel {
            background: #ffffff;
            border: none;
            border-radius: var(--radius-sm);
            padding: 0px 10px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            min-height: 0;
        }

        .subject-tabs {
            display: flex;
            flex-wrap: nowrap;
            gap: 6px;
            width: 100%;
            flex-direction: row;
            padding: 8px 0px 8px 0px;
        }

        .subject-tab {
            border: 1px solid var(--border-strong);
            border-radius: 999px;
            padding: 6px 10px;
            font-size: 12px;
            cursor: pointer;
            background: var(--surface);
            color: var(--text);
            display: inline-flex;
            align-items: center;
            gap: 6px;
            flex: 1 1 auto;
            min-width: 0;
            width: auto;
        }

        .edit-subject-btn {
            border: none;
            background: transparent;
            padding: 0;
            margin: 0;
            line-height: 1;
            cursor: pointer;
            font-size: 12px;
        }

        .subject-tab.active {
            background: transparent;
            color: var(--text);
            border-color: var(--primary);
            border-width: 2px;
        }

        .subject-tab .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 6px;
        }

        .status-dot--none {
            background: #9ca3af;
        }

        .status-dot--partial {
            background: #f59e0b;
        }

        .status-dot--complete {
            background: #16a34a;
        }

        .guideline-list {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow: auto;
        }

        .participants-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 6px;
        }

        .participant-row {
            display: grid;
            grid-template-columns: 1fr 0.8fr auto;
            gap: 6px;
        }

        .participant-row input {
            border: 1px solid var(--border-strong);
            border-radius: 10px;
            padding: 6px 8px;
            font-size: 12px;
        }

        .participant-add-btn {
            align-self: flex-start;
            border-radius: 10px;
            border: 1px dashed var(--border-strong);
            background: var(--surface-soft);
            padding: 6px 10px;
            font-size: 12px;
            cursor: pointer;
        }

        .participants-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding-bottom: 8px;
        }

        .guideline-item {
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 8px 10px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            background: var(--surface-soft);
            font-size: 13px;
        }

        .guideline-actions {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .guideline-actions label {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: var(--muted);
            cursor: pointer;
        }

        .guideline-actions input[type="checkbox"] {
            accent-color: var(--primary);
            cursor: pointer;
        }

        .badge {
            display: inline-flex;
            align-items: center;
            padding: 2px 8px;
            background: var(--primary-soft);
            color: var(--primary);
            border-radius: 999px;
            font-size: 13px;
        }



        .advice-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 8px;
        }

        .advice-card {
            border: 1px dashed var(--border-strong);
            border-radius: 10px;
            padding: 8px 10px;
            font-size: 12px;
            background: var(--surface-soft);
        }

        .gutenberg-card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-soft);
            padding: 10px;
            width: 350px;
            display: none;
            flex-direction: column;
            gap: 12px;
            min-height: 0;
        }

        .gutenberg-card.open {
            display: flex;
        }

        .prompt-template-meta {
            font-size: 12px;
            color: var(--muted);
            margin-bottom: 6px;
        }

        .toast {
            position: fixed;
            bottom: 16px;
            right: 16px;
            background: rgba(17, 24, 39, 0.9);
            color: #fff;
            padding: 10px 14px;
            border-radius: 10px;
            box-shadow: var(--shadow-soft);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            transform: translateY(10px);
            z-index: 9900;
        }

        .toast.visible {
            opacity: 1;
            pointer-events: auto;
            transform: translateY(0);
        }

        .context-menu {
            min-width: 180px;
        }

        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(15, 23, 42, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 120;
        }

        .modal-overlay.open {
            display: flex;
        }

        .modal {
            background: #fff;
            border-radius: 14px;
            padding: 14px;
            width: min(720px, 96vw);
            max-height: 90vh;
            overflow: auto;
            box-shadow: var(--shadow-soft);
        }

        .gt-template-modal__list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 10px;
        }

        .gt-template-card {
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 10px;
            cursor: pointer;
            background: var(--surface-soft);
        }

        .gt-template-card.gt-template-card--selected {
            border-color: var(--primary);
            box-shadow: 0 0 0 2px var(--primary-soft);
        }

        .tabs-actions {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
            flex-wrap: wrap;
        }

        .menu-trigger {
            position: relative;
            display: inline-flex;
        }

        .context-menu {
            position: absolute;
            top: calc(100% + 6px);
            right: 0;
            background: var(--surface);
            border: 1px solid rgba(15, 23, 42, 0.1);
            border-radius: 16px;
            box-shadow: 0 16px 32px rgba(15, 23, 42, 0.2);
            display: none;
            min-width: 220px;
            z-index: 40;
        }

        .context-menu.open {
            display: block;
        }

        .context-menu label,
        .context-menu button {
            font-size: 12px;
        }

        .global-actions {
            display: flex;
            flex-direction: row;
            gap: 8px;
            max-width: 800px;
            width: 100%;
            justify-content: flex-end;
            align-items: flex-start;
        }

        .ia-actions {
            display: flex;
            flex-direction: column;
            gap: 0px;
            height: 100%;
        }

        .ia-actions>.header-row {
            flex: 1 1 auto;
            display: flex;
            flex-direction: column;
        }

        .ia-header-actions {
            width: 100%;
            padding: 4px 0;
        }

        .gutenberg-recette-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            margin-bottom: 6px;
        }

        .ia-prompt-fields textarea {
            width: 100%;
        }

        #clearScenarioBtn {
            margin-left: auto;
            margin-right: 4px;
        }

        @media (max-width: 1100px) {
            .app-main {
                width: 100%;
                grid-template-columns: 1fr;
            }

            .global-actions {
                justify-content: flex-start;
            }

            .voice-main-body {
                grid-template-columns: 1fr;
            }

            .gutenberg-card {
                position: fixed;
                right: 0;
                top: 0;
                bottom: 0;
                width: min(360px, 92vw);
                max-width: 100%;
                transform: translateX(110%);
                opacity: 0;
                pointer-events: none;
                transition: transform 0.2s ease, opacity 0.2s ease;
                z-index: 110;
            }

            .gutenberg-card.open {
                transform: translateX(0);
                opacity: 1;
                pointer-events: auto;
            }
    </style>
</head>

<body class="app-body">
    <div class="app">
        <div class="app-header">
            <a class="app-home-link" href="index.html" title="Revenir √† l'accueil">‚òç</a>
            <div class="nav-switch">
                <button id="navSwitcherBtn" class="nav-switch-btn" type="button" aria-haspopup="true"
                    aria-expanded="false">‚ñ∑ Voice ‚ñæ</button>
                <div id="navSwitcherMenu" class="nav-switch-menu" role="menu">
                    <a class="nav-switch-link" href="canvas.html?v=2025.12.25.1" role="menuitem"> ‚óç Canvas</a>
                    <a class="nav-switch-link" href="grid.html?v=2025.12.25.1" role="menuitem">‚ñ¶ Grid</a>
                    <a class="nav-switch-link" href="draw.html?v=2025.12.25.1" role="menuitem">‚óá Draw</a>
                    <a class="nav-switch-link" href="timeline.html?v=2025.12.25.1" role="menuitem">‚á• Timeline</a>
                </div>
            </div>

            <div class="tabs-actions">
                <div id="viewTabs" class="tabs"></div>
                <button class="tab-action" id="addViewBtn" type="button" aria-label="Ajouter une vue">+</button>
                <button class="tab-action" id="deleteViewBtn" type="button"
                    aria-label="Supprimer la vue active">√ó</button>
            </div>

            <div class="global-actions">
                <button class="btn" id="gtTemplateModalTrigger" aria-label="Ouvrir ‚äû Mod√®le" title="‚äû Mod√®le">‚äû
                    Mod√®le</button>
                <button class="btn" id="gtContextModalTrigger" aria-label="Ouvrir Contexte" title="‚∏ô Gutenberg">‚∏ô
                    Contexte</button>
                <button class="btn" id="gtPromptModalTrigger" aria-label="Ouvrir Prompt" title="‚åò Prompt">‚åò
                    Prompt</button>

                <div class="menu-trigger">
                    <button class="btn" id="fileMenuBtn" aria-label="Capsule" title="Capsule">‚¨† Capsule</button>
                    <div class="context-menu file-menu" id="fileMenu">
                        <div class="menu-panel">
                            <button id="newDocumentBtn" type="button" class="menu-panel-btn">üóã Nouveau</button>
                            <button id="importJsonBtn" type="button" class="menu-panel-btn">‚§∑ Ouvrir</button>
                            <button id="saveDocumentBtn" type="button" class="menu-panel-btn">üñ´
                                Enregistrer</button>
                            <button id="exportJsonBtn" type="button" class="menu-panel-btn">‚≠≥ T√©l√©charger</button>
                            <button id="aboutVoiceBtn" type="button" class="menu-panel-btn">‚éâ √Ä propos</button>
                        </div>
                    </div>
                </div>

                <div class="menu-trigger">
                    <button id="shareBtn" class="btn btn-secondary" type="button" aria-label="Partager"
                        title="Lien de la capsule">‚òç Nexus</button>
                    <div data-share-menu-slot></div>
                </div>
            </div>
        </div>

        <!-- Template modal -->
        <div class="modal-overlay gt-template-modal" id="gtTemplateModal" role="dialog" aria-modal="true"
            aria-labelledby="gtTemplateModalTitle">
            <div class="modal gt-template-modal__dialog">
                <div class="modal-header" style="display:flex;justify-content:space-between;align-items:center;">
                    <h3 id="gtTemplateModalTitle" title="‚äû Mod√®le">‚äû Mod√®le</h3>
                    <button class="modal-close btn" id="gtTemplateModalClose" type="button"
                        aria-label="Fermer ‚äû Mod√®le">√ó</button>
                </div>
                <div class="gt-template-modal__list" id="gtTemplateModalList">
                    <!-- cards rendered by JS -->
                </div>
                <div class="modal-actions" style="margin-top:10px;display:flex;justify-content:flex-end;gap:8px;">
                    <button id="gtTemplateModalApply" class="btn-primary">Appliquer</button>
                </div>
            </div>
        </div>

        <div class="app-main">
            <div class="voice-card">
                <div class="voice-main-header">
                    <div>
                        <div id="pageTitle" class="voice-title" contenteditable="true" role="textbox"
                            aria-label="Titre de la page">Page 1</div>
                    </div>
                </div>
                <div class="voice-main-body">
                    <div class="panel">
                        <div class="panel-columns">
                            <div class="note-column">
                                <div class="panel-header">
                                    <select id="noteModeSelect" class="note-mode-select" aria-label="Mode de note">
                                        <option value="note">Note</option>
                                        <option value="transcript-auto">Transcript auto</option>
                                        <option value="transcript-ia">Transcript IA</option>
                                    </select>
                                    <div class="recording-toolbar">
                                        <span id="transcriptMeta" class="badge"
                                            style="background:#e5e7eb;color:#000;">0' /
                                            0'</span>
                                        <div class="audio-controls">
                                            <button id="audioPlayBtn" type="button" class="audio-play-btn"
                                                title="Lire / pause" aria-label="Lire l'enregistrement">‚ñ∂</button>
                                            <input id="audioProgress" class="audio-progress" type="range" min="0"
                                                max="1" step="0.01" value="0" aria-label="Progression audio" disabled>
                                            <select id="audioSpeedSelect" class="audio-speed" title="Vitesse de lecture"
                                                aria-label="Vitesse de lecture"></select>
                                            <button id="audioDownloadBtn" type="button" class="audio-download-btn"
                                                title="T√©l√©charger l'enregistrement"
                                                aria-label="T√©l√©charger">ü°á</button>
                                            <button id="audioClearBtn" type="button" class="audio-download-btn"
                                                title="Supprimer l'enregistrement"
                                                aria-label="Supprimer l'enregistrement">‚äò</button>
                                        </div>
                                    </div>
                                </div>
                                <div class="transcribe-wrapper speech-field-wrapper">
                                    <textarea id="transcribeInput" class="transcribe-area" placeholder=""
                                        aria-label="Transcription"></textarea>
                                    <div id="transcribeGhost" class="transcribe-ghost" aria-live="polite"></div>
                                    <div id="transcribeMirror" class="transcribe-mirror" aria-hidden="true"></div>
                                    <button class="speech-button" id="speechToggleBtn" type="button"
                                        data-speech-target="transcribeInput" title="Dict√©e vocale"
                                        aria-label="Activer la dict√©e vocale">‚óâ</button>
                                    <button class="speech-button" id="audioImportBtn" type="button"
                                        title="Importer un fichier audio"
                                        aria-label="Importer un fichier audio">‚ô™</button>
                                    <input id="audioImportInput" type="file" accept="audio/*" hidden>
                                </div>
                            </div>
                            <div class="summary-column">
                                <div class="panel-header">
                                    <span>R√©sum√©</span>
                                    <button id="summarizeBtn" type="button" class="btn">‚åò R√©sumer</button>
                                </div>
                                <div class="summary-wrapper">
                                    <textarea id="summaryTextarea" class="summary-area" rows="8" placeholder=""
                                        aria-label="R√©sum√© IA"></textarea>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="guidelines-panel">
                        <div id="guidelineProgress">
                            <div class="panel-header" style="align-items:flex-start;">
                                <div style="display:flex;align-items:center;gap:8px;font-weight:600;">
                                    <div>Sujets</div>
                                    <span style="font-size:12px;color:var(--muted);">Dur√©e pr√©vue</span>
                                    <select id="guidelineDuration">
                                        <!-- options filled by JS -->
                                    </select>
                                </div>
                                <div class="guideline-actions">
                                    <button id="evaluateBtn" type="button" class="btn">‚åò √âvaluer</button>
                                    <button id="addSubjectBtn" type="button" class="btn">+ Sujet</button>
                                </div>
                            </div>
                            <div class="subject-tabs" id="subjectTabs"></div>
                            <div id="subjectRanges" class="subject-ranges"></div>
                            <ul class="guideline-list" id="guidelineList">
                                <li style="color:var(--muted);font-size:13px;">Ajoute un sc√©nario et clique sur ‚åò
                                    R√©pondre
                                    pour g√©n√©rer les sujets.</li>
                            </ul>
                        </div>
                        <div id="guidelineMeta" class="meta-row" style="width:100%;font-size:14px;"></div>
                    </div>
                </div>
            </div>

            <div class="gutenberg-card open gt-context-modal" id="gtContextModal" role="complementary"
                aria-hidden="false">
                <div class="ia-actions">
                    <div class="header-row ia-header-actions gutenberg-recette">
                        <div class="gutenberg-recette-header">
                            <label for="promptCreate">Sc√©nario</label>
                            <button class="btn" type="button" id="clearScenarioBtn"
                                aria-label="R√©initialiser le sc√©nario">‚äò Vider</button>
                            <button class="btn btn-primary" id="respondBtn" type="button">
                                <span>‚åò R√©pondre</span>
                            </button>
                        </div>
                        <div class="ia-prompt-fields">
                            <div class="prompt-template-meta" id="promptTemplateMeta">Mod√®le : ‚Äî</div>
                            <textarea id="promptCreate" class="ia-prompt-field" rows="10"
                                placeholder="D√©cris le contexte, les objectifs et les interlocuteurs."></textarea>
                        </div>
                    </div>
                    <div class="header-row ia-header-actions gutenberg-script">
                        <div class="gutenberg-recette-header">
                            <label for="promptModify"
                                style="margin-top:0;display:block;font-size:13px;color:var(--muted)">Script
                                (JSON)</label>
                            <button class="btn" type="button" id="applyScriptBtn"
                                title="Restaurer la derni√®re r√©ponse IA">‚Ü∫ Restaurer</button>
                        </div>
                        <div class="ia-prompt-fields">
                            <textarea id="promptModify" class="ia-prompt-field" rows="16"
                                placeholder='{"title": "...", "subjects": [...]}'></textarea>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="modal-overlay gt-prompt-modal" id="gtPromptModal" role="dialog" aria-modal="true"
            aria-labelledby="gtPromptModalTitle">
            <div class="modal">
                <div class="modal-header" style="display:flex;align-items:center;justify-content:space-between;">
                    <h3 id="gtPromptModalTitle" title="‚åò Prompt">‚åò Prompt</h3>
                    <button class="modal-close btn" id="gtPromptModalClose" type="button"
                        aria-label="Fermer l'IA">√ó</button>
                </div>
                <div class="ia-actions">
                    <div class="header-row ia-header-actions">
                        <div style="display:flex;align-items:center;gap:8px;justify-content:space-between;">
                            <label for="iaTemplateEditor" style="margin:0;">Prompt</label>
                            <select id="iaPromptSelect" style="min-width:160px;">
                                <option value="system">Trame</option>
                                <option value="evaluate">√âvaluation</option>
                                <option value="summary">R√©sum√©</option>
                            </select>
                        </div>
                        <textarea id="iaTemplateEditor" rows="14"
                            style="font-family: Menlo, Consolas, 'Courier New', monospace; font-size:13px; line-height:1.2; height:320px; overflow:auto; resize:vertical; padding:8px;"></textarea>
                    </div>
                    <div class="modal-actions" style="display:flex;justify-content:flex-end;gap:8px;">
                        <button id="iaResetBtn" class="btn" type="button">R√©initialiser</button>
                        <button id="iaApplyBtn" class="btn-primary" type="button">Appliquer</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="infoPopup" class="info-popup" role="dialog" aria-live="polite">
            <img src="logo.gif" alt="Logo Go-Toolkit">
            <strong>Module Voice (Goal Digger)</strong>
            <span>Version 2025.12.25.1</span>
            <span>D√©velopp√© par Quang TRAN.</span>
            <span>Usage r√©serv√© √† Savane Consulting.</span>
            <div class="info-actions">
                <button id="updateAppBtn" type="button" class="update-btn">R√©initialiser</button>
                <button id="tourReplayBtn" type="button" class="secondary">Tour guid√©</button>
            </div>
        </div>

        <div data-toast-slot="copyToast" data-toast-class="toast" data-toast-aria-live="polite"
            data-toast-aria-atomic="true"></div>
    </div>

    <input id="importJsonInput" type="file" accept="application/json" hidden />

    <script>
        window.GO_TOOLKIT_SHARE_API_URL =
            window.GO_TOOLKIT_SHARE_API_URL || "https://share.gotoolkit.workers.dev/";
    </script>
    <script src="js/idb-doc-store.js"></script>
    <script src="js/storage-service.js"></script>
    <script src="js/shared-ui.js"></script>
    <script src="js/share-worker-client.js"></script>
    <script src="js/share-history.js"></script>
    <script src="js/capsule-drafts.js"></script>
    <script src="js/ia-config.js"></script>
    <script src="js/prompt.js?v=2025.12.25.1"></script>
    <script src="js/ia-client.js"></script>

    <script>
        (() => {
            const STORAGE_KEY = "voice-capsule";
            const FIRESTORE_COLLECTION = "voices";
            const SHARE_QUERY_PARAM = "share";
            const SPEECH_ENGINE_STORAGE_KEY = "go-toolkit-speech-engine";
            const VOICE_TRANSCRIPTION_MODE_STORAGE = "go-toolkit-voice-transcription-mode";
            const ASSEMBLY_AI_KEY_STORAGE = "go-toolkit-assemblyai-key";
            const ASSEMBLY_PROXY_TOKEN_URL = (window.GO_TOOLKIT_ASSEMBLYAI_TOKEN_URL || "https://assemblyai-token.gotoolkit.workers.dev/token").replace(/\/$/, "");
            const ASSEMBLY_PROXY_BASE_URL = ASSEMBLY_PROXY_TOKEN_URL.replace(/\/token\/?$/i, "").replace(/\/$/, "") || ASSEMBLY_PROXY_TOKEN_URL;
            const NOTE_MODE_NOTE = "note";
            const NOTE_MODE_TRANSCRIPT_AUTO = "transcript-auto";
            const NOTE_MODE_TRANSCRIPT_IA = "transcript-ia";
            const templateList = (window.GoPrompts && window.GoPrompts.voicePrompts) || [];
            const defaultSystemPrompt =
                (window.GoPrompts && window.GoPrompts.voiceCreateSystemTemplate) ||
                (document.getElementById("iaTemplateEditor")?.value || "");
            const defaultEvaluatePrompt =
                (window.GoPrompts && window.GoPrompts.voiceEvaluatePrompt) ||
                `Analyse la transcription et indique si chaque phrase cl√© est exprim√©e directement, partiellement ou absente. R√©ponds en JSON: { subjects: [{ title, keySentences: [{ text, match: "direct"|"partiel"|"missing" }] }]}.`;
            const defaultSummaryPrompt =
                (window.GoPrompts && window.GoPrompts.voiceSummaryPrompt) ||
                `En t'appuyant sur le mod√®le "{{template_text}}", produis un r√©sum√© bref en fran√ßais du contenu suivant : {{transcript_content}}. Mets en avant les d√©cisions, actions et points ouverts en 5 phrases maximum.`;
            const promptDefaults = {
                system: defaultSystemPrompt || "",
                evaluate: defaultEvaluatePrompt,
                summary: defaultSummaryPrompt
            };
            const promptState = { ...promptDefaults };
            let activeIaPrompt = "system";
            let activeRequestId = null;
            let activeRequestController = null;
            let respondCountdownTimer = null;
            const subjectModal = document.createElement("div");
            subjectModal.className = "modal-overlay";
            subjectModal.setAttribute("role", "dialog");
            subjectModal.setAttribute("aria-hidden", "true");
            subjectModal.innerHTML = `<div class="modal" style="max-width:800px;">
                <div class="modal-header" style="display:flex;align-items:center;justify-content:space-between;">
                    <h3>Sujet</h3>
                    <button type="button" class="btn" id="closeSubjectModal">√ó</button>
                </div>
                <div style="display:flex;flex-direction:column;gap:8px;">
                    <label style="font-size:13px;">Titre du sujet
                        <input id="newSubjectTitle" type="text" placeholder="Sujet 1" style="width:100%;border:1px solid var(--border-strong);border-radius:10px;padding:6px 8px;">
                    </label>
                    <label style="font-size:13px;">Dur√©e (min)
                        <input id="newSubjectDuration" type="number" min="1" max="90" value="15" style="width:100%;border:1px solid var(--border-strong);border-radius:10px;padding:6px 8px;">
                    </label>
                    <label style="font-size:13px;">3 √† 5 points cl√©s (s√©par√©s par des retours √† la ligne)
                        <textarea id="newSubjectPoints" rows="5" style="border:1px solid var(--border-strong);border-radius:10px;padding:6px 8px;overflow:hidden;"></textarea>
                    </label>
                </div>
                <div class="modal-actions" style="display:flex;justify-content:flex-end;gap:8px;margin-top:10px;">
                    <button type="button" class="btn" id="cancelSubjectModal" style="display:none;">Supprimer</button>
                    <button type="button" class="btn-primary" id="confirmSubjectModal">Ajouter</button>
                </div>
            </div>`;
            document.body.appendChild(subjectModal);
            const enforceSubjectPointsLimit = () => {
                const el = document.getElementById("newSubjectPoints");
                if (!el) return;
                const lines = (el.value || "").split(/\r?\n/).slice(0, 5);
                const next = lines.join("\n");
                if (next !== el.value) {
                    const pos = el.selectionStart;
                    el.value = next;
                    if (typeof pos === "number") {
                        const clampedPos = Math.min(pos, next.length);
                        el.selectionStart = clampedPos;
                        el.selectionEnd = clampedPos;
                    }
                }
            };
            enforceSubjectPointsLimit();
            document.getElementById("newSubjectPoints")?.addEventListener("input", enforceSubjectPointsLimit);
            const templateModalOverlay = document.getElementById("gtTemplateModal");
            const templateModalList = document.getElementById("gtTemplateModalList");
            const templateModalClose = document.getElementById("gtTemplateModalClose");
            const templateModalValidate = document.getElementById("gtTemplateModalApply");
            const openTemplateModalBtn = document.getElementById("gtTemplateModalTrigger");
            const promptTemplateMeta = document.getElementById("promptTemplateMeta");
            const openContextModalBtn = document.getElementById("gtContextModalTrigger");
            const contextPanel = document.getElementById("gtContextModal");
            const appMain = document.querySelector(".app-main");
            const openIaModalBtn = document.getElementById("gtPromptModalTrigger");
            const iaModalOverlay = document.getElementById("gtPromptModal");
            const iaModalClose = document.getElementById("gtPromptModalClose");
            const iaApplyBtn = document.getElementById("iaApplyBtn");
            const iaResetBtn = document.getElementById("iaResetBtn");
            const iaPromptSelect = document.getElementById("iaPromptSelect");
            const iaTemplateEditor = document.getElementById("iaTemplateEditor");
            const promptCreate = document.getElementById("promptCreate");
            const promptModify = document.getElementById("promptModify");
            const respondBtn = document.getElementById("respondBtn");
            const respondDefaultLabel = respondBtn?.textContent || "‚åò R√©pondre";
            const clearScenarioBtn = document.getElementById("clearScenarioBtn");
            const applyScriptBtn = document.getElementById("applyScriptBtn");
            const transcribeInput = document.getElementById("transcribeInput");
            const transcribeGhost = document.getElementById("transcribeGhost");
            const transcribeMirror = document.getElementById("transcribeMirror");
            const speechToggleBtn = document.getElementById("speechToggleBtn");
            const audioImportBtn = document.getElementById("audioImportBtn");
            const audioImportInput = document.getElementById("audioImportInput");
            const summarizeBtn = document.getElementById("summarizeBtn");
            const summaryTextarea = document.getElementById("summaryTextarea");
            const noteModeSelect = document.getElementById("noteModeSelect");
            const audioPlayBtn = document.getElementById("audioPlayBtn");
            const audioProgress = document.getElementById("audioProgress");
            const audioSpeedSelect = document.getElementById("audioSpeedSelect");
            const audioDownloadBtn = document.getElementById("audioDownloadBtn");
            const audioClearBtn = document.getElementById("audioClearBtn");
            const recordBtn = document.getElementById("recordBtn");
            const pauseBtn = document.getElementById("pauseBtn");
            const recordStatus = document.getElementById("recordStatus");
            const transcriptMeta = document.getElementById("transcriptMeta");
            const pageTitleEl = document.getElementById("pageTitle");
            const subjectTabs = document.getElementById("subjectTabs");
            const subjectRanges = document.getElementById("subjectRanges");
            const guidelineList = document.getElementById("guidelineList");
            const guidelineMeta = document.getElementById("guidelineMeta");
            let guidelineDuration = document.getElementById("guidelineDuration");
            const addSubjectBtn = document.getElementById("addSubjectBtn");
            const evaluateBtn = document.getElementById("evaluateBtn");
            const refreshFromScriptBtn = document.getElementById("refreshFromScriptBtn");
            const fileMenuBtn = document.getElementById("fileMenuBtn");
            const fileMenu = document.getElementById("fileMenu");
            const optionsMenu = document.getElementById("optionsMenu");
            const newDocumentBtn = document.getElementById("newDocumentBtn");
            const importJsonBtn = document.getElementById("importJsonBtn");
            const importJsonInput = document.getElementById("importJsonInput");
            const saveDocumentBtn = document.getElementById("saveDocumentBtn");
            const exportJsonBtn = document.getElementById("exportJsonBtn");
            const aboutVoiceBtn = document.getElementById("aboutVoiceBtn");
            const infoPopup = document.getElementById("infoPopup");
            const infoButton = aboutVoiceBtn;
            const updateAppBtn = document.getElementById("updateAppBtn");
            const tourReplayBtn = document.getElementById("tourReplayBtn");
            const viewTabs = document.getElementById("viewTabs");
            const addViewBtn = document.getElementById("addViewBtn");
            const deleteViewBtn = document.getElementById("deleteViewBtn");
            const navSwitcherBtn = document.getElementById("navSwitcherBtn");
            const navSwitcherMenu = document.getElementById("navSwitcherMenu");
            const shareBtn = document.getElementById("shareBtn");
            const shareMenu = document.getElementById("shareMenu");
            const shareLinkField = document.getElementById("shareLinkField");
            const shareCreateBtn = document.getElementById("shareCreateBtn");
            const shareUpdateBtn = document.getElementById("shareUpdateBtn");
            const shareMenuStatus = document.getElementById("shareMenuStatus");
            const copyToast = document.getElementById("copyToast");
            const shareHistory = window.goToolkitShareHistory;
            const shareWorkerService = window.goToolkitShareWorker;
            const capsuleDrafts = window.goToolkitCapsuleDrafts;
            const subjectModalOverlay = subjectModal;

            let selectedTemplateId = null;
            let selectedTemplateText = "";
            let speechRecognition = null;
            let recognitionActive = false;
            let recognitionPaused = false;
            let transcriptPrefix = "";
            let recordingStartedAt = null;
            let recordingTimer = null;
            let recordingBaseElapsedSec = 0;
            let recordingElapsedSec = 0;
            let lastInterim = "";
            let lastCaret = 0;
            let lastTimestampMinute = null;
            let pendingTimestamp = null;
            let currentShareToken = null;
            let shareLoadedFromRemote = false;
            let shareStatusMessage = "";
            let shareStatusType = "";
            let shareRequestInProgress = false;
            let shareLastUpdatedAt = null;
            let assemblyRequestInProgress = false;
            const SELF_PARTICIPANT_KEY = "go-toolkit-voice-self";
            const DEFAULT_SUBJECT_DURATION = 15;
            const MIN_SUBJECT_MINUTES = 10;
            const MAX_SUBJECT_MINUTES = 90;
            const MAX_PARTICIPANTS = 8;
            const setSpeechButtonState = isActive => {
                const btn = speechToggleBtn || recordBtn || pauseBtn;
                if (btn) {
                    btn.classList.toggle("speech-button--active", Boolean(isActive));
                }
                if (transcribeInput) {
                    transcribeInput.classList.toggle("speech-active", Boolean(isActive));
                }
            };
            const AUDIO_DB = {
                name: "go-toolkit-voice-audio",
                store: "recordings",
                key: "latest"
            };
            let mediaRecorder = null;
            let mediaStream = null;
            let audioChunks = [];
            let recordingSegments = [];
            let audioRecordingActive = false;
            let audioBlob = null;
            let audioUrl = null;
            const audioPlayer = new Audio();
            let audioDbPromise = null;

            function getStoredSelfParticipant() {
                try {
                    const raw = localStorage.getItem(SELF_PARTICIPANT_KEY);
                    if (!raw) return null;
                    const parsed = JSON.parse(raw);
                    if (parsed && typeof parsed === "object") {
                        return {
                            name: parsed.name || "",
                            role: parsed.role || ""
                        };
                    }
                } catch (e) { /* noop */ }
                return null;
            }

            function saveSelfParticipant(participant) {
                if (!participant) return;
                try {
                    const payload = {
                        name: participant.name || "",
                        role: participant.role || ""
                    };
                    localStorage.setItem(SELF_PARTICIPANT_KEY, JSON.stringify(payload));
                } catch (e) { /* noop */ }
            }

            function ensureParticipants(list) {
                let arr = Array.isArray(list) ? list.map(p => ({ name: p?.name || "", role: p?.role || "" })) : [];
                arr = arr.slice(0, MAX_PARTICIPANTS);
                while (arr.length < 2) {
                    arr.push({ name: "", role: "" });
                }
                if (arr.length > MAX_PARTICIPANTS) {
                    arr = arr.slice(0, MAX_PARTICIPANTS);
                }
                return arr;
            }

            const defaultPage = () => {
                const self = getStoredSelfParticipant();
                return {
                    id: crypto.randomUUID ? crypto.randomUUID() : String(Date.now()),
                    title: "Page 1",
                    tabLabel: "Page 1",
                    scenario: "",
                    script: "",
                    transcript: "",
                    summary: "",
                    templateId: "",
                    templateName: "",
                    subjects: [],
                    duration: null,
                    participants: [
                        self || { name: "", role: "" },
                        { name: "", role: "" }
                    ],
                    manualTranscript: "",
                    assemblyTranscript: "",
                    noteMode: NOTE_MODE_NOTE,
                    lastIaResponse: "",
                    activeSubjectId: null,
                    checks: {}
                };
            };

            function normalizeState(raw) {
                if (!raw || !Array.isArray(raw.pages)) return raw;
                raw.pages = raw.pages.map(p => {
                    const next = { ...p };
                    next.participants = ensureParticipants(next.participants);
                    if (!next.tabLabel) next.tabLabel = next.title || next.label || "Page";
                    if (typeof next.lastIaResponse !== "string") next.lastIaResponse = "";
                    if (typeof next.summary !== "string") next.summary = "";
                    if (typeof next.templateId !== "string") next.templateId = "";
                    if (typeof next.templateName !== "string") next.templateName = "";
                    if (typeof next.manualTranscript !== "string") next.manualTranscript = next.transcript || "";
                    if (typeof next.assemblyTranscript !== "string") next.assemblyTranscript = "";
                    if (!next.noteMode) next.noteMode = NOTE_MODE_NOTE;
                    return next;
                });
                if (!raw.activePageId && raw.pages[0]) raw.activePageId = raw.pages[0].id;
                return raw;
            }

            let state = (() => {
                try {
                    const stored = localStorage.getItem(STORAGE_KEY);
                    if (stored) {
                        const parsed = JSON.parse(stored);
                        if (parsed && Array.isArray(parsed.pages) && parsed.pages.length) {
                            return normalizeState(parsed);
                        }
                    }
                } catch (err) {
                    console.warn("Impossible de charger l'√©tat Voice", err);
                }
                return { pages: [defaultPage()], activePageId: null };
            })();

            if (!state.activePageId && state.pages[0]) {
                state.activePageId = state.pages[0].id;
            }

            function persistState() {
                try {
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
                } catch (err) {
                    console.warn("Impossible de persister la capsule Voice", err);
                }
            }

            function showToast(message, isError) {
                if (!copyToast) return;
                copyToast.textContent = message;
                copyToast.style.background = "rgba(17, 24, 39, 0.9)";
                copyToast.classList.add("visible");
                setTimeout(() => copyToast.classList.remove("visible"), 2600);
            }

            function setShareStatus(message, type) {
                shareStatusMessage = message || "";
                shareStatusType = type || "";
            }

            function formatRelativeTime(value) {
                if (!value) return "";
                try {
                    const timestamp = new Date(value).getTime();
                    if (Number.isNaN(timestamp)) return "";
                    const deltaSeconds = Math.max(0, Math.floor((Date.now() - timestamp) / 1000));
                    if (deltaSeconds < 60) {
                        return "Mis √† jour √† l'instant";
                    }
                    const deltaMinutes = Math.floor(deltaSeconds / 60);
                    if (deltaMinutes < 60) {
                        return `Mis √† jour il y a ${deltaMinutes} minute${deltaMinutes > 1 ? "s" : ""}`;
                    }
                    const deltaHours = Math.floor(deltaMinutes / 60);
                    if (deltaHours < 24) {
                        return `Mis √† jour il y a ${deltaHours} heure${deltaHours > 1 ? "s" : ""}`;
                    }
                    const deltaDays = Math.floor(deltaHours / 24);
                    return `Mis √† jour il y a ${deltaDays} jour${deltaDays > 1 ? "s" : ""}`;
                } catch (err) {
                    return "";
                }
            }

            function buildShareUrl(token) {
                if (!token || !shareWorkerService) return "";
                return `${shareWorkerService.baseUrl}/${shareWorkerService.version}/shares/${FIRESTORE_COLLECTION}/${token}`;
            }

            function updateShareMenuUI() {
                const hasToken = Boolean(currentShareToken);
                if (shareLinkField) {
                    shareLinkField.value = hasToken ? buildShareUrl(currentShareToken) : "";
                    shareLinkField.placeholder = hasToken ? "" : "Appuie sur Cr√©er pour g√©n√©rer un lien priv√©.";
                }
                if (shareCreateBtn) {
                    shareCreateBtn.disabled = shareRequestInProgress || !shareWorkerService?.isReady;
                    shareCreateBtn.classList.toggle("btn-primary", !hasToken);
                    shareCreateBtn.classList.toggle("btn", hasToken);
                }
                if (shareUpdateBtn) {
                    const showUpdate = hasToken;
                    shareUpdateBtn.hidden = !showUpdate;
                    shareUpdateBtn.style.display = showUpdate ? "" : "none";
                    shareUpdateBtn.setAttribute("aria-hidden", String(!showUpdate));
                    shareUpdateBtn.disabled = shareRequestInProgress || !hasToken || !shareWorkerService?.isReady;
                }
                if (shareMenuStatus) {
                    const text = shareStatusMessage ||
                        (!shareWorkerService?.isReady
                            ? "Le partage priv√© n√©cessite le worker Cloudflare."
                            : shareLastUpdatedAt
                                ? formatRelativeTime(shareLastUpdatedAt)
                                : "Seules les personnes disposant du lien peuvent y acc√©der.");
                    shareMenuStatus.textContent = text;
                    const isError =
                        (shareStatusType === "error" && Boolean(text)) ||
                        (!shareWorkerService?.isReady && !shareStatusMessage);
                    shareMenuStatus.classList.toggle("error", isError);
                }
            }

            function getActivePage() {
                return state.pages.find(p => p.id === state.activePageId) || state.pages[0];
            }

            function setActivePage(id) {
                state.activePageId = id;
                persistState();
                renderTabs();
                renderPage();
            }

            function addPage() {
                const nextIndex = state.pages.length + 1;
                const page = defaultPage();
                page.title = `Page ${nextIndex}`;
                page.tabLabel = page.title;
                state.pages.push(page);
                setActivePage(page.id);
                openTemplateModal();
            }

            function deletePage() {
                if (state.pages.length <= 1) return;
                state.pages = state.pages.filter(p => p.id !== state.activePageId);
                state.activePageId = state.pages[0]?.id || null;
                persistState();
                renderTabs();
                renderPage();
            }

            function renderTabs() {
                if (!viewTabs) return;
                viewTabs.innerHTML = "";
                state.pages.forEach((page, idx) => {
                    if (!page.tabLabel) {
                        page.tabLabel = page.title || `Page ${idx + 1}`;
                    }
                    const btn = document.createElement("button");
                    btn.className = "tab" + (page.id === state.activePageId ? " active" : "");
                    btn.type = "button";
                    btn.textContent = page.tabLabel || page.title || "Page";
                    btn.addEventListener("click", () => setActivePage(page.id));
                    btn.addEventListener("dblclick", () => {
                        const next = prompt("Renommer l'onglet ?", page.tabLabel || page.title || "");
                        if (next && next.trim()) {
                            page.tabLabel = next.trim();
                            persistState();
                            renderTabs();
                        }
                    });
                    viewTabs.appendChild(btn);
                });
            }

            function updateTranscriptMeta() {
                if (!transcribeInput || !transcriptMeta) return;
                const formatTime = secs => {
                    const total = Math.max(0, Math.floor(secs || 0));
                    const m = Math.floor(total / 60);
                    const s = total % 60;
                    return `${m}'${String(s).padStart(2, "0")}"`;
                };
                const page = getActivePage();
                const hasAudio = audioUrl && !Number.isNaN(audioPlayer?.duration || NaN) && (audioPlayer?.duration || 0) > 0;
                if (hasAudio) {
                    const current = Math.floor(audioPlayer.currentTime || 0);
                    const totalAudio = Math.floor(audioPlayer.duration || 0);
                    transcriptMeta.textContent = `${formatTime(current)} / ${formatTime(totalAudio)}`;
                    return;
                }
                const totalMinutes = page?.duration
                    ? Number(page.duration)
                    : (page?.subjects?.length || 0) * DEFAULT_SUBJECT_DURATION;
                const totalSeconds = Math.max(0, Math.floor((totalMinutes || 0) * 60));
                const elapsedSec = recordingElapsedSec || 0;
                transcriptMeta.textContent = `${formatTime(elapsedSec)} / ${formatTime(totalSeconds)}`;
            }

            function getLastTimestampMinuteFromTranscript(text = "") {
                const regex = /\[(\d{2,}):(\d{2})\]/g;
                let match = null;
                let last = null;
                while ((match = regex.exec(text)) !== null) {
                    const mins = Number(match[1]);
                    const secs = Number(match[2]);
                    if (!Number.isNaN(mins) && !Number.isNaN(secs)) {
                        last = Math.floor((mins * 60 + secs) / 60);
                    }
                }
                return last;
            }

            function updateGhostOverlay(interimText = "") {
                if (!transcribeInput || !transcribeGhost || !transcribeMirror) return;
                const ghostText = interimText || "";
                if (!ghostText) {
                    transcribeGhost.textContent = "";
                    transcribeGhost.style.transform = "translate(0, 0)";
                    return;
                }
                const styles = window.getComputedStyle(transcribeInput);
                transcribeMirror.style.fontSize = styles.fontSize;
                transcribeMirror.style.lineHeight = styles.lineHeight;
                transcribeMirror.style.width = `${transcribeInput.clientWidth}px`;
                transcribeMirror.textContent = "";
                const before = document.createElement("span");
                const caret = document.createElement("span");
                caret.textContent = "\u200b";
                before.textContent = (transcribeInput.value || "").slice(0, transcribeInput.selectionStart || 0);
                transcribeMirror.append(before, caret);
                const caretRect = caret.getBoundingClientRect();
                const inputRect = transcribeInput.getBoundingClientRect();
                const paddingLeft = parseFloat(styles.paddingLeft) || 0;
                const paddingTop = parseFloat(styles.paddingTop) || 0;
                const left = caretRect.left - inputRect.left + transcribeInput.scrollLeft - paddingLeft + 5;
                const top = caretRect.top - inputRect.top + transcribeInput.scrollTop - paddingTop + 2;
                transcribeGhost.textContent = ghostText;
                transcribeGhost.style.transform = `translate(${left}px, ${top}px)`;
            }

            function updateRangeVisual(rangeInput, totalDurationMinutes = 0) {
                if (!rangeInput) return;
                const total = Math.max(1, Number(totalDurationMinutes) || 1);
                const progressRatio = Math.min(1, Math.max(0, (recordingElapsedSec / 60) / total));
                const pct = progressRatio * 100;
                if (pct <= 0.001) {
                    rangeInput.style.background = "#e5e7eb";
                } else {
                    rangeInput.style.background = `linear-gradient(to right, var(--primary) 0%, var(--primary) ${pct}%, #e5e7eb ${pct}%, #e5e7eb 100%)`;
                }
            }

            function updateRecordingUi() {
                updateTranscriptMeta();
                const page = getActivePage();
                const total = page?.duration || 0;
                const activeRange = subjectRanges?.querySelector('input[type="range"]');
                if (activeRange) {
                    updateRangeVisual(activeRange, total);
                }
            }

            function addDefaultSubjectsIfEmpty(page) {
                if (!page || (page.subjects && page.subjects.length)) return;
                page.subjects = [
                    {
                        id: "subject-1",
                        title: "Sujet 1",
                        timeframe: { start: 0, end: DEFAULT_SUBJECT_DURATION },
                        keySentences: [{ text: "Point 1.1", match: "pending" }, { text: "Point 1.2", match: "pending" }]
                    },
                    {
                        id: "subject-2",
                        title: "Sujet 2",
                        timeframe: { start: DEFAULT_SUBJECT_DURATION, end: DEFAULT_SUBJECT_DURATION * 2 },
                        keySentences: [{ text: "Point 2.1", match: "pending" }, { text: "Point 2.2", match: "pending" }]
                    }
                ];
                page.activeSubjectId = page.subjects[0].id;
            }

            function normalizeSubjects(raw = []) {
                return raw.map((subject, index) => {
                    const keySentences = (subject["key-sentences"] || subject.keySentences || subject.key_sentence || subject.sentences || [])
                        .map((entry, idx) => {
                            if (typeof entry === "string") return { text: entry, match: "pending" };
                            if (entry && typeof entry === "object") {
                                return {
                                    text: entry.text || entry.label || entry.sentence || `Point ${idx + 1}`,
                                    match: entry.match || entry.status || "pending"
                                };
                            }
                            return { text: `Point ${idx + 1}`, match: "pending" };
                        })
                        .filter(item => item.text && item.text.trim());
                    return {
                        id: subject.id || `subject-${index + 1}`,
                        title: subject.title || subject.name || `Sujet ${index + 1}`,
                        timeframe: subject.timeframe || subject["time-frame"] || {},
                        keySentences
                    };
                });
            }

            function buildScriptPayloadFromPage(page) {
                if (!page) return null;
                const subjects = (page.subjects || []).map((subject, index) => {
                    const timeframe = subject.timeframe || {};
                    const start = Number.isFinite(timeframe.start) ? timeframe.start : index * DEFAULT_SUBJECT_DURATION;
                    let end = Number.isFinite(timeframe.end) ? timeframe.end : start + DEFAULT_SUBJECT_DURATION;
                    if (end <= start) {
                        end = start + DEFAULT_SUBJECT_DURATION;
                    }
                    const keySentences = (subject.keySentences || []).map(entry => ({
                        text: entry?.text || entry?.label || entry?.sentence || "",
                        match: entry?.match === "direct"
                            ? "direct"
                            : entry?.match === "partiel"
                                ? "partiel"
                                : "missing"
                    })).filter(item => item.text);
                    const title = subject.title || subject.name || `Sujet ${index + 1}`;
                    return {
                        label: title,
                        title,
                        timeframe: { start, end },
                        keySentences
                    };
                });
                const maxEnd = subjects.reduce((max, subject) => Math.max(max, subject.timeframe?.end || 0), 0);
                const pageDuration = Number(page.duration);
                const duration = Number.isFinite(pageDuration) && pageDuration > 0 ? pageDuration : (maxEnd || DEFAULT_SUBJECT_DURATION);
                const participants = (page.participants || [])
                    .map(participant => ({ name: participant?.name || "", role: participant?.role || "" }))
                    .filter(participant => participant.name || participant.role);
                if (!participants.length && Array.isArray(page.participants) && page.participants.length) {
                    const fallback = page.participants[0];
                    participants.push({ name: fallback?.name || "", role: fallback?.role || "" });
                }
                return {
                    title: page.title || "",
                    duration,
                    participants,
                    subjects
                };
            }

            function exportPageStateToScriptField() {
                if (!promptModify) return;
                const page = getActivePage();
                if (!page) return;
                const payload = buildScriptPayloadFromPage(page);
                if (!payload) return;
                const formattedScript = JSON.stringify(payload, null, 2);
                promptModify.value = formattedScript;
                page.script = formattedScript;
                persistState();
            }

            function applyScriptJson(text) {
                if (!text) return null;
                const cleaned = text.trim().replace(/^```(?:json)?/i, "").replace(/```$/i, "").trim();
                const parsed = JSON.parse(cleaned);
                const page = getActivePage();
                if (!page) return null;
                if (parsed.title) page.title = parsed.title;
                if (Array.isArray(parsed.subjects)) {
                    page.subjects = normalizeSubjects(parsed.subjects);
                    page.activeSubjectId = page.subjects[0]?.id || null;
                }
                if (parsed.duration) page.duration = parsed.duration;
                if (Array.isArray(parsed.participants)) page.participants = ensureParticipants(parsed.participants);
                else page.participants = ensureParticipants(page.participants);
                if (parsed.transcript && typeof parsed.transcript === "string") {
                    page.transcript = parsed.transcript;
                    if (transcribeInput) transcribeInput.value = parsed.transcript;
                }
                if (parsed.summary && typeof parsed.summary === "string") {
                    page.summary = parsed.summary;
                    if (summaryTextarea) summaryTextarea.value = parsed.summary;
                }
                page.script = JSON.stringify(parsed, null, 2);
                persistState();
                renderPage();
                return parsed;
            }

            function openSubjectModal(subjectId) {
                const page = getActivePage();
                if (!page) return;
                const subject = page.subjects?.find(s => s.id === subjectId);
                const titleInput = document.getElementById("newSubjectTitle");
                const durationInput = document.getElementById("newSubjectDuration");
                const pointsInput = document.getElementById("newSubjectPoints");
                const confirmBtn = document.getElementById("confirmSubjectModal");
                const heading = subjectModalOverlay?.querySelector(".modal-header h3");
                if (heading) heading.textContent = subject ? "√âditer un sujet" : "Ajouter un sujet";
                if (confirmBtn) confirmBtn.textContent = subject ? "Mettre √† jour" : "Ajouter";
                if (titleInput) titleInput.value = subject?.title || "";
                if (durationInput) durationInput.value = subject ? (subject.timeframe?.end || DEFAULT_SUBJECT_DURATION) - (subject.timeframe?.start || 0) : String(DEFAULT_SUBJECT_DURATION);
                if (pointsInput) pointsInput.value = (subject?.keySentences || []).map(k => k.text || "").join("\n");
                confirmBtn.dataset.subjectId = subject?.id || "";
                subjectModalOverlay?.classList.add("open");
                subjectModalOverlay?.setAttribute("aria-hidden", "false");
            }

            function renderGuidelines() {
                const page = getActivePage();
                if (!page) return;
                addDefaultSubjectsIfEmpty(page);
                page.participants = ensureParticipants(page.participants);
                const subjects = page.subjects || [];
                const totalDuration = page.duration || (subjects.length * DEFAULT_SUBJECT_DURATION);
                let rollingEnd = 0;
                const minDurationClamp = Math.max(0, totalDuration - 1);
                subjects.forEach((subject, idx) => {
                    const start = Math.min(idx === 0 ? 0 : rollingEnd, minDurationClamp);
                    const existingDuration = (typeof subject.timeframe?.end === "number" && typeof subject.timeframe?.start === "number")
                        ? Math.max(1, subject.timeframe.end - subject.timeframe.start)
                        : DEFAULT_SUBJECT_DURATION;
                    let end = typeof subject.timeframe?.end === "number" ? subject.timeframe.end : start + existingDuration;
                    end = Math.min(totalDuration, Math.max(start + 1, end));
                    if (idx === subjects.length - 1) {
                        end = totalDuration || Math.max(start + 1, DEFAULT_SUBJECT_DURATION);
                        if (end <= start) {
                            start = Math.max(0, end - 1);
                        }
                    }
                    subject.timeframe = { start, end };
                    rollingEnd = end;
                });
                function getSubjectStart(idx) {
                    if (idx === 0) return 0;
                    const prev = subjects[idx - 1];
                    return prev && typeof prev.timeframe?.end === "number" ? prev.timeframe.end : getSubjectStart(idx - 1) + DEFAULT_SUBJECT_DURATION;
                }
                if (subjectTabs) {
                    subjectTabs.innerHTML = "";
                    subjects.forEach(subject => {
                        const matched = (subject.keySentences || []).filter(item => item.match === "direct" || item.match === "partiel").length;
                        const total = subject.keySentences?.length || 0;
                        let statusClass = "status-dot status-dot--none";
                        if (matched > 0 && matched < total) {
                            statusClass = "status-dot status-dot--partial";
                        } else if (matched > 0 && matched === total) {
                            statusClass = "status-dot status-dot--complete";
                        }
                        const tab = document.createElement("button");
                        tab.className = "subject-tab" + (subject.id === page.activeSubjectId ? " active" : "");
                        tab.type = "button";
                        tab.innerHTML = `<div style="display:flex;flex-direction:column;align-items:flex-start;gap:4px;width:100%;">
<span style="display:flex;align-items:center;gap:8px;justify-content:space-between;width:100%;"><span><span class="${statusClass}" aria-hidden="true"></span>${subject.title}</span><span class="edit-subject-btn" role="button" data-id="${subject.id}" title="√âditer">‚úé</span></span>
</div>`;
                        tab.addEventListener("click", () => {
                            page.activeSubjectId = subject.id;
                            persistState();
                            renderGuidelines();
                        });
                        subjectTabs.appendChild(tab);
                    });
                    subjectTabs.querySelectorAll(".edit-subject-btn").forEach(btn => {
                        btn.addEventListener("click", ev => {
                            ev.stopPropagation();
                            const id = btn.getAttribute("data-id");
                            openSubjectModal(id);
                        });
                    });
                }

                const activeSubject =
                    subjects.find(s => s.id === page.activeSubjectId) || subjects[0] || null;
                if (!page.activeSubjectId && activeSubject) {
                    page.activeSubjectId = activeSubject.id;
                }

                if (guidelineMeta) {
                    guidelineMeta.innerHTML = "";
                    const header = document.createElement("div");
                    header.className = "participants-header";
                    const title = document.createElement("div");
                    title.style.fontWeight = "600";
                    title.textContent = "Participants";
                    const addBtn = document.createElement("button");
                    addBtn.type = "button";
                    addBtn.className = "participant-add-btn";
                    addBtn.textContent = "+ Participant";
                    addBtn.addEventListener("click", () => {
                        if (page.participants.length >= MAX_PARTICIPANTS) {
                            showToast(`Maximum ${MAX_PARTICIPANTS} participants.`, true);
                            addBtn.disabled = true;
                            return;
                        }
                        page.participants.push({ name: "", role: "" });
                        persistState();
                        renderGuidelines();
                    });
                    addBtn.disabled = page.participants.length >= MAX_PARTICIPANTS;
                    header.append(title, addBtn);
                    const list = document.createElement("div");
                    list.className = "participants-list";
                    page.participants.forEach((participant, idx) => {
                        const row = document.createElement("div");
                        row.className = "participant-row";
                        const nameInput = document.createElement("input");
                        nameInput.type = "text";
                        nameInput.placeholder = idx === 0 ? "Moi" : `Participant ${idx + 1}`;
                        nameInput.value = participant.name || "";
                        const roleInput = document.createElement("input");
                        roleInput.type = "text";
                        roleInput.placeholder = "R√¥le";
                        roleInput.value = participant.role || "";
                        const deleteBtn = document.createElement("button");
                        deleteBtn.type = "button";
                        deleteBtn.className = "btn";
                        deleteBtn.textContent = "√ó";
                        deleteBtn.style.width = "32px";
                        deleteBtn.addEventListener("click", () => {
                            if (page.participants.length <= 1) return;
                            page.participants.splice(idx, 1);
                            persistState();
                            renderGuidelines();
                        });
                        const save = () => {
                            page.participants[idx] = { name: nameInput.value.trim(), role: roleInput.value.trim() };
                            if (idx === 0) {
                                saveSelfParticipant(page.participants[idx]);
                            }
                            persistState();
                        };
                        nameInput.addEventListener("blur", save);
                        roleInput.addEventListener("blur", save);
                        row.append(nameInput, roleInput, deleteBtn);
                        list.appendChild(row);
                    });
                    guidelineMeta.append(header, list);
                }
                if (!guidelineDuration) {
                    guidelineDuration = document.createElement("select");
                    guidelineDuration.id = "guidelineDuration";
                    guidelineDuration.style.fontSize = "14px";
                    guidelineDuration.style.border = "1px solid var(--border-strong)";
                    guidelineDuration.style.borderRadius = "10px";
                    guidelineDuration.style.padding = "6px 8px";
                }
                guidelineDuration.innerHTML = "";
                for (let min = MIN_SUBJECT_MINUTES; min <= MAX_SUBJECT_MINUTES; min += 5) {
                    const opt = document.createElement("option");
                    opt.value = String(min);
                    opt.textContent = `${min}'`;
                    if (page.duration === min) opt.selected = true;
                    guidelineDuration.appendChild(opt);
                }
                if (!page.duration) {
                    guidelineDuration.value = String(DEFAULT_SUBJECT_DURATION);
                    page.duration = DEFAULT_SUBJECT_DURATION;
                }
                if (!guidelineDuration.dataset.bound) {
                    guidelineDuration.addEventListener("change", () => {
                        const val = Math.min(MAX_SUBJECT_MINUTES, Math.max(MIN_SUBJECT_MINUTES, Number(guidelineDuration.value) || DEFAULT_SUBJECT_DURATION));
                        const currentPage = getActivePage();
                        if (currentPage) {
                            currentPage.duration = val;
                            persistState();
                            renderGuidelines();
                        }
                    });
                    guidelineDuration.dataset.bound = "true";
                }

                if (subjectRanges) {
                    subjectRanges.innerHTML = "";
                    const activeIndex = subjects.findIndex(s => s.id === page.activeSubjectId);
                    const idx = activeIndex >= 0 ? activeIndex : 0;
                    const subject = subjects[idx];
                    const isLast = idx === subjects.length - 1;
                    if (subject) {
                        const prevSubject = isLast && idx > 0 ? subjects[idx - 1] : null;
                        const prevEnd = idx === 0
                            ? 0
                            : Math.max(0, typeof subjects[idx - 1].timeframe?.end === "number"
                                ? subjects[idx - 1].timeframe.end
                                : getSubjectStart(idx));
                        const start = prevEnd;
                        let safeEnd = typeof subject.timeframe?.end === "number" ? subject.timeframe.end : start + DEFAULT_SUBJECT_DURATION;
                        if (isLast) {
                            safeEnd = totalDuration;
                            if (safeEnd <= start) {
                                safeEnd = Math.max(start + 1, totalDuration || start + 1);
                            }
                        } else {
                            safeEnd = Math.min(totalDuration, Math.max(start + 1, safeEnd));
                        }
                        subject.timeframe = { start, end: safeEnd };
                        const row = document.createElement("div");
                        row.className = "subject-range-row";
                        const rangeContainer = document.createElement("div");
                        rangeContainer.style.display = "flex";
                        rangeContainer.style.alignItems = "center";
                        rangeContainer.style.gap = "6px";
                        const rangeInput = document.createElement("input");
                        rangeInput.type = "range";
                        if (isLast && prevSubject) {
                            const minBoundary = Math.min(totalDuration - 1, Math.max((prevSubject.timeframe?.start || 0) + 1, start + 1));
                            const maxBoundary = Math.max(minBoundary, totalDuration - 1);
                            rangeInput.min = String(minBoundary);
                            rangeInput.max = String(maxBoundary);
                            rangeInput.step = "1";
                            rangeInput.value = String(Math.min(maxBoundary, Math.max(minBoundary, prevSubject.timeframe?.end || start + 1)));
                        } else {
                            rangeInput.min = String(start + 1);
                            rangeInput.max = String(Math.max(start + 1, totalDuration));
                            rangeInput.step = "1";
                            rangeInput.value = String(safeEnd);
                        }
                        const meta = document.createElement("div");
                        meta.className = "subject-range-meta";
                        const durationMinutes = Math.max(1, Math.round((safeEnd - start) * 10) / 10);
                        rangeInput.addEventListener("input", () => {
                            if (isLast && prevSubject) {
                                const minBoundary = Number(rangeInput.min);
                                const maxBoundary = Number(rangeInput.max);
                                const boundary = Math.min(maxBoundary, Math.max(minBoundary, Number(rangeInput.value)));
                                prevSubject.timeframe = prevSubject.timeframe || {};
                                prevSubject.timeframe.end = boundary;
                                subject.timeframe.start = boundary;
                                subject.timeframe.end = totalDuration;
                                const dur = Math.max(1, Math.round((subject.timeframe.end - subject.timeframe.start) * 10) / 10);
                                meta.textContent = `${subject.timeframe.start}' ‚Üí ${subject.timeframe.end}'`;
                                if (durationLabel) {
                                    durationLabel.textContent = isNaN(dur) ? "" : `${dur} mn`;
                                }
                            } else {
                                let nextEnd = Number(rangeInput.value);
                                nextEnd = Math.min(totalDuration, Math.max(start + 1, nextEnd));
                                subject.timeframe.end = nextEnd;
                                const dur = Math.max(1, Math.round((nextEnd - start) * 10) / 10);
                                meta.textContent = `${start}' ‚Üí ${nextEnd}'`;
                                if (durationLabel) {
                                    durationLabel.textContent = isNaN(dur) ? "" : `${dur} mn`;
                                }
                                // Propagate start times to following subjects
                                for (let i = idx + 1; i < subjects.length; i++) {
                                    const previous = subjects[i - 1];
                                    const current = subjects[i];
                                    const previousEnd = typeof previous.timeframe?.end === "number"
                                        ? previous.timeframe.end
                                        : previous.timeframe?.start + DEFAULT_SUBJECT_DURATION || 0;
                                    const currentDuration = typeof current.timeframe?.end === "number" && typeof current.timeframe?.start === "number"
                                        ? Math.max(1, current.timeframe.end - current.timeframe.start)
                                        : DEFAULT_SUBJECT_DURATION;
                                    const nextStart = previousEnd;
                                    const nextEndBound = Math.min(totalDuration, Math.max(nextStart + 1, nextStart + currentDuration));
                                    current.timeframe = { start: nextStart, end: nextEndBound };
                                }
                            }
                            persistState();
                            updateRangeVisual(rangeInput, totalDuration);
                        });
                        updateRangeVisual(rangeInput, totalDuration);
                        const initialDuration = Math.max(1, Math.round((safeEnd - start) * 10) / 10);
                        meta.textContent = `${start}' ‚Üí ${safeEnd}'`;
                        const durationLabel = document.createElement("div");
                        durationLabel.className = "subject-range-meta";
                        durationLabel.textContent = isNaN(initialDuration) ? "" : `${initialDuration} mn`;
                        rangeContainer.append(durationLabel, rangeInput, meta);
                        row.append(rangeContainer);
                        subjectRanges.appendChild(row);
                    }
                }

                if (guidelineList) {
                    guidelineList.innerHTML = "";
                    if (!activeSubject) {
                        // no subjects yet
                    } else {
                        activeSubject.keySentences.forEach((item, idx) => {
                            const li = document.createElement("li");
                            li.className = "guideline-item";
                            const title = document.createElement("div");
                            title.textContent = item.text || `Point ${idx + 1}`;
                            const actions = document.createElement("div");
                            actions.className = "guideline-actions";
                            const directId = `${activeSubject.id}-direct-${idx}`;
                            const indirectId = `${activeSubject.id}-partiel-${idx}`;
                            const direct = document.createElement("label");
                            const directInput = document.createElement("input");
                            directInput.type = "checkbox";
                            directInput.id = directId;
                            directInput.checked = item.match === "direct";
                            directInput.addEventListener("change", () => {
                                item.match = directInput.checked ? "direct" : "pending";
                                if (directInput.checked) {
                                    indirectInput.checked = false;
                                }
                                persistState();
                                renderGuidelines();
                            });
                            direct.appendChild(directInput);
                            direct.appendChild(document.createTextNode("Oui"));
                            const indirect = document.createElement("label");
                            const indirectInput = document.createElement("input");
                            indirectInput.type = "checkbox";
                            indirectInput.id = indirectId;
                            indirectInput.checked = item.match === "partiel";
                            indirectInput.addEventListener("change", () => {
                                item.match = indirectInput.checked ? "partiel" : "pending";
                                if (indirectInput.checked) {
                                    directInput.checked = false;
                                }
                                persistState();
                                renderGuidelines();
                            });
                            indirect.appendChild(indirectInput);
                            indirect.appendChild(document.createTextNode("Partiellement"));
                            actions.append(direct, indirect);
                            li.append(title, actions);
                            guidelineList.appendChild(li);
                        });
                    }
                }

                updateRecordingUi();
            }

            function renderPage() {
                const page = getActivePage();
                if (!page) return;
                selectedTemplateId = page.templateId || selectedTemplateId;
                const tplFromState = templateList.find(tpl => tpl.id === page.templateId);
                selectedTemplateText = tplFromState?.text || selectedTemplateText || "";
                if (pageTitleEl) pageTitleEl.textContent = page.title || "Page";
                if (promptCreate) promptCreate.value = page.scenario || "";
                if (promptModify) promptModify.value = page.script || "";
                if (!page.manualTranscript) {
                    page.manualTranscript = page.transcript || "";
                }
                if (!page.noteMode) {
                    page.noteMode = NOTE_MODE_NOTE;
                }
                activeNoteMode = page.noteMode;
                const noteContent = getNoteContentForMode(page, page.noteMode);
                if (transcribeInput) transcribeInput.value = noteContent;
                if (noteModeSelect) noteModeSelect.value = page.noteMode;
                if (summaryTextarea) summaryTextarea.value = page.summary || "";
                if (promptTemplateMeta) {
                    const label = page.templateName || tplFromState?.title || "‚Äî";
                    promptTemplateMeta.textContent = `Mod√®le : ${label}`;
                }
                updateTranscriptMeta();
                renderGuidelines();
            }

            function openTemplateModal() {
                if (!templateModalOverlay) return;
                renderTemplateModalList();
                templateModalOverlay.classList.add("open");
            }

            function closeTemplateModal() {
                templateModalOverlay?.classList.remove("open");
            }

            function renderTemplateModalList() {
                if (!templateModalList) return;
                templateModalList.innerHTML = "";
                templateList.forEach(tpl => {
                    const card = document.createElement("div");
                    card.className = "gt-template-card";
                    card.innerHTML = `<strong style="font-size:13px">${tpl.title}</strong><div style="font-size:12px;color:var(--muted);white-space:pre-wrap;word-break:break-word;margin-top:6px">${tpl.text}</div>`;
                    if (tpl.id === selectedTemplateId) {
                        card.classList.add("gt-template-card--selected");
                    }
                    card.addEventListener("click", () => {
                        selectedTemplateId = tpl.id;
                        Array.from(templateModalList.children).forEach(c => c.classList.remove("gt-template-card--selected"));
                        card.classList.add("gt-template-card--selected");
                    });
                    templateModalList.appendChild(card);
                });
            }

            function applySelectedTemplate() {
                if (!selectedTemplateId || !promptCreate) return;
                const tpl = templateList.find(t => t.id === selectedTemplateId);
                if (!tpl) return;
                selectedTemplateText = tpl.text || "";
                const page = getActivePage();
                if (page) {
                    page.templateId = tpl.id;
                    page.templateName = tpl.title || "";
                    persistState();
                }
                promptTemplateMeta.textContent = `Mod√®le : ${tpl.title}`;
                persistScenario();
                closeTemplateModal();
            }

            function persistScenario() {
                const page = getActivePage();
                if (!page) return;
                page.scenario = promptCreate?.value || "";
                persistState();
            }

            function getAudioDb() {
                if (audioDbPromise) return audioDbPromise;
                audioDbPromise = new Promise((resolve, reject) => {
                    if (!("indexedDB" in window)) {
                        resolve(null);
                        return;
                    }
                    const request = indexedDB.open(AUDIO_DB.name, 1);
                    request.onupgradeneeded = () => {
                        const db = request.result;
                        if (!db.objectStoreNames.contains(AUDIO_DB.store)) {
                            db.createObjectStore(AUDIO_DB.store);
                        }
                    };
                    request.onerror = () => reject(request.error || new Error("IndexedDB audio indisponible"));
                    request.onsuccess = () => resolve(request.result);
                });
                return audioDbPromise;
            }

            async function saveAudioToDb(blob, key = AUDIO_DB.key) {
                try {
                    const db = await getAudioDb();
                    if (!db || !blob) return;
                    const tx = db.transaction(AUDIO_DB.store, "readwrite");
                    const store = tx.objectStore(AUDIO_DB.store);
                    const buffer = await blob.arrayBuffer();
                    store.put({ type: blob.type || "audio/webm", data: buffer }, key);
                } catch (err) {
                    console.warn("Impossible de sauvegarder l'audio", err);
                }
            }

            async function clearAudioDb(key) {
                try {
                    const db = await getAudioDb();
                    if (!db) return;
                    const tx = db.transaction(AUDIO_DB.store, "readwrite");
                    const store = tx.objectStore(AUDIO_DB.store);
                    if (key) {
                        store.delete(key);
                    } else {
                        store.clear();
                    }
                } catch (err) {
                    console.warn("Impossible de vider l'audio", err);
                }
            }

            async function loadAudioFromDb(key = AUDIO_DB.key) {
                try {
                    const db = await getAudioDb();
                    if (!db) return;
                    const tx = db.transaction(AUDIO_DB.store, "readonly");
                    const store = tx.objectStore(AUDIO_DB.store);
                    const req = store.get(key);
                    const result = await new Promise(resolve => {
                        req.onsuccess = () => resolve(req.result);
                        req.onerror = () => resolve(null);
                    });
                    if (result && result.data) {
                        const blob = new Blob([result.data], { type: result.type || "audio/webm" });
                        recordingSegments = blob ? [blob] : [];
                        setAudioBlob(blob, { skipSave: true });
                    } else {
                        recordingSegments = [];
                    }
                } catch (err) {
                    console.warn("Impossible de charger l'audio", err);
                }
            }

            function rebuildCombinedAudioBlob() {
                if (!recordingSegments.length) {
                    setAudioBlob(null, { skipSave: true });
                    return;
                }
                const combined = new Blob(recordingSegments, { type: recordingSegments[0]?.type || "audio/webm" });
                setAudioBlob(combined);
            }

            function finalizeAudioSegment(type = "audio/webm") {
                if (audioChunks.length) {
                    const segment = new Blob(audioChunks, { type });
                    recordingSegments.push(segment);
                    rebuildCombinedAudioBlob();
                }
                audioChunks = [];
            }

            function setAudioBlob(blob, options = {}) {
                const { skipSave } = options;
                if (audioUrl) {
                    try { URL.revokeObjectURL(audioUrl); } catch (e) { /* noop */ }
                }
                audioBlob = blob || null;
                audioUrl = blob ? URL.createObjectURL(blob) : null;
                audioPlayer.src = audioUrl || "";
                audioPlayer.playbackRate = getAudioSpeed();
                audioPlayer.currentTime = 0;
                if (audioProgress) {
                    audioProgress.disabled = !audioUrl;
                    audioProgress.value = 0;
                }
                if (audioPlayBtn) {
                    audioPlayBtn.disabled = !audioUrl;
                    audioPlayBtn.textContent = "‚ñ∂";
                }
                if (audioDownloadBtn) {
                    audioDownloadBtn.disabled = !audioUrl;
                }
                if (blob && !skipSave) {
                    saveAudioToDb(blob);
                }
            }

            function handleAudioImportClick() {
                if (!audioImportInput) return;
                if (audioBlob) {
                    const confirmClear = window.confirm("Un enregistrement existe d√©j√† et sera remplac√©. Continuer ?");
                    if (!confirmClear) return;
                }
                audioImportInput.value = "";
                audioImportInput.click();
            }

            async function handleAudioImportChange() {
                if (!audioImportInput) return;
                const file = audioImportInput.files?.[0];
                audioImportInput.value = "";
                if (!file) {
                    return;
                }
                stopAudioRecording();
                audioRecordingActive = false;
                recognitionActive = false;
                recognitionPaused = false;
                setSpeechButtonState(false);
                recordingStartedAt = null;
                recordingElapsedSec = 0;
                if (recordingTimer) {
                    clearInterval(recordingTimer);
                    recordingTimer = null;
                }
                recordingSegments = [file];
                setAudioBlob(file);
                updateRecordingUi();
                updateTranscriptMeta();
                await processAssemblyRecording(file);
            }

            function getVoiceTranscriptionMode() {
                try {
                    const stored = (localStorage.getItem(VOICE_TRANSCRIPTION_MODE_STORAGE) || "").trim();
                    if (stored) return stored;
                } catch (err) { /* noop */ }
                return (window.GoToolkitVoiceTranscriptionMode || "web");
            }

            function getAssemblyApiKey() {
                try {
                    const stored = (localStorage.getItem(ASSEMBLY_AI_KEY_STORAGE) || "").trim();
                    if (stored) return stored;
                } catch (err) { /* noop */ }
                return (window.GoToolkitAssemblyAiKey || "").trim();
            }

            function shouldUseAssemblyTranscriptionMode() {
                return getVoiceTranscriptionMode() === "assembly";
            }

            function getAssemblyProxyUrl(path = "") {
                if (!ASSEMBLY_PROXY_BASE_URL) return "";
                const normalized = (path || "").replace(/^\/+/, "");
                if (!normalized) return ASSEMBLY_PROXY_BASE_URL;
                return `${ASSEMBLY_PROXY_BASE_URL}/${normalized}`;
            }

            function getAssemblyKnownValues(page) {
                if (!page) return [];
                const values = [];
                (page.participants || []).forEach(participant => {
                    const name = (participant?.name || "").trim();
                    if (!name) return;
                    const role = (participant?.role || "").trim();
                    values.push(role ? `${name} (${role})` : name);
                });
                return values;
            }

            function buildAssemblyTranscriptPayload(uploadUrl, knownValues, speakersExpected) {
                const payload = {
                    audio_url: uploadUrl,
                    speaker_labels: true,
                    language_detection: true,
                    language_detection_options: {
                        expected_languages: ["en", "fr"],
                        fallback_language: "auto",
                    }
                };
                if (speakersExpected > 0) {
                    payload.speakers_expected = speakersExpected;
                }
                if (knownValues.length) {
                    payload.speech_understanding = {
                        request: {
                            speaker_identification: {
                                speaker_type: "name",
                                known_values: knownValues
                            }
                        }
                    };
                }
                return payload;
            }

            function getNoteContentForMode(page, mode) {
                if (!page) return "";
                if (mode === NOTE_MODE_TRANSCRIPT_IA) {
                    return page.assemblyTranscript || "";
                }
                if (mode === NOTE_MODE_TRANSCRIPT_AUTO) {
                    return page.manualTranscript || "";
                }
                return page.manualTranscript || page.transcript || "";
            }

            let activeNoteMode = NOTE_MODE_NOTE;
            function applyNoteMode(mode) {
                const page = getActivePage();
                if (!page) return;
                activeNoteMode = mode;
                page.noteMode = mode;
                const content = getNoteContentForMode(page, mode);
                if (noteModeSelect) {
                    noteModeSelect.value = mode;
                }
                if (transcribeInput) {
                    transcribeInput.value = content;
                }
                persistState();
                updateGhostOverlay("");
                updateTranscriptMeta();
            }

            function canRequestAssemblyTranscript() {
                if (!audioBlob) {
                    showToast("Cr√©e d'abord un enregistrement audio pour la transcription IA.", true);
                    if (noteModeSelect) noteModeSelect.value = activeNoteMode;
                    return false;
                }
                if (audioRecordingActive) {
                    showToast("Arr√™te l'enregistrement avant de demander la transcription IA.", true);
                    if (noteModeSelect) noteModeSelect.value = activeNoteMode;
                    return false;
                }
                if (recognitionActive && !recognitionPaused) {
                    showToast("Arr√™te l'enregistrement avant de demander la transcription IA.", true);
                    if (noteModeSelect) noteModeSelect.value = activeNoteMode;
                    return false;
                }
                return true;
            }

            function handleNoteModeSelection(value) {
                if (!noteModeSelect) return;
                if (value === NOTE_MODE_TRANSCRIPT_IA) {
                    if (!audioBlob) {
                        handleAudioImportClick();
                        return;
                    }
                    if (!canRequestAssemblyTranscript()) {
                        return;
                    }
                    applyNoteMode(NOTE_MODE_TRANSCRIPT_IA);
                    processAssemblyRecording(audioBlob);
                    return;
                }
                if (value === NOTE_MODE_TRANSCRIPT_AUTO) {
                    applyNoteMode(NOTE_MODE_TRANSCRIPT_AUTO);
                    return;
                }
                applyNoteMode(NOTE_MODE_NOTE);
            }

            function formatAssemblyTimestamp(ms = 0) {
                const totalSeconds = Math.max(0, Math.floor(Number(ms) / 1000));
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;
                if (hours > 0) {
                    return `[${hours}:${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}]`;
                }
                return `[${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}]`;
            }

            function buildTranscriptFromUtterances(result) {
                const utterances = Array.isArray(result?.utterances) ? result.utterances : [];
                if (!utterances.length) {
                    return (result?.text || "").trim();
                }
                return utterances
                    .map(utterance => {
                        const speaker = (utterance?.speaker || "Participant").trim();
                        const text = (utterance?.text || "").trim();
                        if (!text) return null;
                        const timestamp = formatAssemblyTimestamp(utterance?.start);
                        return `${timestamp} ${speaker}\n${text}`;
                    })
                    .filter(Boolean)
                    .join("\n\n");
            }

            function delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            async function uploadAudioToAssembly(blob, key) {
                if (!blob) throw new Error("Audio absent");
                const url = getAssemblyProxyUrl("upload");
                if (!url) throw new Error("Proxy AssemblyAI indisponible");
                const response = await fetch(url, {
                    method: "POST",
                    headers: {
                        "X-AssemblyAI-Key": key,
                        "Content-Type": blob.type || "audio/webm"
                    },
                    body: blob
                });
                if (!response.ok) {
                    throw new Error(`Envoi audio √©chou√© (${response.status})`);
                }
                const data = await response.json();
                if (!data?.upload_url) {
                    throw new Error("URL audio manquante");
                }
                return data.upload_url;
            }

            async function requestAssemblyTranscript(payload, key) {
                const url = getAssemblyProxyUrl("transcript");
                if (!url) throw new Error("Proxy AssemblyAI indisponible");
                const response = await fetch(url, {
                    method: "POST",
                    headers: {
                        "X-AssemblyAI-Key": key,
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                    throw new Error(`Requ√™te transcription √©chou√©e (${response.status})`);
                }
                const data = await response.json();
                if (!data?.id) {
                    throw new Error("ID de transcription manquante");
                }
                return data.id;
            }

            async function pollAssemblyTranscript(transcriptId, key) {
                const url = getAssemblyProxyUrl(`transcript/${transcriptId}`);
                if (!url) throw new Error("Proxy AssemblyAI indisponible");
                for (let attempt = 0; attempt < 40; attempt++) {
                    const response = await fetch(url, {
                        headers: {
                            "X-AssemblyAI-Key": key
                        }
                    });
                    if (!response.ok) {
                        throw new Error(`√âchec du suivi (${response.status})`);
                    }
                    const data = await response.json();
                    if (!data) {
                        throw new Error("R√©ponse AssemblyAI invalide");
                    }
                    if (data.status === "completed") {
                        return data;
                    }
                    if (data.status === "error") {
                        throw new Error(data.error || "Erreur AssemblyAI");
                    }
                    await delay(1200);
                }
                throw new Error("Timeout AssemblyAI");
            }

            async function processAssemblyRecording(blob) {
                if (!blob) return;
                if (!shouldUseAssemblyTranscriptionMode()) return;
                if (assemblyRequestInProgress) return;
                const assemblyKey = getAssemblyApiKey();
                if (!assemblyKey) {
                    showToast("Cl√© AssemblyAI manquante.", true);
                    return;
                }
                const baseUrl = ASSEMBLY_PROXY_BASE_URL;
                if (!baseUrl) {
                    showToast("Proxy AssemblyAI indisponible.", true);
                    return;
                }
                assemblyRequestInProgress = true;
                showToast("Transcription AssemblyAI en cours...");
                try {
                    console.debug("AssemblyAI upload request, blob", blob);
                    const uploadUrl = await uploadAudioToAssembly(blob, assemblyKey);
                    console.debug("AssemblyAI upload response url", uploadUrl);
                    const page = getActivePage();
                    const participantsWithNames = (page?.participants || []).filter(participant => (participant?.name || "").trim());
                    const knownValues = getAssemblyKnownValues(page);
                    const payload = buildAssemblyTranscriptPayload(uploadUrl, knownValues, participantsWithNames.length);
                    console.debug("AssemblyAI request payload", payload);
                    console.log("AssemblyAI request payload", payload);
                    const transcriptId = await requestAssemblyTranscript(payload, assemblyKey);
                    console.debug("AssemblyAI transcript id", transcriptId);
                    const result = await pollAssemblyTranscript(transcriptId, assemblyKey);
                    console.debug("AssemblyAI poll result", result);
                    console.log("AssemblyAI poll response", result);
                    const finalText = buildTranscriptFromUtterances(result);
                    if (!finalText) {
                        throw new Error("Transcription vide");
                    }
                    transcriptPrefix = finalText;
                    lastCaret = finalText.length;
                    const activePage = getActivePage();
                    if (activePage) {
                        activePage.assemblyTranscript = finalText;
                        applyNoteMode(NOTE_MODE_TRANSCRIPT_IA);
                    }
                    showToast("Transcription AssemblyAI termin√©e.");
                } catch (err) {
                    console.error("AssemblyAI transcription failed", err);
                    showToast("Transcription AssemblyAI impossible.", true);
                } finally {
                    assemblyRequestInProgress = false;
                }
            }

            function updateAudioProgress() {
                if (!audioProgress || !audioPlayer?.duration || Number.isNaN(audioPlayer.duration)) return;
                const ratio = Math.min(1, Math.max(0, audioPlayer.currentTime / audioPlayer.duration));
                audioProgress.value = ratio;
            }

            async function ensureAudioRecording() {
                if (!navigator.mediaDevices?.getUserMedia) return false;
                if (mediaRecorder && mediaRecorder.state === "recording") return true;
                try {
                    mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                } catch (err) {
                    console.error("Micro indisponible", err);
                    showToast("Micro indisponible pour l'enregistrement audio.", true);
                    return false;
                }
                const mime = MediaRecorder.isTypeSupported("audio/webm;codecs=opus")
                    ? "audio/webm;codecs=opus"
                    : "audio/webm";
                audioChunks = [];
                try {
                    mediaRecorder = new MediaRecorder(mediaStream, { mimeType: mime });
                } catch (err) {
                    console.error("MediaRecorder indisponible", err);
                    showToast("Enregistrement local indisponible.", true);
                    return false;
                }
                mediaRecorder.ondataavailable = e => {
                    if (e.data && e.data.size > 0) {
                        audioChunks.push(e.data);
                    }
                };
                mediaRecorder.onstop = () => {
                    if (mediaStream) {
                        mediaStream.getTracks().forEach(track => track.stop());
                        mediaStream = null;
                    }
                    finalizeAudioSegment(mime);
                    mediaRecorder = null;
                };
                mediaRecorder.start();
                return true;
            }

            function stopAudioRecording() {
                try {
                    if (mediaRecorder && mediaRecorder.state === "recording") {
                        mediaRecorder.stop();
                    } else if (mediaStream) {
                        mediaStream.getTracks().forEach(track => track.stop());
                        mediaStream = null;
                        mediaRecorder = null;
                    }
                } catch (err) {
                    console.warn("Stop audio recording", err);
                }
                audioRecordingActive = false;
            }

            function toggleAudioPlayback() {
                if (!audioUrl) return;
                if (audioPlayer.paused) {
                    audioPlayer.play();
                    if (audioPlayBtn) audioPlayBtn.textContent = "‚è∏";
                } else {
                    audioPlayer.pause();
                    if (audioPlayBtn) audioPlayBtn.textContent = "‚ñ∂";
                }
            }

            function getAudioSpeed() {
                const val = parseFloat(audioSpeedSelect?.value || "1.2");
                if (Number.isNaN(val)) return 1.2;
                return Math.min(2, Math.max(0.5, val));
            }

            function populateAudioSpeedOptions() {
                if (!audioSpeedSelect) return;
                audioSpeedSelect.innerHTML = "";
                for (let s = 0.5; s <= 2.001; s += 0.1) {
                    const rounded = Math.round(s * 10) / 10;
                    const opt = document.createElement("option");
                    opt.value = String(rounded);
                    opt.textContent = `${rounded.toFixed(1)}x`;
                    audioSpeedSelect.appendChild(opt);
                }
                audioSpeedSelect.value = "1.2";
            }

            function downloadAudio() {
                if (!audioBlob) return;
                const url = audioUrl || URL.createObjectURL(audioBlob);
                const a = document.createElement("a");
                a.href = url;
                a.download = "voice-recording.webm";
                a.click();
                if (!audioUrl) {
                    URL.revokeObjectURL(url);
                }
            }

            function startRespondCountdown(seconds = 30) {
                if (!respondBtn) return;
                let remaining = seconds;
                const tick = () => {
                    if (!activeRequestId) {
                        stopRespondCountdown();
                        return;
                    }
                    const label = remaining < 10 ? `0${remaining}` : `${remaining}`;
                    respondBtn.textContent = `‚ó¥ ${label}s`;
                    remaining -= 1;
                    if (remaining < 0) remaining = seconds;
                };
                tick();
                if (respondCountdownTimer) clearInterval(respondCountdownTimer);
                respondCountdownTimer = setInterval(tick, 1000);
            }

            function stopRespondCountdown() {
                if (respondCountdownTimer) clearInterval(respondCountdownTimer);
                respondCountdownTimer = null;
                if (respondBtn) respondBtn.textContent = respondDefaultLabel;
            }

            function clearActiveRequest() {
                activeRequestId = null;
                activeRequestController = null;
                stopRespondCountdown();
                respondBtn?.classList.remove("btn-primary");
            }

            function cancelActiveRequest(showToastMessage = true) {
                if (!activeRequestId) return;
                try { activeRequestController?.abort(); } catch (e) { /* noop */ }
                clearActiveRequest();
                if (showToastMessage) showToast("Requ√™te IA annul√©e.");
            }

            async function runVoicePrompt() {
                const page = getActivePage();
                if (!page) return;
                if (activeRequestId) {
                    cancelActiveRequest();
                    return;
                }
                const scenario = promptCreate?.value?.trim();
                const transcript = transcribeInput?.value?.trim();
                const basePrompt = promptState.system || promptDefaults.system;
                const templateText = selectedTemplateText || "";
                const systemPrompt = (basePrompt || promptDefaults.system || "")
                    .replace(/{{scenario_prompt}}/gi, scenario || "")
                    .replace(/{{template_text}}/gi, templateText || "");
                if (!systemPrompt || !scenario) {
                    showToast("Ajoute un sc√©nario avant de lancer l'IA.", true);
                    return;
                }
                const requestId = crypto.randomUUID ? crypto.randomUUID() : String(Date.now());
                activeRequestId = requestId;
                activeRequestController = typeof AbortController !== "undefined" ? new AbortController() : null;
                respondBtn?.classList.add("btn-primary");
                startRespondCountdown();
                try {
                    const model = (window.GoToolkitIAConfig && window.GoToolkitIAConfig.getOpenAiModel?.()) || "gpt-5-nano";
                    const payload = {
                        model,
                        input: [
                            {
                                role: "system",
                                content: systemPrompt
                            },
                            {
                                role: "user",
                                content:
                                    `Contexte : ${scenario}` +
                                    (templateText ? `\nMod√®le choisi : ${templateText}` : "") +
                                    (transcript ? `\nTranscription actuelle :\n${transcript}` : "")
                            }
                        ],
                        max_output_tokens: 1200
                    };
                    const messageText = await window.GoToolkitIA.chatCompletion({
                        payload,
                        signal: activeRequestController?.signal
                    });
                    if (requestId !== activeRequestId) return;
                    if (promptModify) {
                        promptModify.value = messageText;
                    }
                    page.lastIaResponse = messageText;
                    applyScriptJson(messageText);
                    persistState();
                    showToast("Trame g√©n√©r√©e.");
                } catch (err) {
                    if (requestId !== activeRequestId) return;
                    if (err?.name !== "AbortError") {
                        console.error("Voice prompt failed", err);
                        showToast("Impossible de g√©n√©rer la trame.", true);
                    }
                } finally {
                    if (requestId !== activeRequestId) return;
                    clearActiveRequest();
                    if (respondBtn) respondBtn.textContent = respondDefaultLabel;
                }
            }

            async function evaluateGuidelines() {
                const page = getActivePage();
                if (!page || !page.subjects.length) {
                    showToast("Pas de sujets √† √©valuer.", true);
                    return;
                }
                const transcript = transcribeInput?.value?.trim() || "";
                if (!transcript) {
                    showToast("Ajoute une transcription avant d'√©valuer.", true);
                    return;
                }
                evaluateBtn?.setAttribute("disabled", "true");
                evaluateBtn.textContent = "Analyse...";
                try {
                    const evaluatePrompt = promptState.evaluate || promptDefaults.evaluate;
                    const summary = page.subjects.map(s => {
                        return {
                            title: s.title,
                            keySentences: s.keySentences.map(k => k.text)
                        };
                    });
                    const payload = {
                        model: (window.GoToolkitIAConfig && window.GoToolkitIAConfig.getOpenAiModel?.()) || "gpt-5-nano",
                        input: [
                            {
                                role: "system",
                                content: evaluatePrompt
                            },
                            {
                                role: "user",
                                content: `Transcription :\n${transcript}\nGuidelines : ${JSON.stringify(summary)}`
                            }
                        ],
                        max_output_tokens: 900
                    };
                    const response = await window.GoToolkitIA.chatCompletion({ payload });
                    const cleaned = response.trim().replace(/^```(?:json)?/i, "").replace(/```$/i, "");
                    const parsed = JSON.parse(cleaned);
                    if (parsed && Array.isArray(parsed.subjects)) {
                        parsed.subjects.forEach(subjectResult => {
                            const target = page.subjects.find(s => s.title === subjectResult.title);
                            if (!target) return;
                            (subjectResult.keySentences || []).forEach(ks => {
                                const found = target.keySentences.find(k => k.text === ks.text);
                                if (found && ks.match) {
                                    found.match = ks.match;
                                }
                            });
                        });
                        persistState();
                        renderGuidelines();
                        showToast("√âvaluation termin√©e.");
                    }
                } catch (err) {
                    console.error("Evaluation failed", err);
                    showToast("Impossible d'√©valuer via IA.", true);
                } finally {
                    evaluateBtn?.removeAttribute("disabled");
                    evaluateBtn.textContent = "‚åò √âvaluer";
                }
            }

            async function summarizeTranscript() {
                const page = getActivePage();
                if (!page) return;
                const transcript = (transcribeInput?.value || "").trim();
                if (!transcript) {
                    showToast("Ajoute une transcription avant de r√©sumer.", true);
                    return;
                }
                summarizeBtn?.setAttribute("disabled", "true");
                if (summarizeBtn) summarizeBtn.textContent = "R√©sum√©...";
                try {
                    const templateText = selectedTemplateText || "";
                    const prompt = (promptState.summary || promptDefaults.summary || "")
                        .replace(/{{transcript_content}}/gi, transcript)
                        .replace(/{{template_text}}/gi, templateText);
                    const payload = {
                        model: (window.GoToolkitIAConfig && window.GoToolkitIAConfig.getOpenAiModel?.()) || "gpt-5-nano",
                        input: [
                            {
                                role: "system",
                                content: prompt
                            }
                        ],
                        max_output_tokens: 800
                    };
                    const response = await window.GoToolkitIA.chatCompletion({ payload });
                    const cleaned = response.trim().replace(/^```(?:[a-z]+)?/i, "").replace(/```$/i, "").trim();
                    if (summaryTextarea) summaryTextarea.value = cleaned;
                    page.summary = cleaned;
                    persistState();
                    showToast("R√©sum√© g√©n√©r√©.");
                } catch (err) {
                    console.error("R√©sum√© IA impossible", err);
                    showToast("Impossible de r√©sumer via IA.", true);
                } finally {
                    summarizeBtn?.removeAttribute("disabled");
                    if (summarizeBtn) summarizeBtn.textContent = "‚åò R√©sumer";
                }
            }

            function toggleOptionsMenu() {
                optionsMenu?.classList.toggle("open");
            }

            function toggleFileMenu() {
                fileMenu?.classList.toggle("open");
            }

            function toggleShareMenu() {
                shareMenu?.classList.toggle("open");
            }

            function closeMenus(except) {
                if (optionsMenu && optionsMenu !== except) optionsMenu.classList.remove("open");
                if (fileMenu && fileMenu !== except) fileMenu.classList.remove("open");
                if (shareMenu && shareMenu !== except) shareMenu.classList.remove("open");
                if (navSwitcherMenu && navSwitcherMenu !== except) navSwitcherMenu.classList.remove("open");
            }

            function persistCapsuleDraft() {
                if (!capsuleDrafts || typeof capsuleDrafts.upsertRecord !== "function") return;
                const page = getActivePage();
                const payload = { ...state };
                const draftId = state.activePageId || (capsuleDrafts.generateId ? capsuleDrafts.generateId() : null);
                capsuleDrafts.upsertRecord({
                    id: draftId,
                    app: "voice",
                    payload,
                    title: page?.title || "Voice",
                    description: (page?.scenario || "").slice(0, 120)
                });
                if (draftId && audioBlob) {
                    saveAudioToDb(audioBlob, draftId);
                }
            }

            function resetDocument() {
                state = { pages: [defaultPage()], activePageId: null };
                state.activePageId = state.pages[0].id;
                persistState();
                renderTabs();
                renderPage();
                clearAudioStoreAll();
                openTemplateModal();
            }

            function importFromFile(file) {
                const reader = new FileReader();
                reader.onload = () => {
                    try {
                        const payload = JSON.parse(reader.result);
                        if (payload && Array.isArray(payload.pages)) {
                            state = normalizeState(payload) || state;
                            persistState();
                            renderTabs();
                            renderPage();
                            showToast("Capsule charg√©e.");
                        }
                    } catch (err) {
                        showToast("Fichier JSON invalide.", true);
                    }
                };
                reader.readAsText(file);
            }

            async function exportJson() {
                const payload = JSON.stringify(state, null, 2);
                const blob = new Blob([payload], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = "voice-capsule.json";
                a.click();
                URL.revokeObjectURL(url);
                showToast("Capsule t√©l√©charg√©e.");
            }

            async function copyCurrentShareLinkToClipboard() {
                if (!currentShareToken) return false;
                const link = buildShareUrl(currentShareToken);
                if (!link) return false;
                try {
                    await navigator.clipboard.writeText(link);
                    showToast("Lien priv√© copi√©");
                    return true;
                } catch (err) {
                    console.error("Copie du lien priv√© impossible", err);
                    return false;
                }
            }

            async function saveSharePayload(token, payload) {
                if (!shareWorkerService || !shareWorkerService.isReady) {
                    throw new Error("Partage indisponible");
                }
                const meta = await shareWorkerService.saveSharePayload(FIRESTORE_COLLECTION, token, payload);
                if (shareHistory && typeof shareHistory.upsertRecord === "function") {
                    try {
                        const firstPage = payload.pages?.[0];
                        await shareHistory.upsertRecord("voice", {
                            token,
                            updatedAt: meta?.updatedAt || new Date().toISOString(),
                            title: firstPage?.title || "Voice",
                            description: (firstPage?.scenario || "").slice(0, 120)
                        });
                    } catch (err) {
                        console.warn("share history voice", err);
                    }
                }
                return meta;
            }

            async function createOrUpdateShare(isUpdate = false) {
                if (!shareWorkerService?.isReady) {
                    setShareStatus("Le partage priv√© n√©cessite le worker Cloudflare.", "error");
                    updateShareMenuUI();
                    return;
                }
                if (shareRequestInProgress) return;
                shareRequestInProgress = true;
                updateShareMenuUI();
                try {
                    const token = isUpdate && currentShareToken ? currentShareToken : (crypto.randomUUID ? crypto.randomUUID() : String(Date.now()));
                    const payload = { ...state };
                    const meta = await saveSharePayload(token, payload);
                    currentShareToken = token;
                    shareLoadedFromRemote = true;
                    shareLastUpdatedAt = meta?.updatedAt || new Date().toISOString();
                    setShareStatus(shareLastUpdatedAt);
                    updateShareMenuUI();
                    await copyCurrentShareLinkToClipboard();
                    showToast(isUpdate ? "Lien mis √† jour" : "Lien cr√©√©");
                    persistState();
                } catch (err) {
                    console.error("Share voice failed", err);
                    setShareStatus("Impossible de sauvegarder le partage.", "error");
                } finally {
                    shareRequestInProgress = false;
                    updateShareMenuUI();
                }
            }

            async function tryLoadSharedStateFromUrl() {
                const params = new URLSearchParams(window.location.search);
                const token = params.get(SHARE_QUERY_PARAM);
                if (!token || !shareWorkerService?.isReady) return false;
                try {
                    const result = await shareWorkerService.fetchSharePayload(FIRESTORE_COLLECTION, token);
                    if (result?.payload) {
                        state = normalizeState(result.payload) || state;
                        currentShareToken = token;
                        shareLoadedFromRemote = true;
                        shareLastUpdatedAt = result.meta?.updatedAt || new Date().toISOString();
                        if (!state.activePageId && state.pages?.[0]) {
                            state.activePageId = state.pages[0].id;
                        }
                        persistState();
                        renderTabs();
                        renderPage();
                        updateShareMenuUI();
                        showToast("Capsule charg√©e depuis Nexus.");
                        return true;
                    }
                } catch (err) {
                    console.error("Chargement share voice impossible", err);
                }
                return false;
            }

            function applyScriptFromTextarea(options = {}) {
                const { silent } = options;
                const text = promptModify?.value;
                if (!text) {
                    if (!silent) showToast("JSON vide.", true);
                    return;
                }
                try {
                    applyScriptJson(text);
                    if (!silent) showToast("JSON appliqu√©.");
                } catch (err) {
                    console.error("Invalid JSON", err);
                    if (!silent) showToast("JSON invalide.", true);
                }
            }

            function restoreLastIaResponse() {
                const page = getActivePage();
                const fallback = page?.lastIaResponse || page?.script || "";
                if (!fallback) {
                    showToast("Aucune r√©ponse IA √† restaurer.", true);
                    return;
                }
                if (promptModify) {
                    promptModify.value = fallback;
                }
                applyScriptFromTextarea({ silent: true });
                showToast("Derni√®re r√©ponse IA restaur√©e.");
            }

            function setupSpeechRecognition() {
                let engine = "web-speech";
                try {
                    const stored = localStorage.getItem(SPEECH_ENGINE_STORAGE_KEY) || window.GoToolkitSpeechEngine;
                    engine = stored === "whisperer" ? "whisperer" : "web-speech";
                    window.GoToolkitSpeechEngine = engine;
                } catch (e) { /* noop */ }
                if (recordStatus) {
                    recordStatus.textContent = engine === "whisperer" ? "Whisperer" : "Web Speech";
                }
                if (engine === "whisperer") {
                    showToast("Whisperer utilisera le micro mais reste en pr√©paration.", false);
                }
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                if (!SpeechRecognition) {
                    recordBtn?.setAttribute("disabled", "true");
                    pauseBtn?.setAttribute("disabled", "true");
                    speechToggleBtn?.setAttribute("disabled", "true");
                    if (recordStatus) recordStatus.textContent = "Indispo";
                    return;
                }
                speechRecognition = new SpeechRecognition();
                speechRecognition.lang = "fr-FR";
                speechRecognition.interimResults = true;
                speechRecognition.continuous = true;
                speechRecognition.onstart = () => {
                    console.debug("speechRecognition started");
                    setSpeechButtonState(true);
                };
                speechRecognition.onerror = e => {
                    console.warn("speechRecognition error", e);
                };
                speechRecognition.onresult = event => {
                    console.debug("speechRecognition.onresult", { index: event.resultIndex, results: event.results?.length });
                    const now = Date.now();
                    const sessionElapsed = recordingStartedAt ? Math.max(0, Math.floor((now - recordingStartedAt) / 1000)) : 0;
                    const elapsedSec = recordingBaseElapsedSec + sessionElapsed;
                    recordingElapsedSec = elapsedSec;

                    const formatTimestamp = secs => {
                        const total = Math.max(0, Math.floor(secs));
                        const m = String(Math.floor(total / 60)).padStart(2, "0");
                        const s = String(total % 60).padStart(2, "0");
                        return `${m}:${s}`;
                    };

                    let finals = [];
                    let interim = "";
                    for (let i = event.resultIndex || 0; i < event.results.length; i++) {
                        const res = event.results[i];
                        if (res.isFinal) finals.push((res[0].transcript || "").trim());
                        else interim = `${interim} ${res[0].transcript || ""}`.trim();
                    }

                    // Determine base text (strip any previously-displayed interim)
                    const base = getBaseWithoutInterim();
                    if (lastTimestampMinute === null && base) {
                        lastTimestampMinute = getLastTimestampMinuteFromTranscript(base);
                    }

                    // Insert finals at the caret position (do not force a newline)
                    if (finals.length) {
                        const effectiveBase = transcriptPrefix || base || "";
                        let inserted = "";

                        const appendSpeechSegment = segment => {
                            const trimmed = (segment || "").trim();
                            if (!trimmed) return;
                            if (inserted && !/\s$/.test(inserted) && !trimmed.startsWith("\n")) {
                                inserted += " ";
                            }
                            inserted += trimmed;
                            const lastChar = trimmed.charAt(trimmed.length - 1);
                            if (SENTENCE_TERMINATOR_REGEX.test(lastChar) && !inserted.endsWith("\n")) {
                                inserted += "\n";
                            }
                        };

                        const flushPendingTimestampIfReady = beforeText => {
                            if (!pendingTimestamp) return;
                            if (!isSentenceBoundary(beforeText)) return;
                            inserted += buildTimestampBlock(pendingTimestamp.label, beforeText);
                            lastTimestampMinute = pendingTimestamp.minuteBucket;
                            pendingTimestamp = null;
                        };

                        finals.filter(Boolean).forEach(text => {
                            const minuteBucket = Math.floor(elapsedSec / 60);
                            if (minuteBucket > (lastTimestampMinute ?? -1)) {
                                pendingTimestamp = { label: formatTimestamp(elapsedSec), minuteBucket };
                            }
                            const beforeText = (effectiveBase || "") + inserted;
                            flushPendingTimestampIfReady(beforeText);
                            appendSpeechSegment(text);
                        });

                        const combinedText = (effectiveBase || "") + inserted;
                        flushPendingTimestampIfReady(combinedText);

                        const caret = Math.min(lastCaret || 0, base.length);
                        const defaultSep = base && !/\s$/.test(base) ? " " : "";
                        const sep = inserted.startsWith("\n") ? "" : defaultSep;
                        const newBase = base.slice(0, caret) + sep + inserted + base.slice(caret);
                        transcriptPrefix = newBase;
                        // move caret after inserted text
                        lastCaret = Math.min(transcriptPrefix.length, caret + sep.length + inserted.length);
                    }

                    const interimLine = interim || "";
                    // Show finalized base and overlay interim at caret for live feedback
                    if (transcribeInput) {
                        const displayBase = transcriptPrefix || base || "";
                        const caretPos = recognitionActive
                            ? displayBase.length
                            : Math.min(lastCaret || 0, displayBase.length);
                        transcribeInput.value = displayBase;
                        try { transcribeInput.selectionStart = transcribeInput.selectionEnd = caretPos; } catch (e) { }
                        updateGhostOverlay(interimLine);
                        updateTranscriptMeta();
                        lastInterim = interimLine;
                    }

                    // persist the finalized transcript (no interim)
                    const page = getActivePage();
                    if (page) {
                        const manualText = transcriptPrefix || getBaseWithoutInterim() || "";
                        page.manualTranscript = manualText;
                        if (page.noteMode !== NOTE_MODE_TRANSCRIPT_AUTO) {
                            page.transcript = manualText;
                        }
                        persistState();
                    }

                    updateRecordingUi();
                };
                speechRecognition.onend = () => {
                    if (recognitionActive && !recognitionPaused) {
                        speechRecognition.start();
                    } else {
                        setSpeechButtonState(false);
                    }
                };
            }

            async function startRecording() {
                if (audioRecordingActive) return;
                const shouldUseSpeech = activeNoteMode === NOTE_MODE_TRANSCRIPT_AUTO;
                if (shouldUseSpeech && !speechRecognition) {
                    setupSpeechRecognition();
                }
                const ready = await ensureAudioRecording();
                if (!ready) return;
                transcriptPrefix = transcribeInput?.value || "";
                recordingStartedAt = Date.now();
                recordingElapsedSec = 0;
                lastTimestampMinute = null;
                pendingTimestamp = null;
                if (recordingTimer) clearInterval(recordingTimer);
                recordingTimer = setInterval(() => {
                    if (!recordingStartedAt) return;
                    recordingElapsedSec = Math.max(recordingElapsedSec, Math.floor((Date.now() - recordingStartedAt) / 1000));
                    updateRecordingUi();
                }, 1000);
                if (transcribeGhost) {
                    updateGhostOverlay("");
                }
                audioRecordingActive = true;
                const canStartRecognition = shouldUseSpeech && Boolean(speechRecognition);
                if (canStartRecognition) {
                    recognitionActive = true;
                    recognitionPaused = false;
                    speechRecognition.start();
                } else {
                    recognitionActive = false;
                    recognitionPaused = false;
                    if (shouldUseSpeech && !speechRecognition) {
                        showToast("Dict√©e vocale indisponible.", true);
                    }
                }
                recordBtn?.classList.add("btn-primary");
                pauseBtn?.classList.remove("btn-primary");
                setSpeechButtonState(true);
                updateRecordingUi();
            }

            function pauseRecording() {
                if (!audioRecordingActive && !recognitionActive) return;
                const hadRecognition = recognitionActive;
                recognitionPaused = hadRecognition;
                recognitionActive = false;
                try { speechRecognition?.stop(); } catch (e) { /* ignore */ }
                stopAudioRecording();
                audioRecordingActive = false;
                recordingStartedAt = null;
                if (recordingTimer) {
                    clearInterval(recordingTimer);
                    recordingTimer = null;
                }
                recordBtn?.classList.remove("btn-primary");
                pauseBtn?.classList.add("btn-primary");
                setSpeechButtonState(false);
                transcriptPrefix = transcribeInput?.value || "";
                if (hadRecognition) {
                    insertPauseSpacing();
                }
                updateGhostOverlay("");
                updateRecordingUi();
            }

            function resetRecording() {
                recognitionPaused = false;
                recognitionActive = false;
                try { speechRecognition?.stop(); } catch (e) { /* ignore */ }
                stopAudioRecording();
                recordingStartedAt = null;
                recordingSegments = [];
                audioRecordingActive = false;
                recordingElapsedSec = 0;
                lastTimestampMinute = null;
                pendingTimestamp = null;
                if (recordingTimer) {
                    clearInterval(recordingTimer);
                    recordingTimer = null;
                }
                setSpeechButtonState(false);
                if (transcribeInput) {
                    transcribeInput.value = "";
                    const page = getActivePage();
                    if (page) {
                        page.transcript = "";
                        persistState();
                    }
                }
                setAudioBlob(null);
                updateTranscriptMeta();
                updateGhostOverlay("");
                updateRecordingUi();
            }

            function toggleSpeechRecording() {
                if (audioRecordingActive) {
                    pauseRecording();
                } else {
                    startRecording();
                }
            }

            function toggleContextPanel(forceOpen) {
                if (!contextPanel) return;
                const willOpen = typeof forceOpen === "boolean" ? forceOpen : !contextPanel.classList.contains("open");
                contextPanel.classList.toggle("open", willOpen);
                contextPanel.setAttribute("aria-hidden", willOpen ? "false" : "true");
                if (appMain) {
                    appMain.classList.toggle("context-open", willOpen);
                    appMain.classList.toggle("context-closed", !willOpen);
                }
            }

            function closeInfoPopup() {
                infoPopup?.classList.remove("open");
            }

            function toggleInfoPopup() {
                infoPopup?.classList.toggle("open");
            }

            async function clearAudioStoreAll() {
                stopAudioRecording();
                await clearAudioDb();
                recordingSegments = [];
                audioRecordingActive = false;
                recognitionActive = false;
                recognitionPaused = false;
                recordingStartedAt = null;
                recordingElapsedSec = 0;
                if (recordingTimer) {
                    clearInterval(recordingTimer);
                    recordingTimer = null;
                }
                setAudioBlob(null, { skipSave: true });
            }

            function clearCurrentAudioWithConfirm() {
                const confirmed = window.confirm("Supprimer l'enregistrement audio ?");
                if (!confirmed) return;
                clearAudioStoreAll();
                showToast("Enregistrement supprim√©.");
            }

            function syncIaEditor(key) {
                const nextKey = key || iaPromptSelect?.value || activeIaPrompt || "system";
                activeIaPrompt = nextKey;
                if (iaPromptSelect) iaPromptSelect.value = nextKey;
                if (iaTemplateEditor) {
                    iaTemplateEditor.value = promptState[nextKey] || promptDefaults[nextKey] || "";
                }
            }

            function applyIaEditorValue() {
                const key = iaPromptSelect?.value || activeIaPrompt || "system";
                promptState[key] = iaTemplateEditor?.value || "";
                showToast("Prompt appliqu√©.");
                toggleIaModal(false);
            }

            function resetIaEditorValue() {
                const key = iaPromptSelect?.value || activeIaPrompt || "system";
                promptState[key] = promptDefaults[key] || "";
                syncIaEditor(key);
                showToast("Prompt r√©initialis√©.");
            }

            function toggleIaModal(open) {
                const shouldOpen = typeof open === "boolean" ? open : !iaModalOverlay?.classList.contains("open");
                if (!iaModalOverlay) return;
                if (shouldOpen) {
                    syncIaEditor(activeIaPrompt);
                }
                iaModalOverlay.classList.toggle("open", shouldOpen);
                iaModalOverlay.setAttribute("aria-hidden", shouldOpen ? "false" : "true");
            }

            function toggleNavMenu() {
                navSwitcherMenu?.classList.toggle("open");
            }

            // Event binding
            openTemplateModalBtn?.addEventListener("click", openTemplateModal);
            templateModalClose?.addEventListener("click", closeTemplateModal);
            templateModalOverlay?.addEventListener("click", ev => { if (ev.target === templateModalOverlay) closeTemplateModal(); });
            templateModalValidate?.addEventListener("click", applySelectedTemplate);
            promptCreate?.addEventListener("input", persistScenario);
            promptModify?.addEventListener("focus", exportPageStateToScriptField);
            promptModify?.addEventListener("blur", () => applyScriptFromTextarea({ silent: true }));
            respondBtn?.addEventListener("click", runVoicePrompt);
            clearScenarioBtn?.addEventListener("click", () => {
                if (promptCreate) promptCreate.value = "";
                persistScenario();
                showToast("Sc√©nario vid√©.");
            });
            applyScriptBtn?.addEventListener("click", restoreLastIaResponse);
            openContextModalBtn?.addEventListener("click", () => toggleContextPanel());
            openIaModalBtn?.addEventListener("click", () => {
                syncIaEditor(activeIaPrompt);
                toggleIaModal(true);
            });
            iaModalClose?.addEventListener("click", () => toggleIaModal(false));
            iaApplyBtn?.addEventListener("click", applyIaEditorValue);
            iaResetBtn?.addEventListener("click", resetIaEditorValue);
            iaPromptSelect?.addEventListener("change", () => syncIaEditor(iaPromptSelect.value));
            evaluateBtn?.addEventListener("click", evaluateGuidelines);
            summarizeBtn?.addEventListener("click", summarizeTranscript);
            refreshFromScriptBtn?.addEventListener("click", applyScriptFromTextarea);
            addSubjectBtn?.addEventListener("click", () => {
                openSubjectModal(null);
                const confirmBtn = document.getElementById("confirmSubjectModal");
                const deleteBtn = document.getElementById("cancelSubjectModal");
                if (confirmBtn) confirmBtn.dataset.subjectId = "";
                if (deleteBtn) deleteBtn.style.display = "none";
            });
            document.getElementById("closeSubjectModal")?.addEventListener("click", () => {
                subjectModalOverlay.classList.remove("open");
                subjectModalOverlay.setAttribute("aria-hidden", "true");
            });
            document.getElementById("cancelSubjectModal")?.addEventListener("click", () => {
                const existingId = document.getElementById("confirmSubjectModal")?.dataset?.subjectId || "";
                const deleteBtn = document.getElementById("cancelSubjectModal");
                const page = getActivePage();
                if (existingId && page) {
                    const confirmed = window.confirm("Supprimer ce sujet ?");
                    if (confirmed) {
                        page.subjects = (page.subjects || []).filter(s => s.id !== existingId);
                        if (page.activeSubjectId === existingId) {
                            page.activeSubjectId = page.subjects[0]?.id || null;
                        }
                        persistState();
                        renderGuidelines();
                        showToast("Sujet supprim√©.");
                    }
                } else if (deleteBtn) {
                    deleteBtn.style.display = "none";
                }
                subjectModalOverlay.classList.remove("open");
                subjectModalOverlay.setAttribute("aria-hidden", "true");
            });
            document.getElementById("confirmSubjectModal")?.addEventListener("click", () => {
                const titleInput = document.getElementById("newSubjectTitle");
                const durationInput = document.getElementById("newSubjectDuration");
                const pointsInput = document.getElementById("newSubjectPoints");
                const title = (titleInput?.value || "").trim() || `Sujet ${(getActivePage()?.subjects?.length || 0) + 1}`;
                const duration = Math.min(MAX_SUBJECT_MINUTES, Math.max(MIN_SUBJECT_MINUTES, Number(durationInput?.value || DEFAULT_SUBJECT_DURATION)));
                const points = (pointsInput?.value || "").split(/\r?\n/).map(l => l.trim()).filter(Boolean);
                const page = getActivePage();
                if (!page) return;
                const existingId = document.getElementById("confirmSubjectModal")?.dataset?.subjectId || "";
                const deleteBtn = document.getElementById("cancelSubjectModal");
                if (existingId) {
                    const target = page.subjects.find(s => s.id === existingId);
                    if (target) {
                        target.title = title;
                        const start = target.timeframe?.start || 0;
                        target.timeframe = { start, end: start + duration };
                        target.keySentences = (points.length ? points : ["Point 1", "Point 2"]).map(text => ({ text, match: "pending" }));
                    }
                } else {
                    const lastEnd = page.subjects?.[page.subjects.length - 1]?.timeframe?.end || 0;
                    const newSubject = {
                        id: `subject-${Date.now()}`,
                        title,
                        timeframe: { start: lastEnd, end: lastEnd + duration },
                        keySentences: (points.length ? points : ["Point 1", "Point 2"]).map(text => ({ text, match: "pending" }))
                    };
                    page.subjects = page.subjects || [];
                    page.subjects.push(newSubject);
                    const confirmBtn = document.getElementById("confirmSubjectModal");
                    if (confirmBtn) {
                        confirmBtn.dataset.subjectId = newSubject.id;
                    }
                    if (deleteBtn) deleteBtn.style.display = "inline-flex";
                }
                persistState();
                renderGuidelines();
                subjectModalOverlay.classList.remove("open");
                subjectModalOverlay.setAttribute("aria-hidden", "true");
            });
            const escapeRegExp = s => s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            function getBaseWithoutInterim() {
                const val = transcribeInput?.value || "";
                if (lastInterim && val.endsWith(lastInterim)) {
                    return val.slice(0, val.length - lastInterim.length);
                }
                return val;
            }

            function ensureTrailingPauseSpacing(text = "") {
                if (!text) return "";
                if (/\s$/.test(text)) return text;
                if (/[.?!]$/.test(text)) {
                    return `${text}\n`;
                }
                return `${text} `;
            }

            const SENTENCE_TERMINATOR_REGEX = /[.!?‚Ä¶]/;
            function isSentenceBoundary(text = "") {
                if (!text) return true;
                if (text.endsWith("\n")) return true;
                const trimmed = text.replace(/\s+$/g, "");
                if (!trimmed) return true;
                const lastChar = trimmed.charAt(trimmed.length - 1);
                return SENTENCE_TERMINATOR_REGEX.test(lastChar);
            }

            function buildTimestampBlock(label, beforeText = "") {
                const hasContent = Boolean((beforeText || "").replace(/\s+$/g, ""));
                const needsLeadingNewline = hasContent && !beforeText.endsWith("\n");
                return `${needsLeadingNewline ? "\n" : ""}[${label}]\n`;
            }

            function insertPauseSpacing() {
                if (!transcribeInput) return;
                const base = getBaseWithoutInterim();
                if (!base) return;
                const needsBreak = !base.endsWith("\n");
                if (!needsBreak) return;
                const spaced = `${base}\n`;
                transcriptPrefix = spaced;
                transcribeInput.value = spaced;
                const caretPos = spaced.length;
                try {
                    transcribeInput.selectionStart = transcribeInput.selectionEnd = caretPos;
                } catch (e) { /* ignore */ }
                lastCaret = caretPos;
                const page = getActivePage();
                if (page) {
                    page.transcript = spaced;
                    persistState();
                }
            }
            function updateCaretPos() {
                try { lastCaret = transcribeInput?.selectionStart || 0; } catch (e) { lastCaret = 0; }
            }
            transcribeInput?.addEventListener("input", () => {
                updateCaretPos();
                const page = getActivePage();
                if (!page) return;
                // If user types while recognition active, mark manual edit and capture base
                if (recognitionActive && !recognitionPaused) {
                    userEditedDuringRecognition = true;
                    // update transcriptPrefix to user's base text (strip any interim)
                    transcriptPrefix = getBaseWithoutInterim();
                    lastInterim = "";
                    lastCaret = Math.min(lastCaret, transcriptPrefix.length);
                }
                const manualText = getBaseWithoutInterim();
                page.manualTranscript = manualText;
                if (page.noteMode !== NOTE_MODE_TRANSCRIPT_AUTO) {
                    page.transcript = manualText;
                }
                persistState();
                updateTranscriptMeta();
                updateGhostOverlay("");
            });
            summaryTextarea?.addEventListener("input", () => {
                const page = getActivePage();
                if (!page) return;
                page.summary = summaryTextarea.value;
                persistState();
            });
            noteModeSelect?.addEventListener("change", () => {
                handleNoteModeSelection(noteModeSelect.value);
            });
            ["click", "keyup", "mouseup", "focus", "select"].forEach(evt => {
                transcribeInput?.addEventListener(evt, () => {
                    updateCaretPos();
                    updateGhostOverlay(transcribeGhost?.textContent || "");
                });
            });
            speechToggleBtn?.addEventListener("click", toggleSpeechRecording);
            recordBtn?.addEventListener("click", startRecording);
            pauseBtn?.addEventListener("click", pauseRecording);
            audioPlayBtn?.addEventListener("click", toggleAudioPlayback);
            audioDownloadBtn?.addEventListener("click", downloadAudio);
            audioClearBtn?.addEventListener("click", clearCurrentAudioWithConfirm);
            audioImportBtn?.addEventListener("click", handleAudioImportClick);
            audioImportInput?.addEventListener("change", handleAudioImportChange);
            populateAudioSpeedOptions();
            audioSpeedSelect?.addEventListener("change", () => {
                const speed = getAudioSpeed();
                audioPlayer.playbackRate = speed;
            });
            audioProgress?.addEventListener("input", () => {
                if (!audioPlayer || !audioPlayer.duration || Number.isNaN(audioPlayer.duration)) return;
                const ratio = Number(audioProgress.value) || 0;
                audioPlayer.currentTime = ratio * audioPlayer.duration;
            });
            audioPlayer.addEventListener("timeupdate", updateAudioProgress);
            audioPlayer.addEventListener("loadedmetadata", updateAudioProgress);
            audioPlayer.addEventListener("ended", () => {
                if (audioPlayBtn) audioPlayBtn.textContent = "‚ñ∂";
                updateAudioProgress();
            });
            audioPlayer.addEventListener("timeupdate", updateTranscriptMeta);
            audioPlayer.addEventListener("loadedmetadata", updateTranscriptMeta);
            pageTitleEl?.addEventListener("input", () => {
                const page = getActivePage();
                if (!page) return;
                page.title = pageTitleEl.textContent || "Page";
                renderTabs();
                persistState();
            });
            fileMenuBtn?.addEventListener("click", ev => {
                ev.stopPropagation();
                if (!fileMenu?.classList.contains("open")) {
                    closeMenus(fileMenu);
                }
                toggleFileMenu();
            });
            shareBtn?.addEventListener("click", ev => {
                ev.stopPropagation();
                if (!shareMenu?.classList.contains("open")) {
                    closeMenus(shareMenu);
                }
                toggleShareMenu();
            });
            navSwitcherBtn?.addEventListener("click", ev => { ev.stopPropagation(); toggleNavMenu(); });
            document.addEventListener("click", ev => {
                if (fileMenu?.contains(ev.target) || fileMenuBtn === ev.target) return;
                if (shareMenu?.contains(ev.target) || shareBtn === ev.target) return;
                if (navSwitcherMenu?.contains(ev.target) || navSwitcherBtn === ev.target) return;
                closeMenus();
            });
            newDocumentBtn?.addEventListener("click", () => {
                resetDocument();
                showToast("Nouvelle capsule.");
            });
            importJsonBtn?.addEventListener("click", () => {
                importJsonInput?.click();
                closeMenus();
            });
            importJsonInput?.addEventListener("change", event => {
                const file = event.target.files?.[0];
                if (file) importFromFile(file);
                importJsonInput.value = "";
            });
            saveDocumentBtn?.addEventListener("click", () => {
                persistCapsuleDraft();
                showToast("Capsule enregistr√©e localement.");
                closeMenus();
            });
            exportJsonBtn?.addEventListener("click", () => { exportJson(); closeMenus(); });
            aboutVoiceBtn?.addEventListener("click", ev => {
                ev.stopPropagation();
                toggleInfoPopup();
            });
            updateAppBtn?.addEventListener("click", () => {
                resetDocument();
                closeInfoPopup();
                showToast("Capsule r√©initialis√©e.");
            });
            tourReplayBtn?.addEventListener("click", () => {
                closeInfoPopup();
                showToast("Tour guid√© indisponible pour le moment.");
            });
            addViewBtn?.addEventListener("click", addPage);
            deleteViewBtn?.addEventListener("click", deletePage);
            shareCreateBtn?.addEventListener("click", ev => { ev.stopPropagation(); createOrUpdateShare(false); });
            shareUpdateBtn?.addEventListener("click", ev => { ev.stopPropagation(); createOrUpdateShare(true); });
            shareLinkField?.addEventListener("focus", ev => ev.target.select());
            shareLinkField?.addEventListener("click", ev => ev.target.select());

            window.addEventListener("keydown", ev => {
                if (ev.key === "Escape") {
                    closeMenus();
                    toggleIaModal(false);
                    toggleContextPanel(false);
                    closeInfoPopup();
                    if (subjectModalOverlay?.classList.contains("open")) {
                        subjectModalOverlay.classList.remove("open");
                        subjectModalOverlay.setAttribute("aria-hidden", "true");
                    }
                    if (templateModalOverlay?.classList.contains("open")) {
                        closeTemplateModal();
                    }
                }
            });

            // Init
            syncIaEditor(activeIaPrompt);
            renderTabs();
            renderPage();
            setupSpeechRecognition();
            updateShareMenuUI();
            tryLoadSharedStateFromUrl();
            loadAudioFromDb();
            toggleContextPanel(true);
            populateAudioSpeedOptions();
            audioPlayer.playbackRate = getAudioSpeed();
            document.addEventListener("click", ev => {
                if (infoPopup && !infoPopup.contains(ev.target) && ev.target !== infoButton) {
                    closeInfoPopup();
                }
            });
            window.GoToolkitAppFeedbackConfig = {
                appId: "voice",
                appName: "Voice",
                defaultType: "bug-voice",
                shareCollection: "voices",
                buildSharePayload: () => ({
                    app: "voice",
                    url: window.location.href,
                    payload: state
                })
            };
        })();
    </script>
    <script>
        (function removeVersionQueryParam() {
            try {
                const url = new URL(window.location.href);
                if (!url.searchParams.has("v")) return;
                url.searchParams.delete("v");
                const search = url.searchParams.toString();
                const newUrl = url.pathname + (search ? `?${search}` : "") + url.hash;
                window.history.replaceState({}, "", newUrl);
            } catch (err) {
                /* noop */
            }
        })();
    </script>
    <script src="js/feedback-app.js"></script>
</body>

</html>
