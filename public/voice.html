<!DOCTYPE html>
<html lang="fr">

<head>
    <script>window.GO_TOOLKIT_SHARE_API_URL = 'https://share.gotoolkit.workers.dev/'</script>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Voice | Go-Toolkit</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap">
    <link rel="stylesheet" href="styles/app-shell.css?v=2025.12.27">
    <link rel="stylesheet" href="styles/cgu.css?v=2025.12.27">
    <style>
        :root {
            --bg: #f3f4f6;
            --surface: #ffffff;
            --surface-soft: #f8fafc;
            --border: #e5e7eb;
            --border-strong: #cbd5e1;
            --primary: #2a7a57;
            --primary-soft: rgba(42, 122, 87, 0.1);
            --text: #0f172a;
            --muted: #6b7280;
            --radius-lg: 16px;
            --radius-sm: 10px;
            --shadow-soft: 0 14px 34px rgba(15, 23, 42, 0.1);
        }

        body {
            margin: 0;
            background: var(--bg);
            color: var(--text);
            font-family: var(--app-font, "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif);
            overflow: hidden;
        }

        .app {
            height: 100vh;
            max-width: none;
        }

        .app-main {
            display: grid;
            grid-template-columns: 1fr;
            grid-template-rows: 1fr;
            gap: 12px;
            min-height: 0;
            height: calc(100vh - 20px);
        }

        .app-main.context-open {
            grid-template-columns: 1fr 350px;
        }

        .voice-card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-soft);
            padding: 8px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            min-height: 0;
            width: 100%;
        }

        .voice-main-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .voice-title {
            font-size: 15px;
            font-weight: 500;
            margin: 0;
            padding: 4px 8px;
            border-radius: 10px;
            border: 1px solid transparent;
            cursor: text;
            min-width: 120px;
            max-width: 100%;
        }

        .voice-title:focus-visible {
            outline: none;
            border-color: var(--primary);
            background: var(--primary-soft);
        }

        .voice-main-body {
            display: grid;
            grid-template-columns: 1.1fr 0.9fr;
            gap: 8px;
            min-height: 0;
            flex: 1 1 auto;
        }

        .app-main:not(.context-open) .voice-main-body {
            grid-template-columns: minmax(0, 1fr) 500px;
        }

        .panel {
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            background: var(--surface-soft);
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-height: 0;
            height: 100%;
            overflow: hidden;
        }

        .panel-columns {
            display: block;
        }

        @media (min-width: 1400px) {
            .app-main:not(.context-open) .panel-columns {
                display: grid;
                grid-template-columns: minmax(600px, 1fr) minmax(0, 1fr);
                gap: 12px;
                flex: 1 1 0;
                min-height: 0;
                align-content: stretch;
            }

            .app-main:not(.context-open) .summary-column {
                height: 100%;
            }

            .app-main:not(.context-open) .summary-wrapper {
                flex: 1 1 0;
                min-height: 0;
                display: flex;
                flex-direction: column;
            }

            .app-main:not(.context-open) .summary-area {
                flex: 1 1 0;
                min-height: 0;
                height: 100%;
                overflow-y: auto;
            }
        }

        .app-main.context-open .panel-columns {
            display: flex;
            flex-direction: column;
            flex: 1 1 0;
            min-height: 0;
            gap: 12px;
        }

        .app-main.context-open .note-column {
            flex: 1 1 0;
        }


        .note-column,
        .summary-column {
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-height: 0;
            height: 100%;
            margin-top: 0;
        }

        .note-column {
            min-width: 600px;
        }

        .summary-column {
            display: flex;
            flex-direction: column;
            gap: px;
            min-height: 0;
            height: 100%;
            margin-top: 0;
        }

        .note-column .transcribe-wrapper {
            flex: 1;
            min-height: 0;
            display: flex;
            flex-direction: column;
        }

        .note-column .transcribe-area {
            flex: 1;
            min-height: 0;
        }

        .summary-column .summary-wrapper {
            flex: 0 0 auto;
            min-height: 0;
        }

        .app-main.context-open .note-column,
        .app-main.context-open .summary-column {
            height: auto;
            margin-top: 6px;
        }

        @media (max-width: 1399px) {

            .app-main:not(.context-open) .note-column,
            .app-main:not(.context-open) .summary-column {
                margin-top: 6px;
            }
        }

        .panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            font-weight: 500;
            color: var(--text);
            font-size: 14px;
        }

        .note-mode-select {
            font-size: 13px;
            border-radius: 8px;
            border: 1px solid var(--border-strong);
            padding: 4px 4px;
            background: var(--surface);
            color: var(--text);
            cursor: pointer;
        }

        .recording-toolbar {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .audio-controls {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            min-width: 170px;
        }

        .audio-download {
            position: relative;
            display: inline-flex;
        }

        .audio-download-menu {
            position: absolute;
            top: 110%;
            right: 0;
            background: #fff;
            border: 1px solid var(--border-strong);
            border-radius: 10px;
            box-shadow: var(--shadow-soft);
            display: none;
            flex-direction: column;
            min-width: 180px;
            z-index: 20;
            padding: 6px 0;
        }

        .audio-download-menu.open {
            display: flex;
        }

        .audio-download-option {
            border: none;
            background: transparent;
            text-align: left;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 12px;
            color: var(--text);
            width: 100%;
        }

        .audio-download-option:hover:not(:disabled) {
            background: var(--surface-soft);
        }

        .audio-download-option:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .audio-play-btn,
        .audio-download-btn {
            border: 1px solid var(--border-strong);
            background: transparent;
            border-radius: 8px;
            padding: 2px 6px;
            font-size: 14px;
            cursor: pointer;
        }

        .audio-progress {
            width: 120px;
            accent-color: var(--primary);
            appearance: none;
            height: 6px;
            border-radius: 6px;
            background: #e5e7eb;
            outline: none;
        }

        .audio-progress::-webkit-slider-thumb {
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            border: 2px solid #fff;
            box-shadow: 0 0 0 1px var(--border-strong);
        }

        .audio-progress::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            border: 2px solid #fff;
            box-shadow: 0 0 0 1px var(--border-strong);
        }

        .audio-speed {
            border: 1px solid var(--border-strong);
            border-radius: 10px;
            padding: 2px 6px;
            font-size: 13px;
            background: #fff;
        }

        .screen-toggle {
            border: 1px solid var(--border-strong);
            border-radius: 8px;
            background: transparent;
            color: var(--text);
            font-size: 14px;
            cursor: pointer;
            transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
        }

        .screen-toggle.active {
            background: var(--primary);
            color: #fff;
            border-color: var(--primary);
        }

        .toast {
            z-index: 10050;
        }

        .info-popup {
            position: absolute;
            top: 56px;
            right: 12px;
            width: 280px;
            background: #fff;
            border-radius: 14px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            padding: 15px;
            display: none;
            flex-direction: column;
            gap: 6px;
            font-size: 12px;
            z-index: 200;
        }

        .info-popup.open {
            display: flex;
        }

        .info-popup img {
            width: 48px;
            height: 48px;
            object-fit: contain;
            align-self: center;
        }

        .info-popup a {
            color: #2a7a57;
            text-decoration: none;
            font-weight: 600;
        }

        .info-popup button {
            border-radius: 8px;
            border: 1px solid rgba(15, 23, 42, 0.15);
            background: #fff;
            color: #0f172a;
            padding: 6px 10px;
            font-size: 12px;
            cursor: pointer;
            min-width: 110px;
        }

        .info-popup button.update-btn {
            background: #2a7a57;
            border-color: #2a7a57;
            color: #fff;
        }

        .info-popup button.secondary {
            background: #fff;
            border-color: rgba(15, 23, 42, 0.15);
            color: #0f172a;
        }

        .info-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        textarea {
            width: 100%;
            border-radius: 10px;
            border: 1px solid var(--border-strong);
            padding: 8px 10px;
            font-size: 13px;
            font-family: Menlo, Consolas, "Courier New", monospace;
            resize: none;
            min-height: 120px;
            background: #fff;
            line-height: 1.45;
        }

        textarea:focus,
        input:focus {
            outline: none;
            border: 1px solid var(--primary);
            box-shadow: 0 0 0 1px var(--primary-soft);
        }

        .speech-active {
            border: 2px solid #B11226 !important;
            animation: speech-border 2s infinite ease-in-out;
        }

        .speech-active:focus {
            border: 1px solid #B11226 !important;
            box-shadow: none;
        }

        @keyframes speech-border {
            0% {
                box-shadow: 0 0 0 0 rgba(177, 18, 38, 0.4);
            }

            50% {
                box-shadow: 0 0 0 4px rgba(177, 18, 38, 0.15);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(177, 18, 38, 0.4);
            }
        }

        .transcribe-area {
            font-family: "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
            line-height: 1.3;
            min-height: 0;
            height: 100%;
        }

        .transcribe-wrapper {
            position: relative;
            height: 100%;
            min-height: 0;
        }

        textarea::-webkit-scrollbar,
        .transcribe-area::-webkit-scrollbar,
        .summary-area::-webkit-scrollbar,
        .ia-prompt-field::-webkit-scrollbar,
        #iaTemplateEditor::-webkit-scrollbar,
        #promptCreate::-webkit-scrollbar,
        #promptModify::-webkit-scrollbar,
        #newSubjectPoints::-webkit-scrollbar {
            width: 2px;
        }

        textarea::-webkit-scrollbar-thumb,
        .transcribe-area::-webkit-scrollbar-thumb,
        .summary-area::-webkit-scrollbar-thumb,
        .ia-prompt-field::-webkit-scrollbar-thumb,
        #iaTemplateEditor::-webkit-scrollbar-thumb,
        #promptCreate::-webkit-scrollbar-thumb,
        #promptModify::-webkit-scrollbar-thumb,
        #newSubjectPoints::-webkit-scrollbar-thumb {
            background: rgba(156, 163, 175, 0.45);
            border-radius: 4px;
        }

        /* Firefox scrollbar color for textarea-like fields */
        textarea,
        .transcribe-area,
        .summary-area,
        .ia-prompt-field,
        #iaTemplateEditor,
        #promptCreate,
        #promptModify,
        #newSubjectPoints {
            scrollbar-color: rgba(156, 163, 175, 0.45) transparent;
        }

        .transcribe-ghost {
            position: absolute;
            inset: 0;
            padding: 8px 10px;
            pointer-events: none;
            transform: translate(0, 0);
            color: var(--muted);
            white-space: pre-wrap;
            font-size: 13px;
            line-height: 1.3;
            font-family: "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
            z-index: 3;
        }

        .transcribe-mirror {
            position: absolute;
            visibility: hidden;
            white-space: pre-wrap;
            word-wrap: break-word;
            padding: 8px 10px;
            font-family: "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
            line-height: 1.3;
            inset: 0;
        }

        .transcribe-ghost span {
            font-size: 13px;
        }

        .speech-field-wrapper {
            position: relative;
            height: 100%;
        }

        .speech-field-wrapper textarea {
            position: relative;
            z-index: 2;
        }

        .speech-button {
            position: absolute;
            top: 6px;
            right: 6px;
            width: 24px;
            height: 24px;
            background: rgba(255, 255, 255, 0.85);
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border: none;
            color: var(--muted);
            border-radius: 999px;
            transition: box-shadow 0.2s ease, opacity 0.2s ease;
            opacity: 1;
            pointer-events: auto;
            z-index: 3;
            transform: translateX(2px);
        }

        #audioImportBtn {
            right: 28px;
            top: 4px;
            transform: translateX(0);
        }

        .speech-button--active,
        .speech-button:active {
            color: #B11226;
            animation: speech-blink 2s infinite linear;
            opacity: 1;
        }

        .summary-wrapper {
            min-height: 0;
            height: 100%;
        }

        .summary-area {
            min-height: 0;
            height: 100%;
            line-height: 1.45;
            font-family: "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
        }

        .app-main.context-open .summary-wrapper,
        .app-main.context-open .summary-area {
            height: auto;
        }

        @keyframes speech-blink {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.4;
            }
        }

        .subject-ranges {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin: 10px 0 12px 0;
            width: 100%;
        }

        .subject-range-row {
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: space-between;
            width: 100%;
        }

        .subject-range-row input[type="range"] {
            flex: 1 1 auto;
            appearance: none;
            height: 6px;
            border-radius: 6px;
            background: #e5e7eb;
            outline: none;
        }

        .subject-range-row input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            border: 2px solid #fff;
            box-shadow: 0 0 0 1px var(--border-strong);
        }

        .subject-range-row input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            border: 2px solid #fff;
            box-shadow: 0 0 0 1px var(--border-strong);
        }

        .subject-range-meta {
            font-size: 12px;
            color: var(--muted);
        }

        #guidelineDuration {
            font-size: 14px;
            border: 1px solid var(--border-strong);
            border-radius: 10px;
            padding: 4px 6px;
        }

        .guidelines-panel {
            background: #ffffff;
            border: none;
            border-radius: var(--radius-sm);
            padding: 0px 6px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-height: 0;
        }

        .subject-tabs {
            display: flex;
            flex-wrap: nowrap;
            gap: 6px;
            width: 100%;
            flex-direction: row;
            padding: 8px 0px 8px 0px;
        }

        .subject-tab {
            border: 1px solid var(--border-strong);
            border-radius: 999px;
            padding: 6px 10px;
            font-size: 12px;
            cursor: pointer;
            background: var(--surface);
            color: var(--text);
            display: inline-flex;
            align-items: center;
            gap: 6px;
            flex: 1 1 auto;
            min-width: 0;
            width: auto;
        }

        .edit-subject-btn {
            border: none;
            background: transparent;
            padding: 0;
            margin: 0;
            line-height: 1;
            cursor: pointer;
            font-size: 12px;
        }

        .subject-tab.active {
            background: transparent;
            color: var(--text);
            border-color: var(--primary);
            border-width: 2px;
        }

        .subject-tab .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 6px;
        }

        .status-dot--none {
            background: #9ca3af;
        }

        .status-dot--partial {
            background: #f59e0b;
        }

        .status-dot--complete {
            background: #16a34a;
        }

        .guideline-list {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow: auto;
        }

        .participants-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 6px;
        }

        .participant-row {
            display: grid;
            grid-template-columns: 1fr 0.8fr auto;
            gap: 6px;
        }

        .participant-row input {
            border: 1px solid var(--border-strong);
            border-radius: 10px;
            padding: 6px 8px;
            font-size: 12px;
        }



        .participants-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding-top: 8px;
            padding-bottom: 8px;
        }

        .guideline-item {
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 8px 10px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            background: var(--surface-soft);
            font-size: 13px;
        }

        .guideline-actions {
            display: flex;
            align-items: center;
            gap: 6px;
            flex-wrap: wrap;
        }

        .guideline-actions label {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: var(--muted);
            cursor: pointer;
        }

        .guideline-actions input[type="checkbox"] {
            accent-color: var(--primary);
            cursor: pointer;
        }

        .badge {
            display: inline-flex;
            align-items: center;
            padding: 2px 8px;
            background: var(--primary-soft);
            color: var(--primary);
            border-radius: 999px;
            font-size: 12px;
        }



        .advice-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 8px;
        }

        .advice-card {
            border: 1px dashed var(--border-strong);
            border-radius: 10px;
            padding: 8px 10px;
            font-size: 12px;
            background: var(--surface-soft);
        }

        .gutenberg-card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-soft);
            padding: 10px;
            width: 350px;
            display: none;
            flex-direction: column;
            gap: 12px;
            min-height: 0;
        }

        .gutenberg-card.open {
            display: flex;
        }

        .gutenberg-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.28);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.25s ease;
            z-index: 108;
        }

        .gutenberg-backdrop.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .prompt-template-meta {
            font-size: 12px;
            color: var(--muted);
            margin-bottom: 6px;
        }

        .toast {
            position: fixed;
            bottom: 16px;
            right: 16px;
            background: rgba(17, 24, 39, 0.9);
            color: #fff;
            padding: 10px 14px;
            border-radius: 10px;
            box-shadow: var(--shadow-soft);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            transform: translateY(10px);
            z-index: 11000;
        }

        .toast.visible {
            opacity: 1;
            pointer-events: auto;
            transform: translateY(0);
        }

        .context-menu {
            min-width: 180px;
        }

        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(15, 23, 42, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 120;
        }

        .modal-overlay.open {
            display: flex;
        }

        .modal {
            background: #fff;
            border-radius: 14px;
            padding: 14px;
            width: min(900px, 96vw);
            max-height: 90vh;
            overflow: auto;
            box-shadow: var(--shadow-soft);
        }

        .gt-template-modal__list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 10px;
        }

        .gt-template-card {
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 10px;
            cursor: pointer;
            background: var(--surface-soft);
        }

        .gt-template-card.gt-template-card--selected {
            border-color: var(--primary);
            box-shadow: 0 0 0 2px var(--primary-soft);
        }

        .tabs-actions {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
            flex-wrap: wrap;
        }

        .menu-trigger {
            position: relative;
            display: inline-flex;
        }

        .context-menu {
            position: absolute;
            top: calc(100% + 6px);
            right: 0;
            background: var(--surface);
            border: 1px solid rgba(15, 23, 42, 0.1);
            border-radius: 16px;
            box-shadow: 0 16px 32px rgba(15, 23, 42, 0.2);
            display: none;
            min-width: 220px;
            z-index: 40;
        }

        .context-menu.open {
            display: block;
        }

        .context-menu label,
        .context-menu button {
            font-size: 12px;
        }

        .global-actions {
            display: flex;
            flex-direction: row;
            gap: 8px;
            max-width: 800px;
            width: 100%;
            justify-content: flex-end;
            align-items: flex-start;
        }

        .ia-actions {
            display: flex;
            flex-direction: column;
            gap: 0px;
            height: 100%;
        }

        .ia-actions>.header-row {
            flex: 1 1 auto;
            display: flex;
            flex-direction: column;
        }

        .ia-header-actions {
            width: 100%;
            padding: 4px 0;
        }

        .gutenberg-recette-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            margin-bottom: 6px;
        }

        .ia-prompt-fields textarea {
            width: 100%;
            min-height: 250px;
        }

        #clearScenarioBtn {
            margin-left: auto;
            margin-right: 4px;
        }

        @media (max-width: 1100px) {
            .app-main {
                width: 100%;
                grid-template-columns: 1fr;
            }

            .global-actions {
                justify-content: flex-start;
            }

            .voice-main-body {
                grid-template-columns: 1fr;
            }

            .gutenberg-card {
                position: fixed;
                right: 0;
                top: 0;
                bottom: 0;
                width: min(360px, 92vw);
                max-width: 100%;
                transform: translateX(110%);
                opacity: 0;
                pointer-events: none;
                transition: transform 0.2s ease, opacity 0.2s ease;
                z-index: 110;
            }

            .gutenberg-card.open {
                transform: translateX(0);
                opacity: 1;
                pointer-events: auto;
            }
        }

        @media (max-width: 1000px) {
            .gutenberg-card {
                width: min(340px, 90vw);
            }
        }
    </style>
</head>

<body class="app-body">
    <div class="app">
        <div class="app-header">
            <a class="app-home-link" href="index.html?v=2025.12.27" title="Revenir √† l'accueil">‚òç</a>
            <div class="nav-switch">
                <button id="navSwitcherBtn" class="nav-switch-btn" type="button" aria-haspopup="true"
                    aria-expanded="false">‚ñ∑ Voice ‚ñæ</button>
                <div id="navSwitcherMenu" class="nav-switch-menu" role="menu">
                    <a class="nav-switch-link" href="canvas.html?v=2025.12.27" role="menuitem"> ‚óç Canvas</a>
                    <a class="nav-switch-link" href="grid.html?v=2025.12.27" role="menuitem">‚ñ¶ Grid</a>
                    <a class="nav-switch-link" href="draw.html?v=2025.12.27" role="menuitem">‚óá Draw</a>
                    <a class="nav-switch-link" href="timeline.html?v=2025.12.27" role="menuitem">‚á• Timeline</a>
                </div>
            </div>

            <div class="tabs-actions">
                <div id="viewTabs" class="tabs"></div>
                <button class="tab-action" id="addViewBtn" type="button" aria-label="Ajouter une vue">+</button>
                <button class="tab-action" id="deleteViewBtn" type="button"
                    aria-label="Supprimer la vue active">√ó</button>
            </div>

            <div class="global-actions">
                <button class="btn" id="gtTemplateModalTrigger" aria-label="Ouvrir ‚äû Mod√®les" title="‚äû Mod√®les">‚äû Mod√®les</button>
                <button class="btn" id="gtContextModalTrigger" aria-label="Ouvrir ‚åò Agent" title="‚åò Agent">‚åò Agent</button>
                <button class="btn" id="gtPromptModalTrigger" aria-label="Ouvrir Prompt" title="‚å¨ Prompt">‚å¨ Prompt</button>

                <div class="menu-trigger">
                    <button class="btn" id="fileMenuBtn" aria-label="Document" title="Document">‚¨† Document</button>
                    <div class="context-menu file-menu" id="fileMenu">
                        <div class="menu-panel">
                            <button id="newDocumentBtn" type="button" class="menu-panel-btn">üóã Nouveau</button>
                            <button id="importJsonBtn" type="button" class="menu-panel-btn">‚§∑ Ouvrir</button>
                            <button id="saveDocumentBtn" type="button" class="menu-panel-btn">üñ´
                                Enregistrer</button>
                            <button id="exportJsonBtn" type="button" class="menu-panel-btn">‚≠≥ T√©l√©charger</button>
                            <button id="aboutVoiceBtn" type="button" class="menu-panel-btn">‚éâ √Ä propos</button>
                        </div>
                    </div>
                </div>

                <div class="menu-trigger">
                    <button id="shareBtn" class="btn btn-secondary" type="button" aria-label="Partager"
                        title="Lien de partage">‚òç Partage</button>
                    <div data-share-menu-slot></div>
                </div>
            </div>
        </div>

        <!-- Template modal -->
        <div class="modal-overlay gt-template-modal" id="gtTemplateModal" role="dialog" aria-modal="true"
            aria-labelledby="gtTemplateModalTitle">
            <div class="modal gt-template-modal__dialog">
                <div class="modal-header" style="display:flex;justify-content:space-between;align-items:center;">
                    <h3 id="gtTemplateModalTitle" title="‚äû Mod√®les">‚äû Mod√®les</h3>
                    <button class="modal-close btn" id="gtTemplateModalClose" type="button"
                        aria-label="Fermer ‚äû Mod√®les">√ó</button>
                </div>
                <div class="gt-template-modal__list" id="gtTemplateModalList">
                    <!-- cards rendered by JS -->
                </div>
                <div class="modal-actions" style="margin-top:10px;display:flex;justify-content:flex-end;gap:8px;">
                    <button id="gtTemplateModalApply" class="btn-primary">Appliquer</button>
                </div>
            </div>
        </div>

        <div class="app-main">
            <div class="voice-card">
                <div class="voice-main-header">
                    <div>
                        <div id="pageTitle" class="voice-title" contenteditable="true" role="textbox"
                            aria-label="Titre de la page">Page 1</div>
                    </div>
                </div>
                <div class="voice-main-body">
                    <div class="panel">
                        <div class="panel-columns">
                            <div class="note-column">
                                <div class="panel-header">
                                    <select id="noteModeSelect" class="note-mode-select" aria-label="Mode de note">
                                        <option value="note">Note √©crite</option>
                                        <option value="transcript-auto">Dict√©e vocale</option>
                                        <option value="transcript-ia">Transcript audio</option>
                                        <option value="transcript-video">Transcript vid√©o</option>
                                    </select>
                                    <div class="recording-toolbar">
                                        <span id="transcriptMeta" class="badge"
                                            style="background:#e5e7eb;color:#000;">0' /
                                            0'</span>
                                        <div class="audio-controls">
                                            <button id="audioPlayBtn" type="button" class="audio-play-btn"
                                                title="Lire / pause" aria-label="Lire l'enregistrement">‚ñ∂</button>
                                            <input id="audioProgress" class="audio-progress" type="range" min="0"
                                                max="1" step="0.01" value="0" aria-label="Progression audio" disabled>
                                            <select id="audioSpeedSelect" class="audio-speed" title="Vitesse de lecture"
                                                aria-label="Vitesse de lecture"></select>
                                            <div class="audio-download">
                                                <button id="audioDownloadBtn" type="button" class="audio-download-btn"
                                                    title="T√©l√©charger l'enregistrement"
                                                    aria-label="T√©l√©charger">ü°á</button>
                                                <div id="audioDownloadMenu" class="audio-download-menu"
                                                    aria-hidden="true">
                                                    <button type="button" id="audioDownloadAudio"
                                                        class="audio-download-option">Fichier Audio .webm</button>
                                                    <button type="button" id="audioDownloadVideo"
                                                        class="audio-download-option">Fichier Vid√©o .webm</button>
                                                </div>
                                            </div>
                                            <button id="audioClearBtn" type="button" class="audio-download-btn"
                                                title="Supprimer l'enregistrement"
                                                aria-label="Supprimer l'enregistrement">‚äò</button>
                                            <button id="screenCaptureToggleBtn" type="button"
                                                class="audio-download-btn screen-toggle" title="Capturer l'√©cran"
                                                aria-label="Capturer l'√©cran">‚ßâ</button>
                                        </div>
                                    </div>
                                </div>
                                <div class="transcribe-wrapper speech-field-wrapper">
                                    <textarea id="transcribeInput" class="transcribe-area" placeholder=""
                                        aria-label="Transcription"></textarea>
                                    <div id="transcribeGhost" class="transcribe-ghost" aria-live="polite"></div>
                                    <div id="transcribeMirror" class="transcribe-mirror" aria-hidden="true"></div>
                                    <button class="speech-button" id="speechToggleBtn" type="button"
                                        data-speech-target="transcribeInput" title="Dict√©e vocale"
                                        aria-label="Activer la dict√©e vocale">‚óâ</button>
                                    <button class="speech-button" id="audioImportBtn" type="button"
                                        title="Importer un fichier audio"
                                        aria-label="Importer un fichier audio">‚ô™</button>
                                    <input id="audioImportInput" type="file"
                                        accept="audio/mpeg,audio/mp3,audio/wav,audio/x-wav,audio/mp4,audio/aac,audio/ogg,audio/webm,audio/flac"
                                        hidden />
                                </div>
                            </div>
                            <div class="summary-column">
                                <div class="panel-header">
                                    <span>R√©sum√©</span>
                                    <button id="summarizeBtn" type="button" class="btn">‚åò R√©sumer</button>
                                </div>
                                <div class="summary-wrapper">
                                    <textarea id="summaryTextarea" class="summary-area" rows="8" placeholder=""
                                        aria-label="R√©sum√© IA"></textarea>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="guidelines-panel">
                        <div id="guidelineProgress">
                            <div class="panel-header panel-progress" style="align-items:flex-start;">
                                <div style="display:flex;align-items:center;gap:8px;font-weight:600;">
                                    <div>Sujets</div>
                                    <span style="font-size:12px;color:var(--muted);">Dur√©e pr√©vue</span>
                                    <select id="guidelineDuration">
                                        <!-- options filled by JS -->
                                    </select>
                                </div>
                                <div class="guideline-actions guideline-ai-btn">
                                    <button id="completeBtn" type="button" class="btn">‚åò Remplir</button>
                                    <button id="addSubjectBtn" type="button" class="btn">+ Sujet</button>
                                </div>
                            </div>
                            <div class="subject-tabs" id="subjectTabs"></div>
                            <div id="subjectRanges" class="subject-ranges"></div>
                            <button id="evaluateBtn" type="button" class="btn" style="display:none;">‚åò √âvaluer</button>
                            <ul class="guideline-list" id="guidelineList">
                                <li style="color:var(--muted);font-size:13px;">Ajoute un sc√©nario et clique sur ‚åò
                                    R√©pondre
                                    pour g√©n√©rer les sujets.</li>
                            </ul>
                        </div>
                        <div id="guidelineMeta" class="meta-row" style="width:100%;font-size:14px;"></div>
                    </div>
                </div>
            </div>

            <div class="gutenberg-card gt-context-modal" id="gtContextModal" role="complementary" aria-hidden="true">
                <div class="ia-actions">
                    <div class="header-row ia-header-actions gutenberg-recette">
                        <div class="gutenberg-recette-header">
                            <label for="promptCreate">Commande</label>
                            <button class="btn" type="button" id="clearScenarioBtn"
                                aria-label="R√©initialiser le sc√©nario">‚äò Vider</button>
                            <button class="btn btn-primary" id="respondBtn" type="button">
                                <span>‚åò Envoyer</span>
                            </button>
                        </div>
                        <div class="ia-prompt-fields">
                            <div class="prompt-template-meta" id="promptTemplateMeta">Mod√®le : ‚Äî</div>
                            <textarea id="promptCreate" class="ia-prompt-field" rows="10"
                                placeholder="D√©cris le contexte, les objectifs et les interlocuteurs."></textarea>
                        </div>
                    </div>
                    <div class="header-row ia-header-actions gutenberg-script">
                        <div class="gutenberg-recette-header">
                            <label for="promptModify"
                                style="margin-top:0;display:block;font-size:13px;color:var(--muted)">Script
                                (JSON)</label>
                            <button class="btn" type="button" id="applyScriptBtn"
                                title="Restaurer la derni√®re r√©ponse IA">‚Ü∫ Restaurer</button>
                        </div>
                        <div class="ia-prompt-fields">
                            <textarea id="promptModify" class="ia-prompt-field" rows="16"
                                placeholder='{"title": "...", "subjects": [...]}'></textarea>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="gtContextModalBackdrop" class="gutenberg-backdrop" aria-hidden="true"></div>

        <div class="modal-overlay gt-prompt-modal" id="gtPromptModal" role="dialog" aria-modal="true"
            aria-labelledby="gtPromptModalTitle">
            <div class="modal">
                <div class="modal-header" style="display:flex;align-items:center;justify-content:space-between;">
                    <h3 id="gtPromptModalTitle" title="‚å¨ Prompt">‚å¨ Prompt</h3>
                    <button class="modal-close btn" id="gtPromptModalClose" type="button"
                        aria-label="Fermer l'IA">√ó</button>
                </div>
                <div class="ia-actions">
                    <div class="header-row ia-header-actions">
                        <div style="display:flex;align-items:center;gap:8px;justify-content:space-between;">
                            <label for="iaTemplateEditor" style="margin:0;">Prompt</label>
                            <select id="iaPromptSelect" style="min-width:160px;">
                                <option value="system">R√©pondre</option>
                                <option value="evaluate">√âvaluer</option>
                                <option value="summary">R√©sumer</option>
                                <option value="complete">Remplir</option>
                            </select>
                        </div>
                        <textarea id="iaTemplateEditor" rows="14"
                            style="font-family: Menlo, Consolas, 'Courier New', monospace; font-size:13px; line-height:1.2; height:320px; overflow:auto; resize:vertical; padding:8px;"></textarea>
                    </div>
                    <div class="modal-actions" style="display:flex;justify-content:flex-end;gap:8px;">
                        <button id="iaResetBtn" class="btn" type="button">R√©initialiser</button>
                        <button id="iaApplyBtn" class="btn-primary" type="button">Appliquer</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="infoPopup" class="info-popup" role="dialog" aria-live="polite">
            <img src="logo.gif" alt="Logo Go-Toolkit">
            <strong>Module Voice (Goal Digger)</strong>
            <span>Version 2025.12.27</span>
            <span>Usage r√©serv√© √† Savane Consulting.</span>
            <div class="info-actions">
                <button id="updateAppBtn" type="button" class="update-btn">Mettre √† jour</button>
                <button type="button" class="secondary" data-open-nexus-modal>Mentions l√©gales</button>
            </div>
        </div>

        <div data-toast-slot="copyToast" data-toast-class="toast" data-toast-aria-live="polite"
            data-toast-aria-atomic="true"></div>
    </div>

    <input id="importJsonInput" type="file" accept="application/json" hidden />

    <script>
        window.GO_TOOLKIT_SHARE_API_URL =
            window.GO_TOOLKIT_SHARE_API_URL || "https://share.gotoolkit.workers.dev/";
    </script>
    <script src="js/idb-doc-store.js"></script>
    <script src="js/storage-service.js"></script>
    <script src="js/shared-ui.js"></script>
    <script src="js/cgu.js?v=2025.12.27"></script>
    <script src="js/share-worker-client.js"></script>
    <script src="js/share-history.js"></script>
    <script src="js/capsule-drafts.js"></script>
    <script src="js/ia-config.js"></script>
    <script src="js/prompt.js?v=2025.12.27"></script>
    <script src="js/ia-client.js"></script>
    <script src="js/voice-video-player.js"></script>

    <script>
        (() => {
            const STORAGE_KEY = "voice-capsule";
            const FIRESTORE_COLLECTION = "voices";
            const SHARE_QUERY_PARAM = "share";
            const SPEECH_ENGINE_STORAGE_KEY = "go-toolkit-speech-engine";
            const ASSEMBLY_AI_KEY_STORAGE = "go-toolkit-assemblyai-key";
            const ASSEMBLY_PROXY_TOKEN_URL = (window.GO_TOOLKIT_ASSEMBLYAI_TOKEN_URL || "https://assemblyai.gotoolkit.workers.dev/token").replace(/\/$/, "");
            const ASSEMBLY_PROXY_BASE_URL = ASSEMBLY_PROXY_TOKEN_URL.replace(/\/token\/?$/i, "").replace(/\/$/, "") || ASSEMBLY_PROXY_TOKEN_URL;
            const NOTE_MODE_NOTE = "note";
            const NOTE_MODE_TRANSCRIPT_AUTO = "transcript-auto";
            const NOTE_MODE_TRANSCRIPT_IA = "transcript-ia";
            const NOTE_MODE_TRANSCRIPT_VIDEO = "transcript-video";
            const templateList = (window.GoPrompts && window.GoPrompts.voicePrompts) || [];
            const DEFAULT_TEMPLATE_ID = "default";
            const defaultTemplate = templateList.find(tpl => tpl.id === DEFAULT_TEMPLATE_ID) || templateList[0] || null;
            const promptDefaults = {
                system: (window.GoPrompts && window.GoPrompts.voiceCreateSystemTemplate) || "",
                evaluate: (window.GoPrompts && window.GoPrompts.voiceEvaluatePrompt) || "",
                summary: (window.GoPrompts && window.GoPrompts.voiceSummaryPrompt) || "",
                complete: (window.GoPrompts && window.GoPrompts.voiceCompletePrompt) || ""
            };
            const promptState = { ...promptDefaults };
            let activeIaPrompt = "system";
            let activeRequestId = null;
            let activeRequestController = null;
            let respondCountdownTimer = null;
            const summarizeCountdownState = { timer: null };
            const evaluateCountdownState = { timer: null };
            const completeCountdownState = { timer: null };
            const subjectModal = document.createElement("div");
            subjectModal.className = "modal-overlay";
            subjectModal.setAttribute("role", "dialog");
            subjectModal.setAttribute("aria-hidden", "true");
            subjectModal.innerHTML = `<div class="modal" style="max-width:800px;">
                <div class="modal-header" style="display:flex;align-items:center;justify-content:space-between;">
                    <h3>Sujet</h3>
                    <button type="button" class="btn" id="closeSubjectModal">√ó</button>
                </div>
                <div style="display:flex;flex-direction:column;gap:8px;">
                    <label style="font-size:13px;">Titre du sujet
                        <input id="newSubjectTitle" type="text" placeholder="Sujet 1" style="width:100%;border:1px solid var(--border-strong);border-radius:10px;padding:6px 8px;">
                    </label>
                    <label style="font-size:13px;">Dur√©e (min)
                        <input id="newSubjectDuration" type="number" min="1" max="90" value="15" style="width:100%;border:1px solid var(--border-strong);border-radius:10px;padding:6px 8px;">
                    </label>
                    <label style="font-size:13px;">3 √† 5 points cl√©s (s√©par√©s par des retours √† la ligne)
                        <textarea id="newSubjectPoints" rows="5" style="border:1px solid var(--border-strong);border-radius:10px;padding:6px 8px;overflow:hidden;"></textarea>
                    </label>
                </div>
                <div class="modal-actions" style="display:flex;justify-content:flex-end;gap:8px;margin-top:10px;">
                    <button type="button" class="btn" id="cancelSubjectModal" style="display:none;">Supprimer</button>
                    <button type="button" class="btn-primary" id="confirmSubjectModal">Ajouter</button>
                </div>
            </div>`;
            document.body.appendChild(subjectModal);
            const enforceSubjectPointsLimit = () => {
                const el = document.getElementById("newSubjectPoints");
                if (!el) return;
                const lines = (el.value || "").split(/\r?\n/).slice(0, 5);
                const next = lines.join("\n");
                if (next !== el.value) {
                    const pos = el.selectionStart;
                    el.value = next;
                    if (typeof pos === "number") {
                        const clampedPos = Math.min(pos, next.length);
                        el.selectionStart = clampedPos;
                        el.selectionEnd = clampedPos;
                    }
                }
            };
            enforceSubjectPointsLimit();
            document.getElementById("newSubjectPoints")?.addEventListener("input", enforceSubjectPointsLimit);
            const templateModalOverlay = document.getElementById("gtTemplateModal");
            const templateModalList = document.getElementById("gtTemplateModalList");
            const templateModalClose = document.getElementById("gtTemplateModalClose");
            const templateModalValidate = document.getElementById("gtTemplateModalApply");
            const openTemplateModalBtn = document.getElementById("gtTemplateModalTrigger");
            const promptTemplateMeta = document.getElementById("promptTemplateMeta");
            const openContextModalBtn = document.getElementById("gtContextModalTrigger");
            const contextPanel = document.getElementById("gtContextModal");
            const contextBackdrop = document.getElementById("gtContextModalBackdrop");
            const appMain = document.querySelector(".app-main");
            const openIaModalBtn = document.getElementById("gtPromptModalTrigger");
            const CONTEXT_RESPONSIVE_BREAKPOINT = 1000;
            const iaModalOverlay = document.getElementById("gtPromptModal");
            const iaModalClose = document.getElementById("gtPromptModalClose");
            const iaApplyBtn = document.getElementById("iaApplyBtn");
            const iaResetBtn = document.getElementById("iaResetBtn");
            const iaPromptSelect = document.getElementById("iaPromptSelect");
            const iaTemplateEditor = document.getElementById("iaTemplateEditor");
            const promptCreate = document.getElementById("promptCreate");
            const promptModify = document.getElementById("promptModify");
            const respondBtn = document.getElementById("respondBtn");
            const respondDefaultLabel = respondBtn?.textContent || "‚åò Envoyer";
            const completeBtn = document.getElementById("completeBtn");
            const completeDefaultLabel = completeBtn?.textContent || "‚åò Remplir";
            const clearScenarioBtn = document.getElementById("clearScenarioBtn");
            const applyScriptBtn = document.getElementById("applyScriptBtn");
            const transcribeInput = document.getElementById("transcribeInput");
            const transcribeGhost = document.getElementById("transcribeGhost");
            const transcribeMirror = document.getElementById("transcribeMirror");
            const speechToggleBtn = document.getElementById("speechToggleBtn");
            const audioImportBtn = document.getElementById("audioImportBtn");
            const audioImportInput = document.getElementById("audioImportInput");
            const summarizeBtn = document.getElementById("summarizeBtn");
            const summaryTextarea = document.getElementById("summaryTextarea");
            const summarizeDefaultLabel = summarizeBtn?.textContent || "‚åò R√©sumer";
            const noteModeSelect = document.getElementById("noteModeSelect");
            const audioModeOption = noteModeSelect?.querySelector(`option[value="${NOTE_MODE_TRANSCRIPT_IA}"]`);
            const videoModeOption = noteModeSelect?.querySelector(`option[value="${NOTE_MODE_TRANSCRIPT_VIDEO}"]`);
            const audioPlayBtn = document.getElementById("audioPlayBtn");
            const audioProgress = document.getElementById("audioProgress");
            const audioSpeedSelect = document.getElementById("audioSpeedSelect");
            const audioDownloadBtn = document.getElementById("audioDownloadBtn");
            const audioDownloadMenu = document.getElementById("audioDownloadMenu");
            const audioDownloadAudio = document.getElementById("audioDownloadAudio");
            const audioDownloadVideo = document.getElementById("audioDownloadVideo");
            const audioClearBtn = document.getElementById("audioClearBtn");
            const screenCaptureToggleBtn = document.getElementById("screenCaptureToggleBtn");
            const recordBtn = document.getElementById("recordBtn");
            const pauseBtn = document.getElementById("pauseBtn");
            const recordStatus = document.getElementById("recordStatus");
            const transcriptMeta = document.getElementById("transcriptMeta");
            const pageTitleEl = document.getElementById("pageTitle");
            const subjectTabs = document.getElementById("subjectTabs");
            const subjectRanges = document.getElementById("subjectRanges");
            const guidelineList = document.getElementById("guidelineList");
            const guidelineMeta = document.getElementById("guidelineMeta");
            let guidelineDuration = document.getElementById("guidelineDuration");
            const addSubjectBtn = document.getElementById("addSubjectBtn");
            const evaluateBtn = document.getElementById("evaluateBtn");
            const evaluateDefaultLabel = evaluateBtn?.textContent || "‚åò √âvaluer";
            const refreshFromScriptBtn = document.getElementById("refreshFromScriptBtn");
            const fileMenuBtn = document.getElementById("fileMenuBtn");
            const fileMenu = document.getElementById("fileMenu");
            const optionsMenu = document.getElementById("optionsMenu");
            const newDocumentBtn = document.getElementById("newDocumentBtn");
            const importJsonBtn = document.getElementById("importJsonBtn");
            const importJsonInput = document.getElementById("importJsonInput");
            const saveDocumentBtn = document.getElementById("saveDocumentBtn");
            const exportJsonBtn = document.getElementById("exportJsonBtn");
            const aboutVoiceBtn = document.getElementById("aboutVoiceBtn");
            const infoPopup = document.getElementById("infoPopup");
            const infoButton = aboutVoiceBtn;
            const updateAppBtn = document.getElementById("updateAppBtn");
            const APP_VERSION = "2025.12.27";
            const VERSION_QUERY_PARAM = "v";
            const viewTabs = document.getElementById("viewTabs");
            const addViewBtn = document.getElementById("addViewBtn");
            const deleteViewBtn = document.getElementById("deleteViewBtn");
            const navSwitcherBtn = document.getElementById("navSwitcherBtn");
            const navSwitcherMenu = document.getElementById("navSwitcherMenu");
            const shareBtn = document.getElementById("shareBtn");
            const shareMenu = document.getElementById("shareMenu");
            const shareLinkField = document.getElementById("shareLinkField");
            const shareCreateBtn = document.getElementById("shareCreateBtn");
            const shareUpdateBtn = document.getElementById("shareUpdateBtn");
            const shareMenuStatus = document.getElementById("shareMenuStatus");
            const copyToast = document.getElementById("copyToast");
            const shareHistory = window.goToolkitShareHistory;
            const shareWorkerService = window.goToolkitShareWorker;
            const capsuleDrafts = window.goToolkitCapsuleDrafts;
            const subjectModalOverlay = subjectModal;

            let selectedTemplateId = defaultTemplate?.id || null;
            let selectedTemplateText = defaultTemplate?.text || "";
            let speechRecognition = null;
            let recognitionActive = false;
            let recognitionPaused = false;
            let transcriptPrefix = "";
            let recordingStartedAt = null;
            let recordingTimer = null;
            let recordingBaseElapsedSec = 0;
            let recordingElapsedSec = 0;
            let lastInterim = "";
            let lastCaret = 0;
            let lastTimestampMinute = null;
            let pendingTimestamp = null;
            let currentShareToken = null;
            let shareLoadedFromRemote = false;
            let shareStatusMessage = "";
            let shareStatusType = "";
            let shareRequestInProgress = false;
            let shareLastUpdatedAt = null;
            let assemblyRequestInProgress = false;
            const SELF_PARTICIPANT_KEY = "go-toolkit-voice-self";
            const DEFAULT_SUBJECT_DURATION = 15;
            const MIN_SUBJECT_MINUTES = 10;
            const MAX_SUBJECT_MINUTES = 90;
            const MAX_PARTICIPANTS = 8;
            const setSpeechButtonState = isActive => {
                const btn = speechToggleBtn || recordBtn || pauseBtn;
                if (btn) {
                    btn.classList.toggle("speech-button--active", Boolean(isActive));
                }
                if (transcribeInput) {
                    transcribeInput.classList.toggle("speech-active", Boolean(isActive));
                }
            };
            const AUDIO_DB = {
                name: "go-toolkit-voice-audio",
                store: "recordings",
                key: "latest"
            };
            const VIDEO_DB = {
                name: "go-toolkit-voice-video",
                store: "recordings",
                key: "latest"
            };
            let mediaRecorder = null;
            let mediaStream = null;
            let audioChunks = [];
            let recordingSegments = [];
            let audioRecordingActive = false;
            let audioBlob = null;
            let audioUrl = null;
            const audioPlayer = new Audio();
            let audioDbPromise = null;
            let videoDbPromise = null;
            let videoBlob = null;
            let videoUrl = null;
            let screenCaptureEnabled = false;
            let screenStream = null;
            let screenRecorder = null;
            let screenRecordingActive = false;
            let screenChunks = [];
            let videoPlayerModal = null;

            function getStoredSelfParticipant() {
                try {
                    const raw = localStorage.getItem(SELF_PARTICIPANT_KEY);
                    if (!raw) return null;
                    const parsed = JSON.parse(raw);
                    if (parsed && typeof parsed === "object") {
                        return {
                            name: parsed.name || "",
                            role: parsed.role || ""
                        };
                    }
                } catch (e) { /* noop */ }
                return null;
            }

            function saveSelfParticipant(participant) {
                if (!participant) return;
                try {
                    const payload = {
                        name: participant.name || "",
                        role: participant.role || ""
                    };
                    localStorage.setItem(SELF_PARTICIPANT_KEY, JSON.stringify(payload));
                } catch (e) { /* noop */ }
            }

            function ensureParticipants(list) {
                let arr = Array.isArray(list) ? list.map(p => ({ name: p?.name || "", role: p?.role || "" })) : [];
                arr = arr.slice(0, MAX_PARTICIPANTS);
                while (arr.length < 2) {
                    arr.push({ name: "", role: "" });
                }
                if (arr.length > MAX_PARTICIPANTS) {
                    arr = arr.slice(0, MAX_PARTICIPANTS);
                }
                return arr;
            }

            const defaultPage = () => {
                const self = getStoredSelfParticipant();
                return {
                    id: crypto.randomUUID ? crypto.randomUUID() : String(Date.now()),
                    title: "Page 1",
                    tabLabel: "Page 1",
                    scenario: "",
                    script: "",
                    transcript: "",
                    summary: "",
                    templateId: defaultTemplate?.id || "",
                    templateName: defaultTemplate?.title || "",
                    subjects: [],
                    duration: null,
                    participants: [
                        self || { name: "", role: "" },
                        { name: "", role: "" }
                    ],
                    manualTranscript: "",
                    assemblyTranscript: "",
                    assemblyTranscriptId: "",
                    assemblyTranscriptSentences: [],
                    assemblyTranscriptLastManualEditAt: 0,
                    videoTranscript: "",
                    videoTranscriptId: "",
                    videoTranscriptSentences: [],
                    videoTranscriptFetchedId: "",
                    videoTranscriptLastManualEditAt: 0,
                    audioRecordingVersion: 0,
                    audioTranscriptVersion: 0,
                    noteMode: NOTE_MODE_NOTE,
                    lastIaResponse: "",
                    activeSubjectId: null,
                    checks: {}
                };
            };

            function normalizeState(raw) {
                if (!raw || !Array.isArray(raw.pages)) return raw;
                raw.pages = raw.pages.map(p => {
                    const next = { ...p };
                    next.participants = ensureParticipants(next.participants);
                    if (!next.tabLabel) next.tabLabel = next.title || next.label || "Page";
                    if (typeof next.lastIaResponse !== "string") next.lastIaResponse = "";
                    if (typeof next.summary !== "string") next.summary = "";
                    if (typeof next.templateId !== "string") next.templateId = "";
                    if (typeof next.templateName !== "string") next.templateName = "";
                    if (!next.templateId && defaultTemplate) {
                        next.templateId = defaultTemplate.id;
                    }
                    if (!next.templateName) {
                        const tpl = templateList.find(t => t.id === next.templateId);
                        if (tpl) next.templateName = tpl.title || "";
                    }
                    if (typeof next.manualTranscript !== "string") next.manualTranscript = next.transcript || "";
                    if (typeof next.assemblyTranscript !== "string") next.assemblyTranscript = "";
                    if (typeof next.assemblyTranscriptId !== "string") next.assemblyTranscriptId = "";
                    if (!Array.isArray(next.assemblyTranscriptSentences)) next.assemblyTranscriptSentences = [];
                    if (!Number.isFinite(next.assemblyTranscriptLastManualEditAt)) next.assemblyTranscriptLastManualEditAt = 0;
                    if (typeof next.videoTranscript !== "string") next.videoTranscript = "";
                    if (typeof next.videoTranscriptId !== "string") next.videoTranscriptId = "";
                    if (!Array.isArray(next.videoTranscriptSentences)) next.videoTranscriptSentences = [];
                    if (typeof next.videoTranscriptFetchedId !== "string") next.videoTranscriptFetchedId = "";
                    if (!Number.isFinite(next.videoTranscriptLastManualEditAt)) next.videoTranscriptLastManualEditAt = 0;
                    if (!Number.isFinite(next.audioRecordingVersion)) next.audioRecordingVersion = 0;
                    if (!Number.isFinite(next.audioTranscriptVersion)) next.audioTranscriptVersion = 0;
                    if (!next.noteMode) next.noteMode = NOTE_MODE_NOTE;
                    return next;
                });
                if (!raw.activePageId && raw.pages[0]) raw.activePageId = raw.pages[0].id;
                return raw;
            }

            let loadedFromStorage = false;
            let state = (() => {
                try {
                    const stored = localStorage.getItem(STORAGE_KEY);
                    if (stored) {
                        const parsed = JSON.parse(stored);
                        if (parsed && Array.isArray(parsed.pages) && parsed.pages.length) {
                            loadedFromStorage = true;
                            return normalizeState(parsed);
                        }
                    }
                } catch (err) {
                    console.warn("Impossible de charger l'√©tat Voice", err);
                }
                return { pages: [defaultPage()], activePageId: null };
            })();

            if (!state.activePageId && state.pages[0]) {
                state.activePageId = state.pages[0].id;
            }

            function getMediaStorageKey() {
                return (state?.activePageId && state.activePageId.toString()) || AUDIO_DB.key;
            }

            function persistState() {
                try {
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
                } catch (err) {
                    console.warn("Impossible de persister la capsule Voice", err);
                }
            }

            function showToast(message, isError, durationMs = 2600) {
                if (!copyToast) return;
                copyToast.textContent = message;
                copyToast.style.background = "rgba(17, 24, 39, 0.9)";
                copyToast.classList.add("visible");
                setTimeout(() => copyToast.classList.remove("visible"), durationMs);
            }

            function setShareStatus(message, type) {
                shareStatusMessage = message || "";
                shareStatusType = type || "";
            }

            function formatRelativeTime(value) {
                if (!value) return "";
                try {
                    const timestamp = new Date(value).getTime();
                    if (Number.isNaN(timestamp)) return "";
                    const deltaSeconds = Math.max(0, Math.floor((Date.now() - timestamp) / 1000));
                    if (deltaSeconds < 60) {
                        return "Mis √† jour √† l'instant";
                    }
                    const deltaMinutes = Math.floor(deltaSeconds / 60);
                    if (deltaMinutes < 60) {
                        return `Mis √† jour il y a ${deltaMinutes} minute${deltaMinutes > 1 ? "s" : ""}`;
                    }
                    const deltaHours = Math.floor(deltaMinutes / 60);
                    if (deltaHours < 24) {
                        return `Mis √† jour il y a ${deltaHours} heure${deltaHours > 1 ? "s" : ""}`;
                    }
                    const deltaDays = Math.floor(deltaHours / 24);
                    return `Mis √† jour il y a ${deltaDays} jour${deltaDays > 1 ? "s" : ""}`;
                } catch (err) {
                    return "";
                }
            }

            function buildShareUrl(token) {
                if (!token || !shareWorkerService) return "";
                return `${shareWorkerService.baseUrl}/${shareWorkerService.version}/shares/${FIRESTORE_COLLECTION}/${token}`;
            }

            function updateShareMenuUI() {
                const hasToken = Boolean(currentShareToken);
                if (shareLinkField) {
                    shareLinkField.value = hasToken ? buildShareUrl(currentShareToken) : "";
                    shareLinkField.placeholder = hasToken ? "" : "Appuie sur Cr√©er pour g√©n√©rer un lien priv√©.";
                }
                if (shareCreateBtn) {
                    shareCreateBtn.disabled = shareRequestInProgress || !shareWorkerService?.isReady;
                    shareCreateBtn.classList.toggle("btn-primary", !hasToken);
                    shareCreateBtn.classList.toggle("btn", hasToken);
                }
                if (shareUpdateBtn) {
                    const showUpdate = hasToken;
                    shareUpdateBtn.hidden = !showUpdate;
                    shareUpdateBtn.style.display = showUpdate ? "" : "none";
                    shareUpdateBtn.setAttribute("aria-hidden", String(!showUpdate));
                    shareUpdateBtn.disabled = shareRequestInProgress || !hasToken || !shareWorkerService?.isReady;
                }
                if (shareMenuStatus) {
                    const text = shareStatusMessage ||
                        (!shareWorkerService?.isReady
                            ? "Le partage priv√© n√©cessite le worker Cloudflare."
                            : shareLastUpdatedAt
                                ? formatRelativeTime(shareLastUpdatedAt)
                                : "Seules les personnes disposant du lien peuvent y acc√©der.");
                    shareMenuStatus.textContent = text;
                    const isError =
                        (shareStatusType === "error" && Boolean(text)) ||
                        (!shareWorkerService?.isReady && !shareStatusMessage);
                    shareMenuStatus.classList.toggle("error", isError);
                }
            }

            function getActivePage() {
                return state.pages.find(p => p.id === state.activePageId) || state.pages[0];
            }

            function setActivePage(id) {
                state.activePageId = id;
                persistState();
                renderTabs();
                renderPage();
                void hydrateMediaFromDb();
            }

            function addPage() {
                const nextIndex = state.pages.length + 1;
                const page = defaultPage();
                page.title = `Page ${nextIndex}`;
                page.tabLabel = page.title;
                state.pages.push(page);
                setActivePage(page.id);
                openTemplateModal();
            }

            function deletePage() {
                if (state.pages.length <= 1) {
                    const page = defaultPage();
                    page.title = "Page 1";
                    page.tabLabel = page.title;
                    state.pages = [page];
                    state.activePageId = page.id;
                    persistState();
                    renderTabs();
                    renderPage();
                    openTemplateModal();
                    return;
                }
                state.pages = state.pages.filter(p => p.id !== state.activePageId);
                if (!state.pages.length) {
                    const page = defaultPage();
                    page.title = "Page 1";
                    page.tabLabel = page.title;
                    state.pages = [page];
                    state.activePageId = page.id;
                    persistState();
                    renderTabs();
                    renderPage();
                    openTemplateModal();
                    return;
                }
                state.activePageId = state.pages[0]?.id || null;
                persistState();
                renderTabs();
                renderPage();
            }

            function renderTabs() {
                if (!viewTabs) return;
                viewTabs.innerHTML = "";
                state.pages.forEach((page, idx) => {
                    if (!page.tabLabel) {
                        page.tabLabel = page.title || `Page ${idx + 1}`;
                    }
                    const btn = document.createElement("button");
                    btn.className = "tab" + (page.id === state.activePageId ? " active" : "");
                    btn.type = "button";
                    btn.textContent = page.tabLabel || page.title || "Page";
                    btn.addEventListener("click", () => setActivePage(page.id));
                    btn.addEventListener("dblclick", () => {
                        const next = prompt("Renommer l'onglet ?", page.tabLabel || page.title || "");
                        if (next && next.trim()) {
                            page.tabLabel = next.trim();
                            persistState();
                            renderTabs();
                        }
                    });
                    viewTabs.appendChild(btn);
                });
            }

            function updateTranscriptMeta() {
                if (!transcribeInput || !transcriptMeta) return;
                const formatTime = secs => {
                    const total = Math.max(0, Math.floor(secs || 0));
                    const m = Math.floor(total / 60);
                    const s = total % 60;
                    return `${m}'${String(s).padStart(2, "0")}"`;
                };
                const page = getActivePage();
                const hasAudio = audioUrl && !Number.isNaN(audioPlayer?.duration || NaN) && (audioPlayer?.duration || 0) > 0;
                if (hasAudio) {
                    const current = Math.floor(audioPlayer.currentTime || 0);
                    const totalAudio = Math.floor(audioPlayer.duration || 0);
                    transcriptMeta.textContent = `${formatTime(current)} / ${formatTime(totalAudio)}`;
                    return;
                }
                const totalMinutes = page?.duration
                    ? Number(page.duration)
                    : (page?.subjects?.length || 0) * DEFAULT_SUBJECT_DURATION;
                const totalSeconds = Math.max(0, Math.floor((totalMinutes || 0) * 60));
                const elapsedSec = recordingElapsedSec || 0;
                transcriptMeta.textContent = `${formatTime(elapsedSec)} / ${formatTime(totalSeconds)}`;
            }

            function getLastTimestampMinuteFromTranscript(text = "") {
                const regex = /\[(\d{2,}):(\d{2})\]/g;
                let match = null;
                let last = null;
                while ((match = regex.exec(text)) !== null) {
                    const mins = Number(match[1]);
                    const secs = Number(match[2]);
                    if (!Number.isNaN(mins) && !Number.isNaN(secs)) {
                        last = Math.floor((mins * 60 + secs) / 60);
                    }
                }
                return last;
            }

            function updateGhostOverlay(interimText = "") {
                if (!transcribeInput || !transcribeGhost || !transcribeMirror) return;
                const ghostText = interimText || "";
                if (!ghostText) {
                    transcribeGhost.textContent = "";
                    transcribeGhost.style.transform = "translate(0, 0)";
                    return;
                }
                const styles = window.getComputedStyle(transcribeInput);
                transcribeMirror.style.fontSize = styles.fontSize;
                transcribeMirror.style.lineHeight = styles.lineHeight;
                transcribeMirror.style.width = `${transcribeInput.clientWidth}px`;
                transcribeMirror.textContent = "";
                const before = document.createElement("span");
                const caret = document.createElement("span");
                caret.textContent = "\u200b";
                before.textContent = (transcribeInput.value || "").slice(0, transcribeInput.selectionStart || 0);
                transcribeMirror.append(before, caret);
                const caretRect = caret.getBoundingClientRect();
                const inputRect = transcribeInput.getBoundingClientRect();
                const paddingLeft = parseFloat(styles.paddingLeft) || 0;
                const paddingTop = parseFloat(styles.paddingTop) || 0;
                const left = caretRect.left - inputRect.left + transcribeInput.scrollLeft - paddingLeft + 5;
                const top = caretRect.top - inputRect.top + transcribeInput.scrollTop - paddingTop + 2;
                transcribeGhost.textContent = ghostText;
                transcribeGhost.style.transform = `translate(${left}px, ${top}px)`;
            }

            function updateRangeVisual(rangeInput, totalDurationMinutes = 0) {
                if (!rangeInput) return;
                const total = Math.max(1, Number(totalDurationMinutes) || 1);
                const progressRatio = Math.min(1, Math.max(0, (recordingElapsedSec / 60) / total));
                const pct = progressRatio * 100;
                if (pct <= 0.001) {
                    rangeInput.style.background = "#e5e7eb";
                } else {
                    rangeInput.style.background = `linear-gradient(to right, var(--primary) 0%, var(--primary) ${pct}%, #e5e7eb ${pct}%, #e5e7eb 100%)`;
                }
            }

            function updateRecordingUi() {
                updateTranscriptMeta();
                updateNoteModeOptions();
                const page = getActivePage();
                const total = page?.duration || 0;
                const activeRange = subjectRanges?.querySelector('input[type="range"]');
                if (activeRange) {
                    updateRangeVisual(activeRange, total);
                }
            }

            function addDefaultSubjectsIfEmpty(page) {
                if (!page || (page.subjects && page.subjects.length)) return;
                if (page.__guidelinesCleared) {
                    return;
                }
                page.subjects = [
                    {
                        id: "subject-1",
                        title: "Sujet 1",
                        timeframe: { start: 0, end: DEFAULT_SUBJECT_DURATION },
                        keySentences: [{ text: "Point 1.1", match: "pending" }, { text: "Point 1.2", match: "pending" }]
                    },
                    {
                        id: "subject-2",
                        title: "Sujet 2",
                        timeframe: { start: DEFAULT_SUBJECT_DURATION, end: DEFAULT_SUBJECT_DURATION * 2 },
                        keySentences: [{ text: "Point 2.1", match: "pending" }, { text: "Point 2.2", match: "pending" }]
                    }
                ];
                page.activeSubjectId = page.subjects[0].id;
            }

            function normalizeSubjects(raw = []) {
                return raw.map((subject, index) => {
                    const keySentences = (subject["key-sentences"] || subject.keySentences || subject.key_sentence || subject.sentences || [])
                        .map((entry, idx) => {
                            if (typeof entry === "string") return { text: entry, match: "pending" };
                            if (entry && typeof entry === "object") {
                                return {
                                    text: entry.text || entry.label || entry.sentence || `Point ${idx + 1}`,
                                    match: entry.match || entry.status || "pending"
                                };
                            }
                            return { text: `Point ${idx + 1}`, match: "pending" };
                        })
                        .filter(item => item.text && item.text.trim());
                    return {
                        id: subject.id || `subject-${index + 1}`,
                        title: subject.title || subject.name || `Sujet ${index + 1}`,
                        timeframe: subject.timeframe || subject["time-frame"] || {},
                        keySentences
                    };
                });
            }

            function buildScriptPayloadFromPage(page) {
                if (!page) return null;
                const subjects = (page.subjects || []).map((subject, index) => {
                    const timeframe = subject.timeframe || {};
                    const start = Number.isFinite(timeframe.start) ? timeframe.start : index * DEFAULT_SUBJECT_DURATION;
                    let end = Number.isFinite(timeframe.end) ? timeframe.end : start + DEFAULT_SUBJECT_DURATION;
                    if (end <= start) {
                        end = start + DEFAULT_SUBJECT_DURATION;
                    }
                    const keySentences = (subject.keySentences || []).map(entry => {
                        const match = entry?.match || entry?.status;
                        return {
                            text: entry?.text || entry?.label || entry?.sentence || "",
                            match: match === "direct"
                                ? "direct"
                                : match === "indirect"
                                    ? "indirect"
                                    : match === "partiel"
                                        ? "partiel"
                                        : "missing"
                        };
                    }).filter(item => item.text);
                    const title = subject.title || subject.name || `Sujet ${index + 1}`;
                    return {
                        title,
                        timeframe: { start, end },
                        keySentences
                    };
                });
                const maxEnd = subjects.reduce((max, subject) => Math.max(max, subject.timeframe?.end || 0), 0);
                const pageDuration = Number(page.duration);
                const duration = Number.isFinite(pageDuration) && pageDuration > 0 ? pageDuration : (maxEnd || DEFAULT_SUBJECT_DURATION);
                const participants = (page.participants || [])
                    .map(participant => ({ name: participant?.name || "", role: participant?.role || "" }))
                    .filter(participant => participant.name || participant.role);
                if (!participants.length && Array.isArray(page.participants) && page.participants.length) {
                    const fallback = page.participants[0];
                    participants.push({ name: fallback?.name || "", role: fallback?.role || "" });
                }
                return {
                    title: page.title || "",
                    duration,
                    participants,
                    subjects
                };
            }

            function exportPageStateToScriptField() {
                if (!promptModify) return;
                const page = getActivePage();
                if (!page) return;
                const payload = buildScriptPayloadFromPage(page);
                if (!payload) return;
                const formattedScript = JSON.stringify(payload, null, 2);
                promptModify.value = formattedScript;
                page.script = formattedScript;
                persistState();
            }

            function applyScriptJson(text) {
                if (!text) return null;
                const cleaned = text.trim().replace(/^```(?:json)?/i, "").replace(/```$/i, "").trim();
                const parsed = JSON.parse(cleaned);
                const page = getActivePage();
                if (!page) return null;
                if (parsed.title) page.title = parsed.title;
                if (Array.isArray(parsed.subjects)) {
                    page.subjects = normalizeSubjects(parsed.subjects);
                    page.activeSubjectId = page.subjects[0]?.id || null;
                }
                if (parsed.duration) page.duration = parsed.duration;
                if (Array.isArray(parsed.participants)) page.participants = ensureParticipants(parsed.participants);
                else page.participants = ensureParticipants(page.participants);
                if (parsed.transcript && typeof parsed.transcript === "string") {
                    page.transcript = parsed.transcript;
                    if (transcribeInput) transcribeInput.value = parsed.transcript;
                }
                if (parsed.summary && typeof parsed.summary === "string") {
                    page.summary = parsed.summary;
                    if (summaryTextarea) summaryTextarea.value = parsed.summary;
                }
                page.script = JSON.stringify(parsed, null, 2);
                page.__guidelinesCleared = false;
                persistState();
                renderPage();
                return parsed;
            }

            function openSubjectModal(subjectId) {
                const page = getActivePage();
                if (!page) return;
                const subject = page.subjects?.find(s => s.id === subjectId);
                const titleInput = document.getElementById("newSubjectTitle");
                const durationInput = document.getElementById("newSubjectDuration");
                const pointsInput = document.getElementById("newSubjectPoints");
                const confirmBtn = document.getElementById("confirmSubjectModal");
                const heading = subjectModalOverlay?.querySelector(".modal-header h3");
                if (heading) heading.textContent = subject ? "√âditer un sujet" : "Ajouter un sujet";
                if (confirmBtn) confirmBtn.textContent = subject ? "Mettre √† jour" : "Ajouter";
                if (titleInput) titleInput.value = subject?.title || "";
                if (durationInput) durationInput.value = subject ? (subject.timeframe?.end || DEFAULT_SUBJECT_DURATION) - (subject.timeframe?.start || 0) : String(DEFAULT_SUBJECT_DURATION);
                if (pointsInput) pointsInput.value = (subject?.keySentences || []).map(k => k.text || "").join("\n");
                confirmBtn.dataset.subjectId = subject?.id || "";
                subjectModalOverlay?.classList.add("open");
                subjectModalOverlay?.setAttribute("aria-hidden", "false");
            }

            function renderGuidelines() {
                const page = getActivePage();
                if (!page) return;
                if (Array.isArray(page.subjects) && page.subjects.length) {
                    page.__guidelinesCleared = false;
                }
                addDefaultSubjectsIfEmpty(page);
                page.participants = ensureParticipants(page.participants);
                const subjects = page.subjects || [];
                const totalDuration = page.duration || (subjects.length * DEFAULT_SUBJECT_DURATION);
                let rollingEnd = 0;
                const minDurationClamp = Math.max(0, totalDuration - 1);
                subjects.forEach((subject, idx) => {
                    const start = Math.min(idx === 0 ? 0 : rollingEnd, minDurationClamp);
                    const existingDuration = (typeof subject.timeframe?.end === "number" && typeof subject.timeframe?.start === "number")
                        ? Math.max(1, subject.timeframe.end - subject.timeframe.start)
                        : DEFAULT_SUBJECT_DURATION;
                    let end = typeof subject.timeframe?.end === "number" ? subject.timeframe.end : start + existingDuration;
                    end = Math.min(totalDuration, Math.max(start + 1, end));
                    if (idx === subjects.length - 1) {
                        end = totalDuration || Math.max(start + 1, DEFAULT_SUBJECT_DURATION);
                        if (end <= start) {
                            start = Math.max(0, end - 1);
                        }
                    }
                    subject.timeframe = { start, end };
                    rollingEnd = end;
                });
                function getSubjectStart(idx) {
                    if (idx === 0) return 0;
                    const prev = subjects[idx - 1];
                    return prev && typeof prev.timeframe?.end === "number" ? prev.timeframe.end : getSubjectStart(idx - 1) + DEFAULT_SUBJECT_DURATION;
                }
                if (subjectTabs) {
                    subjectTabs.innerHTML = "";
                    subjects.forEach(subject => {
                        const matched = (subject.keySentences || []).filter(item => item.match === "direct" || item.match === "partiel").length;
                        const total = subject.keySentences?.length || 0;
                        let statusClass = "status-dot status-dot--none";
                        if (matched > 0 && matched < total) {
                            statusClass = "status-dot status-dot--partial";
                        } else if (matched > 0 && matched === total) {
                            statusClass = "status-dot status-dot--complete";
                        }
                        const tab = document.createElement("button");
                        tab.className = "subject-tab" + (subject.id === page.activeSubjectId ? " active" : "");
                        tab.type = "button";
                        tab.innerHTML = `<div style="display:flex;flex-direction:column;align-items:flex-start;gap:4px;width:100%;">
<span style="display:flex;align-items:center;gap:8px;justify-content:space-between;width:100%;"><span><span class="${statusClass}" aria-hidden="true"></span>${subject.title}</span><span class="edit-subject-btn" role="button" data-id="${subject.id}" title="√âditer">‚úé</span></span>
</div>`;
                        tab.addEventListener("click", () => {
                            page.activeSubjectId = subject.id;
                            persistState();
                            renderGuidelines();
                        });
                        subjectTabs.appendChild(tab);
                    });
                    subjectTabs.querySelectorAll(".edit-subject-btn").forEach(btn => {
                        btn.addEventListener("click", ev => {
                            ev.stopPropagation();
                            const id = btn.getAttribute("data-id");
                            openSubjectModal(id);
                        });
                    });
                }

                const activeSubject =
                    subjects.find(s => s.id === page.activeSubjectId) || subjects[0] || null;
                if (!page.activeSubjectId && activeSubject) {
                    page.activeSubjectId = activeSubject.id;
                }

                if (guidelineMeta) {
                    guidelineMeta.innerHTML = "";
                    const header = document.createElement("div");
                    header.className = "participants-header";
                    const title = document.createElement("div");
                    title.style.fontWeight = "600";
                    title.textContent = "Participants";
                    const addBtn = document.createElement("button");
                    addBtn.type = "button";
                    addBtn.className = "btn";
                    addBtn.textContent = "+ Participant";
                    addBtn.addEventListener("click", () => {
                        if (page.participants.length >= MAX_PARTICIPANTS) {
                            showToast(`Maximum ${MAX_PARTICIPANTS} participants.`, true);
                            addBtn.disabled = true;
                            return;
                        }
                        page.participants.push({ name: "", role: "" });
                        persistState();
                        renderGuidelines();
                    });
                    addBtn.disabled = page.participants.length >= MAX_PARTICIPANTS;
                    header.append(title, addBtn);
                    const list = document.createElement("div");
                    list.className = "participants-list";
                    page.participants.forEach((participant, idx) => {
                        const row = document.createElement("div");
                        row.className = "participant-row";
                        const nameInput = document.createElement("input");
                        nameInput.type = "text";
                        nameInput.placeholder = idx === 0 ? "Moi" : `Participant ${idx + 1}`;
                        nameInput.value = participant.name || "";
                        const roleInput = document.createElement("input");
                        roleInput.type = "text";
                        roleInput.placeholder = "R√¥le";
                        roleInput.value = participant.role || "";
                        const deleteBtn = document.createElement("button");
                        deleteBtn.type = "button";
                        deleteBtn.className = "btn";
                        deleteBtn.textContent = "√ó";
                        deleteBtn.style.width = "32px";
                        deleteBtn.addEventListener("click", () => {
                            if (page.participants.length <= 1) return;
                            page.participants.splice(idx, 1);
                            persistState();
                            renderGuidelines();
                        });
                        const save = () => {
                            page.participants[idx] = { name: nameInput.value.trim(), role: roleInput.value.trim() };
                            if (idx === 0) {
                                saveSelfParticipant(page.participants[idx]);
                            }
                            persistState();
                        };
                        nameInput.addEventListener("blur", save);
                        roleInput.addEventListener("blur", save);
                        row.append(nameInput, roleInput, deleteBtn);
                        list.appendChild(row);
                    });
                    guidelineMeta.append(header, list);
                }
                if (!guidelineDuration) {
                    guidelineDuration = document.createElement("select");
                    guidelineDuration.id = "guidelineDuration";
                    guidelineDuration.style.fontSize = "14px";
                    guidelineDuration.style.border = "1px solid var(--border-strong)";
                    guidelineDuration.style.borderRadius = "10px";
                    guidelineDuration.style.padding = "6px 8px";
                }
                guidelineDuration.innerHTML = "";
                for (let min = MIN_SUBJECT_MINUTES; min <= MAX_SUBJECT_MINUTES; min += 5) {
                    const opt = document.createElement("option");
                    opt.value = String(min);
                    opt.textContent = `${min}'`;
                    if (page.duration === min) opt.selected = true;
                    guidelineDuration.appendChild(opt);
                }
                if (!page.duration) {
                    guidelineDuration.value = String(DEFAULT_SUBJECT_DURATION);
                    page.duration = DEFAULT_SUBJECT_DURATION;
                }
                if (!guidelineDuration.dataset.bound) {
                    guidelineDuration.addEventListener("change", () => {
                        const val = Math.min(MAX_SUBJECT_MINUTES, Math.max(MIN_SUBJECT_MINUTES, Number(guidelineDuration.value) || DEFAULT_SUBJECT_DURATION));
                        const currentPage = getActivePage();
                        if (currentPage) {
                            currentPage.duration = val;
                            persistState();
                            renderGuidelines();
                        }
                    });
                    guidelineDuration.dataset.bound = "true";
                }

                if (subjectRanges) {
                    subjectRanges.innerHTML = "";
                    const activeIndex = subjects.findIndex(s => s.id === page.activeSubjectId);
                    const idx = activeIndex >= 0 ? activeIndex : 0;
                    const subject = subjects[idx];
                    const isLast = idx === subjects.length - 1;
                    if (subject) {
                        const prevSubject = isLast && idx > 0 ? subjects[idx - 1] : null;
                        const prevEnd = idx === 0
                            ? 0
                            : Math.max(0, typeof subjects[idx - 1].timeframe?.end === "number"
                                ? subjects[idx - 1].timeframe.end
                                : getSubjectStart(idx));
                        const start = prevEnd;
                        let safeEnd = typeof subject.timeframe?.end === "number" ? subject.timeframe.end : start + DEFAULT_SUBJECT_DURATION;
                        if (isLast) {
                            safeEnd = totalDuration;
                            if (safeEnd <= start) {
                                safeEnd = Math.max(start + 1, totalDuration || start + 1);
                            }
                        } else {
                            safeEnd = Math.min(totalDuration, Math.max(start + 1, safeEnd));
                        }
                        subject.timeframe = { start, end: safeEnd };
                        const row = document.createElement("div");
                        row.className = "subject-range-row";
                        const rangeContainer = document.createElement("div");
                        rangeContainer.style.display = "flex";
                        rangeContainer.style.alignItems = "center";
                        rangeContainer.style.gap = "6px";
                        const rangeInput = document.createElement("input");
                        rangeInput.type = "range";
                        if (isLast && prevSubject) {
                            const minBoundary = Math.min(totalDuration - 1, Math.max((prevSubject.timeframe?.start || 0) + 1, start + 1));
                            const maxBoundary = Math.max(minBoundary, totalDuration - 1);
                            rangeInput.min = String(minBoundary);
                            rangeInput.max = String(maxBoundary);
                            rangeInput.step = "1";
                            rangeInput.value = String(Math.min(maxBoundary, Math.max(minBoundary, prevSubject.timeframe?.end || start + 1)));
                        } else {
                            rangeInput.min = String(start + 1);
                            rangeInput.max = String(Math.max(start + 1, totalDuration));
                            rangeInput.step = "1";
                            rangeInput.value = String(safeEnd);
                        }
                        const meta = document.createElement("div");
                        meta.className = "subject-range-meta";
                        const durationMinutes = Math.max(1, Math.round((safeEnd - start) * 10) / 10);
                        rangeInput.addEventListener("input", () => {
                            if (isLast && prevSubject) {
                                const minBoundary = Number(rangeInput.min);
                                const maxBoundary = Number(rangeInput.max);
                                const boundary = Math.min(maxBoundary, Math.max(minBoundary, Number(rangeInput.value)));
                                prevSubject.timeframe = prevSubject.timeframe || {};
                                prevSubject.timeframe.end = boundary;
                                subject.timeframe.start = boundary;
                                subject.timeframe.end = totalDuration;
                                const dur = Math.max(1, Math.round((subject.timeframe.end - subject.timeframe.start) * 10) / 10);
                                meta.textContent = `${subject.timeframe.start}' ‚Üí ${subject.timeframe.end}'`;
                                if (durationLabel) {
                                    durationLabel.textContent = isNaN(dur) ? "" : `${dur} mn`;
                                }
                            } else {
                                let nextEnd = Number(rangeInput.value);
                                nextEnd = Math.min(totalDuration, Math.max(start + 1, nextEnd));
                                subject.timeframe.end = nextEnd;
                                const dur = Math.max(1, Math.round((nextEnd - start) * 10) / 10);
                                meta.textContent = `${start}' ‚Üí ${nextEnd}'`;
                                if (durationLabel) {
                                    durationLabel.textContent = isNaN(dur) ? "" : `${dur} mn`;
                                }
                                // Propagate start times to following subjects
                                for (let i = idx + 1; i < subjects.length; i++) {
                                    const previous = subjects[i - 1];
                                    const current = subjects[i];
                                    const previousEnd = typeof previous.timeframe?.end === "number"
                                        ? previous.timeframe.end
                                        : previous.timeframe?.start + DEFAULT_SUBJECT_DURATION || 0;
                                    const currentDuration = typeof current.timeframe?.end === "number" && typeof current.timeframe?.start === "number"
                                        ? Math.max(1, current.timeframe.end - current.timeframe.start)
                                        : DEFAULT_SUBJECT_DURATION;
                                    const nextStart = previousEnd;
                                    const nextEndBound = Math.min(totalDuration, Math.max(nextStart + 1, nextStart + currentDuration));
                                    current.timeframe = { start: nextStart, end: nextEndBound };
                                }
                            }
                            persistState();
                            updateRangeVisual(rangeInput, totalDuration);
                        });
                        updateRangeVisual(rangeInput, totalDuration);
                        const initialDuration = Math.max(1, Math.round((safeEnd - start) * 10) / 10);
                        meta.textContent = `${start}' ‚Üí ${safeEnd}'`;
                        const durationLabel = document.createElement("div");
                        durationLabel.className = "subject-range-meta";
                        durationLabel.textContent = isNaN(initialDuration) ? "" : `${initialDuration} mn`;
                        rangeContainer.append(durationLabel, rangeInput, meta);
                        row.append(rangeContainer);
                        if (evaluateBtn) {
                            row.append(evaluateBtn);
                            evaluateBtn.style.display = "";
                            evaluateBtn.style.marginLeft = "auto";
                        }
                        subjectRanges.appendChild(row);
                    } else {
                        if (evaluateBtn) {
                            evaluateBtn.style.display = "none";
                        }
                    }
                }

                if (guidelineList) {
                    guidelineList.innerHTML = "";
                    if (!activeSubject) {
                        // no subjects yet
                    } else {
                        activeSubject.keySentences.forEach((item, idx) => {
                            const li = document.createElement("li");
                            li.className = "guideline-item";
                            const title = document.createElement("div");
                            title.textContent = item.text || `Point ${idx + 1}`;
                            const actions = document.createElement("div");
                            actions.className = "guideline-actions";
                            const directId = `${activeSubject.id}-direct-${idx}`;
                            const indirectId = `${activeSubject.id}-partiel-${idx}`;
                            const direct = document.createElement("label");
                            const directInput = document.createElement("input");
                            directInput.type = "checkbox";
                            directInput.id = directId;
                            directInput.checked = item.match === "direct";
                            directInput.addEventListener("change", () => {
                                item.match = directInput.checked ? "direct" : "pending";
                                if (directInput.checked) {
                                    indirectInput.checked = false;
                                }
                                persistState();
                                renderGuidelines();
                            });
                            direct.appendChild(directInput);
                            direct.appendChild(document.createTextNode("Discut√©"));
                            const indirect = document.createElement("label");
                            const indirectInput = document.createElement("input");
                            indirectInput.type = "checkbox";
                            indirectInput.id = indirectId;
                            indirectInput.checked = item.match === "partiel" || item.match === "indirect";
                            indirectInput.addEventListener("change", () => {
                                item.match = indirectInput.checked ? "partiel" : "pending";
                                if (indirectInput.checked) {
                                    directInput.checked = false;
                                }
                                persistState();
                                renderGuidelines();
                            });
                            indirect.appendChild(indirectInput);
                            indirect.appendChild(document.createTextNode("Abord√©"));
                            actions.append(direct, indirect);
                            li.append(title, actions);
                            guidelineList.appendChild(li);
                        });
                    }
                }

                updateRecordingUi();
            }

            function renderPage() {
                const page = getActivePage();
                if (!page) return;
                const fallbackTemplateId = defaultTemplate?.id || (templateList[0] ? templateList[0].id : null);
                selectedTemplateId = page.templateId || selectedTemplateId || fallbackTemplateId;
                const tplFromState = templateList.find(tpl => tpl.id === selectedTemplateId);
                selectedTemplateText = tplFromState?.text || selectedTemplateText || defaultTemplate?.text || "";
                if (!page.templateId && tplFromState) {
                    page.templateId = tplFromState.id;
                    if (!page.templateName) {
                        page.templateName = tplFromState.title || "";
                    }
                    persistState();
                }
                if (pageTitleEl) pageTitleEl.textContent = page.title || "Page";
                if (promptCreate) promptCreate.value = page.scenario || "";
                if (promptModify) promptModify.value = page.script || "";
                if (!page.manualTranscript) {
                    page.manualTranscript = page.transcript || "";
                }
                if (!page.noteMode) {
                    page.noteMode = NOTE_MODE_NOTE;
                }
                activeNoteMode = page.noteMode;
                const noteContent = getNoteContentForMode(page, page.noteMode);
                if (transcribeInput) transcribeInput.value = noteContent;
                if (noteModeSelect) noteModeSelect.value = page.noteMode;
                if (summaryTextarea) summaryTextarea.value = page.summary || "";
                if (promptTemplateMeta) {
                    const label = page.templateName || tplFromState?.title || "‚Äî";
                    promptTemplateMeta.textContent = `Mod√®le : ${label}`;
                }
                updateTranscriptMeta();
                renderGuidelines();
                updateNoteModeOptions();
            }

            function openTemplateModal() {
                if (!templateModalOverlay) return;
                renderTemplateModalList();
                templateModalOverlay.classList.add("open");
            }

            function closeTemplateModal() {
                templateModalOverlay?.classList.remove("open");
            }

            function renderTemplateModalList() {
                if (!templateModalList) return;
                templateModalList.innerHTML = "";
                const fallbackTemplateId = selectedTemplateId || defaultTemplate?.id || (templateList[0] ? templateList[0].id : null);
                if (!selectedTemplateId && fallbackTemplateId) {
                    selectedTemplateId = fallbackTemplateId;
                }
                templateList.forEach(tpl => {
                    const card = document.createElement("div");
                    card.className = "gt-template-card";
                    card.innerHTML = `<strong style="font-size:13px">${tpl.title}</strong><div style="font-size:12px;color:var(--muted);white-space:pre-wrap;word-break:break-word;margin-top:6px">${tpl.text}</div>`;
                    if (tpl.id === selectedTemplateId) {
                        card.classList.add("gt-template-card--selected");
                    }
                    card.addEventListener("click", () => {
                        selectedTemplateId = tpl.id;
                        Array.from(templateModalList.children).forEach(c => c.classList.remove("gt-template-card--selected"));
                        card.classList.add("gt-template-card--selected");
                    });
                    templateModalList.appendChild(card);
                });
            }

            function applySelectedTemplate() {
                if (!selectedTemplateId || !promptCreate) return;
                const tpl = templateList.find(t => t.id === selectedTemplateId);
                if (!tpl) return;
                selectedTemplateText = tpl.text || "";
                const page = getActivePage();
                if (page) {
                    page.templateId = tpl.id;
                    page.templateName = tpl.title || "";
                    persistState();
                }
                promptTemplateMeta.textContent = `Mod√®le : ${tpl.title}`;
                persistScenario();
                closeTemplateModal();
            }

            function persistScenario() {
                const page = getActivePage();
                if (!page) return;
                page.scenario = promptCreate?.value || "";
                persistState();
            }

            function getAudioDb() {
                if (audioDbPromise) return audioDbPromise;
                audioDbPromise = new Promise((resolve, reject) => {
                    if (!("indexedDB" in window)) {
                        resolve(null);
                        return;
                    }
                    const request = indexedDB.open(AUDIO_DB.name, 1);
                    request.onupgradeneeded = () => {
                        const db = request.result;
                        if (!db.objectStoreNames.contains(AUDIO_DB.store)) {
                            db.createObjectStore(AUDIO_DB.store);
                        }
                    };
                    request.onerror = () => reject(request.error || new Error("IndexedDB audio indisponible"));
                    request.onsuccess = () => resolve(request.result);
                });
                return audioDbPromise;
            }

            async function saveAudioToDb(blob, key = AUDIO_DB.key) {
                try {
                    const db = await getAudioDb();
                    if (!db || !blob) return;
                    const tx = db.transaction(AUDIO_DB.store, "readwrite");
                    const store = tx.objectStore(AUDIO_DB.store);
                    store.put({ type: blob.type || "audio/webm", data: blob }, key);
                    console.log("Audio saved to IDB", { key, type: blob.type, size: blob.size });
                } catch (err) {
                    console.warn("Impossible de sauvegarder l'audio", err);
                }
            }

            async function clearAudioDb(key) {
                try {
                    const db = await getAudioDb();
                    if (!db) return;
                    const tx = db.transaction(AUDIO_DB.store, "readwrite");
                    const store = tx.objectStore(AUDIO_DB.store);
                    if (key) {
                        store.delete(key);
                    } else {
                        store.clear();
                    }
                } catch (err) {
                    console.warn("Impossible de vider l'audio", err);
                }
            }

            async function loadAudioFromDb(key = AUDIO_DB.key) {
                if (!key) return false;
                try {
                    const db = await getAudioDb();
                    if (!db) return false;
                    const tx = db.transaction(AUDIO_DB.store, "readonly");
                    const store = tx.objectStore(AUDIO_DB.store);
                    const req = store.get(key);
                    const result = await new Promise(resolve => {
                        req.onsuccess = () => resolve(req.result);
                        req.onerror = () => resolve(null);
                    });
                    if (result && result.data) {
                        const blobData = result.data;
                        const blob = blobData instanceof Blob
                            ? blobData
                            : new Blob([blobData], { type: result.type || "audio/webm" });
                        recordingSegments = blob ? [blob] : [];
                        setAudioBlob(blob, { skipSave: true });
                        console.log("Audio loaded from IDB", { key, type: blob.type, size: blob.size });
                        return true;
                    }
                    recordingSegments = [];
                } catch (err) {
                    console.warn("Impossible de charger l'audio", err);
                }
                return false;
            }

            function getVideoDb() {
                if (videoDbPromise) return videoDbPromise;
                videoDbPromise = new Promise((resolve, reject) => {
                    if (!("indexedDB" in window)) {
                        resolve(null);
                        return;
                    }
                    const request = indexedDB.open(VIDEO_DB.name, 1);
                    request.onupgradeneeded = () => {
                        const db = request.result;
                        if (!db.objectStoreNames.contains(VIDEO_DB.store)) {
                            db.createObjectStore(VIDEO_DB.store);
                        }
                    };
                    request.onerror = () => reject(request.error || new Error("IndexedDB vid√©o indisponible"));
                    request.onsuccess = () => resolve(request.result);
                });
                return videoDbPromise;
            }

            async function saveVideoToDb(blob, key = VIDEO_DB.key) {
                try {
                    const db = await getVideoDb();
                    if (!db || !blob) return;
                    const tx = db.transaction(VIDEO_DB.store, "readwrite");
                    const store = tx.objectStore(VIDEO_DB.store);
                    store.put({ type: blob.type || "video/webm", data: blob }, key);
                    console.log("Video saved to IDB", { key, type: blob.type, size: blob.size });
                } catch (err) {
                    console.warn("Impossible de sauvegarder la vid√©o", err);
                }
            }

            async function clearVideoDb(key) {
                try {
                    const db = await getVideoDb();
                    if (!db) return;
                    const tx = db.transaction(VIDEO_DB.store, "readwrite");
                    const store = tx.objectStore(VIDEO_DB.store);
                    if (key) {
                        store.delete(key);
                    } else {
                        store.clear();
                    }
                } catch (err) {
                    console.warn("Impossible de vider la vid√©o", err);
                }
            }

            async function loadVideoFromDb(key = VIDEO_DB.key) {
                if (!key) return false;
                try {
                    const db = await getVideoDb();
                    if (!db) return false;
                    const tx = db.transaction(VIDEO_DB.store, "readonly");
                    const store = tx.objectStore(VIDEO_DB.store);
                    const req = store.get(key);
                    const result = await new Promise(resolve => {
                        req.onsuccess = () => resolve(req.result);
                        req.onerror = () => resolve(null);
                    });
                    if (result && result.data) {
                        const blobData = result.data;
                        const blob = blobData instanceof Blob
                            ? blobData
                            : new Blob([blobData], { type: result.type || "video/webm" });
                        setVideoBlob(blob, { skipSave: true });
                        console.log("Video loaded from IDB", { key, type: blob.type, size: blob.size });
                        return true;
                    }
                } catch (err) {
                    console.warn("Impossible de charger la vid√©o", err);
                }
                return false;
            }

            async function hydrateMediaFromDb(targetKey = "") {
                const key = targetKey || getMediaStorageKey();
                const audioKeys = [];
                if (key) {
                    audioKeys.push(key);
                }
                if (!audioKeys.includes(AUDIO_DB.key)) {
                    audioKeys.push(AUDIO_DB.key);
                }
                for (const k of audioKeys) {
                    const loaded = await loadAudioFromDb(k);
                    if (loaded) {
                        console.log("Hydrated audio", { key: k });
                        break;
                    }
                }
                const videoKeys = [];
                if (key) {
                    videoKeys.push(key);
                }
                if (!videoKeys.includes(VIDEO_DB.key)) {
                    videoKeys.push(VIDEO_DB.key);
                }
                for (const k of videoKeys) {
                    const loaded = await loadVideoFromDb(k);
                    if (loaded) {
                        console.log("Hydrated video", { key: k });
                        break;
                    }
                }
            }

            function rebuildCombinedAudioBlob() {
                if (!recordingSegments.length) {
                    setAudioBlob(null, { skipSave: true });
                    return;
                }
                const combined = new Blob(recordingSegments, { type: recordingSegments[0]?.type || "audio/webm" });
                setAudioBlob(combined);
            }

            function finalizeAudioSegment(type = "audio/webm") {
                if (audioChunks.length) {
                    const segment = new Blob(audioChunks, { type });
                    recordingSegments.push(segment);
                    rebuildCombinedAudioBlob();
                }
                audioChunks = [];
            }

            function setAudioBlob(blob, options = {}) {
                const { skipSave } = options;
                if (audioUrl) {
                    try { URL.revokeObjectURL(audioUrl); } catch (e) { /* noop */ }
                }
                audioBlob = blob || null;
                audioUrl = blob ? URL.createObjectURL(blob) : null;
                audioPlayer.src = audioUrl || "";
                audioPlayer.playbackRate = getAudioSpeed();
                audioPlayer.currentTime = 0;
                if (audioProgress) {
                    audioProgress.disabled = !audioUrl;
                    audioProgress.value = 0;
                }
                if (audioPlayBtn) {
                    audioPlayBtn.disabled = !audioUrl;
                    audioPlayBtn.textContent = "‚ñ∂";
                }
                if (blob && !skipSave) {
                    const mediaKey = getMediaStorageKey();
                    saveAudioToDb(blob);
                    if (mediaKey && mediaKey !== AUDIO_DB.key) {
                        saveAudioToDb(blob, mediaKey);
                    }
                }
                if (!skipSave) {
                    const page = getActivePage();
                    if (page) {
                        if (blob) {
                            page.audioRecordingVersion = Number.isFinite(page.audioRecordingVersion) ? page.audioRecordingVersion + 1 : 1;
                            page.audioTranscriptVersion = 0;
                        } else {
                            page.audioRecordingVersion = 0;
                            page.audioTranscriptVersion = 0;
                        }
                        persistState();
                    }
                }
                updateNoteModeOptions();
                updateDownloadMenu();
            }

            function setVideoBlob(blob, options = {}) {
                const { skipSave } = options;
                if (videoUrl) {
                    try { URL.revokeObjectURL(videoUrl); } catch (e) { /* noop */ }
                }
                videoBlob = blob || null;
                videoUrl = blob ? URL.createObjectURL(blob) : null;
                if (blob && !skipSave) {
                    const mediaKey = getMediaStorageKey();
                    saveVideoToDb(blob);
                    if (mediaKey && mediaKey !== VIDEO_DB.key) {
                        saveVideoToDb(blob, mediaKey);
                    }
                }
                updateNoteModeOptions();
                updateDownloadMenu();
            }

            function hasAudioRecording() {
                return Boolean(audioBlob || recordingSegments.length);
            }

            async function discardAudioRecording() {
                stopAudioRecording();
                recordingSegments = [];
                setAudioBlob(null);
                try {
                    await clearAudioDb();
                } catch (err) {
                    console.warn("Impossible de vider l'audio", err);
                }
                updateNoteModeOptions();
            }

            function updateNoteModeOptions() {
                if (!noteModeSelect) return;
                const hasRecording = hasAudioRecording();
                if (audioModeOption) {
                    audioModeOption.hidden = !hasRecording;
                    audioModeOption.disabled = !hasRecording || audioRecordingActive;
                    if (!hasRecording && activeNoteMode === NOTE_MODE_TRANSCRIPT_IA) {
                        showToast("La transcription audio n√©cessite un enregistrement.", true);
                        applyNoteMode(NOTE_MODE_NOTE);
                    }
                }
                if (videoModeOption) {
                    const showVideo = hasRecording;
                    videoModeOption.hidden = false;
                    videoModeOption.disabled = !showVideo || audioRecordingActive;
                    if (!showVideo && activeNoteMode === NOTE_MODE_TRANSCRIPT_VIDEO) {
                        showToast("La transcription vid√©o n√©cessite un enregistrement audio.", true);
                        applyNoteMode(NOTE_MODE_NOTE);
                    }
                }
            }

            function hasManualTranscriptEdits(page) {
                if (!page) return false;
                return Boolean(page.videoTranscriptLastManualEditAt || page.assemblyTranscriptLastManualEditAt);
            }

            function isAudioTranscriptFresh(page) {
                if (!page) return false;
                if (!Number.isFinite(page.audioRecordingVersion) || page.audioRecordingVersion <= 0) return false;
                return Number.isFinite(page.audioTranscriptVersion) &&
                    page.audioRecordingVersion === page.audioTranscriptVersion &&
                    Boolean(page.assemblyTranscript);
            }

            function hasVideoTranscriptContent(page) {
                if (!page) return false;
                return Boolean(page.videoTranscript);
            }

            function shouldTranscribeForVideo(page) {
                if (!page || !audioBlob) return false;
                if (!hasVideoTranscriptContent(page)) return true;
                return !isAudioTranscriptFresh(page);
            }

            function confirmTranscriptRegeneration() {
                if (!audioBlob) return true;
                const page = getActivePage();
                if (!page || !hasManualTranscriptEdits(page)) {
                    return true;
                }
                const confirmed = window.confirm(
                    "Le transcript vid√©o / transcript IA sera reg√©n√©r√© et vos modifications seront perdues. Continuer ?"
                );
                if (!confirmed) {
                    return false;
                }
                page.videoTranscriptLastManualEditAt = 0;
                page.assemblyTranscriptLastManualEditAt = 0;
                persistState();
                return true;
            }

            function updateScreenToggleVisual() {
                if (screenCaptureToggleBtn) {
                    screenCaptureToggleBtn.classList.toggle("active", screenCaptureEnabled);
                    screenCaptureToggleBtn.setAttribute("aria-pressed", screenCaptureEnabled ? "true" : "false");
                }
                updateNoteModeOptions();
            }

            async function ensureScreenCapture() {
                if (!screenCaptureEnabled || !navigator.mediaDevices?.getDisplayMedia) {
                    if (screenCaptureEnabled) {
                        showToast("Capture d'√©cran indisponible.", true);
                        screenCaptureEnabled = false;
                        updateScreenToggleVisual();
                    }
                    return false;
                }
                try {
                    const displayStream = await navigator.mediaDevices.getDisplayMedia({
                        video: { cursor: "always" },
                        audio: false
                    });
                    const videoTrack = displayStream.getVideoTracks()[0];
                    if (!videoTrack) {
                        throw new Error("Flux vid√©o indisponible");
                    }
                    const combined = new MediaStream();
                    combined.addTrack(videoTrack);
                    const micTrack = mediaStream?.getAudioTracks?.()[0];
                    if (micTrack) {
                        combined.addTrack(micTrack.clone());
                    }
                    screenChunks = [];
                    const mimeType = MediaRecorder.isTypeSupported("video/webm;codecs=vp9")
                        ? "video/webm;codecs=vp9"
                        : "video/webm";
                    screenRecorder = new MediaRecorder(combined, { mimeType });
                    screenRecorder.ondataavailable = event => {
                        if (event.data && event.data.size) {
                            screenChunks.push(event.data);
                        }
                    };
                    screenRecorder.onstop = finalizeScreenRecording;
                    screenRecorder.start();
                    screenStream = displayStream;
                    screenRecordingActive = true;
                    return true;
                } catch (err) {
                    console.warn("Capture √©cran impossible", err);
                    showToast("Capture d'√©cran annul√©e.", true);
                    screenCaptureEnabled = false;
                    updateScreenToggleVisual();
                    stopScreenRecording();
                    return false;
                }
            }

            function stopScreenRecording() {
                try {
                    if (screenRecorder && screenRecorder.state === "recording") {
                        screenRecorder.stop();
                    }
                } catch (err) {
                    console.warn("Arr√™t capture √©cran", err);
                }
                if (screenStream) {
                    screenStream.getTracks().forEach(track => track.stop());
                    screenStream = null;
                }
            }

            function finalizeScreenRecording() {
                if (screenChunks.length) {
                    const blob = new Blob(screenChunks, { type: screenChunks[0]?.type || "video/webm" });
                    setVideoBlob(blob);
                } else {
                    setVideoBlob(null, { skipSave: true });
                }
                screenChunks = [];
                screenRecordingActive = false;
                screenRecorder = null;
                if (screenStream) {
                    screenStream.getTracks().forEach(track => track.stop());
                    screenStream = null;
                }
            }

            function parseVttTimestamp(value = "") {
                const normalized = String(value || "").trim();
                if (!normalized) return NaN;
                const sanitized = normalized.replace(/,/g, ".");
                const parts = sanitized.split(":");
                let hours = 0;
                let minutes = 0;
                let seconds = 0;
                if (parts.length === 3) {
                    hours = Number(parts[0]);
                    minutes = Number(parts[1]);
                    seconds = Number(parts[2]);
                } else if (parts.length === 2) {
                    minutes = Number(parts[0]);
                    seconds = Number(parts[1]);
                } else {
                    return NaN;
                }
                if ([hours, minutes, seconds].some(num => Number.isNaN(num))) return NaN;
                return hours * 3600 + minutes * 60 + seconds;
            }

            function formatVttTimestamp(value = 0) {
                const totalMillis = Math.max(0, Math.floor((Number(value) || 0) * 1000));
                const hours = Math.floor(totalMillis / 3600000);
                const minutes = Math.floor((totalMillis % 3600000) / 60000);
                const seconds = Math.floor((totalMillis % 60000) / 1000);
                const millis = totalMillis % 1000;
                return `${String(hours).padStart(2, "0")}:${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}.${String(millis).padStart(3, "0")}`;
            }

            function parseSrtTimestamp(value = "") {
                const normalized = String(value || "").trim();
                const match = normalized.match(/(\d{1,2}):(\d{2}):(\d{2})[,.](\d{1,3})/);
                if (!match) return NaN;
                const hours = Number(match[1]);
                const minutes = Number(match[2]);
                const seconds = Number(match[3]);
                const rawMillis = match[4] || "0";
                const padded = (rawMillis + "000").slice(0, 3);
                const millis = Number(padded);
                if ([hours, minutes, seconds, millis].some(num => Number.isNaN(num))) return NaN;
                return hours * 3600 + minutes * 60 + seconds + millis / 1000;
            }

            function parseVttTranscript(text) {
                const raw = String(text || "").trim();
                if (!raw) return [];
                const lines = raw.split(/\r?\n/);
                const blocks = [];
                let current = [];
                lines.forEach(line => {
                    const trimmed = line.trim();
                    if (!trimmed || trimmed === "---") {
                        if (current.length) {
                            blocks.push(current);
                            current = [];
                        }
                        return;
                    }
                    if (trimmed.toUpperCase().startsWith("WEBVTT") || trimmed.toUpperCase().startsWith("NOTE")) {
                        return;
                    }
                    current.push(trimmed);
                });
                if (current.length) {
                    blocks.push(current);
                }
                return blocks.map((block, index) => {
                    const timingIndex = block.findIndex(line => line.includes("-->"));
                    if (timingIndex === -1) return null;
                    const timing = block[timingIndex];
                    const [startPart, endPart] = timing.split("-->").map(part => part.trim());
                    const start = parseVttTimestamp(startPart);
                    const end = parseVttTimestamp(endPart);
                    if (!Number.isFinite(start)) return null;
                    const safeEnd = Number.isFinite(end) && end > start ? end : start + 2;
                    const contentLines = block.slice(timingIndex + 1);
                    const textContent = contentLines.join("\n").trim();
                    const id = timingIndex > 0 ? block[0] : `segment-${index}`;
                    return {
                        id,
                        text: textContent,
                        start,
                        end: safeEnd
                    };
                }).filter(Boolean);
            }

            function parseSrtTranscript(text) {
                const raw = String(text || "").trim();
                if (!raw) return [];
                const blocks = raw.split(/\r?\n\r?\n/).map(block => block.trim()).filter(Boolean);
                return blocks.map((block, index) => {
                    const lines = block.split(/\r?\n/).map(line => line.trim()).filter(Boolean);
                    if (!lines.length) return null;
                    const timingIndex = lines.findIndex(line => line.includes("-->"));
                    if (timingIndex === -1) return null;
                    const timing = lines[timingIndex];
                    const [startPart, endPart] = timing.split("-->").map(part => part.trim());
                    const start = parseSrtTimestamp(startPart);
                    const end = parseSrtTimestamp(endPart);
                    if (!Number.isFinite(start)) return null;
                    const safeEnd = Number.isFinite(end) && end > start ? end : start + 2;
                    const contentLines = lines.slice(timingIndex + 1);
                    const textContent = contentLines.join("\n").trim();
                    const firstLine = lines[0];
                    const id = firstLine && /^\d+$/.test(firstLine) ? `segment-${firstLine}` : `segment-${index}`;
                    return {
                        id,
                        text: textContent,
                        start,
                        end: safeEnd
                    };
                }).filter(Boolean);
            }

            function buildVttFromSegments(segments = []) {
                if (!Array.isArray(segments) || !segments.length) return "";
                const entries = segments.map(segment => {
                    const start = formatVttTimestamp(segment.start);
                    const end = formatVttTimestamp(segment.end);
                    const content = (segment.text || "").trim();
                    return `${start} --> ${end}\n${content}`;
                });
                return `WEBVTT\n\n${entries.join("\n\n")}`;
            }

            async function ensureVideoTranscriptSegments(page, options = {}) {
                if (!page || !page.videoTranscriptId) return [];
                const { forceRefresh = false } = options;
                const storedSegments = Array.isArray(page.videoTranscriptSentences) ? page.videoTranscriptSentences : [];
                const syncedForCurrentId = page.videoTranscriptFetchedId === page.videoTranscriptId && storedSegments.length;
                const hasManualEdits = Boolean(page.videoTranscriptLastManualEditAt);
                if (syncedForCurrentId && (!forceRefresh || hasManualEdits)) {
                    return storedSegments;
                }
                if (!storedSegments.length && page.videoTranscript) {
                    const parsed = parseVttTranscript(page.videoTranscript);
                    if (parsed.length) {
                        page.videoTranscriptSentences = parsed;
                        page.videoTranscriptFetchedId = page.videoTranscriptId;
                        persistState();
                        return parsed;
                    }
                }
                try {
                    const assemblyKey = getAssemblyApiKey();
                    const vtt = await fetchAssemblyTranscriptVtt(page.videoTranscriptId, assemblyKey);
                    const vttSegments = vtt ? parseVttTranscript(vtt) : [];
                    if (vttSegments.length) {
                        page.videoTranscript = vtt;
                        page.videoTranscriptSentences = vttSegments;
                        page.videoTranscriptFetchedId = page.videoTranscriptId;
                        page.videoTranscriptLastManualEditAt = 0;
                        persistState();
                        return vttSegments;
                    }
                    const fallback = Array.isArray(page.assemblyTranscriptSentences)
                        ? page.assemblyTranscriptSentences
                        : [];
                    if (fallback.length) {
                        const fallbackVtt = buildVttFromSegments(fallback);
                        if (fallbackVtt) {
                            page.videoTranscript = fallbackVtt;
                        }
                        page.videoTranscriptSentences = fallback;
                        page.videoTranscriptFetchedId = page.videoTranscriptId;
                        page.videoTranscriptLastManualEditAt = 0;
                        persistState();
                        return fallback;
                    }
                } catch (err) {
                    console.warn("√âchec de la r√©cup√©ration VTT vid√©o", err);
                }
                return Array.isArray(page.videoTranscriptSentences) ? page.videoTranscriptSentences : [];
            }

            function getVideoTranscriptSegments(page) {
                if (!page) return [];
                const stored = Array.isArray(page.videoTranscriptSentences) ? page.videoTranscriptSentences : [];
                if (stored.length) {
                    return stored.map((sentence, index) => {
                        const start = Number.isFinite(sentence.start) ? sentence.start : 0;
                        let end = Number.isFinite(sentence.end) ? sentence.end : start + 2;
                        if (end <= start) end = start + 2;
                        return {
                            id: sentence.id || `segment-${index}`,
                            text: sentence.text || "",
                            start,
                            end
                        };
                    });
                }
                const parsed = parseVttTranscript(page.videoTranscript || "");
                if (parsed.length) return parsed;
                const legacyParsed = parseSrtTranscript(page.videoTranscript || "");
                if (legacyParsed.length) {
                    const converted = buildVttFromSegments(legacyParsed);
                    if (converted) {
                        page.videoTranscript = converted;
                    }
                    page.videoTranscriptSentences = legacyParsed;
                    persistState();
                    return legacyParsed;
                }
                const assembly = Array.isArray(page.assemblyTranscriptSentences) ? page.assemblyTranscriptSentences : [];
                if (assembly.length) {
                    return assembly.map((sentence, index) => ({
                        id: sentence.id || `sentence-${index}`,
                        text: sentence.text || "",
                        start: Number.isFinite(sentence.start) ? sentence.start : 0,
                        end: Number.isFinite(sentence.end) ? sentence.end : (Number.isFinite(sentence.start) ? sentence.start + 2 : 2)
                    }));
                }
                return [{
                    id: "segment-0",
                    text: page.videoTranscript || page.assemblyTranscript || "",
                    start: 0,
                    end: 2
                }];
            }

            function handleTranscriptUpdateFromModal(sentences) {
                if (!Array.isArray(sentences)) return;
                const page = getActivePage();
                if (!page) return;
                const normalized = sentences.map((sentence, index) => {
                    const start = Number.isFinite(sentence.start) ? sentence.start : 0;
                    let end = Number.isFinite(sentence.end) ? sentence.end : start + 2;
                    if (end <= start) {
                        end = start + 2;
                    }
                    return {
                        id: sentence.id || `segment-${index}`,
                        text: sentence.text || "",
                        start,
                        end
                    };
                });
                page.videoTranscriptSentences = normalized;
                page.videoTranscript = buildVttFromSegments(normalized);
                page.videoTranscriptLastManualEditAt = Date.now();
                if (page.noteMode === NOTE_MODE_TRANSCRIPT_VIDEO && transcribeInput) {
                    transcribeInput.value = page.videoTranscript;
                }
                persistState();
                updateTranscriptMeta();
            }

            function handleVideoTranscriptSaved(sentences) {
                handleTranscriptUpdateFromModal(sentences);
                showToast("Transcription vid√©o enregistr√©e.");
            }

            async function openVoiceVideoModal() {
                if (!videoBlob) {
                    toggleAudioPlayback();
                    return;
                }
                if (!window.VoiceVideoPlayerModal) {
                    showToast("Lecteur vid√©o indisponible.", true);
                    return;
                }
                if (!videoPlayerModal) {
                    videoPlayerModal = new window.VoiceVideoPlayerModal();
                }
                const page = getActivePage();
                if (page) {
                    const needsTranscription = shouldTranscribeForVideo(page);
                    if (needsTranscription && audioBlob) {
                        await processAssemblyRecording(audioBlob, {
                            targetNoteMode: NOTE_MODE_TRANSCRIPT_VIDEO,
                            skipModeApply: true,
                            toastLabel: "Transcription"
                        });
                    }
                    await ensureVideoTranscriptSegments(page);
                    if (page.noteMode === NOTE_MODE_TRANSCRIPT_VIDEO && transcribeInput) {
                        transcribeInput.value = page.videoTranscript || "";
                        updateTranscriptMeta();
                    }
                }
                const sentences = getVideoTranscriptSegments(page);
                videoPlayerModal.open({
                    videoBlob,
                    sentences,
                    onTranscriptChange: handleTranscriptUpdateFromModal,
                    onTranscriptSaved: handleVideoTranscriptSaved
                });
            }

            async function fetchAssemblyTranscriptVtt(transcriptId, key) {
                if (!transcriptId) return "";
                const url = getAssemblyProxyUrl(`transcript/${transcriptId}/vtt`);
                if (!url) return "";
                try {
                    console.log("AssemblyAI VTT request", { url, transcriptId });
                    const response = await fetch(url, {
                        headers: key ? { "X-AssemblyAI-Key": key } : {}
                    });
                    const vtt = await response.text();
                    console.log("AssemblyAI VTT response", {
                        status: response.status,
                        ok: response.ok,
                        length: vtt.length,
                        preview: vtt.slice(0, 280)
                    });
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    return vtt;
                } catch (err) {
                    console.warn("Assembly VTT fetch failed", err);
                    return "";
                }
            }

            async function handleAudioPlayClick() {
                if (!videoBlob) {
                    toggleAudioPlayback();
                    return;
                }
                try {
                    await openVoiceVideoModal();
                } catch (err) {
                    console.warn("Lecteur vid√©o indisponible :", err);
                    showToast("Impossible d'ouvrir le lecteur vid√©o.", true);
                }
            }

            function handleAudioImportClick() {
                if (!audioImportInput) return;
                if (audioBlob) {
                    const confirmClear = window.confirm("Un enregistrement existe d√©j√† et sera remplac√©. Continuer ?");
                    if (!confirmClear) return;
                }
                audioImportInput.value = "";
                audioImportInput.click();
            }

            async function handleAudioImportChange() {
                if (!audioImportInput) return;
                const file = audioImportInput.files?.[0];
                audioImportInput.value = "";
                if (!file) {
                    return;
                }
                stopAudioRecording();
                audioRecordingActive = false;
                recognitionActive = false;
                recognitionPaused = false;
                setSpeechButtonState(false);
                recordingStartedAt = null;
                recordingElapsedSec = 0;
                if (recordingTimer) {
                    clearInterval(recordingTimer);
                    recordingTimer = null;
                }
                recordingSegments = [file];
                setAudioBlob(file);
                updateRecordingUi();
                updateTranscriptMeta();
                await processAssemblyRecording(file);
            }

            function getAssemblyApiKey() {
                try {
                    const stored = (localStorage.getItem(ASSEMBLY_AI_KEY_STORAGE) || "").trim();
                    if (stored) return stored;
                } catch (err) { /* noop */ }
                return (window.GoToolkitAssemblyAiKey || "").trim();
            }

            function getAssemblyProxyUrl(path = "") {
                if (!ASSEMBLY_PROXY_BASE_URL) return "";
                const normalized = (path || "").replace(/^\/+/, "");
                if (!normalized) return ASSEMBLY_PROXY_BASE_URL;
                return `${ASSEMBLY_PROXY_BASE_URL}/${normalized}`;
            }

            function getVoiceContextData() {
                const page = getActivePage();
                const participants = Array.isArray(page?.participants)
                    ? page.participants.map(participant => ({
                        name: participant?.name || "",
                        role: participant?.role || ""
                    })).filter(p => p.name || p.role)
                    : [];
                const subjects = Array.isArray(page?.subjects)
                    ? page.subjects.map(subject => ({
                        title: subject.title || "",
                        keySentences: (subject.keySentences || []).map(ks => ks?.text || "").filter(Boolean)
                    }))
                    : [];
                const voiceContextStrings = [
                    page?.title,
                    promptCreate?.value,
                    ...participants.map(p => [p.name, p.role].filter(Boolean).join(" ")),
                    ...subjects.flatMap(subject => [
                        subject.title,
                        ...subject.keySentences
                    ])
                ].filter(Boolean);
                return {
                    pageTitle: page?.title || "",
                    promptValue: promptCreate?.value || "",
                    participants,
                    subjects,
                    voiceContextStrings
                };
            }

            function getAssemblyKnownValues(page) {
                if (!page) return [];
                const values = [];
                (page.participants || []).forEach(participant => {
                    const name = (participant?.name || "").trim();
                    if (!name) return;
                    const role = (participant?.role || "").trim();
                    values.push(role ? `${name} (${role})` : name);
                });
                return values;
            }

            function buildAssemblyTranscriptPayload(uploadUrl, speakersExpected, knownValues = []) {
                const {
                    participants,
                    subjects,
                    voiceContextStrings
                } = getVoiceContextData();
                const keyterms = [];
                const seenKeyterms = new Set();
                voiceContextStrings.forEach(entry => {
                    const tokens = String(entry || "")
                        .split(/[^A-Za-z√Ä-√ø0-9'-]+/)
                        .filter(Boolean);
                    tokens.forEach(token => {
                        const lowered = token.toLowerCase();
                        if (seenKeyterms.has(lowered) || keyterms.length >= 14) return;
                        seenKeyterms.add(lowered);
                        keyterms.push(token);
                    });
                });
                const payload = {
                    audio_url: uploadUrl,
                    filter_profanity: true,
                    speaker_labels: true,
                    language_detection: true,
                    language_detection_options: {
                        expected_languages: ["en", "fr"],
                        fallback_language: "fr",
                    },
                    punctuate: true,
                    format_text: true,
                    ...(keyterms.length ? { keyterms_prompt: keyterms } : {})
                };
                if (speakersExpected > 0) {
                    payload.speakers_expected = speakersExpected;
                }
                if (knownValues.length) {
                    payload.speech_understanding = {
                        request: {
                            speaker_identification: {
                                speaker_type: "name",
                                known_values: knownValues
                            }
                        }
                    };
                }
                return payload;
            }

            function getNoteContentForMode(page, mode) {
                if (!page) return "";
                if (mode === NOTE_MODE_TRANSCRIPT_VIDEO) {
                    if (page.videoTranscript) {
                        return page.videoTranscript;
                    }
                    if (Array.isArray(page.videoTranscriptSentences) && page.videoTranscriptSentences.length) {
                        return buildVttFromSegments(page.videoTranscriptSentences);
                    }
                    return "";
                }
                if (mode === NOTE_MODE_TRANSCRIPT_IA) {
                    return page.assemblyTranscript || "";
                }
                if (mode === NOTE_MODE_TRANSCRIPT_AUTO) {
                    return page.manualTranscript || "";
                }
                return page.manualTranscript || page.transcript || "";
            }

            let activeNoteMode = NOTE_MODE_NOTE;
            function applyNoteMode(mode) {
                const page = getActivePage();
                if (!page) return;
                activeNoteMode = mode;
                page.noteMode = mode;
                const content = getNoteContentForMode(page, mode);
                if (noteModeSelect) {
                    noteModeSelect.value = mode;
                }
                if (transcribeInput) {
                    transcribeInput.value = content;
                }
                persistState();
                updateGhostOverlay("");
                updateTranscriptMeta();
            }

            function canRequestAssemblyTranscript() {
                if (!audioBlob) {
                    showToast("Cr√©e d'abord un enregistrement audio pour la transcription.", true);
                    if (noteModeSelect) noteModeSelect.value = activeNoteMode;
                    return false;
                }
                if (audioRecordingActive) {
                    showToast("Arr√™te l'enregistrement avant de demander la transcription.", true);
                    if (noteModeSelect) noteModeSelect.value = activeNoteMode;
                    return false;
                }
                if (recognitionActive && !recognitionPaused) {
                    showToast("Arr√™te l'enregistrement avant de demander la transcription.", true);
                    if (noteModeSelect) noteModeSelect.value = activeNoteMode;
                    return false;
                }
                return true;
            }

            async function handleNoteModeSelection(value) {
                if (!noteModeSelect) return;
                const hasRecording = hasAudioRecording();
                if (value === NOTE_MODE_TRANSCRIPT_IA || value === NOTE_MODE_TRANSCRIPT_VIDEO) {
                    if (audioRecordingActive) {
                        showToast("Arr√™te l'enregistrement avant de changer de mode.", true);
                        if (noteModeSelect) noteModeSelect.value = activeNoteMode;
                        return;
                    }
                    if (!hasRecording) {
                        showToast("Cr√©e d'abord un enregistrement audio.", true);
                        if (noteModeSelect) noteModeSelect.value = activeNoteMode;
                        return;
                    }
                }
                if (value === NOTE_MODE_TRANSCRIPT_VIDEO) {
                    if (!screenCaptureEnabled) {
                        showToast("La transcription vid√©o n√©cessite une capture d'√©cran.", true);
                        applyNoteMode(NOTE_MODE_NOTE);
                        return;
                    }
                    const page = getActivePage();
                    const needsTranscription = shouldTranscribeForVideo(page);
                    applyNoteMode(NOTE_MODE_TRANSCRIPT_VIDEO);
                    if (needsTranscription && audioBlob) {
                        await processAssemblyRecording(audioBlob, {
                            targetNoteMode: NOTE_MODE_TRANSCRIPT_VIDEO,
                            skipModeApply: true,
                            toastLabel: "Transcription"
                        });
                    }
                    if (page) {
                        await ensureVideoTranscriptSegments(page);
                        applyNoteMode(NOTE_MODE_TRANSCRIPT_VIDEO);
                    }
                    return;
                }
                if (value === NOTE_MODE_TRANSCRIPT_IA) {
                    if (!canRequestAssemblyTranscript()) {
                        return;
                    }
                    const page = getActivePage();
                    if (
                        page &&
                        Number.isFinite(page.audioRecordingVersion) &&
                        page.audioRecordingVersion > 0 &&
                        page.audioRecordingVersion === page.audioTranscriptVersion &&
                        page.assemblyTranscript
                    ) {
                        applyNoteMode(NOTE_MODE_TRANSCRIPT_IA);
                        return;
                    }
                    applyNoteMode(NOTE_MODE_TRANSCRIPT_IA);
                    processAssemblyRecording(audioBlob);
                    return;
                }
                if (value === NOTE_MODE_TRANSCRIPT_AUTO) {
                    applyNoteMode(NOTE_MODE_TRANSCRIPT_AUTO);
                    return;
                }
                applyNoteMode(NOTE_MODE_NOTE);
            }

            function formatAssemblyTimestamp(ms = 0) {
                const totalSeconds = Math.max(0, Math.floor(Number(ms) / 1000));
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;
                if (hours > 0) {
                    return `[${hours}:${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}]`;
                }
                return `[${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}]`;
            }

            function buildTranscriptFromUtterances(result) {
                const utterances = Array.isArray(result?.utterances) ? result.utterances : [];
                if (!utterances.length) {
                    return (result?.text || "").trim();
                }
                return utterances
                    .map(utterance => {
                        const speaker = (utterance?.speaker || "Participant").trim();
                        const text = (utterance?.text || "").trim();
                        if (!text) return null;
                        const timestamp = formatAssemblyTimestamp(utterance?.start);
                        return `${timestamp} ${speaker}\n${text}`;
                    })
                    .filter(Boolean)
                    .join("\n\n");
            }

            function extractAssemblySentences(result) {
                if (!result) return [];
                const mapSentences = (raw = []) => {
                    return raw
                        .map((sentence, index) => {
                            const startMs = Number.isFinite(sentence.start)
                                ? sentence.start
                                : Number.isFinite(sentence.start_time)
                                    ? sentence.start_time
                                    : 0;
                            const endMs = Number.isFinite(sentence.end)
                                ? sentence.end
                                : Number.isFinite(sentence.end_time)
                                    ? sentence.end_time
                                    : startMs;
                            const start = startMs / 1000;
                            const end = endMs > start ? endMs / 1000 : start + 0.1;
                            return {
                                id: sentence.id || `sentence-${index}`,
                                text: (sentence.text || "").trim(),
                                start,
                                end
                            };
                        })
                        .filter(sentence => Boolean(sentence.text) || sentence.start >= 0);
                };
                const rawSentences = Array.isArray(result.sentences) ? result.sentences : [];
                if (rawSentences.length) {
                    return mapSentences(rawSentences);
                }
                const utterances = Array.isArray(result.utterances) ? result.utterances : [];
                if (utterances.length) {
                    return mapSentences(
                        utterances.map(utterance => ({
                            id: utterance.id || undefined,
                            text: utterance.text || "",
                            start: utterance.start,
                            end: utterance.end
                        }))
                    );
                }
                return [];
            }

            function delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            async function uploadAudioToAssembly(blob, key) {
                if (!blob) throw new Error("Audio absent");
                const url = getAssemblyProxyUrl("upload");
                if (!url) throw new Error("Proxy AssemblyAI indisponible");
                console.log("AssemblyAI upload request", {
                    url,
                    method: "POST",
                    blobType: blob.type,
                    blobSize: blob.size,
                    hasKey: Boolean(key)
                });
                const response = await fetch(url, {
                    method: "POST",
                    headers: {
                        ...(key ? { "X-AssemblyAI-Key": key } : {}),
                        "Content-Type": blob.type || "audio/webm"
                    },
                    body: blob
                });
                let data = null;
                try {
                    data = await response.json();
                } catch (err) {
                    console.warn("AssemblyAI upload response parse failed", err);
                }
                console.log("AssemblyAI upload response", {
                    status: response.status,
                    ok: response.ok,
                    data
                });
                if (!response.ok) {
                    throw new Error(`Envoi audio √©chou√© (${response.status})`);
                }
                if (!data?.upload_url) {
                    throw new Error("URL audio manquante");
                }
                return data.upload_url;
            }

            async function requestAssemblyTranscript(payload, key) {
                const url = getAssemblyProxyUrl("transcript");
                if (!url) throw new Error("Proxy AssemblyAI indisponible");
                console.log("AssemblyAI transcript POST request", {
                    url,
                    hasKey: Boolean(key),
                    payload
                });
                const response = await fetch(url, {
                    method: "POST",
                    headers: {
                        ...(key ? { "X-AssemblyAI-Key": key } : {}),
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify(payload)
                });
                const responseText = await response.text();
                console.log("AssemblyAI transcript POST response", {
                    status: response.status,
                    ok: response.ok,
                    length: responseText.length,
                    preview: responseText.slice(0, 400)
                });
                if (!response.ok) {
                    const detail = responseText ? `: ${responseText.replace(/\s+/g, " ").trim()}` : "";
                    const err = new Error(`Requ√™te transcription √©chou√©e (${response.status})${detail}`);
                    err.status = response.status;
                    err.responseText = responseText;
                    throw err;
                }
                let data;
                try {
                    data = responseText ? JSON.parse(responseText) : null;
                } catch (err) {
                    console.warn("AssemblyAI transcript response parse failed", err);
                    data = null;
                }
                if (!data?.id) {
                    throw new Error("ID de transcription manquante");
                }
                return data.id;
            }

            async function pollAssemblyTranscript(transcriptId, key) {
                const url = getAssemblyProxyUrl(`transcript/${transcriptId}`);
                if (!url) throw new Error("Proxy AssemblyAI indisponible");
                for (let attempt = 0; attempt < 40; attempt++) {
                    const response = await fetch(url, {
                        headers: key ? { "X-AssemblyAI-Key": key } : {}
                    });
                    const responseText = await response.text();
                    const preview = responseText.slice(0, 400);
                    if (!response.ok) {
                        console.log("AssemblyAI transcript GET response", {
                            attempt,
                            status: response.status,
                            ok: false,
                            preview
                        });
                        throw new Error(`√âchec du suivi (${response.status})`);
                    }
                    let data = null;
                    try {
                        data = responseText ? JSON.parse(responseText) : null;
                    } catch (err) {
                        console.warn("AssemblyAI transcript GET response parse failed", err);
                        throw new Error("R√©ponse AssemblyAI invalide");
                    }
                    console.log("AssemblyAI transcript GET response", {
                        attempt,
                        status: response.status,
                        ok: true,
                        preview,
                        data
                    });
                    if (!data) {
                        throw new Error("R√©ponse AssemblyAI invalide");
                    }
                    if (data.status === "completed") {
                        return data;
                    }
                    if (data.status === "error") {
                        throw new Error(data.error || "Erreur AssemblyAI");
                    }
                    await delay(1200);
                }
                throw new Error("Timeout AssemblyAI");
            }

            async function processAssemblyRecording(blob, options = {}) {
                const {
                    targetNoteMode = NOTE_MODE_TRANSCRIPT_IA,
                    skipModeApply = false,
                    toastLabel = "Transcription IA"
                } = options;
                if (!blob) return;
                if (assemblyRequestInProgress) return;
                const assemblyKey = getAssemblyApiKey();
                const baseUrl = ASSEMBLY_PROXY_BASE_URL;
                if (!baseUrl) {
                    showToast("Proxy AssemblyAI indisponible.", true);
                    return;
                }
                assemblyRequestInProgress = true;
                showToast(`${toastLabel} en cours‚Ä¶`, false, 5200);
                try {
                    console.debug("AssemblyAI upload request, blob", blob);
                    const uploadUrl = await uploadAudioToAssembly(blob, assemblyKey);
                    console.debug("AssemblyAI upload response url", uploadUrl);
                    const page = getActivePage();
                    const participantsWithNames = (page?.participants || []).filter(participant => (participant?.name || "").trim());
                    const knownValues = getAssemblyKnownValues(page);
                    const payload = buildAssemblyTranscriptPayload(uploadUrl, participantsWithNames.length, knownValues);
                    console.debug("AssemblyAI request payload", payload);
                    console.log("AssemblyAI request payload", payload);
                    let transcriptId;
                    try {
                        transcriptId = await requestAssemblyTranscript(payload, assemblyKey);
                    } catch (err) {
                        const responseText = String(err?.responseText || "");
                        const schemaError = responseText.includes("Invalid endpoint schema");
                        if (err?.status === 400 && schemaError) {
                            const fallbackPayload = {
                                audio_url: uploadUrl,
                                speaker_labels: true,
                                language_detection: true,
                                punctuate: true,
                                format_text: true,
                                ...(participantsWithNames.length > 0 ? { speakers_expected: participantsWithNames.length } : {})
                            };
                            console.warn("AssemblyAI payload rejected, retrying with fallback schema", {
                                error: responseText,
                                fallbackPayload
                            });
                            transcriptId = await requestAssemblyTranscript(fallbackPayload, assemblyKey);
                        } else {
                            throw err;
                        }
                    }
                    console.debug("AssemblyAI transcript id", transcriptId);
                    const result = await pollAssemblyTranscript(transcriptId, assemblyKey);
                    console.debug("AssemblyAI poll result", result);
                    console.log("AssemblyAI poll response", result);
                    const finalText = buildTranscriptFromUtterances(result);
                    if (!finalText) {
                        throw new Error("Transcription vide");
                    }
                    transcriptPrefix = finalText;
                    lastCaret = finalText.length;
                    const activePage = getActivePage();
                    if (activePage) {
                        const assemblySentences = extractAssemblySentences(result);
                        const vttText = await fetchAssemblyTranscriptVtt(transcriptId, assemblyKey);
                        let videoSentences = vttText ? parseVttTranscript(vttText) : [];
                        if (!videoSentences.length && assemblySentences.length) {
                            videoSentences = assemblySentences;
                        }
                        if (!videoSentences.length) {
                            videoSentences = [{
                                id: `segment-${Date.now()}`,
                                text: finalText,
                                start: 0,
                                end: 0.1
                            }];
                        }
                        const videoTranscriptString = vttText || buildVttFromSegments(videoSentences);
                        activePage.assemblyTranscript = finalText;
                        activePage.assemblyTranscriptId = transcriptId;
                        activePage.assemblyTranscriptSentences = assemblySentences;
                        activePage.assemblyTranscriptLastManualEditAt = 0;
                        activePage.videoTranscript = videoTranscriptString;
                        activePage.videoTranscriptId = transcriptId;
                        activePage.videoTranscriptSentences = videoSentences;
                        activePage.videoTranscriptFetchedId = transcriptId;
                        activePage.videoTranscriptLastManualEditAt = 0;
                        activePage.audioTranscriptVersion = Number.isFinite(activePage.audioRecordingVersion)
                            ? activePage.audioRecordingVersion
                            : 0;
                    }
                    if (!skipModeApply) {
                        applyNoteMode(targetNoteMode);
                    } else {
                        persistState();
                    }
                    showToast(`${toastLabel} termin√©e.`);
                } catch (err) {
                    console.error("AssemblyAI transcription failed", err);
                    showToast("Transcription AssemblyAI impossible.", true);
                } finally {
                    assemblyRequestInProgress = false;
                }
            }

            function updateAudioProgress() {
                if (!audioProgress || !audioPlayer?.duration || Number.isNaN(audioPlayer.duration)) return;
                const ratio = Math.min(1, Math.max(0, audioPlayer.currentTime / audioPlayer.duration));
                audioProgress.value = ratio;
            }

            async function ensureAudioRecording() {
                if (!navigator.mediaDevices?.getUserMedia) return false;
                if (mediaRecorder && mediaRecorder.state === "recording") return true;
                try {
                    mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                } catch (err) {
                    console.error("Micro indisponible", err);
                    showToast("Micro indisponible pour l'enregistrement audio.", true);
                    return false;
                }
                const mime = MediaRecorder.isTypeSupported("audio/webm;codecs=opus")
                    ? "audio/webm;codecs=opus"
                    : "audio/webm";
                audioChunks = [];
                try {
                    mediaRecorder = new MediaRecorder(mediaStream, { mimeType: mime });
                } catch (err) {
                    console.error("MediaRecorder indisponible", err);
                    showToast("Enregistrement local indisponible.", true);
                    return false;
                }
                mediaRecorder.ondataavailable = e => {
                    if (e.data && e.data.size > 0) {
                        audioChunks.push(e.data);
                    }
                };
                mediaRecorder.onstop = () => {
                    if (mediaStream) {
                        mediaStream.getTracks().forEach(track => track.stop());
                        mediaStream = null;
                    }
                    finalizeAudioSegment(mime);
                    mediaRecorder = null;
                };
                mediaRecorder.start();
                return true;
            }

            function stopAudioRecording() {
                try {
                    if (mediaRecorder && mediaRecorder.state === "recording") {
                        mediaRecorder.stop();
                    } else if (mediaStream) {
                        mediaStream.getTracks().forEach(track => track.stop());
                        mediaStream = null;
                        mediaRecorder = null;
                    }
                } catch (err) {
                    console.warn("Stop audio recording", err);
                }
                stopScreenRecording();
                audioRecordingActive = false;
            }

            function toggleAudioPlayback() {
                if (!audioUrl) return;
                if (audioPlayer.paused) {
                    audioPlayer.play();
                    if (audioPlayBtn) audioPlayBtn.textContent = "‚è∏";
                } else {
                    audioPlayer.pause();
                    if (audioPlayBtn) audioPlayBtn.textContent = "‚ñ∂";
                }
            }

            function getAudioSpeed() {
                const val = parseFloat(audioSpeedSelect?.value || "1.2");
                if (Number.isNaN(val)) return 1.2;
                return Math.min(2, Math.max(0.5, val));
            }

            function populateAudioSpeedOptions() {
                if (!audioSpeedSelect) return;
                audioSpeedSelect.innerHTML = "";
                for (let s = 0.5; s <= 2.001; s += 0.1) {
                    const rounded = Math.round(s * 10) / 10;
                    const opt = document.createElement("option");
                    opt.value = String(rounded);
                    opt.textContent = `${rounded.toFixed(1)}x`;
                    audioSpeedSelect.appendChild(opt);
                }
                audioSpeedSelect.value = "1.2";
            }

            function formatBlobSize(blob) {
                if (!blob?.size) return "";
                const mb = blob.size / (1024 * 1024);
                if (mb >= 10) return `${Math.round(mb)} MB`;
                const rounded = Math.max(0.1, Math.round(mb * 10) / 10);
                return `${rounded.toFixed(1)} MB`;
            }

            function updateDownloadMenu() {
                const hasAudio = Boolean(audioBlob);
                const hasVideo = Boolean(videoBlob);
                const canDownload = hasAudio || hasVideo;
                if (audioDownloadBtn) {
                    audioDownloadBtn.disabled = !canDownload;
                }
                if (audioDownloadMenu && !canDownload) {
                    audioDownloadMenu.classList.remove("open");
                    audioDownloadMenu.setAttribute("aria-hidden", "true");
                }
                if (audioDownloadAudio) {
                    audioDownloadAudio.disabled = !hasAudio;
                    audioDownloadAudio.textContent = hasAudio
                        ? `Audio (${formatBlobSize(audioBlob)})`
                        : "Audio";
                }
                if (audioDownloadVideo) {
                    if (hasVideo) {
                        audioDownloadVideo.style.display = "block";
                        audioDownloadVideo.disabled = false;
                        audioDownloadVideo.textContent = `Vid√©o (${formatBlobSize(videoBlob)})`;
                    } else {
                        audioDownloadVideo.style.display = "none";
                        audioDownloadVideo.disabled = true;
                    }
                }
            }

            function toggleDownloadMenu(forceOpen) {
                if (!audioDownloadMenu || audioDownloadBtn?.disabled) return;
                const shouldOpen = typeof forceOpen === "boolean"
                    ? forceOpen
                    : !audioDownloadMenu.classList.contains("open");
                audioDownloadMenu.classList.toggle("open", shouldOpen);
                audioDownloadMenu.setAttribute("aria-hidden", shouldOpen ? "false" : "true");
            }

            function downloadBlob(blob, filename) {
                if (!blob) return;
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = filename;
                a.click();
                setTimeout(() => URL.revokeObjectURL(url), 1000);
            }

            function handleDownloadAudio() {
                if (!audioBlob) return;
                downloadBlob(audioBlob, "voice-recording.webm");
                toggleDownloadMenu(false);
            }

            function handleDownloadVideo() {
                if (!videoBlob) return;
                downloadBlob(videoBlob, "voice-video.webm");
                toggleDownloadMenu(false);
            }

            function startRespondCountdown(seconds = 30) {
                if (!respondBtn) return;
                let remaining = seconds;
                const tick = () => {
                    if (!activeRequestId) {
                        stopRespondCountdown();
                        return;
                    }
                    const label = remaining < 10 ? `0${remaining}` : `${remaining}`;
                    respondBtn.textContent = `‚ó¥ ${label}s`;
                    remaining -= 1;
                    if (remaining < 0) remaining = seconds;
                };
                tick();
                if (respondCountdownTimer) clearInterval(respondCountdownTimer);
                respondCountdownTimer = setInterval(tick, 1000);
            }

            function stopRespondCountdown() {
                if (respondCountdownTimer) clearInterval(respondCountdownTimer);
                respondCountdownTimer = null;
                if (respondBtn) respondBtn.textContent = respondDefaultLabel;
            }

            const ACTION_COUNTDOWN_PREFIX = "‚ó¥";

            function startActionCountdown(button, state, defaultLabel, seconds = 30) {
                if (!button) return;
                let remaining = seconds;
                const tick = () => {
                    const label = remaining < 10 ? `0${remaining}` : `${remaining}`;
                    button.textContent = `${ACTION_COUNTDOWN_PREFIX} ${label}s`;
                    remaining -= 1;
                    if (remaining < 0) remaining = seconds;
                };
                tick();
                if (state.timer) clearInterval(state.timer);
                state.timer = setInterval(tick, 1000);
            }

            function stopActionCountdown(button, state, defaultLabel) {
                if (state.timer) clearInterval(state.timer);
                state.timer = null;
                if (button) button.textContent = defaultLabel;
            }

            function clearActiveRequest() {
                activeRequestId = null;
                activeRequestController = null;
                stopRespondCountdown();
                respondBtn?.classList.remove("btn-primary");
            }

            function cancelActiveRequest(showToastMessage = true) {
                if (!activeRequestId) return;
                try { activeRequestController?.abort(); } catch (e) { /* noop */ }
                clearActiveRequest();
                if (showToastMessage) showToast("Requ√™te IA annul√©e.");
            }

            async function runVoicePrompt() {
                const page = getActivePage();
                if (!page) return;
                if (!selectedTemplateId && defaultTemplate) {
                    selectedTemplateId = defaultTemplate.id;
                    selectedTemplateText = defaultTemplate.text || selectedTemplateText || "";
                    if (!page.templateId) {
                        page.templateId = selectedTemplateId;
                        page.templateName = page.templateName || defaultTemplate.title || "";
                        persistState();
                    }
                }
                if (activeRequestId) {
                    cancelActiveRequest();
                    return;
                }
                const scenario = promptCreate?.value?.trim();
                const transcript = transcribeInput?.value?.trim();
                const basePrompt = promptState.system || promptDefaults.system;
                const templateText = selectedTemplateText || "";
                const systemPrompt = (basePrompt || promptDefaults.system || "")
                    .replace(/{{scenario_prompt}}/gi, scenario || "")
                    .replace(/{{template_text}}/gi, templateText || "");
                if (!systemPrompt || !scenario) {
                    showToast("Ajoute un sc√©nario avant de lancer l'IA.", true);
                    return;
                }
                const requestId = crypto.randomUUID ? crypto.randomUUID() : String(Date.now());
                activeRequestId = requestId;
                activeRequestController = typeof AbortController !== "undefined" ? new AbortController() : null;
                respondBtn?.classList.add("btn-primary");
                startRespondCountdown();
                try {
                    const model = (window.GoToolkitIAConfig && window.GoToolkitIAConfig.getOpenAiModel?.()) || "gpt-5-nano";
                    const payload = {
                        model,
                        input: [
                            {
                                role: "system",
                                content: systemPrompt
                            },
                            {
                                role: "user",
                                content:
                                    `Contexte : ${scenario}` +
                                    (templateText ? `\nMod√®le choisi : ${templateText}` : "") +
                                    (transcript ? `\nTranscription actuelle :\n${transcript}` : "")
                            }
                        ],
                        max_output_tokens: 1200
                    };
                    const messageText = await window.GoToolkitIA.chatCompletion({
                        payload,
                        signal: activeRequestController?.signal
                    });
                    if (requestId !== activeRequestId) return;
                    if (promptModify) {
                        promptModify.value = messageText;
                    }
                    page.lastIaResponse = messageText;
                    applyScriptJson(messageText);
                    persistState();
                    showToast("Trame g√©n√©r√©e.");
                } catch (err) {
                    if (requestId !== activeRequestId) return;
                    if (err?.name !== "AbortError") {
                        console.error("Voice prompt failed", err);
                        showToast("Impossible de g√©n√©rer la trame.", true);
                    }
                } finally {
                    if (requestId !== activeRequestId) return;
                    clearActiveRequest();
                    if (respondBtn) respondBtn.textContent = respondDefaultLabel;
                }
            }

            async function completeGuidelinesFromTranscript() {
                const page = getActivePage();
                if (!page) return;
                const transcript = (transcribeInput?.value || "").trim();
                if (!transcript) {
                    showToast("Ajoute une transcription avant de compl√©ter.", true);
                    return;
                }
                if (hasCustomGuidelineData(page)) {
                    const preview = transcript.replace(/\s+/g, " ").slice(0, 120);
                    const labelSuffix = transcript.length > 120 ? "‚Ä¶" : "";
                    const confirmMsg = preview
                        ? `Des sujets existent d√©j√† et seront remplac√©s par cette transcription : "${preview}${labelSuffix}". Continuer ?`
                        : "Des sujets existent d√©j√† et seront remplac√©s par la transcription actuelle. Continuer ?";
                    if (!window.confirm(confirmMsg)) return;
                    clearGuidelineData();
                }
                completeBtn?.setAttribute("disabled", "true");
                startActionCountdown(completeBtn, completeCountdownState, completeDefaultLabel);
                try {
                    const promptTemplate = promptState.complete || promptDefaults.complete || "";
                    const prompt = promptTemplate.replace(/{{transcript_content}}/gi, transcript);
                    const payload = {
                        model: (window.GoToolkitIAConfig && window.GoToolkitIAConfig.getOpenAiModel?.()) || "gpt-5-nano",
                        input: [
                            {
                                role: "system",
                                content: prompt
                            }
                        ],
                        max_output_tokens: 1200
                    };
                    const response = await window.GoToolkitIA.chatCompletion({ payload });
                    const cleaned = response.trim().replace(/^```(?:json)?/i, "").replace(/```$/i, "").trim();
                    const parsed = JSON.parse(cleaned);
                    if (!parsed || typeof parsed !== "object") {
                        throw new Error("R√©ponse IA invalide");
                    }
                    const subjectsRaw = Array.isArray(parsed.subjects) ? parsed.subjects : [];
                    const subjectsWithMinutes = subjectsRaw.map(subject => {
                        const timeframe = subject.timeframe || {};
                        const startSeconds = Number.isFinite(Number(timeframe.start)) ? Number(timeframe.start) :
                            Number.isFinite(Number(timeframe.start_seconds)) ? Number(timeframe.start_seconds) :
                                Number.isFinite(Number(timeframe.startSeconds)) ? Number(timeframe.startSeconds) : 0;
                        const endSeconds = Number.isFinite(Number(timeframe.end)) ? Number(timeframe.end) :
                            Number.isFinite(Number(timeframe.end_seconds)) ? Number(timeframe.end_seconds) :
                                Number.isFinite(Number(timeframe.endSeconds)) ? Number(timeframe.endSeconds) :
                                    Math.max(startSeconds + DEFAULT_SUBJECT_DURATION * 60, 0);
                        const normalizedKeySentences = Array.isArray(subject.keySentences)
                            ? subject.keySentences.map(entry => {
                                if (!entry || typeof entry !== "object") return entry;
                                return {
                                    ...entry,
                                    match: entry.match === "indirect" ? "partiel" : entry.match
                                };
                            })
                            : subject.keySentences;
                        return {
                            ...subject,
                            timeframe: {
                                start: convertSecondsToMinutes(startSeconds),
                                end: convertSecondsToMinutes(Math.max(endSeconds, startSeconds + 1))
                            },
                            keySentences: normalizedKeySentences
                        };
                    });
                    const normalizedSubjects = normalizeSubjects(subjectsWithMinutes);
                    page.subjects = normalizedSubjects;
                    page.activeSubjectId = normalizedSubjects[0]?.id || null;
                    const lastSubject = normalizedSubjects[normalizedSubjects.length - 1];
                    const lastEnd = Number(lastSubject?.timeframe?.end || 0);
                    page.duration = lastEnd || page.duration || DEFAULT_SUBJECT_DURATION;
                    page.__guidelinesCleared = false;
                    if (Array.isArray(parsed.participants) && parsed.participants.length) {
                        page.participants = ensureParticipants(parsed.participants);
                    } else {
                        page.participants = ensureParticipants(page.participants);
                    }
                    const scriptPayload = JSON.stringify(parsed, null, 2);
                    if (promptModify) promptModify.value = scriptPayload;
                    page.script = scriptPayload;
                    persistState();
                    renderGuidelines();
                    showToast("Guidelines compl√©t√©s.");
                } catch (err) {
                    console.error("Complete guidelines failed", err);
                    showToast("Impossible de compl√©ter via IA.", true);
                } finally {
                    completeBtn?.removeAttribute("disabled");
                    stopActionCountdown(completeBtn, completeCountdownState, completeDefaultLabel);
                }
            }

            async function evaluateGuidelines() {
                const page = getActivePage();
                if (!page || !page.subjects.length) {
                    showToast("Pas de sujets √† √©valuer.", true);
                    return;
                }
                const transcript = transcribeInput?.value?.trim() || "";
                if (!transcript) {
                    showToast("Ajoute une transcription avant d'√©valuer.", true);
                    return;
                }
                evaluateBtn?.setAttribute("disabled", "true");
                startActionCountdown(evaluateBtn, evaluateCountdownState, evaluateDefaultLabel);
                try {
                    const evaluatePrompt = promptState.evaluate || promptDefaults.evaluate;
                    const summary = page.subjects.map(s => {
                        return {
                            title: s.title,
                            keySentences: s.keySentences.map(k => k.text)
                        };
                    });
                    const payload = {
                        model: (window.GoToolkitIAConfig && window.GoToolkitIAConfig.getOpenAiModel?.()) || "gpt-5-nano",
                        input: [
                            {
                                role: "system",
                                content: evaluatePrompt
                            },
                            {
                                role: "user",
                                content: `Transcription :\n${transcript}\nGuidelines : ${JSON.stringify(summary)}`
                            }
                        ],
                        max_output_tokens: 900
                    };
                    const response = await window.GoToolkitIA.chatCompletion({ payload });
                    const cleaned = response.trim().replace(/^```(?:json)?/i, "").replace(/```$/i, "");
                    const parsed = JSON.parse(cleaned);
                    if (parsed && Array.isArray(parsed.subjects)) {
                        parsed.subjects.forEach(subjectResult => {
                            const target = page.subjects.find(s => s.title === subjectResult.title);
                            if (!target) return;
                            (subjectResult.keySentences || []).forEach(ks => {
                                const found = target.keySentences.find(k => k.text === ks.text);
                                if (found && ks.match) {
                                    found.match = ks.match;
                                }
                            });
                        });
                        persistState();
                        renderGuidelines();
                        showToast("√âvaluation termin√©e.");
                    }
                } catch (err) {
                    console.error("Evaluation failed", err);
                    showToast("Impossible d'√©valuer via IA.", true);
                } finally {
                    evaluateBtn?.removeAttribute("disabled");
                    stopActionCountdown(evaluateBtn, evaluateCountdownState, evaluateDefaultLabel);
                }
            }

            async function summarizeTranscript() {
                const page = getActivePage();
                if (!page) return;
                const transcript = (transcribeInput?.value || "").trim();
                if (!transcript) {
                    showToast("Ajoute une transcription avant de r√©sumer.", true);
                    return;
                }
                summarizeBtn?.setAttribute("disabled", "true");
                startActionCountdown(summarizeBtn, summarizeCountdownState, summarizeDefaultLabel);
                try {
                    const templateText = selectedTemplateText || "";
                    const prompt = (promptState.summary || promptDefaults.summary || "")
                        .replace(/{{transcript_content}}/gi, transcript)
                        .replace(/{{template_text}}/gi, templateText);
                    const payload = {
                        model: (window.GoToolkitIAConfig && window.GoToolkitIAConfig.getOpenAiModel?.()) || "gpt-5-nano",
                        input: [
                            {
                                role: "system",
                                content: prompt
                            }
                        ],
                        max_output_tokens: 800
                    };
                    const response = await window.GoToolkitIA.chatCompletion({ payload });
                    const cleaned = response.trim().replace(/^```(?:[a-z]+)?/i, "").replace(/```$/i, "").trim();
                    if (summaryTextarea) summaryTextarea.value = cleaned;
                    page.summary = cleaned;
                    persistState();
                    showToast("R√©sum√© g√©n√©r√©.");
                } catch (err) {
                    console.error("R√©sum√© IA impossible", err);
                    showToast("Impossible de r√©sumer via IA.", true);
                } finally {
                    summarizeBtn?.removeAttribute("disabled");
                    stopActionCountdown(summarizeBtn, summarizeCountdownState, summarizeDefaultLabel);
                }
            }

            function toggleOptionsMenu() {
                optionsMenu?.classList.toggle("open");
            }

            function toggleFileMenu() {
                fileMenu?.classList.toggle("open");
            }

            function toggleShareMenu() {
                shareMenu?.classList.toggle("open");
            }

            function closeMenus(except) {
                if (optionsMenu && optionsMenu !== except) optionsMenu.classList.remove("open");
                if (fileMenu && fileMenu !== except) fileMenu.classList.remove("open");
                if (shareMenu && shareMenu !== except) shareMenu.classList.remove("open");
                if (navSwitcherMenu && navSwitcherMenu !== except) navSwitcherMenu.classList.remove("open");
            }

            function persistCapsuleDraft() {
                if (!capsuleDrafts || typeof capsuleDrafts.upsertRecord !== "function") return;
                const page = getActivePage();
                const payload = { ...state };
                const draftId = state.activePageId || (capsuleDrafts.generateId ? capsuleDrafts.generateId() : null);
                capsuleDrafts.upsertRecord({
                    id: draftId,
                    app: "voice",
                    payload,
                    title: page?.title || "Voice",
                    description: (page?.scenario || "").slice(0, 120)
                });
                if (draftId && audioBlob) {
                    saveAudioToDb(audioBlob, draftId);
                }
                if (draftId && videoBlob) {
                    saveVideoToDb(videoBlob, draftId);
                }
            }

            function resetDocument() {
                state = { pages: [defaultPage()], activePageId: null };
                state.activePageId = state.pages[0].id;
                persistState();
                renderTabs();
                renderPage();
                clearAudioStoreAll();
                openTemplateModal();
            }

            function importFromFile(file) {
                const reader = new FileReader();
                reader.onload = () => {
                    try {
                        const payload = JSON.parse(reader.result);
                        if (payload && Array.isArray(payload.pages)) {
                            state = normalizeState(payload) || state;
                            persistState();
                            renderTabs();
                            renderPage();
                            showToast("Capsule charg√©e.");
                        }
                    } catch (err) {
                        showToast("Fichier JSON invalide.", true);
                    }
                };
                reader.readAsText(file);
            }

            async function exportJson() {
                const payload = JSON.stringify(state, null, 2);
                const blob = new Blob([payload], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = "voice-capsule.json";
                a.click();
                URL.revokeObjectURL(url);
                showToast("Capsule t√©l√©charg√©e.");
            }

            async function copyCurrentShareLinkToClipboard() {
                if (!currentShareToken) return false;
                const link = buildShareUrl(currentShareToken);
                if (!link) return false;
                try {
                    await navigator.clipboard.writeText(link);
                    showToast("Lien priv√© copi√©");
                    return true;
                } catch (err) {
                    console.error("Copie du lien priv√© impossible", err);
                    return false;
                }
            }

            async function saveSharePayload(token, payload) {
                if (!shareWorkerService || !shareWorkerService.isReady) {
                    throw new Error("Partage indisponible");
                }
                const meta = await shareWorkerService.saveSharePayload(FIRESTORE_COLLECTION, token, payload);
                if (shareHistory && typeof shareHistory.upsertRecord === "function") {
                    try {
                        const firstPage = payload.pages?.[0];
                        await shareHistory.upsertRecord("voice", {
                            token,
                            updatedAt: meta?.updatedAt || new Date().toISOString(),
                            title: firstPage?.title || "Voice",
                            description: (firstPage?.scenario || "").slice(0, 120)
                        });
                    } catch (err) {
                        console.warn("share history voice", err);
                    }
                }
                return meta;
            }

            async function createOrUpdateShare(isUpdate = false) {
                if (!shareWorkerService?.isReady) {
                    setShareStatus("Le partage priv√© n√©cessite le worker Cloudflare.", "error");
                    updateShareMenuUI();
                    return;
                }
                if (shareRequestInProgress) return;
                shareRequestInProgress = true;
                updateShareMenuUI();
                try {
                    const token = isUpdate && currentShareToken ? currentShareToken : (crypto.randomUUID ? crypto.randomUUID() : String(Date.now()));
                    const payload = { ...state };
                    const meta = await saveSharePayload(token, payload);
                    currentShareToken = token;
                    shareLoadedFromRemote = true;
                    shareLastUpdatedAt = meta?.updatedAt || new Date().toISOString();
                    setShareStatus(shareLastUpdatedAt);
                    updateShareMenuUI();
                    await copyCurrentShareLinkToClipboard();
                    showToast(isUpdate ? "Lien mis √† jour" : "Lien cr√©√©");
                    persistState();
                } catch (err) {
                    console.error("Share voice failed", err);
                    setShareStatus("Impossible de sauvegarder le partage.", "error");
                } finally {
                    shareRequestInProgress = false;
                    updateShareMenuUI();
                }
            }

            async function tryLoadSharedStateFromUrl() {
                const params = new URLSearchParams(window.location.search);
                const token = params.get(SHARE_QUERY_PARAM);
                if (!token || !shareWorkerService?.isReady) return false;
                try {
                    const result = await shareWorkerService.fetchSharePayload(FIRESTORE_COLLECTION, token);
                    if (result?.payload) {
                        state = normalizeState(result.payload) || state;
                        currentShareToken = token;
                        shareLoadedFromRemote = true;
                        shareLastUpdatedAt = result.meta?.updatedAt || new Date().toISOString();
                        if (!state.activePageId && state.pages?.[0]) {
                            state.activePageId = state.pages[0].id;
                        }
                        persistState();
                        renderTabs();
                        renderPage();
                        updateShareMenuUI();
                        showToast("Document charg√© depuis Partage.");
                        return true;
                    }
                } catch (err) {
                    console.error("Chargement share voice impossible", err);
                }
                return false;
            }

            function applyScriptFromTextarea(options = {}) {
                const { silent } = options;
                const text = promptModify?.value;
                if (!text) {
                    clearGuidelineData();
                    if (!silent) showToast("JSON vide.", true);
                    return;
                }
                try {
                    applyScriptJson(text);
                    if (!silent) showToast("JSON appliqu√©.");
                } catch (err) {
                    console.error("Invalid JSON", err);
                    if (!silent) showToast("JSON invalide.", true);
                }
            }

            function clearGuidelineData() {
                const page = getActivePage();
                if (!page) return;
                page.subjects = [];
                page.activeSubjectId = null;
                page.duration = null;
                page.script = "";
                page.__guidelinesCleared = true;
                if (promptModify) promptModify.value = "";
                persistState();
                renderGuidelines();
            }

            function hasCustomGuidelineData(page) {
                if (!page || !Array.isArray(page.subjects) || !page.subjects.length) return false;
                return page.subjects.some(subject => {
                    const title = (subject.title || "").trim();
                    const isDefaultTitle = /^Sujet\s+\d+$/i.test(title);
                    const hasCustomTitle = title && !isDefaultTitle;
                    const keySentences = Array.isArray(subject.keySentences) ? subject.keySentences : [];
                    const hasCustomKeys = keySentences.some(ks => {
                        const text = (ks.text || "").trim();
                        return text && !/^Point\s+\d+/i.test(text);
                    });
                    return hasCustomTitle || hasCustomKeys;
                });
            }

            function convertSecondsToMinutes(value) {
                const secs = Number(value);
                if (!Number.isFinite(secs)) return 0;
                return Math.round((secs / 60) * 10) / 10;
            }

            function restoreLastIaResponse() {
                const page = getActivePage();
                const fallback = page?.lastIaResponse || page?.script || "";
                if (!fallback) {
                    showToast("Aucune r√©ponse IA √† restaurer.", true);
                    return;
                }
                if (promptModify) {
                    promptModify.value = fallback;
                }
                applyScriptFromTextarea({ silent: true });
                showToast("Derni√®re r√©ponse IA restaur√©e.");
            }

            function setupSpeechRecognition() {
                let engine = "web-speech";
                try {
                    const stored = localStorage.getItem(SPEECH_ENGINE_STORAGE_KEY) || window.GoToolkitSpeechEngine;
                    engine = stored === "whisperer" ? "whisperer" : "web-speech";
                    window.GoToolkitSpeechEngine = engine;
                } catch (e) { /* noop */ }
                if (recordStatus) {
                    recordStatus.textContent = engine === "whisperer" ? "Whisperer" : "Web Speech";
                }
                if (engine === "whisperer") {
                    showToast("Whisperer utilisera le micro mais reste en pr√©paration.", false);
                }
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                if (!SpeechRecognition) {
                    recordBtn?.setAttribute("disabled", "true");
                    pauseBtn?.setAttribute("disabled", "true");
                    speechToggleBtn?.setAttribute("disabled", "true");
                    if (recordStatus) recordStatus.textContent = "Indispo";
                    return;
                }
                speechRecognition = new SpeechRecognition();
                speechRecognition.lang = "fr-FR";
                speechRecognition.interimResults = true;
                speechRecognition.continuous = true;
                speechRecognition.onstart = () => {
                    console.debug("speechRecognition started");
                    setSpeechButtonState(true);
                };
                speechRecognition.onerror = e => {
                    console.warn("speechRecognition error", e);
                };
                speechRecognition.onresult = event => {
                    console.debug("speechRecognition.onresult", { index: event.resultIndex, results: event.results?.length });
                    const now = Date.now();
                    const sessionElapsed = recordingStartedAt ? Math.max(0, Math.floor((now - recordingStartedAt) / 1000)) : 0;
                    const elapsedSec = recordingBaseElapsedSec + sessionElapsed;
                    recordingElapsedSec = elapsedSec;

                    const formatTimestamp = secs => {
                        const total = Math.max(0, Math.floor(secs));
                        const m = String(Math.floor(total / 60)).padStart(2, "0");
                        const s = String(total % 60).padStart(2, "0");
                        return `${m}:${s}`;
                    };

                    let finals = [];
                    let interim = "";
                    for (let i = event.resultIndex || 0; i < event.results.length; i++) {
                        const res = event.results[i];
                        if (res.isFinal) finals.push((res[0].transcript || "").trim());
                        else interim = `${interim} ${res[0].transcript || ""}`.trim();
                    }

                    // Determine base text (strip any previously-displayed interim)
                    const base = getBaseWithoutInterim();
                    if (lastTimestampMinute === null && base) {
                        lastTimestampMinute = getLastTimestampMinuteFromTranscript(base);
                    }

                    // Insert finals at the caret position (do not force a newline)
                    if (finals.length) {
                        const effectiveBase = transcriptPrefix || base || "";
                        let inserted = "";

                        const appendSpeechSegment = segment => {
                            const trimmed = (segment || "").trim();
                            if (!trimmed) return;
                            if (inserted && !/\s$/.test(inserted) && !trimmed.startsWith("\n")) {
                                inserted += " ";
                            }
                            inserted += trimmed;
                            const lastChar = trimmed.charAt(trimmed.length - 1);
                            if (SENTENCE_TERMINATOR_REGEX.test(lastChar) && !inserted.endsWith("\n")) {
                                inserted += "\n";
                            }
                        };

                        const flushPendingTimestampIfReady = beforeText => {
                            if (!pendingTimestamp) return;
                            if (!isSentenceBoundary(beforeText)) return;
                            inserted += buildTimestampBlock(pendingTimestamp.label, beforeText);
                            lastTimestampMinute = pendingTimestamp.minuteBucket;
                            pendingTimestamp = null;
                        };

                        finals.filter(Boolean).forEach(text => {
                            const minuteBucket = Math.floor(elapsedSec / 60);
                            if (minuteBucket > (lastTimestampMinute ?? -1)) {
                                pendingTimestamp = { label: formatTimestamp(elapsedSec), minuteBucket };
                            }
                            const beforeText = (effectiveBase || "") + inserted;
                            flushPendingTimestampIfReady(beforeText);
                            appendSpeechSegment(text);
                        });

                        const combinedText = (effectiveBase || "") + inserted;
                        flushPendingTimestampIfReady(combinedText);

                        const caret = Math.min(lastCaret || 0, base.length);
                        const defaultSep = base && !/\s$/.test(base) ? " " : "";
                        const sep = inserted.startsWith("\n") ? "" : defaultSep;
                        const newBase = base.slice(0, caret) + sep + inserted + base.slice(caret);
                        transcriptPrefix = newBase;
                        // move caret after inserted text
                        lastCaret = Math.min(transcriptPrefix.length, caret + sep.length + inserted.length);
                    }

                    const interimLine = interim || "";
                    // Show finalized base and overlay interim at caret for live feedback
                    if (transcribeInput) {
                        const displayBase = transcriptPrefix || base || "";
                        const caretPos = recognitionActive
                            ? displayBase.length
                            : Math.min(lastCaret || 0, displayBase.length);
                        transcribeInput.value = displayBase;
                        try { transcribeInput.selectionStart = transcribeInput.selectionEnd = caretPos; } catch (e) { }
                        updateGhostOverlay(interimLine);
                        updateTranscriptMeta();
                        lastInterim = interimLine;
                    }

                    // persist the finalized transcript (no interim)
                    const page = getActivePage();
                    if (page) {
                        const manualText = transcriptPrefix || getBaseWithoutInterim() || "";
                        if (page.noteMode === NOTE_MODE_TRANSCRIPT_VIDEO) {
                            page.videoTranscript = manualText;
                            page.videoTranscriptSentences = parseVttTranscript(manualText);
                        } else {
                            page.manualTranscript = manualText;
                            if (page.noteMode !== NOTE_MODE_TRANSCRIPT_AUTO) {
                                page.transcript = manualText;
                            }
                        }
                        persistState();
                    }

                    updateRecordingUi();
                };
                speechRecognition.onend = () => {
                    if (recognitionActive && !recognitionPaused) {
                        speechRecognition.start();
                    } else {
                        setSpeechButtonState(false);
                    }
                };
            }

            async function startRecording() {
                if (audioRecordingActive) return;
                stopScreenRecording();
                setVideoBlob(null, { skipSave: true });
                const shouldUseSpeech = activeNoteMode === NOTE_MODE_TRANSCRIPT_AUTO;
                if (shouldUseSpeech && !speechRecognition) {
                    setupSpeechRecognition();
                }
                const ready = await ensureAudioRecording();
                if (!ready) return;
                if (screenCaptureEnabled) {
                    const screenReady = await ensureScreenCapture();
                    if (!screenReady) {
                        screenCaptureEnabled = false;
                        updateScreenToggleVisual();
                    }
                }
                transcriptPrefix = transcribeInput?.value || "";
                recordingStartedAt = Date.now();
                recordingElapsedSec = 0;
                lastTimestampMinute = null;
                pendingTimestamp = null;
                if (recordingTimer) clearInterval(recordingTimer);
                recordingTimer = setInterval(() => {
                    if (!recordingStartedAt) return;
                    recordingElapsedSec = Math.max(recordingElapsedSec, Math.floor((Date.now() - recordingStartedAt) / 1000));
                    updateRecordingUi();
                }, 1000);
                if (transcribeGhost) {
                    updateGhostOverlay("");
                }
                audioRecordingActive = true;
                const canStartRecognition = shouldUseSpeech && Boolean(speechRecognition);
                if (canStartRecognition) {
                    recognitionActive = true;
                    recognitionPaused = false;
                    speechRecognition.start();
                } else {
                    recognitionActive = false;
                    recognitionPaused = false;
                    if (shouldUseSpeech && !speechRecognition) {
                        showToast("Dict√©e vocale indisponible.", true);
                    }
                }
                recordBtn?.classList.add("btn-primary");
                pauseBtn?.classList.remove("btn-primary");
                setSpeechButtonState(true);
                updateRecordingUi();
            }

            function pauseRecording() {
                if (!audioRecordingActive && !recognitionActive) return;
                const hadRecognition = recognitionActive;
                recognitionPaused = hadRecognition;
                recognitionActive = false;
                try { speechRecognition?.stop(); } catch (e) { /* ignore */ }
                stopAudioRecording();
                audioRecordingActive = false;
                recordingStartedAt = null;
                if (recordingTimer) {
                    clearInterval(recordingTimer);
                    recordingTimer = null;
                }
                recordBtn?.classList.remove("btn-primary");
                pauseBtn?.classList.add("btn-primary");
                setSpeechButtonState(false);
                transcriptPrefix = transcribeInput?.value || "";
                if (hadRecognition) {
                    insertPauseSpacing();
                }
                updateGhostOverlay("");
                updateRecordingUi();
            }

            function resetRecording() {
                recognitionPaused = false;
                recognitionActive = false;
                try { speechRecognition?.stop(); } catch (e) { /* ignore */ }
                stopAudioRecording();
                recordingStartedAt = null;
                recordingSegments = [];
                audioRecordingActive = false;
                recordingElapsedSec = 0;
                lastTimestampMinute = null;
                pendingTimestamp = null;
                if (recordingTimer) {
                    clearInterval(recordingTimer);
                    recordingTimer = null;
                }
                setSpeechButtonState(false);
                if (transcribeInput) {
                    transcribeInput.value = "";
                    const page = getActivePage();
                    if (page) {
                        page.transcript = "";
                        persistState();
                    }
                }
                setAudioBlob(null);
                stopScreenRecording();
                setVideoBlob(null, { skipSave: true });
                updateTranscriptMeta();
                updateGhostOverlay("");
                updateRecordingUi();
            }

            function toggleSpeechRecording() {
                if (audioRecordingActive) {
                    pauseRecording();
                    return;
                }
                if (!confirmTranscriptRegeneration()) {
                    return;
                }
                startRecording();
            }

            const isResponsiveContextMode = () => (window.innerWidth || 0) < CONTEXT_RESPONSIVE_BREAKPOINT;

            function syncContextBackdrop(show) {
                if (!contextBackdrop) return;
                contextBackdrop.classList.toggle("visible", show);
                contextBackdrop.setAttribute("aria-hidden", show ? "false" : "true");
            }

            function setContextPanelOpen(isOpen) {
                if (!contextPanel) return;
                contextPanel.classList.toggle("open", isOpen);
                contextPanel.setAttribute("aria-hidden", isOpen ? "false" : "true");
                if (appMain) {
                    const showContextColumn = isOpen && !isResponsiveContextMode();
                    appMain.classList.toggle("context-open", showContextColumn);
                    appMain.classList.toggle("context-closed", !isOpen);
                }
                syncContextBackdrop(isOpen && isResponsiveContextMode());
            }

            function toggleContextPanel(forceOpen) {
                if (!contextPanel) return;
                const isOpen = contextPanel.classList.contains("open");
                const willOpen = typeof forceOpen === "boolean" ? forceOpen : !isOpen;
                setContextPanelOpen(willOpen);
            }

            function ensureContextPanelForBreakpoint() {
                if (!contextPanel) return;
                if (isResponsiveContextMode() && contextPanel.classList.contains("open")) {
                    setContextPanelOpen(false);
                }
            }

            contextBackdrop?.addEventListener("pointerdown", () => setContextPanelOpen(false));
            window.addEventListener("resize", ensureContextPanelForBreakpoint);

            function closeInfoPopup() {
                infoPopup?.classList.remove("open");
            }

            function reloadAppWithVersion() {
                try {
                    const url = new URL(window.location.href);
                    url.searchParams.set(VERSION_QUERY_PARAM, APP_VERSION);
                    window.location.href = url.toString();
                } catch (err) {
                    window.location.reload();
                }
            }

            function toggleInfoPopup() {
                infoPopup?.classList.toggle("open");
            }

            async function clearAudioStoreAll() {
                stopAudioRecording();
                await clearAudioDb();
                recordingSegments = [];
                audioRecordingActive = false;
                recognitionActive = false;
                recognitionPaused = false;
                recordingStartedAt = null;
                recordingElapsedSec = 0;
                if (recordingTimer) {
                    clearInterval(recordingTimer);
                    recordingTimer = null;
                }
                setAudioBlob(null, { skipSave: true });
                const page = getActivePage();
                if (page) {
                    page.audioRecordingVersion = 0;
                    page.audioTranscriptVersion = 0;
                    page.assemblyTranscript = "";
                    page.assemblyTranscriptId = "";
                    page.assemblyTranscriptSentences = [];
                    page.videoTranscript = "";
                    page.videoTranscriptId = "";
                    page.videoTranscriptSentences = [];
                    page.videoTranscriptFetchedId = "";
                    persistState();
                }
                stopScreenRecording();
                await clearVideoDb();
                setVideoBlob(null, { skipSave: true });
            }

            function clearCurrentAudioWithConfirm() {
                const confirmed = window.confirm("Supprimer l'enregistrement audio (et vid√©o) ?");
                if (!confirmed) return;
                clearAudioStoreAll();
                showToast("Enregistrement supprim√©.");
            }

            function syncIaEditor(key) {
                const nextKey = key || iaPromptSelect?.value || activeIaPrompt || "system";
                activeIaPrompt = nextKey;
                if (iaPromptSelect) iaPromptSelect.value = nextKey;
                if (iaTemplateEditor) {
                    iaTemplateEditor.value = promptState[nextKey] || promptDefaults[nextKey] || "";
                }
            }

            function applyIaEditorValue() {
                const key = iaPromptSelect?.value || activeIaPrompt || "system";
                promptState[key] = iaTemplateEditor?.value || "";
                showToast("Prompt appliqu√©.");
                toggleIaModal(false);
            }

            function resetIaEditorValue() {
                const key = iaPromptSelect?.value || activeIaPrompt || "system";
                promptState[key] = promptDefaults[key] || "";
                syncIaEditor(key);
                showToast("Prompt r√©initialis√©.");
            }

            function toggleIaModal(open) {
                const shouldOpen = typeof open === "boolean" ? open : !iaModalOverlay?.classList.contains("open");
                if (!iaModalOverlay) return;
                if (shouldOpen) {
                    syncIaEditor(activeIaPrompt);
                }
                iaModalOverlay.classList.toggle("open", shouldOpen);
                iaModalOverlay.setAttribute("aria-hidden", shouldOpen ? "false" : "true");
            }

            function toggleNavMenu() {
                navSwitcherMenu?.classList.toggle("open");
            }

            // Event binding
            openTemplateModalBtn?.addEventListener("click", openTemplateModal);
            templateModalClose?.addEventListener("click", closeTemplateModal);
            templateModalOverlay?.addEventListener("click", ev => { if (ev.target === templateModalOverlay) closeTemplateModal(); });
            templateModalValidate?.addEventListener("click", applySelectedTemplate);
            promptCreate?.addEventListener("input", persistScenario);
            promptModify?.addEventListener("focus", exportPageStateToScriptField);
            promptModify?.addEventListener("blur", () => applyScriptFromTextarea({ silent: true }));
            respondBtn?.addEventListener("click", runVoicePrompt);
            clearScenarioBtn?.addEventListener("click", () => {
                const ok = confirm("Supprimer le sc√©nario ? Cette action est irr√©versible.");
                if (!ok) return;
                if (promptCreate) promptCreate.value = "";
                persistScenario();
                clearGuidelineData();
                showToast("Commande vid√©.");
            });
            applyScriptBtn?.addEventListener("click", restoreLastIaResponse);
            openContextModalBtn?.addEventListener("click", () => toggleContextPanel());
            openIaModalBtn?.addEventListener("click", () => {
                syncIaEditor(activeIaPrompt);
                toggleIaModal(true);
            });
            iaModalClose?.addEventListener("click", () => toggleIaModal(false));
            iaApplyBtn?.addEventListener("click", applyIaEditorValue);
            iaResetBtn?.addEventListener("click", resetIaEditorValue);
            iaPromptSelect?.addEventListener("change", () => syncIaEditor(iaPromptSelect.value));
            completeBtn?.addEventListener("click", completeGuidelinesFromTranscript);
            evaluateBtn?.addEventListener("click", evaluateGuidelines);
            summarizeBtn?.addEventListener("click", summarizeTranscript);
            refreshFromScriptBtn?.addEventListener("click", applyScriptFromTextarea);
            addSubjectBtn?.addEventListener("click", () => {
                openSubjectModal(null);
                const confirmBtn = document.getElementById("confirmSubjectModal");
                const deleteBtn = document.getElementById("cancelSubjectModal");
                if (confirmBtn) confirmBtn.dataset.subjectId = "";
                if (deleteBtn) deleteBtn.style.display = "none";
            });
            document.getElementById("closeSubjectModal")?.addEventListener("click", () => {
                subjectModalOverlay.classList.remove("open");
                subjectModalOverlay.setAttribute("aria-hidden", "true");
            });
            document.getElementById("cancelSubjectModal")?.addEventListener("click", () => {
                const existingId = document.getElementById("confirmSubjectModal")?.dataset?.subjectId || "";
                const deleteBtn = document.getElementById("cancelSubjectModal");
                const page = getActivePage();
                if (existingId && page) {
                    const confirmed = window.confirm("Supprimer ce sujet ?");
                    if (confirmed) {
                        page.subjects = (page.subjects || []).filter(s => s.id !== existingId);
                        if (page.activeSubjectId === existingId) {
                            page.activeSubjectId = page.subjects[0]?.id || null;
                        }
                        persistState();
                        renderGuidelines();
                        showToast("Sujet supprim√©.");
                    }
                } else if (deleteBtn) {
                    deleteBtn.style.display = "none";
                }
                subjectModalOverlay.classList.remove("open");
                subjectModalOverlay.setAttribute("aria-hidden", "true");
            });
            document.getElementById("confirmSubjectModal")?.addEventListener("click", () => {
                const titleInput = document.getElementById("newSubjectTitle");
                const durationInput = document.getElementById("newSubjectDuration");
                const pointsInput = document.getElementById("newSubjectPoints");
                const title = (titleInput?.value || "").trim() || `Sujet ${(getActivePage()?.subjects?.length || 0) + 1}`;
                const duration = Math.min(MAX_SUBJECT_MINUTES, Math.max(MIN_SUBJECT_MINUTES, Number(durationInput?.value || DEFAULT_SUBJECT_DURATION)));
                const points = (pointsInput?.value || "").split(/\r?\n/).map(l => l.trim()).filter(Boolean);
                const page = getActivePage();
                if (!page) return;
                const existingId = document.getElementById("confirmSubjectModal")?.dataset?.subjectId || "";
                const deleteBtn = document.getElementById("cancelSubjectModal");
                if (existingId) {
                    const target = page.subjects.find(s => s.id === existingId);
                    if (target) {
                        target.title = title;
                        const start = target.timeframe?.start || 0;
                        target.timeframe = { start, end: start + duration };
                        target.keySentences = (points.length ? points : ["Point 1", "Point 2"]).map(text => ({ text, match: "pending" }));
                    }
                } else {
                    const lastEnd = page.subjects?.[page.subjects.length - 1]?.timeframe?.end || 0;
                    const newSubject = {
                        id: `subject-${Date.now()}`,
                        title,
                        timeframe: { start: lastEnd, end: lastEnd + duration },
                        keySentences: (points.length ? points : ["Point 1", "Point 2"]).map(text => ({ text, match: "pending" }))
                    };
                    page.subjects = page.subjects || [];
                    page.subjects.push(newSubject);
                    const confirmBtn = document.getElementById("confirmSubjectModal");
                    if (confirmBtn) {
                        confirmBtn.dataset.subjectId = newSubject.id;
                    }
                    if (deleteBtn) deleteBtn.style.display = "inline-flex";
                }
                persistState();
                renderGuidelines();
                subjectModalOverlay.classList.remove("open");
                subjectModalOverlay.setAttribute("aria-hidden", "true");
            });
            const escapeRegExp = s => s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            function getBaseWithoutInterim() {
                const val = transcribeInput?.value || "";
                if (lastInterim && val.endsWith(lastInterim)) {
                    return val.slice(0, val.length - lastInterim.length);
                }
                return val;
            }

            function ensureTrailingPauseSpacing(text = "") {
                if (!text) return "";
                if (/\s$/.test(text)) return text;
                if (/[.?!]$/.test(text)) {
                    return `${text}\n`;
                }
                return `${text} `;
            }

            const SENTENCE_TERMINATOR_REGEX = /[.!?‚Ä¶]/;
            function isSentenceBoundary(text = "") {
                if (!text) return true;
                if (text.endsWith("\n")) return true;
                const trimmed = text.replace(/\s+$/g, "");
                if (!trimmed) return true;
                const lastChar = trimmed.charAt(trimmed.length - 1);
                return SENTENCE_TERMINATOR_REGEX.test(lastChar);
            }

            function buildTimestampBlock(label, beforeText = "") {
                const hasContent = Boolean((beforeText || "").replace(/\s+$/g, ""));
                const needsLeadingNewline = hasContent && !beforeText.endsWith("\n");
                return `${needsLeadingNewline ? "\n" : ""}[${label}]\n`;
            }

            function insertPauseSpacing() {
                if (!transcribeInput) return;
                const base = getBaseWithoutInterim();
                if (!base) return;
                const needsBreak = !base.endsWith("\n");
                if (!needsBreak) return;
                const spaced = `${base}\n`;
                transcriptPrefix = spaced;
                transcribeInput.value = spaced;
                const caretPos = spaced.length;
                try {
                    transcribeInput.selectionStart = transcribeInput.selectionEnd = caretPos;
                } catch (e) { /* ignore */ }
                lastCaret = caretPos;
                const page = getActivePage();
                if (page) {
                    page.transcript = spaced;
                    persistState();
                }
            }
            function updateCaretPos() {
                try { lastCaret = transcribeInput?.selectionStart || 0; } catch (e) { lastCaret = 0; }
            }
            transcribeInput?.addEventListener("input", () => {
                updateCaretPos();
                const page = getActivePage();
                if (!page) return;
                // If user types while recognition active, mark manual edit and capture base
                if (recognitionActive && !recognitionPaused) {
                    userEditedDuringRecognition = true;
                    // update transcriptPrefix to user's base text (strip any interim)
                    transcriptPrefix = getBaseWithoutInterim();
                    lastInterim = "";
                    lastCaret = Math.min(lastCaret, transcriptPrefix.length);
                }
                const manualText = getBaseWithoutInterim();
                if (page.noteMode === NOTE_MODE_TRANSCRIPT_VIDEO) {
                    page.videoTranscript = manualText;
                    page.videoTranscriptSentences = parseVttTranscript(manualText);
                    page.videoTranscriptLastManualEditAt = Date.now();
                } else {
                    page.manualTranscript = manualText;
                    if (page.noteMode !== NOTE_MODE_TRANSCRIPT_AUTO) {
                        page.transcript = manualText;
                    }
                    if (page.noteMode === NOTE_MODE_TRANSCRIPT_IA) {
                        page.assemblyTranscriptLastManualEditAt = Date.now();
                    }
                }
                persistState();
                updateTranscriptMeta();
                updateGhostOverlay("");
            });
            summaryTextarea?.addEventListener("input", () => {
                const page = getActivePage();
                if (!page) return;
                page.summary = summaryTextarea.value;
                persistState();
            });
            noteModeSelect?.addEventListener("change", () => {
                void handleNoteModeSelection(noteModeSelect.value);
            });
            ["click", "keyup", "mouseup", "focus", "select"].forEach(evt => {
                transcribeInput?.addEventListener(evt, () => {
                    updateCaretPos();
                    updateGhostOverlay(transcribeGhost?.textContent || "");
                });
            });
            speechToggleBtn?.addEventListener("click", toggleSpeechRecording);
            recordBtn?.addEventListener("click", startRecording);
            pauseBtn?.addEventListener("click", pauseRecording);
            audioPlayBtn?.addEventListener("click", handleAudioPlayClick);
            audioDownloadBtn?.addEventListener("click", ev => {
                ev.stopPropagation();
                toggleDownloadMenu();
            });
            audioDownloadAudio?.addEventListener("click", handleDownloadAudio);
            audioDownloadVideo?.addEventListener("click", handleDownloadVideo);
            document.addEventListener("click", ev => {
                if (!audioDownloadMenu?.classList.contains("open")) return;
                if (audioDownloadMenu.contains(ev.target) || audioDownloadBtn?.contains(ev.target)) return;
                toggleDownloadMenu(false);
            });
            audioClearBtn?.addEventListener("click", clearCurrentAudioWithConfirm);
            screenCaptureToggleBtn?.addEventListener("click", async () => {
                const willEnable = !screenCaptureEnabled;
                if (willEnable && hasAudioRecording()) {
                    const confirmed = window.confirm("L'enregistrement audio pr√©c√©dent sera supprim√©. Continuer ?");
                    if (!confirmed) {
                        return;
                    }
                    await discardAudioRecording();
                }
                screenCaptureEnabled = willEnable;
                updateScreenToggleVisual();
                if (!screenCaptureEnabled) {
                    stopScreenRecording();
                }
            });
            audioImportBtn?.addEventListener("click", handleAudioImportClick);
            audioImportInput?.addEventListener("change", handleAudioImportChange);
            populateAudioSpeedOptions();
            updateScreenToggleVisual();
            updateDownloadMenu();
            audioSpeedSelect?.addEventListener("change", () => {
                const speed = getAudioSpeed();
                audioPlayer.playbackRate = speed;
            });
            audioProgress?.addEventListener("input", () => {
                if (!audioPlayer || !audioPlayer.duration || Number.isNaN(audioPlayer.duration)) return;
                const ratio = Number(audioProgress.value) || 0;
                audioPlayer.currentTime = ratio * audioPlayer.duration;
            });
            audioPlayer.addEventListener("timeupdate", updateAudioProgress);
            audioPlayer.addEventListener("loadedmetadata", updateAudioProgress);
            audioPlayer.addEventListener("ended", () => {
                if (audioPlayBtn) audioPlayBtn.textContent = "‚ñ∂";
                updateAudioProgress();
            });
            audioPlayer.addEventListener("timeupdate", updateTranscriptMeta);
            audioPlayer.addEventListener("loadedmetadata", updateTranscriptMeta);
            pageTitleEl?.addEventListener("input", () => {
                const page = getActivePage();
                if (!page) return;
                page.title = pageTitleEl.textContent || "Page";
                renderTabs();
                persistState();
            });
            fileMenuBtn?.addEventListener("click", ev => {
                ev.stopPropagation();
                if (!fileMenu?.classList.contains("open")) {
                    closeMenus(fileMenu);
                }
                toggleFileMenu();
            });
            shareBtn?.addEventListener("click", ev => {
                ev.stopPropagation();
                if (!shareMenu?.classList.contains("open")) {
                    closeMenus(shareMenu);
                }
                toggleShareMenu();
            });
            navSwitcherBtn?.addEventListener("click", ev => { ev.stopPropagation(); toggleNavMenu(); });
            document.addEventListener("click", ev => {
                if (fileMenu?.contains(ev.target) || fileMenuBtn === ev.target) return;
                if (shareMenu?.contains(ev.target) || shareBtn === ev.target) return;
                if (navSwitcherMenu?.contains(ev.target) || navSwitcherBtn === ev.target) return;
                closeMenus();
            });
            newDocumentBtn?.addEventListener("click", () => {
                closeMenus();
                try {
                    const shouldSave = confirm("Sauvegarder le document existant avant d'ouvrir un nouveau ?");
                    if (shouldSave) {
                        persistCapsuleDraft();
                        showToast("Capsule enregistr√©e localement.");
                    }
                } catch (err) { /* ignore */ }
                resetDocument();
                showToast("Nouvelle capsule.");
            });
            importJsonBtn?.addEventListener("click", () => {
                importJsonInput?.click();
                closeMenus();
            });
            importJsonInput?.addEventListener("change", event => {
                const file = event.target.files?.[0];
                if (file) importFromFile(file);
                importJsonInput.value = "";
            });
            saveDocumentBtn?.addEventListener("click", () => {
                persistCapsuleDraft();
                showToast("Capsule enregistr√©e localement.");
                closeMenus();
            });
            exportJsonBtn?.addEventListener("click", () => { exportJson(); closeMenus(); });
            aboutVoiceBtn?.addEventListener("click", ev => {
                ev.stopPropagation();
                toggleInfoPopup();
            });
            updateAppBtn?.addEventListener("click", () => {
                closeInfoPopup();
                reloadAppWithVersion();
            });
            addViewBtn?.addEventListener("click", addPage);
            deleteViewBtn?.addEventListener("click", () => {
                const page = getActivePage();
                const label = page?.tabLabel || page?.title || "Page";
                const ok = confirm(`Supprimer la vue '${label}' ? Cette action est irr√©versible.`);
                if (!ok) return;
                deletePage();
            });
            shareCreateBtn?.addEventListener("click", ev => { ev.stopPropagation(); createOrUpdateShare(false); });
            shareUpdateBtn?.addEventListener("click", ev => { ev.stopPropagation(); createOrUpdateShare(true); });
            shareLinkField?.addEventListener("focus", ev => ev.target.select());
            shareLinkField?.addEventListener("click", ev => ev.target.select());

            window.addEventListener("keydown", ev => {
                if (ev.key === "Escape") {
                    closeMenus();
                    toggleIaModal(false);
                    toggleContextPanel(false);
                    closeInfoPopup();
                    if (subjectModalOverlay?.classList.contains("open")) {
                        subjectModalOverlay.classList.remove("open");
                        subjectModalOverlay.setAttribute("aria-hidden", "true");
                    }
                    if (templateModalOverlay?.classList.contains("open")) {
                        closeTemplateModal();
                    }
                }
            });

            // Init
            syncIaEditor(activeIaPrompt);
            renderTabs();
            renderPage();
            setupSpeechRecognition();
            updateShareMenuUI();
            tryLoadSharedStateFromUrl();
            void hydrateMediaFromDb();
            toggleContextPanel(!isResponsiveContextMode());
            populateAudioSpeedOptions();
            audioPlayer.playbackRate = getAudioSpeed();
            try {
                const params = new URLSearchParams(window.location.search);
                if (!loadedFromStorage && !params.get(SHARE_QUERY_PARAM)) {
                    openTemplateModal();
                }
            } catch (err) { /* ignore */ }
            document.addEventListener("pointerdown", ev => {
                if (!contextPanel?.classList.contains("open")) return;
                if (!isResponsiveContextMode()) return;
                const target = ev.target;
                if (target instanceof Node) {
                    if (contextPanel.contains(target) || openContextModalBtn?.contains(target)) {
                        return;
                    }
                }
                setContextPanelOpen(false);
            });
            document.addEventListener("click", ev => {
                if (infoPopup && !infoPopup.contains(ev.target) && ev.target !== infoButton) {
                    closeInfoPopup();
                }
            });
            window.GoToolkitAppFeedbackConfig = {
                appId: "voice",
                appName: "Voice",
                defaultType: "bug-voice",
                shareCollection: "voices",
                buildSharePayload: () => ({
                    app: "voice",
                    url: window.location.href,
                    payload: state
                })
            };
        })();
    </script>
    <script>
        (function removeVersionQueryParam() {
            try {
                const url = new URL(window.location.href);
                if (!url.searchParams.has("v")) return;
                url.searchParams.delete("v");
                const search = url.searchParams.toString();
                const newUrl = url.pathname + (search ? `?${search}` : "") + url.hash;
                window.history.replaceState({}, "", newUrl);
            } catch (err) {
                /* noop */
            }
        })();
    </script>
    <script src="js/feedback.js"></script>
</body>

</html>
